<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>You Know Nothing</title><link href="https://xutree.github.io/" rel="alternate"></link><link href="https://xutree.github.io/feeds/all.atom.xml" rel="self"></link><id>https://xutree.github.io/</id><updated>2018-10-11T20:39:04+08:00</updated><entry><title>数据结构——向量</title><link href="https://xutree.github.io/pages/2018/10/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%90%91%E9%87%8F/" rel="alternate"></link><published>2018-10-10T19:50:46+08:00</published><updated>2018-10-11T20:39:04+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-10:/pages/2018/10/10/数据结构向量/</id><summary type="html">&lt;p&gt;数据结构大致可分为：线性结构、半线性结构和非线性结构。线性结构中最基本的称为序列（sequence），根据其中数据项的逻辑次序与其物理存储地址的对应关系不同，又可分为向量（vector）和列表（list）。&lt;/p&gt;
&lt;h2&gt;从数组到向量&lt;/h2&gt;
&lt;p&gt;数组：集合 S 由 n 个元素组成，且各元素之间具有一个线性次序，则可以将它们存放于起始地址 A，物理位置连续的一段存储空间。记为：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;A[0,n) = { A[0], A[1], ..., A[n-1] }&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;将它们存放于起始地址 A，若每个元素占用 s 个单位的空间，则元素 A[i] 的物理地址为：&lt;code&gt;A + i * s&lt;/code&gt;，所以被称作线性数组。&lt;/p&gt;
&lt;p&gt;向量：&lt;code&gt;V[0,n) = { v[0 …&lt;/code&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;数据结构大致可分为：线性结构、半线性结构和非线性结构。线性结构中最基本的称为序列（sequence），根据其中数据项的逻辑次序与其物理存储地址的对应关系不同，又可分为向量（vector）和列表（list）。&lt;/p&gt;
&lt;h2&gt;从数组到向量&lt;/h2&gt;
&lt;p&gt;数组：集合 S 由 n 个元素组成，且各元素之间具有一个线性次序，则可以将它们存放于起始地址 A，物理位置连续的一段存储空间。记为：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;A[0,n) = { A[0], A[1], ..., A[n-1] }&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;将它们存放于起始地址 A，若每个元素占用 s 个单位的空间，则元素 A[i] 的物理地址为：&lt;code&gt;A + i * s&lt;/code&gt;，所以被称作线性数组。&lt;/p&gt;
&lt;p&gt;向量：&lt;code&gt;V[0,n) = { v[0], v[1], ..., v[n-1] }&lt;/code&gt;是线性数组的一种抽象和泛化，由具有线性次序的一组元素构成的集合，其中的元素由秩区分。各元素秩互异，且均为 [0, n) 内的整数。采用“寻秩访问”。经过抽象，不限定同一向量中元素都属于同一数据类型，故而不保证它们之间可以相互比较大小。&lt;/p&gt;
&lt;h2&gt;接口&lt;/h2&gt;
&lt;p&gt;作为一种抽象数据类型，向量对象应支持如下操作接口：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;操作接口&lt;/th&gt;
&lt;th align="left"&gt;功能&lt;/th&gt;
&lt;th align="left"&gt;适用对象&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;size()&lt;/td&gt;
&lt;td align="left"&gt;元素总数&lt;/td&gt;
&lt;td align="left"&gt;向量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;get(r)&lt;/td&gt;
&lt;td align="left"&gt;获取秩为 r 的元素&lt;/td&gt;
&lt;td align="left"&gt;向量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;put(r, e)&lt;/td&gt;
&lt;td align="left"&gt;用 e 代替秩为 r 的元素&lt;/td&gt;
&lt;td align="left"&gt;向量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;insert(r, e)&lt;/td&gt;
&lt;td align="left"&gt;e 作为秩为 r 的元素插入，原后继元素依次后移&lt;/td&gt;
&lt;td align="left"&gt;向量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;remove(r)&lt;/td&gt;
&lt;td align="left"&gt;删除秩为 r 的元素，返回该元素中原存放的对象&lt;/td&gt;
&lt;td align="left"&gt;向量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;disordered()&lt;/td&gt;
&lt;td align="left"&gt;判断所有元素是否已按非降序排列&lt;/td&gt;
&lt;td align="left"&gt;向量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;sort()&lt;/td&gt;
&lt;td align="left"&gt;非降序排序&lt;/td&gt;
&lt;td align="left"&gt;向量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;find(e)&lt;/td&gt;
&lt;td align="left"&gt;查找等于 e 且秩最大的元素&lt;/td&gt;
&lt;td align="left"&gt;向量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;search(e)&lt;/td&gt;
&lt;td align="left"&gt;查找目标元素 e，返回不大于 e 且秩最大的元素&lt;/td&gt;
&lt;td align="left"&gt;有序向量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;deduplicate()&lt;/td&gt;
&lt;td align="left"&gt;剔除重复元素&lt;/td&gt;
&lt;td align="left"&gt;向量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;uniquify()&lt;/td&gt;
&lt;td align="left"&gt;剔除重复元素&lt;/td&gt;
&lt;td align="left"&gt;有序向量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;traverse()&lt;/td&gt;
&lt;td align="left"&gt;遍历向量并统一处理所有元素，处理方法由函数对象指定&lt;/td&gt;
&lt;td align="left"&gt;向量&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;Vector 模板类&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;typedef int Rank;   //秩
#define DEFAULT_CAPACITY 3  //默认的初始容量（实际应用中可设置为更大）

template &amp;lt;typename T&amp;gt; class Vector {    //向量模板类
protected:
    Rank _size; int _capacity; T* _elem;    //规模、容量、数据区
    void copyFrom(T const* A, Rank lo, Rank hi);    //复制数组区间A[lo,hi)
    void expand();  //空间不足时扩容
    void shrink();  //装填因子过小时压缩
    bool bubble(Rank lo, Rank hi);  //扫描交换
    void bubbleSort()Rank lo, Rank hi); //气泡排序算法
    Rank max(Rank lo, Rank hi); //选取最大元素
    void selectionSort(Rank lo, Rank hi);   //选择排序算法
    void merge(Rank lo, Rank mi, Rank hi);   //归并算法
    void mergeSort(Rank lo, Rank hi);   //归并排序算法
    Rank partition(Rank lo, Rank hi);   //轴点构造算法
    void quickSort(Rank lo, Rank hi);   //快速排序算法
    void heapSort(Rank lo, Rank hi);    //堆排序
public:
//构造函数
     //容量为 c，规模为 s，所有元素初始化为 v，s&amp;lt;=c
    Vector(int c = DEFAULT_CAPACITY, int s = 0, T v = 0)
    { _elem = new T[_capacity = c]; for(_size = 0; _size &amp;lt; s; _elem[_size++] = v);  }
    Vector(T const* A, Rank n) { copyFrom(A, 0, n); }   //数组整体复制
    Vector(T const* A, Rank lo, Rank hi) { copyFrom(A, lo, hi); }   //区间
    Vector(Vector&amp;lt;T&amp;gt; const&amp;amp; V) { copyFrom(V._elem, 0, V._size); }   //向量整体复制
    Vector(Vector&amp;lt;T&amp;gt; const&amp;amp; V, Rank lo, Rank hi) { copyFrom(V._elem, lo, hi); } //区间
//析构函数
~Vector() { delete [] _elem; }  //释放内部空间
//只读访问接口
    Rank size() const { return _size; } //规模
    bool empty() const { return !_size; }   //判空
    int disordered() const; //判断向量是否已排序
    Rank find(T const&amp;amp; e) const { return find(e, 0, _size); }   //无序向量整体查找
    Rank find(T const&amp;amp; e, Rank lo, Rank hi) const;  //无序向量区间查找
    Rank search(T const&amp;amp; e) const   //有序向量整体查找
    { return (0 &amp;gt;= _size) ? -1 : search(e, 0, _size); }
    Rank search(T const&amp;amp; e, Rank lo, Rank hi) const   //有序向量区间查找
//可写访问接口
    T&amp;amp; operator[](Rank r) const;    //重载下标运算符，可以类似于数组形式引用各元素
    Vector&amp;lt;T&amp;gt; &amp;amp; operator=(Vector&amp;lt;T&amp;gt; const&amp;amp;);    //重载赋值运算符，以便直接克隆向量
    T remove(Rank r);   //删除秩为 r 的元素
    int remove(Rank lo, Rank hi);   //删除秩在区间 [lo,hi) 之内的元素
    Rank insert(Rank r, T const&amp;amp; e);    //插入元素
    Rank insert(T const&amp;amp; e) { return insert(_size, e); }    //默认作为尾元素插入
    void sort(Rank lo, Rank hi);    //对 [lo,hi) 排序
    void sort() { sort(0, _size); } //整体排序
    void unsort(Rank lo, Rank hi);    //对 [lo,hi) 置乱
    void unsort() { unsort(0, _size); } //整体置乱
    int deduplicate();  //无序去重
    int uniquify(); //有序去重
//遍历
    void traverse(void (*)(T&amp;amp;));    //遍历（使用函数指针，只读或局部性修改）
    template &amp;lt;typename VST&amp;gt; void traverse(VST&amp;amp;);    //遍历（使用函数对象，可全局性修改）
};//Vector
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;构造与析构&lt;/h2&gt;
&lt;p&gt;约定：向量中秩为 r 的元素，对应于内部数组中的 _elem[r]，其物理地址为：_elem + r&lt;/p&gt;
&lt;h3&gt;默认构造函数&lt;/h3&gt;
&lt;p&gt;整个默认构造过程顺序进行，没有任何迭代，故忽略用于分配数组空间的时间，需要常数时间。&lt;/p&gt;
&lt;h3&gt;基于复制的构造函数&lt;/h3&gt;
&lt;p&gt;在模板的实现中，我们将基于数组或者向量的复制操作（局部或整体的）都转交给如下的&lt;code&gt;copyFrom&lt;/code&gt;函数处理：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;template &amp;lt;typename T&amp;gt; void Vector&amp;lt;T&amp;gt;::copyFrom(T const* A, Rank lo, Rank hi) {
    _elem = new T[_capacity = 2 * (hi -lo) ]; _size = 0; //分配空间，规模清零
    while( lo &amp;lt;hi) //A[lo,hi) 元素逐一复制
        _elem[_size++] = A[lo++];   //
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;需要 &lt;em&gt;O&lt;/em&gt;(_size) 时间。&lt;/p&gt;
&lt;p&gt;需要强调的是，由于向量内部含有动态分配的空间，默认的“=”运算符不足以支持向量之间的直接赋值。故要重建“=”：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;template &amp;lt;typename T&amp;gt; Vector&amp;lt;T&amp;gt;&amp;amp; Vector&amp;lt;T&amp;gt;::operator=(Vector&amp;lt;T&amp;gt; const&amp;amp; V) {
    if( _elem ) delet [] _elem;
    copyFrom(V._elem, 0, V.size());
    return *this;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;析构&lt;/h3&gt;
&lt;p&gt;若不计系统用于空间回收的时间，整个析构过程只需常数时间。&lt;/p&gt;
&lt;h2&gt;动态空间管理&lt;/h2&gt;
&lt;h3&gt;扩容&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;template &amp;lt;typename T&amp;gt; void Vector&amp;lt;T&amp;gt;::expand() {
    if(_size &amp;lt; _capacity) return;   //尚未满员，不必扩容
    if(_capacity &amp;lt; DEFAULT_CAPACITY) _capacity = DEFAULT_CAPACITY;  //不低于最小容量
    T *oldElem = _elem; _elem = new T[_capacity &amp;lt;&amp;lt; 1]; //容量加倍
    for( int i = 0; i &amp;lt; _size; i++)
        _elem[i] = oldElem[i]; //复制原向量内容（T为基本类型，或以重载赋值运算符
    delete [] oldElem;  //释放原空间
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;分摊运行时间为 &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;
&lt;h3&gt;缩容&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;template &amp;lt;typename T&amp;gt; void Vector&amp;lt;T&amp;gt;::shrink() {
    if(_capacity &amp;lt; DEFAULT_CAPACITY &amp;lt;&amp;lt; 1) return;   //不至收缩到DEFAULT_CAPACITY
    if(_size &amp;lt;&amp;lt; 2 &amp;gt; _capacity) return;  //以25%为界
    T *oldElem = _elem; _elem = new T[_capacity &amp;gt;&amp;gt; 1]; //容量减半
    for( int i = 0; i &amp;lt; _size; i++)
        _elem[i] = oldElem[i]; //复制原向量内容（T为基本类型，或以重载赋值运算符
    delete [] oldElem;  //释放原空间
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;就单次扩容或缩容操作而言，所需时间的确会高达 &lt;em&gt;O&lt;/em&gt;(n)，因此在对单次操作的执行速度及其敏感的应用场合以上策略并不适用，其中缩容操作甚至可以完全不予考虑。&lt;/p&gt;
&lt;h2&gt;常规向量&lt;/h2&gt;
&lt;h3&gt;直接引用元素&lt;/h3&gt;
&lt;p&gt;与数组直接通过下标访问元素的形式相比，向量 ADT（abstract data type）所设置的&lt;code&gt;get()&lt;/code&gt;和&lt;code&gt;put()&lt;/code&gt;接口都显得不甚自然。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;template &amp;lt;typename T&amp;gt; T&amp;amp; Vector&amp;lt;T&amp;gt;::operator[](Rank r) const
{ return _elem[r]; }    //assert: 0 &amp;lt;= r &amp;lt; _size
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;置乱器&lt;/h3&gt;
&lt;p&gt;重载后&lt;code&gt;[]&lt;/code&gt;返回的是对数组元素的引用，这就意味着它既可以取代&lt;code&gt;get()&lt;/code&gt;操作（通常作为赋值表达式的右值），也可以取代&lt;code&gt;set()&lt;/code&gt;操作（通常作为左值）。采用这种形式，可以很清晰地实现如下的向量置乱器：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;template &amp;lt;typename T&amp;gt; void permute(Vector&amp;lt;T&amp;gt;&amp;amp; V) {
    for(int i = V.size(); i &amp;gt; 0; i--)
        swap(V[i-1], V[rand() % i]); //V[i-1] 与 V[0,i) 中某一随机元素交换
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;从理论上讲，上述算法可以枚举出同一向量所有可能的排列，而且能够保证生成各种排列的概率均等。&lt;/p&gt;
&lt;p&gt;为便于对各种向量算法的测试与比较，不妨将上述算法封装到向量 ADT 中，并对外提供向量的置乱接口操作：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;template &amp;lt;typename T&amp;gt; void Vector&amp;lt;T&amp;gt;::unsort(Rank lo, Rank hi) {
    T* V = _elem + lo;
    for(Rank i =hi -lo; i &amp;gt; 0; i--)
        swap(V[i-1], V[rand() % i]);
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上述两段代码的细微差异：上面的代码通过重载“[]”，利用秩间接访问&lt;strong&gt;向量&lt;/strong&gt;元素，下面的代码通过下标直接访问内部&lt;strong&gt;数组&lt;/strong&gt;的元素。&lt;/p&gt;
&lt;h3&gt;判等器和比较器&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;template &amp;lt;typename T&amp;gt; static bool lt(T* a, T* b) { return lt(*a, *b); } //less than
template &amp;lt;typename T&amp;gt; static bool lt(T&amp;amp; a, T&amp;amp; b) { return a &amp;lt; b; } //less than
template &amp;lt;typename T&amp;gt; static bool eq(T* a, T* b) { return eq(*a, *b); } //equal
template &amp;lt;typename T&amp;gt; static bool eq(T&amp;amp; a, T&amp;amp; b) { return a == b; } //equal
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在一些复杂的数据结构中，内部元素本身的类型可能就是指向其他对象的指针，从而外部更多关注的，往往是其所指向对象的大小如直接比较指针，则结果毫无意义，故上面的代码分别出了了指针和引用的情况。&lt;/p&gt;
&lt;h3&gt;无序查找&lt;/h3&gt;
&lt;h4&gt;判等器&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;Vector&lt;/code&gt;模板中的&lt;code&gt;find&lt;/code&gt;接口的语义为“查找与数据对象 e 相等的元素”。这暗示向量元素可以通过相互“比对”判断是否相等。这类仅支持比对，但未必支持比较的向量，称为无序向量（unsorted vector）。&lt;/p&gt;
&lt;h4&gt;顺序查找&lt;/h4&gt;
&lt;p&gt;由于&lt;code&gt;find&lt;/code&gt;函数查找相等的最大秩元素，故从后往前比对：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;template &amp;lt;typename T&amp;gt; Rank Vector&amp;lt;T&amp;gt;::find(T const&amp;amp; e, Rank lo, Rank hi) const {
    while( (lo &amp;lt; hi--) &amp;amp;&amp;amp; (e != _elem[hi]) ); //assert: 0 &amp;lt;= lo &amp;lt; hi &amp;lt;= _size
    return hi;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;最坏情况：&lt;em&gt;O&lt;/em&gt;(n)；最好情况：&lt;em&gt;O&lt;/em&gt;(1)。为输入敏感（input sensitive）算法。&lt;/p&gt;
&lt;h3&gt;插入&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//assert: 0 &amp;lt;= r &amp;lt;= size
template &amp;lt;typename T&amp;gt; Rank Vector&amp;lt;T&amp;gt;::insert(Rank r, T const&amp;amp; e) {
    expan(); //如有必要，扩容
    for(int i = _size; i &amp;gt; r; i--) _elem[i] = _elem[i-1];
    _elem[r] = e; _size++; //插入并更新容量
    return r;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意从后往前搬移数据，以防覆盖。复杂度：若插入位置等概论分布，则平均运行时间为&lt;em&gt;O&lt;/em&gt;(_size)=&lt;em&gt;O&lt;/em&gt;(n)。&lt;/p&gt;
&lt;h3&gt;删除&lt;/h3&gt;
&lt;p&gt;应将单元素删除视为区间删除的特例，并基于后者来实现前者。&lt;/p&gt;
&lt;h4&gt;区间删除&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//删除区间[lo, hi)
template &amp;lt;typename T&amp;gt; int Vector&amp;lt;T&amp;gt;::remove(Rank lo, Rank hi) {
    if(lo === hi) return 0;
    while(hi &amp;lt; _size)   _elem[lo++] = _elem[hi++];
    _size = lo;
    shrink();
    return hi - lo; //返回被删除元素个数
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;单元素删除&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;template &amp;lt;typename T&amp;gt; T Vector&amp;lt;T&amp;gt;::remove(Rank r) {
    T e = _elem[r];
    remove(r, r + 1);
    return e;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;被删除元素在向量中的位置越靠后（前）所需时间越短（长），最好为&lt;em&gt;O&lt;/em&gt;(1)，最坏为&lt;em&gt;O&lt;/em&gt;(n)。&lt;/p&gt;
&lt;h3&gt;唯一化&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;template &amp;lt;typename T&amp;gt; int Vector&amp;lt;T&amp;gt;::deduplicate() {
    int oldSize = _size;
    Rank i = 1;
    while(i &amp;lt; _size)
        (find(_elem[i], 0, i) &amp;lt; 0) ? i++ : remove(i);
    return oldSize - _size;
}
&lt;/pre&gt;&lt;/div&gt;</content><category term="数据结构"></category></entry><entry><title>C++ Primer 第八章 IO 库</title><link href="https://xutree.github.io/pages/2018/10/09/C++_Primer_Chapter_8/" rel="alternate"></link><published>2018-10-09T22:19:51+08:00</published><updated>2018-10-09T22:19:51+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-09:/pages/2018/10/09/C++_Primer_Chapter_8/</id><summary type="html">&lt;h2&gt;IO 类&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;iostream&lt;/code&gt;头文件：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;istream&lt;/code&gt;,&lt;code&gt;wistream&lt;/code&gt;,&lt;code&gt;ostream&lt;/code&gt;,&lt;code&gt;wostream&lt;/code&gt;,&lt;code&gt;iostream&lt;/code&gt;,&lt;code&gt;wiostream&lt;/code&gt;类型。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;fstream&lt;/code&gt;头文件：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ifstream&lt;/code&gt;,&lt;code&gt;wifstream&lt;/code&gt;,&lt;code&gt;ofstream&lt;/code&gt;,&lt;code&gt;wofstream&lt;/code&gt;,&lt;code&gt;fstream&lt;/code&gt;,&lt;code&gt;wfstream&lt;/code&gt;类型。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sstream&lt;/code&gt;头文件：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;istringstream&lt;/code&gt;,&lt;code&gt;wistringstream&lt;/code&gt;,&lt;code&gt;ostringstream&lt;/code&gt;,&lt;code&gt;wostringstream&lt;/code&gt;,&lt;code&gt;stringstream&lt;/code&gt;,&lt;code&gt;wstringstream&lt;/code&gt;类型。&lt;/p&gt;
&lt;p&gt;宽字符版本的类型和函数的名字以一个“w”开始。&lt;/p&gt;
&lt;p&gt;IO 对象无拷贝和赋值。进行 IO 操作的函数通常以引用方式传递和返回值。读写一个 IO 对象会改变其状态，因此传递和返回的引用不能是&lt;code&gt;const&lt;/code&gt;的。&lt;/p&gt;
&lt;h3&gt;条件状态&lt;/h3&gt;
&lt;p&gt;下表中 &lt;em&gt;strm&lt;/em&gt; 是一种 IO 类型：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;状态 …&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;/table&gt;</summary><content type="html">&lt;h2&gt;IO 类&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;iostream&lt;/code&gt;头文件：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;istream&lt;/code&gt;,&lt;code&gt;wistream&lt;/code&gt;,&lt;code&gt;ostream&lt;/code&gt;,&lt;code&gt;wostream&lt;/code&gt;,&lt;code&gt;iostream&lt;/code&gt;,&lt;code&gt;wiostream&lt;/code&gt;类型。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;fstream&lt;/code&gt;头文件：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ifstream&lt;/code&gt;,&lt;code&gt;wifstream&lt;/code&gt;,&lt;code&gt;ofstream&lt;/code&gt;,&lt;code&gt;wofstream&lt;/code&gt;,&lt;code&gt;fstream&lt;/code&gt;,&lt;code&gt;wfstream&lt;/code&gt;类型。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sstream&lt;/code&gt;头文件：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;istringstream&lt;/code&gt;,&lt;code&gt;wistringstream&lt;/code&gt;,&lt;code&gt;ostringstream&lt;/code&gt;,&lt;code&gt;wostringstream&lt;/code&gt;,&lt;code&gt;stringstream&lt;/code&gt;,&lt;code&gt;wstringstream&lt;/code&gt;类型。&lt;/p&gt;
&lt;p&gt;宽字符版本的类型和函数的名字以一个“w”开始。&lt;/p&gt;
&lt;p&gt;IO 对象无拷贝和赋值。进行 IO 操作的函数通常以引用方式传递和返回值。读写一个 IO 对象会改变其状态，因此传递和返回的引用不能是&lt;code&gt;const&lt;/code&gt;的。&lt;/p&gt;
&lt;h3&gt;条件状态&lt;/h3&gt;
&lt;p&gt;下表中 &lt;em&gt;strm&lt;/em&gt; 是一种 IO 类型：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;状态&lt;/th&gt;
&lt;th align="left"&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;em&gt;strm&lt;/em&gt;::iostate&lt;/td&gt;
&lt;td align="left"&gt;iostate 是一种机器相关的类型，提供了表达条件状态的完整功能&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;em&gt;strm&lt;/em&gt;::badbit&lt;/td&gt;
&lt;td align="left"&gt;流已崩溃&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;em&gt;strm&lt;/em&gt;::failbit&lt;/td&gt;
&lt;td align="left"&gt;IO 操作失败了&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;em&gt;strm&lt;/em&gt;::eofbit&lt;/td&gt;
&lt;td align="left"&gt;流到达了文件结束&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;em&gt;strm&lt;/em&gt;::goodbit&lt;/td&gt;
&lt;td align="left"&gt;流未处于错误状态，此值保证为0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;s.eof()&lt;/td&gt;
&lt;td align="left"&gt;若流 s 的 eofbit 置位，返回 true&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;s.fail()&lt;/td&gt;
&lt;td align="left"&gt;若流 s 的 failbit 或 badbit 置位，返回 true&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;s.bad()&lt;/td&gt;
&lt;td align="left"&gt;若流 s 的 badbit 置位，返回 true&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;s.good()&lt;/td&gt;
&lt;td align="left"&gt;若流 s 处于有效状态，返回 true&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;s.clear()&lt;/td&gt;
&lt;td align="left"&gt;将流 s 所以状态位复位，将流的状态设为有效，返回 void&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;s.clear(flags)&lt;/td&gt;
&lt;td align="left"&gt;根据 flags 复位，flags 类型为 &lt;em&gt;strm&lt;/em&gt;::iostate，返回 void&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;s.setstate(flags)&lt;/td&gt;
&lt;td align="left"&gt;根据 flags 置位，flags 类型为 &lt;em&gt;strm&lt;/em&gt;::iostate，返回 void&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;s.rdstate()&lt;/td&gt;
&lt;td align="left"&gt;返回流 s 的当前条件状态，返回值类型为 &lt;em&gt;strm&lt;/em&gt;::iostate&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;badbit&lt;/code&gt;表示系统级错误，如不可恢复的读写错误，一旦被置位，流就无法再使用了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;failbit&lt;/code&gt;表示可恢复的错误，例如期望读取数值却读到一个字符等错误。这种问题通常是可以修正的，流还可以继续使用。&lt;/p&gt;
&lt;p&gt;如果到达文件结尾，&lt;code&gt;eofbit&lt;/code&gt;和&lt;code&gt;failbit&lt;/code&gt;都会被置位。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;goodbit&lt;/code&gt;值为0，表示流未发生错误。&lt;/p&gt;
&lt;p&gt;如果&lt;code&gt;badbit&lt;/code&gt;、&lt;code&gt;failbit&lt;/code&gt;和&lt;code&gt;eofbit&lt;/code&gt;任一个被置位，则检测流状态的条件会失败。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;good()&lt;/code&gt;函数在所有错误位均未置位的情况下返回&lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;我们将流当做条件使用的代码等价于&lt;code&gt;!fail()&lt;/code&gt;。&lt;/p&gt;
&lt;h3&gt;管理条件状态&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;// 记住 cin 的当前状态
auto old_state = cin.rdstate(); // 记住 cin 的当前状态
cin.clean();  // 使 cin 有效
process_input(cin); // 使用 cin
cin.setstate(old_state);  // 将 cin 置为原有状态
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;// 复位 failbit 和 badbit，保持其他标志位布标
cin.clear(cin.rdstate() &amp;amp; ~cin.failbit &amp;amp; ~cin.badbit);
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;管理输出缓冲&lt;/h3&gt;
&lt;p&gt;每个输出流都管理一个缓冲区，用来保存程序读写的数据。&lt;/p&gt;
&lt;p&gt;导致缓冲刷新（即，数据真正写到输出设备或文件）的原因有很多：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;程序正常结束，作为&lt;code&gt;main&lt;/code&gt;函数的&lt;code&gt;return&lt;/code&gt;操作的一部分，缓冲刷新被执行&lt;/li&gt;
&lt;li&gt;缓冲区满&lt;/li&gt;
&lt;li&gt;使用操纵符&lt;code&gt;endl&lt;/code&gt;（插入换行）、&lt;code&gt;ends&lt;/code&gt;（插入空字符）、&lt;code&gt;flush&lt;/code&gt;（什么都不插入）显式刷新&lt;/li&gt;
&lt;li&gt;在每个输出操作之后，可以用操纵符&lt;code&gt;unitbuf&lt;/code&gt;设置流的内部状态，来情况缓冲区。默认情况下，对&lt;code&gt;cerr&lt;/code&gt;是设置&lt;code&gt;unitbuf&lt;/code&gt;的，因此&lt;code&gt;cerr&lt;/code&gt;的内容都是立即刷新的&lt;/li&gt;
&lt;li&gt;一个输出流可以关联到另一个流。当读写被关联的流时，关联到的流的缓冲区会被刷新。默认情况下，&lt;code&gt;cin&lt;/code&gt;和&lt;code&gt;cerr&lt;/code&gt;都关联到&lt;code&gt;cout&lt;/code&gt;。因此读&lt;code&gt;cin&lt;/code&gt;或者写&lt;code&gt;cerr&lt;/code&gt;都会导致&lt;code&gt;cout&lt;/code&gt;的缓冲区被刷新&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;unitbuf 操纵符&lt;/h3&gt;
&lt;p&gt;如果想在每次输出操作后都刷新缓冲区，可以使用&lt;code&gt;unitbuf&lt;/code&gt;操纵符。它告诉流在接下来的每次写操作之后都执行一次&lt;code&gt;flush&lt;/code&gt;刷新。&lt;code&gt;nounitbuf&lt;/code&gt;操纵符则重置流，使其恢复使用正常的系统管理的缓冲区刷新机制：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;cout &amp;lt;&amp;lt; unitbuf;    // 所有输出操作后都会立即刷新缓冲区
// 任何输出都会立即刷新，无缓冲
cout &amp;lt;&amp;lt; nounitbuf;    // 回到正常的缓冲方式
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;关联输入和输出流&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;tie()&lt;/code&gt;有两个重载的版本：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不带参数的版本返回指向输出流的指针。如果本对象当前关联到一个输出流，则返回的就是指向这个流的指针，如果对象未关联到流，则返回空指针&lt;/li&gt;
&lt;li&gt;第二个版本接受一个指向&lt;code&gt;ostream&lt;/code&gt;的指针，将自己关联到此&lt;code&gt;ostream&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每个流同时最多关联到一个流，但多个流可以同时关联到同一个&lt;code&gt;ostream&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;文件输入输出&lt;/h2&gt;
&lt;h3&gt;fstream 特有的操作&lt;/h3&gt;
&lt;p&gt;下表中的 &lt;em&gt;fstream&lt;/em&gt; 是头文件 fstream 中定义的一个类型：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;操作&lt;/th&gt;
&lt;th align="left"&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;em&gt;fstream&lt;/em&gt; fstrm;&lt;/td&gt;
&lt;td align="left"&gt;创建一个未绑定的文件流&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;em&gt;fstream&lt;/em&gt; fstrm(s);&lt;/td&gt;
&lt;td align="left"&gt;创建一个 &lt;em&gt;fstream&lt;/em&gt;，并打开名为 s 的文件。s 可以是 string 类型或者指向 C 风格字符串的指针。这些构造函数都是&lt;code&gt;explicit&lt;/code&gt;的。默认的文件模式 mode 依赖于 &lt;em&gt;fstream&lt;/em&gt; 的类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;em&gt;fstream&lt;/em&gt; fstrm(s, mode);&lt;/td&gt;
&lt;td align="left"&gt;按 mode 打开文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;fstrm.open(s)&lt;/td&gt;
&lt;td align="left"&gt;打开名为 s 的文件并与 fstrm 绑定。s 可以是 string 类型或者指向 C 风格字符串的指针。默认的文件模式 mode 依赖于 &lt;em&gt;fstream&lt;/em&gt; 的类型。返回&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;fstrm.close()&lt;/td&gt;
&lt;td align="left"&gt;关闭与 fstrm 绑定的文件。返回&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;fstrm.is_open()&lt;/td&gt;
&lt;td align="left"&gt;返回一个布尔值，指出与 fstrm 关联的文件是否打开成功且尚未关闭&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;如果调用&lt;code&gt;open()&lt;/code&gt;失败，&lt;code&gt;failbit&lt;/code&gt;会被置位，条件会为假：&lt;code&gt;if(open(file))&lt;/code&gt;可用于判定。&lt;/p&gt;
&lt;p&gt;对一个已经打开的文件流调用&lt;code&gt;open()&lt;/code&gt;会失败，并且&lt;code&gt;failbit&lt;/code&gt;会被置位。为了将文件流关联到另一个文件，必须先关闭已经关联的文件。&lt;/p&gt;
&lt;p&gt;当一个&lt;code&gt;fstream&lt;/code&gt;对象被销毁时，&lt;code&gt;close&lt;/code&gt;会自动被调用。&lt;/p&gt;
&lt;h3&gt;文件模式&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;文件模式&lt;/th&gt;
&lt;th align="left"&gt;意义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;in&lt;/td&gt;
&lt;td align="left"&gt;只读&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;out&lt;/td&gt;
&lt;td align="left"&gt;只写（会清空已有数据）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;app&lt;/td&gt;
&lt;td align="left"&gt;每次写操作前均定位到文件末尾&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;ate&lt;/td&gt;
&lt;td align="left"&gt;打开文件后立即定位到文件末尾&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;trunc&lt;/td&gt;
&lt;td align="left"&gt;截断文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;binary&lt;/td&gt;
&lt;td align="left"&gt;以二进制方式进行 IO&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;ifstream&lt;/code&gt;默认&lt;code&gt;in&lt;/code&gt;模式；&lt;code&gt;ofstream&lt;/code&gt;默认&lt;code&gt;out&lt;/code&gt;模式；&lt;code&gt;fstream&lt;/code&gt;默认&lt;code&gt;in&lt;/code&gt;和&lt;code&gt;out&lt;/code&gt;模式打开。&lt;/p&gt;
&lt;h2&gt;string 流&lt;/h2&gt;
&lt;h3&gt;fstream 特有的操作&lt;/h3&gt;
&lt;p&gt;下表中的 &lt;em&gt;sstream&lt;/em&gt; 是头文件 sstream 中定义的一个类型：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;操作&lt;/th&gt;
&lt;th align="left"&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;em&gt;sstream&lt;/em&gt; strm;&lt;/td&gt;
&lt;td align="left"&gt;创建一个未绑定的 stringstream 对象&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;em&gt;sstream&lt;/em&gt; strm(s);&lt;/td&gt;
&lt;td align="left"&gt;strm 是一个 sstream 对象，保存 string s 的一个拷贝。此构造函数时&lt;code&gt;explicit&lt;/code&gt;的&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;strm.str()&lt;/td&gt;
&lt;td align="left"&gt;返回 strm 所保存的 string 的拷贝&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;strm.str(s)&lt;/td&gt;
&lt;td align="left"&gt;将 string s 拷贝到 strm 中，返回 void&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</content><category term="C++"></category></entry><entry><title>C++ Primer 第七章 类</title><link href="https://xutree.github.io/pages/2018/10/09/C++_Primer_Chapter_7/" rel="alternate"></link><published>2018-10-09T20:38:15+08:00</published><updated>2018-10-09T20:38:15+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-09:/pages/2018/10/09/C++_Primer_Chapter_7/</id><summary type="html">&lt;p&gt;类的基本思想是数据抽象和封装。&lt;/p&gt;
&lt;p&gt;数据抽象是一种依赖于接口和实现分离的编程（以及设计）技术。类的接口包括用户可以执行的操作，类的实现包括类的数据成员，负责接口实现的函数体以及定义类所需的各种私有函数。&lt;/p&gt;
&lt;p&gt;封装实现了类的接口和实现的分离。封装后的类隐藏了它的实现细节，类的用户只能使用接口而无法访问实现部分。&lt;/p&gt;
&lt;h2&gt;类的定义&lt;/h2&gt;
&lt;p&gt;定义在类内部的函数时隐式&lt;code&gt;inline&lt;/code&gt;的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;this&lt;/code&gt;是一个常量指针。&lt;/p&gt;
&lt;h3&gt;const 成员函数&lt;/h3&gt;
&lt;p&gt;通过在紧随参数列表之后添加&lt;code&gt;const&lt;/code&gt;，可以定义&lt;code&gt;const&lt;/code&gt;成员函数。&lt;code&gt;const&lt;/code&gt;的作用是修改隐式&lt;code&gt;this&lt;/code&gt;指针的类型。&lt;/p&gt;
&lt;p&gt;默认情况下，&lt;code&gt;this&lt;/code&gt;指针的类型是指向类类型非常量版本的常量指针（顶层常量）。这意味着我们不能把&lt;code&gt;this&lt;/code&gt;绑定到一个常量对象上。&lt;/p&gt;
&lt;p&gt;常量对象，以及常量对象的引用或者指针都只能调用常量成员函数。&lt;/p&gt;
&lt;h3&gt;类作用域和成员函数&lt;/h3&gt;
&lt;p&gt;编译器分两步处理类：首先编译成员的声明，然后才轮到成员函数体（如果有的话）。因此，成员函数体可以随意使用类中的其他成员而无须在意这些成员出现的顺序。&lt;/p&gt;
&lt;p&gt;编译器处理完类中的全部声明后才会处理成员函数的定义。&lt;/p&gt;
&lt;p&gt;这种两阶段的处理方式只适用于成员函数中使用的名字。声明中使用的名字，包括返回类型或者参数列表中使用的名字，都必须在使用前确保可见。如果某个成员的声明使用了类中尚未出现的名字，则编译器将会在定义该类的作用域中继续查找 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;类的基本思想是数据抽象和封装。&lt;/p&gt;
&lt;p&gt;数据抽象是一种依赖于接口和实现分离的编程（以及设计）技术。类的接口包括用户可以执行的操作，类的实现包括类的数据成员，负责接口实现的函数体以及定义类所需的各种私有函数。&lt;/p&gt;
&lt;p&gt;封装实现了类的接口和实现的分离。封装后的类隐藏了它的实现细节，类的用户只能使用接口而无法访问实现部分。&lt;/p&gt;
&lt;h2&gt;类的定义&lt;/h2&gt;
&lt;p&gt;定义在类内部的函数时隐式&lt;code&gt;inline&lt;/code&gt;的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;this&lt;/code&gt;是一个常量指针。&lt;/p&gt;
&lt;h3&gt;const 成员函数&lt;/h3&gt;
&lt;p&gt;通过在紧随参数列表之后添加&lt;code&gt;const&lt;/code&gt;，可以定义&lt;code&gt;const&lt;/code&gt;成员函数。&lt;code&gt;const&lt;/code&gt;的作用是修改隐式&lt;code&gt;this&lt;/code&gt;指针的类型。&lt;/p&gt;
&lt;p&gt;默认情况下，&lt;code&gt;this&lt;/code&gt;指针的类型是指向类类型非常量版本的常量指针（顶层常量）。这意味着我们不能把&lt;code&gt;this&lt;/code&gt;绑定到一个常量对象上。&lt;/p&gt;
&lt;p&gt;常量对象，以及常量对象的引用或者指针都只能调用常量成员函数。&lt;/p&gt;
&lt;h3&gt;类作用域和成员函数&lt;/h3&gt;
&lt;p&gt;编译器分两步处理类：首先编译成员的声明，然后才轮到成员函数体（如果有的话）。因此，成员函数体可以随意使用类中的其他成员而无须在意这些成员出现的顺序。&lt;/p&gt;
&lt;p&gt;编译器处理完类中的全部声明后才会处理成员函数的定义。&lt;/p&gt;
&lt;p&gt;这种两阶段的处理方式只适用于成员函数中使用的名字。声明中使用的名字，包括返回类型或者参数列表中使用的名字，都必须在使用前确保可见。如果某个成员的声明使用了类中尚未出现的名字，则编译器将会在定义该类的作用域中继续查找。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;typedef&lt;/span&gt; &lt;span class="kr"&gt;double&lt;/span&gt; &lt;span class="nx"&gt;Money&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;string&lt;/span&gt; &lt;span class="nx"&gt;bal&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;Account&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="kr"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="nx"&gt;Money&lt;/span&gt; &lt;span class="nx"&gt;balance() {&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;bal&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kr"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="nx"&gt;Money&lt;/span&gt; &lt;span class="nx"&gt;bal&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="c1"&gt;// ...&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当编译器看到 balance 函数的声明语句时，它将在 Account 类的范围内寻找对 Money 的声明。编译器只考虑 Account 中在使用 Money 前出现的声明，因为没找到匹配的成员，所以编译器会接着到 Account 的外层作用域中查找。在上面的例子中，编译器会找到 Money 的&lt;code&gt;typedef&lt;/code&gt;语句，该类型被用作 balance 函数的返回类型及数据成员 bal 的类型。另一方面，balance 函数体在整个类可见后才被处理。因此，该函数的&lt;code&gt;return&lt;/code&gt;语句返回名为 bal 的成员，而非外层作用域的&lt;code&gt;string&lt;/code&gt;对象。&lt;/p&gt;
&lt;h3&gt;构造函数&lt;/h3&gt;
&lt;p&gt;构造函数不能被声明成&lt;code&gt;const&lt;/code&gt;的。&lt;/p&gt;
&lt;p&gt;当我们创建类的一个&lt;code&gt;const&lt;/code&gt;对象时，直到构造函数完成初始化过程，对象才能真正取得其“常量”属性。因此，构造函数在&lt;code&gt;const&lt;/code&gt;对象的构造过程中可以向其写值。&lt;/p&gt;
&lt;p&gt;如果我们的类没有显式定义构造函数，编译器会生成合成的默认构造函数。对于大多数类来说，合成的默认构造函数按照如下规则初始化类的数据成员：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果存在类内的初始值，用它来初始化成员&lt;/li&gt;
&lt;li&gt;否则，执行默认初始化&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 C++ 11中，如果我们需要默认的行为，那么可以通过在参数列表后面写上 &lt;strong&gt;= default&lt;/strong&gt; 来要求编译器生成构造函数。如果 &lt;strong&gt;= default&lt;/strong&gt; 出现在类的内部，则默认构造函数是内联的；如果它出现在外部，则该成员默认情况下不是内联的。&lt;/p&gt;
&lt;h4&gt;构造函数初始值列表&lt;/h4&gt;
&lt;p&gt;构造函数初始值列表：&lt;code&gt;Sales_data(const std::string &amp;amp;s) : bookNo(s) { }&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果成员是&lt;code&gt;const&lt;/code&gt;或者引用的话，必须将其初始化。类似的，当成员属于某种类类型且该类类型没有定义默认构造函数时，也必须将这个成员初始化。&lt;/p&gt;
&lt;p&gt;随着构造函数体一开始执行，初始化就完成了。我们初始化&lt;code&gt;const&lt;/code&gt;或者引用类型的唯一机会就是通过构造函数初始化。&lt;/p&gt;
&lt;p&gt;构造函数初始值列表只说明用于初始化成员的值。成员的初始化顺序与它们在类定义中出现顺序一致。&lt;/p&gt;
&lt;h4&gt;委托构造函数&lt;/h4&gt;
&lt;p&gt;一个委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程，或者说它把它自己的一些（或者全部）职责委托给了其他构造函数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;Sales_data&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="kr"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="c1"&gt;// 非委托构造函数&lt;/span&gt;
    &lt;span class="nx"&gt;Sales_data&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt; &lt;span class="nx"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;unsigned&lt;/span&gt; &lt;span class="nx"&gt;cnt&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kr"&gt;double&lt;/span&gt; &lt;span class="nx"&gt;price&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt;
        &lt;span class="nx"&gt;bookNo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;s&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="nx"&gt;units_sold&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;cnt&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="nx"&gt;revenue&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;cnt&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;price&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="c1"&gt;// 其余构造函数都委托给另外一个构造函数&lt;/span&gt;
    &lt;span class="nx"&gt;Sales_data&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;Sales_data&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="nx"&gt;Sales_data&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt; &lt;span class="nx"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;Sales_data&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="nx"&gt;Sales_data&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;istream&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;is&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;Sales_data() {&lt;/span&gt; &lt;span class="nx"&gt;read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;is&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="c1"&gt;//其他成员&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;受委托的构造函数先执行。&lt;/p&gt;
&lt;h2&gt;访问控制与封装&lt;/h2&gt;
&lt;p&gt;定义在 &lt;strong&gt;public&lt;/strong&gt; 说明符之后的成员在整个程序内可被访问，&lt;strong&gt;public&lt;/strong&gt; 成员定义类的接口。&lt;/p&gt;
&lt;p&gt;定义在 &lt;strong&gt;private&lt;/strong&gt; 说明符之后的成员可以被类的成员函数访问，但是不能被使用该类的代码访问。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;class&lt;/code&gt;和&lt;code&gt;struct&lt;/code&gt;定义类唯一的区别就是默认的访问权限。&lt;/p&gt;
&lt;h3&gt;友元&lt;/h3&gt;
&lt;p&gt;通过友元，类可以允许其他类或者函数访问它的&lt;strong&gt;非公有成员&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果类想把一个函数作为它的友元，只需要增加一条以&lt;code&gt;friend&lt;/code&gt;关键字开始的函数声明即可。友元声明只能出现在类定义的内部，但是在类内出现的具体位置不限。友元不是类的成员也不受它所在区域访问控制级别的约束。&lt;/p&gt;
&lt;p&gt;友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明。如果我们希望类的用户能够调用某个友元函数，那么我们必须在友元声明之外再专门对函数进行一次声明。&lt;/p&gt;
&lt;p&gt;友元关系不存在传递性。&lt;/p&gt;
&lt;p&gt;如果一个类指定了友元类，则友元类的成员函数可以访问此类&lt;strong&gt;包括非公有成员在内的所有成员&lt;/strong&gt;。&lt;/p&gt;
&lt;h2&gt;类的其他特性&lt;/h2&gt;
&lt;h3&gt;定义类型成员&lt;/h3&gt;
&lt;p&gt;类可以自定义某种类型在类中的别名。要注意，用来定义类型的成员必须先定义后使用。&lt;/p&gt;
&lt;h3&gt;可变数据成员&lt;/h3&gt;
&lt;p&gt;有时我们希望能够修改类的某个数据成员，即使是在一个&lt;code&gt;const&lt;/code&gt;成员函数内。通过关键字&lt;code&gt;mutable&lt;/code&gt;可以达到这种效果。一个可变数据成员永远不会是&lt;code&gt;const&lt;/code&gt;，即使它是&lt;code&gt;const&lt;/code&gt;对象的成员。&lt;/p&gt;
&lt;h3&gt;返回 *this 的成员函数&lt;/h3&gt;
&lt;p&gt;一个&lt;code&gt;const&lt;/code&gt;成员函数如果以引用的方式返回*this，那么它的返回类型将是常量引用。&lt;/p&gt;
&lt;p&gt;基于&lt;code&gt;const&lt;/code&gt;的重载：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;Screen&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="kr"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="c1"&gt;// 根据对象是否是 const 重载 display 函数&lt;/span&gt;
    &lt;span class="nx"&gt;Screen&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;display&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;ostream&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;os&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;   &lt;span class="nx"&gt;do_display&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;os&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;Screen&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;display&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;ostream&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;os&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;const&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;   &lt;span class="nx"&gt;do_display&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;os&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kr"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="c1"&gt;// 该函数负责显示 Screen 的内容&lt;/span&gt;
    &lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="nx"&gt;do_display&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;ostream&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;os&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;   &lt;span class="nx"&gt;os&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="nx"&gt;contents&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;类类型&lt;/h3&gt;
&lt;p&gt;声明方法：&lt;code&gt;Sales_data item1;&lt;/code&gt;或&lt;code&gt;class Sales_data item1;&lt;/code&gt;后一种从 C 语言继承而来。&lt;/p&gt;
&lt;p&gt;类的声明：前向声明，在类声明之后定义之前，类是一个不完全类型。&lt;/p&gt;
&lt;p&gt;不完全类型只能在非常有限的情景下使用：定义指向这种类型的引用或指针，也可以声明（但是不能定义）以不完全类型作为参数或者返回类型的函数。&lt;/p&gt;
&lt;p&gt;直到类被定义之后数据成员才可以被声明成这种类类型。然而，当一个类的名字出现后，它被认为是声明过了（但尚未定义），因此允许包含指向它自身类型的引用或者指针（有没有想到链表结构）。&lt;/p&gt;
&lt;h4&gt;隐式的类类型转换&lt;/h4&gt;
&lt;p&gt;如果构造函数只接受一个实参，则它实际上定义了转换为此类类型的隐式转换机制，有时我们把这种构造函数称为转换构造函数。&lt;/p&gt;
&lt;p&gt;只允许一步类类型转换。类类型转换不是总有效。&lt;/p&gt;
&lt;h4&gt;抑制构造函数定义的隐式转换&lt;/h4&gt;
&lt;p&gt;可以通过将构造函数声明为&lt;code&gt;explicit&lt;/code&gt;加以阻止。&lt;/p&gt;
&lt;p&gt;关键字&lt;code&gt;explicit&lt;/code&gt;只对一个实参的构造函数有效。需要多个实参的构造函数不能用于执行隐式转换，所以无须将这些构造函数指定为&lt;code&gt;explicit&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;只能在类内声明构造函数时使用&lt;code&gt;explicit&lt;/code&gt;关键字，在类外部定义时不应重复。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;explicit&lt;/code&gt;构造函数只能用于直接初始化。&lt;/p&gt;
&lt;p&gt;尽管编译器不会将&lt;code&gt;explicit&lt;/code&gt;的构造函数用于隐式转换过程，但是我们可以使用这样的构造函数显式地强制类型转换：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;item.combine(static_cast&amp;lt;Sales_data&amp;gt;(cin));
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;聚合类&lt;/h3&gt;
&lt;p&gt;当一个类满足如下条件时，我们说它是聚合的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有成员都是&lt;code&gt;public&lt;/code&gt;的&lt;/li&gt;
&lt;li&gt;没有定义任何构造函数&lt;/li&gt;
&lt;li&gt;没有类内初始值&lt;/li&gt;
&lt;li&gt;没有基类，也没有虚函数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;struct Data {
    int ival;
    string s;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以使用初始化列表初始化，初始值的顺序必须与声明的顺序一致。如果初始值列表中的元素个数少于类的成员数量，则靠后的成员被值初始化。&lt;/p&gt;
&lt;h3&gt;字面值常量类&lt;/h3&gt;
&lt;p&gt;字面值类型的类可能含有&lt;code&gt;constexpr&lt;/code&gt;函数成员，它们是隐式&lt;code&gt;const&lt;/code&gt;成员函数。&lt;/p&gt;
&lt;p&gt;数据成员都是字面值类型的聚合类是字面值常量类。&lt;/p&gt;
&lt;p&gt;如果一个类不是聚合类，符合以下要求也是一个字面值常量类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据成员都必须是字面值类型&lt;/li&gt;
&lt;li&gt;类必须至少有一个&lt;code&gt;constexpr&lt;/code&gt;构造函数&lt;/li&gt;
&lt;li&gt;如果一个数据成员含有类内初始值，则内置类型成员的初始值必须是一条常量表达式；如果成员属于某种类类型，则初始值必须使用成员自己的&lt;code&gt;constexpr&lt;/code&gt;构造函数&lt;/li&gt;
&lt;li&gt;类必须使用析构函数的默认定义，该成员负责销毁类的定义&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;尽管构造函数不能是&lt;code&gt;const&lt;/code&gt;的，但是字面值常量类的构造函数可以使&lt;code&gt;constexpr&lt;/code&gt;函数。事实上，一个字面值常量类都必须至少提供一个&lt;code&gt;constexpr&lt;/code&gt;构造函数。通过前置关键字&lt;code&gt;constexpr&lt;/code&gt;就可以声明一个&lt;code&gt;constexpr&lt;/code&gt;构造函数。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;constexpr&lt;/code&gt;构造函数可以声明成&lt;code&gt;=default&lt;/code&gt;或者删除函数的形式，否则，&lt;code&gt;constexpr&lt;/code&gt;构造函数就必须既符合构造函数的要求（意味着不能包含返回语句），又符合&lt;code&gt;constexpr&lt;/code&gt;函数的要求（意味着它唯一可执行语句就是返回语句），综合这两点，&lt;code&gt;constexpr&lt;/code&gt;构造函数体一般来说应该是空的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;constexpr&lt;/code&gt;构造函数必须初始化所有数据成员，初始值或者使用&lt;code&gt;constexpr&lt;/code&gt;构造函数，或者是一条常量表达式。&lt;/p&gt;
&lt;h2&gt;类的静态成员&lt;/h2&gt;
&lt;p&gt;类的静态成员存在于任何对象之外，对象中不包含任何与静态数据成员有关的数据。类似的，静态成员函数也不与任何对象绑定在一起，它们不包含&lt;code&gt;this&lt;/code&gt;指针。作为结果，静态成员函数不能声明成&lt;code&gt;const&lt;/code&gt;的，而且我们也不能在静态函数体内使用&lt;code&gt;this&lt;/code&gt;指针。&lt;/p&gt;
&lt;p&gt;成员函数不用通过作用域运算符就能直接使用静态成员。&lt;/p&gt;
&lt;p&gt;当在类的外部定义静态成员时，不能重复&lt;code&gt;static&lt;/code&gt;关键字，该关键字只出现在类内部的声明语句。&lt;/p&gt;
&lt;p&gt;必须在类的外部定义和初始化每个静态成员（一个例外，如果静态成员是字面值类型的&lt;code&gt;constexpr&lt;/code&gt;可以在类内给它提供一个整数类型的常量表达式初始值），一个静态成员只能被初始化一次。&lt;/p&gt;
&lt;p&gt;类似于全局变量，静态数据成员定义在任何函数之外，一直存在于程序的整个生命周期中。&lt;/p&gt;
&lt;p&gt;静态数据成员可以是不完全类型，非静态数据成员只能声明成它所属类的指针或引用。&lt;/p&gt;
&lt;p&gt;静态数据成员可以作为默认实参，非静态数据成员不行，因为它的值本身属于对象的一部分，这么做的结果是无法真正提供一个对象以便从中获得成员的值（类似于循环定义），将引发错误。&lt;/p&gt;</content><category term="C++"></category></entry><entry><title>C++ Primer 第六章 函数</title><link href="https://xutree.github.io/pages/2018/10/09/C++_Primer_Chapter_6/" rel="alternate"></link><published>2018-10-09T15:55:08+08:00</published><updated>2018-10-09T15:55:08+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-09:/pages/2018/10/09/C++_Primer_Chapter_6/</id><summary type="html">&lt;p&gt;函数是一个命名了的代码块。&lt;/p&gt;
&lt;h2&gt;函数基础&lt;/h2&gt;
&lt;p&gt;为了与 C 语言兼容，可以使用关键字&lt;code&gt;void&lt;/code&gt;表示函数没有形参。&lt;/p&gt;
&lt;p&gt;函数的返回值不能是数组或者函数类型，但可以返回指向数组和函数的指针。&lt;/p&gt;
&lt;p&gt;自动对象：只存在于块执行期间的对象。当块的执行结束后，块中创建的自动对象的值就变成未定义的了。&lt;/p&gt;
&lt;p&gt;局部静态对象：在程序执行路径第一次经过对象定义语句时初始化，并且直到程序终止才销毁。如果没有显示初始化，则执行值初始化，内置类型的局部静态变量初始化为0。&lt;/p&gt;
&lt;h2&gt;参数传递&lt;/h2&gt;
&lt;p&gt;值传递和引用传递。&lt;/p&gt;
&lt;p&gt;当某种类型不支持拷贝操作时，函数只能通过引用形参访问该类型的对象。如 IO 类型。&lt;/p&gt;
&lt;h3&gt;const 形参和实参&lt;/h3&gt;
&lt;p&gt;如果函数无须改变引用形参的值，最好将其声明为常量引用。&lt;/p&gt;
&lt;p&gt;此外，使用引用而非常量引用也会极大地限制函数所能接受的实参类型。例如，我们不能把&lt;code&gt;const&lt;/code&gt;对象、字面值或者需要类型转换的对象传递给普通的引用形参，这种绝不像看起来那么简单，它可能造成出人意料的后果。考虑如下函数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nd"&gt;size_type&lt;/span&gt; &lt;span class="nt"&gt;find_char&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;string&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nt"&gt;s&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;char&lt;/span&gt; &lt;span class="nt"&gt;c&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nd"&gt;size_type …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;函数是一个命名了的代码块。&lt;/p&gt;
&lt;h2&gt;函数基础&lt;/h2&gt;
&lt;p&gt;为了与 C 语言兼容，可以使用关键字&lt;code&gt;void&lt;/code&gt;表示函数没有形参。&lt;/p&gt;
&lt;p&gt;函数的返回值不能是数组或者函数类型，但可以返回指向数组和函数的指针。&lt;/p&gt;
&lt;p&gt;自动对象：只存在于块执行期间的对象。当块的执行结束后，块中创建的自动对象的值就变成未定义的了。&lt;/p&gt;
&lt;p&gt;局部静态对象：在程序执行路径第一次经过对象定义语句时初始化，并且直到程序终止才销毁。如果没有显示初始化，则执行值初始化，内置类型的局部静态变量初始化为0。&lt;/p&gt;
&lt;h2&gt;参数传递&lt;/h2&gt;
&lt;p&gt;值传递和引用传递。&lt;/p&gt;
&lt;p&gt;当某种类型不支持拷贝操作时，函数只能通过引用形参访问该类型的对象。如 IO 类型。&lt;/p&gt;
&lt;h3&gt;const 形参和实参&lt;/h3&gt;
&lt;p&gt;如果函数无须改变引用形参的值，最好将其声明为常量引用。&lt;/p&gt;
&lt;p&gt;此外，使用引用而非常量引用也会极大地限制函数所能接受的实参类型。例如，我们不能把&lt;code&gt;const&lt;/code&gt;对象、字面值或者需要类型转换的对象传递给普通的引用形参，这种绝不像看起来那么简单，它可能造成出人意料的后果。考虑如下函数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nd"&gt;size_type&lt;/span&gt; &lt;span class="nt"&gt;find_char&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;string&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nt"&gt;s&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;char&lt;/span&gt; &lt;span class="nt"&gt;c&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nd"&gt;size_type&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nt"&gt;occurs&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;则只能将 find_char 函数用于&lt;code&gt;string&lt;/code&gt;对象。类似下面的调用将在编译时发生错误：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;find_char(&amp;quot;Hello World&amp;quot;, &amp;#39;o&amp;#39;, ctr);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;还有一个更难察觉的问题。假如其它函数（正确的）将它们的形参定义成常量引用，那么上述的 find_char 函数无法在此类函数中正常使用。例如&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;bool&lt;/span&gt; &lt;span class="nt"&gt;is_sentence&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;const&lt;/span&gt; &lt;span class="nt"&gt;string&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nt"&gt;s&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;size_type&lt;/span&gt; &lt;span class="n"&gt;ctr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="err"&gt;return&lt;/span&gt; &lt;span class="err"&gt;find_char(s,&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;.&amp;#39;,&lt;/span&gt; &lt;span class="err"&gt;ctr)&lt;/span&gt; &lt;span class="err"&gt;==&lt;/span&gt; &lt;span class="err"&gt;s.size()&lt;/span&gt; &lt;span class="err"&gt;-&lt;/span&gt; &lt;span class="err"&gt;1&lt;/span&gt; &lt;span class="err"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="err"&gt;ctr&lt;/span&gt; &lt;span class="err"&gt;==&lt;/span&gt; &lt;span class="err"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;正确的修改思路是改正 find_char 函数的形参。如果实在不能修改 find_char，就在 is_sentence 内部定义一个&lt;code&gt;string&lt;/code&gt;类型的变量，令其为 s 的副本，然后把这个对象传递给 find_char。&lt;/p&gt;
&lt;p&gt;用实参初始化形参时，会忽略顶层&lt;code&gt;const&lt;/code&gt;。也就是说，当形参是顶层&lt;code&gt;const&lt;/code&gt;时，传给它常量对象或者非常量对象都是可以的。&lt;/p&gt;
&lt;p&gt;可以使用一个非常量初始化一个底层&lt;code&gt;const&lt;/code&gt;对象，但反过来不行。&lt;/p&gt;
&lt;h3&gt;数组形参&lt;/h3&gt;
&lt;p&gt;数组的两个性质：不允许拷贝数组；使用数组时会将其转换成指针。&lt;/p&gt;
&lt;p&gt;当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针。&lt;/p&gt;
&lt;p&gt;尽管不能以值传递的方式传递数组，但是我们可以把形参写成类似数组的形式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;void print(const int*);
void print(const int[]);
void print(const int[10]);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;尽管表现形式不同，但是上面的三个函数是等价的：每个函数的唯一形参都是&lt;code&gt;const int*&lt;/code&gt;类型的。如果我们传给 print 函数的是一个数组，则实参自动的转换成指向数组首元素的指针，数组的大小对函数的调用没有影响。&lt;/p&gt;
&lt;p&gt;因为数组是以指针的形式传递给函数的，所以一开始函数并不知道数组的确切尺寸，调用者应该为此提供一些额外的信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用标记指定数组长度：让数组本身包含一个结束标记，例如 C 风格字符串&lt;/li&gt;
&lt;li&gt;使用标准库规范，&lt;code&gt;begin()&lt;/code&gt;和&lt;code&gt;end()&lt;/code&gt;函数&lt;/li&gt;
&lt;li&gt;显示传递一个表示数组大小的形参&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当函数不需要对数组元素执行写操作的时候，数组形参应该是指向&lt;code&gt;const&lt;/code&gt;的指针，注意下面的函数只能作用于大小为10的数组&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;void print(int (&amp;amp;arr)[10])
{
        for (auto elem : arr)
                cout &amp;lt;&amp;lt; elem &amp;lt;&amp;lt; endl;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;main：处理命令行选项&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int main(int argc, char *argv[]) { ... }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;第二个形参 argv 是一个数组，它的元素是指向 C 风格字符串的指针；第一个形参 argc 表示数组中字符串的数量。因为第二个形参是数组，所以 main 函数也可以定义成：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int main(int argc, char **argv) { ... }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当实参传给 main 函数之后，argv 的第一个元素指向程序的名字或者一个空字符串，接下来的元素依次传递命令行提供的实参，最后一个指针之后的元素值保证为0。&lt;/p&gt;
&lt;h3&gt;含有可变形参的函数&lt;/h3&gt;
&lt;p&gt;为了编写能够处理不同数量实参的函数，C++11 新标准提供了两种主要的方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果所有实参类型相同，可以传递一个名为&lt;code&gt;initializer_list&lt;/code&gt;的标准库类型&lt;/li&gt;
&lt;li&gt;如果实参的类型不同，可以编写可变参数模板&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++ 还有一种特殊的形参类型（即省略号），可以用它传递可变数量的实参，不过需要注意的是，这种功能一般只用于与 C 函数交互的接口程序&lt;/p&gt;
&lt;h4&gt;initializer_list 形参&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;initializer_list&lt;/code&gt;类型定义在同名的头文件中。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;initializer_list&lt;/code&gt;是一种类型模板，提供的操作如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;initializer_list &amp;lt;T&amp;gt; lst;&lt;/code&gt;默认初始化；T 类型元素的空列表。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;initializer_list &amp;lt;T&amp;gt; lst{a,b,c...};&lt;/code&gt;lst 的元素数量和初始值一样多；lst 的元素是对应初始值的副本；列表中的元素是 const。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;lst2(lst);&lt;/code&gt;拷贝或赋值一个&lt;code&gt;initializer_list&lt;/code&gt;对象不会拷贝列表中的元素；拷贝后，原始列表和副本共享元素。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;lst2 = lst;&lt;/code&gt;等价于&lt;code&gt;lst2(lst)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;lst.size();&lt;/code&gt;列表中的元素数量。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;lst.begin();&lt;/code&gt;返回指向 lst 中首元素的指针。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;lst.end();&lt;/code&gt;返回指向 lst 中尾元素下一位置的指针。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;initializer_list&lt;/code&gt;和&lt;code&gt;vector&lt;/code&gt;一样，也是类型模板，定义&lt;code&gt;initializer_list&lt;/code&gt;对象时，必须说明列表中所含对象的类型。和&lt;code&gt;vector&lt;/code&gt;不一样的是，&lt;code&gt;initializer_list&lt;/code&gt;对象中的元素永远是常量值。&lt;/p&gt;
&lt;p&gt;如果想向&lt;code&gt;initializer_list&lt;/code&gt;形参中传递一个值的序列，则必须把序列放在一对花括号内：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//expected和actual是string对象
if (expected != actual)
        error_msg({&amp;quot;functionX&amp;quot;, expected, actual});
else
        error_msg({&amp;quot;functionX&amp;quot;, &amp;quot;okay&amp;quot;});
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;省略符形参&lt;/h4&gt;
&lt;p&gt;省略符形参是为了便于 C++ 程序访问某些特殊的 C 代码而设置的，这些代码使用了名为 varargs 的 C 标准库功能。通常，省略符形参不应用于其他目的。你的 C 编译器文档会描述如何使用 varargs。&lt;/p&gt;
&lt;p&gt;省略符形参只能出现在形参列表的最后一个位置，无外乎两种形式，在第一种形式中，形参声明后面的逗号是可选的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;void foo(parm_list,...);
void foo(...);
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;返回类型和 return 语句&lt;/h2&gt;
&lt;p&gt;返回&lt;code&gt;void&lt;/code&gt;的函数不要求非得有&lt;code&gt;return&lt;/code&gt;语句，以为这类函数的最后一句会隐式的执行&lt;code&gt;return&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;返回的值用于初始化调用点的一个临时量，该临时量就是函数调用的结果。&lt;/p&gt;
&lt;p&gt;不要返回局部对象的引用或指针。&lt;/p&gt;
&lt;p&gt;调用一个返回引用的函数得到左值，其他返回类型得到右值。&lt;/p&gt;
&lt;p&gt;C++ 11新标准规定，函数可以返回花括号包围的值的列表，类似于其他返回结果，此处的列表也用来对表示函数返回的临时量进行初始化。如果列表为空，临时量执行值初始化。如果函数返回的是内置类型，则花括号包围的列表最多包含一个值，且该值所占空间不应该大于目标类型的空间。如果返回的是类类型，由类本身定义初始值如何使用。&lt;/p&gt;
&lt;p&gt;如果控制语句到达了 main 函数的结尾处而且没有&lt;code&gt;return&lt;/code&gt;语句，编译器会隐式的插入一条返回0的&lt;code&gt;return&lt;/code&gt;语句。&lt;/p&gt;
&lt;p&gt;cstdlib 头文件定义了两个预处理变量表示成功与失败：&lt;code&gt;EXIT_SUCCESS&lt;/code&gt;，&lt;code&gt;EXIT_FAILURE&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;int (*func(int i))[10];&lt;/code&gt;func 是一个函数指针，指向：接受一个&lt;code&gt;int&lt;/code&gt;参数，返回值是包含10个&lt;code&gt;int&lt;/code&gt;数组的地址的函数。也可以利用尾置返回类型（C++ 11）写为：&lt;code&gt;auto func(int i) -&amp;gt; int(*)[10];&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;还有一种情况，如果我们知道函数返回的指针将指向哪个数组，就可以使用&lt;code&gt;decltype&lt;/code&gt;关键字声明返回类型。例如，下面的函数返回一个指针，该指针根据参数i的不同指向两个已知数组中的某一个：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int odd[] = {1, 3, 5, 7, 9};
int even[] = {0, 2, 4, 6, 8};
//返回一个指针，该指针指向含有5个整数的数组
decltype(odd) *arrPtr(int i)
{
        return (i % 2) ? &amp;amp;odd : &amp;amp;even;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;arrPtr 使用关键字&lt;code&gt;decltype&lt;/code&gt;表示它的返回类型是个指针，并且该指针所指的对象与 odd 的类型一致。因为 odd 是数组，所以 arrPtr 返回一个指向含有5个整数的数组的指针。有一个地方需要注意，&lt;code&gt;decltype&lt;/code&gt;并不负责把数组类型转换成对应的指针，所以&lt;code&gt;decltype&lt;/code&gt;的结果是个数组，要想表示 arrPtr 返回指针还必须在函数声明时加一个 * 符号。&lt;/p&gt;
&lt;h2&gt;函数重载&lt;/h2&gt;
&lt;h3&gt;顶层 const&lt;/h3&gt;
&lt;p&gt;顶层&lt;code&gt;const&lt;/code&gt;不影响传入函数的对象。一个用于顶层&lt;code&gt;const&lt;/code&gt;的形参无法和一个没有顶层&lt;code&gt;const&lt;/code&gt;的形参区分开，无法重载：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Record lookup(Phone);
Record lookup(const Phone);
//
Record lookup(Phone*);
Record lookup(Phone* const);
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;底层 const&lt;/h3&gt;
&lt;p&gt;底层&lt;code&gt;const&lt;/code&gt;可以实现重载。当我们传递一个非常量对象或者指向非常量对象的指针时，编译器会优先选用非常量的版本：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Record lookup(Account&amp;amp;);
Record lookup(const Account&amp;amp;);
//
Record lookup(Account*);
Record lookup(const Account*);
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;const_cast和重载&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//函数1
const string &amp;amp;shorterString(const string &amp;amp;s1, const strinf &amp;amp;s2)
{
        return s1.size() &amp;lt;= s2.size() ? s1 : s2;
}
//函数2
string &amp;amp;shorterString(string &amp;amp;s1, string &amp;amp;s2)
{
        auto &amp;amp;r = shorterString(const_cast&amp;lt;const string &amp;amp;&amp;gt;(s1),
                                const_cast&amp;lt;const string&amp;amp;&amp;gt;(s2));
        return const_cast&amp;lt;string&amp;amp;&amp;gt;(r);
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;函数1的参数和返回类型都是&lt;code&gt;const string&lt;/code&gt;的引用。我们当然可以对两个非常量的&lt;code&gt;string&lt;/code&gt;实参调用这个函数，但返回的结果仍然是&lt;code&gt;const string&lt;/code&gt;的引用。&lt;/p&gt;
&lt;h3&gt;作用域与重载&lt;/h3&gt;
&lt;p&gt;编译器首先在当前作用域寻找函数，一旦找到，就会忽略掉外层作用域中的同名实体，剩下的工作就是检查函数调用是否有效了。&lt;/p&gt;
&lt;p&gt;在C++语言中，名字查找发生在类型检查之前。&lt;/p&gt;
&lt;h2&gt;特殊用于语言特性&lt;/h2&gt;
&lt;h3&gt;默认实参&lt;/h3&gt;
&lt;p&gt;一旦一个形参被赋予了默认值，它后面的所有形参都必须有默认值。&lt;/p&gt;
&lt;p&gt;在给定的作用域中，一个形参只能被赋予一次默认实参。&lt;/p&gt;
&lt;p&gt;局部变量不能作为默认实参。&lt;/p&gt;
&lt;p&gt;用作函数实参的名字在函数声明所在的作用域内解析，而这些名字的求值过程发生在函数调用时：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sz wd = 80;
char def = &amp;#39;&amp;#39;;
sz ht();
string screen(sz = ht(), sz = wd, char = def);

void f()
{
    def = &amp;#39;*&amp;#39;;  //改变默认实参的值
    sz wd = 100;    //隐藏了外层定义的wd，但是没有改变默认值
    window = screen();  //调用 screen(ht(), 80, &amp;#39;*&amp;#39;)
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;内联函数&lt;/h3&gt;
&lt;p&gt;以空间换时间。在函数返回类型前面加上关键字&lt;code&gt;inline&lt;/code&gt;。内联说明只是向编译器发出一个请求，编译器可以选择忽略这个请求。&lt;/p&gt;
&lt;h3&gt;constexpr 函数&lt;/h3&gt;
&lt;p&gt;能用于常量表达式的函数。函数的返回类型及所有的形参类型都得是字面值类型。函数体中必须有且只有一条&lt;code&gt;return&lt;/code&gt;语句。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;constexpr int new_sz() { return 42; }
constexpr int foo = new_sz();
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;编译器在程序编译时验证 new_sz 函数的返回类型。执行初始化任务时，编译器把对&lt;code&gt;constexpr&lt;/code&gt;函数的调用替换成其结果值。为了能在编译过程中随时展开，&lt;code&gt;constexpr&lt;/code&gt;函数被隐式指定为内联函数。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;constexpr&lt;/code&gt;函数体内也可以包含其他语句，只要这些语句在运行时不执行任何操作就行，例如，空语句、类型别名及&lt;code&gt;using&lt;/code&gt;声明。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;constexpr&lt;/code&gt;函数不一定返回常量表达式，当把这类函数用在需要常量表达式的上下文中时，会出错。&lt;/p&gt;
&lt;p&gt;把内联函数和&lt;code&gt;constexpr&lt;/code&gt;函数放在头文件内。&lt;/p&gt;
&lt;p&gt;和其它函数不一样，内联函数和&lt;code&gt;constexpr&lt;/code&gt;函数可以在程序中多次定义，但是多个定义必须完全一致。&lt;/p&gt;
&lt;h3&gt;调试帮助&lt;/h3&gt;
&lt;h4&gt;assert 预处理宏&lt;/h4&gt;
&lt;p&gt;所谓预处理宏其实是一个预处理变量，它的行为有点类似于内联函数。&lt;code&gt;assert&lt;/code&gt;宏使用一个表达式作为它的条件：&lt;code&gt;assert(expr);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;首先对 expr 求值，如果表达式为假，&lt;code&gt;assert&lt;/code&gt;输出信息并终止程序的执行。如果表达式为真，&lt;code&gt;assert&lt;/code&gt;什么也不做。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;assert&lt;/code&gt;定义在cassert头文件中，&lt;code&gt;assert&lt;/code&gt;宏常用于检查“不能发生”的条件。&lt;/p&gt;
&lt;h4&gt;NDEBUG 预处理变量&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;assert&lt;/code&gt;的行为依赖于&lt;code&gt;NDEBUG&lt;/code&gt;预处理变量的状态。如果定义了&lt;code&gt;NDEBUG&lt;/code&gt;，&lt;code&gt;assert&lt;/code&gt;什么都不做，默认情况下没有定义&lt;code&gt;NDEBUG&lt;/code&gt;，&lt;code&gt;assert&lt;/code&gt;将执行运行时检查。我们可以使用一个&lt;code&gt;#define&lt;/code&gt;语句定义&lt;code&gt;NDEBUG&lt;/code&gt;，从而关闭调试状态。同时，很多编译器都提供了一个命令行选项使我们可以定义预处理变量：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ CC -D NDEBUG main.C &lt;span class="c1"&gt;#use /D with the Mocrosoft compiler.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;除了使用&lt;code&gt;assert&lt;/code&gt;外，也可以使用&lt;code&gt;NDEBUG&lt;/code&gt;编写自己的条件调试代码。如果&lt;code&gt;NDEBUG&lt;/code&gt;未定义，将执行&lt;code&gt;#ifndef&lt;/code&gt;和&lt;code&gt;#endif&lt;/code&gt;之间的代码；如果定义了&lt;code&gt;NDEBUG&lt;/code&gt;，这些代码将被忽略掉。&lt;/p&gt;
&lt;p&gt;编译器为每个函数都定义了&lt;code&gt;__func__&lt;/code&gt;，它是一个&lt;code&gt;const char&lt;/code&gt;局部静态数组，用于存放函数的名字，除了 C++ 编译器定义的&lt;code&gt;__func__&lt;/code&gt;之外，预处理器还定义了另外4个对于程序调试很有用的名字：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;__FILE__&lt;/code&gt; 存放文件名的字符串字面值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__LINE__&lt;/code&gt; 存放当前行号的整型字面值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__TIME__&lt;/code&gt; 存放文件编译时间的字符串字面值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__DATE__&lt;/code&gt; 存放文件编译日期的字符串字面值&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;函数匹配&lt;/h2&gt;
&lt;p&gt;候选函数：函数匹配的第一步是选定本次调用对应的重载函数集。&lt;/p&gt;
&lt;p&gt;可行函数：形参数量与本次提供的实参数量相等（默认形参可以少于）；每个实参的类型与对应的形参相同，或者可以转换成形参的类型。&lt;/p&gt;
&lt;p&gt;寻找最佳匹配（如果有的话）：该函数每个实参的匹配都不劣于其他可行函数需要的匹配；至少有一个实参的匹配优于其他可行函数提供的匹配。&lt;/p&gt;
&lt;p&gt;如果没找到可行函数：编译器报告无匹配函数的错误；如果最佳匹配不唯一，编译器报告二义性错误。&lt;/p&gt;
&lt;h2&gt;函数指针&lt;/h2&gt;
&lt;p&gt;要声明一个函数指针，只需要用指针替换函数名：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;bool (*pf)(const string &amp;amp;, const string &amp;amp;); //未初始化，pf 两端括号必不可少
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当把函数名作为一个值使用时，该函数自动转换为指针，也就是说取地址符是可选的。同样，我们可以直接用函数指针调用函数，解引用符也是可选的。&lt;/p&gt;
&lt;p&gt;不同类型的函数指针之前不存在转换规则。&lt;/p&gt;
&lt;p&gt;函数指针没有指向任何一个函数：将函数指针赋为0或者 &lt;code&gt;nullptr&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;和数组类似，虽然不能定义函数类型的形参，但是可以定义指向函数的指针。此时，形参看起来是函数，实际上被当成指针使用：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//形参是函数类型，会自动转化为指向函数的指针
void test(bool pf(const string &amp;amp;, const string &amp;amp;));
//等价的定义
void test(bool (*pf)(const string &amp;amp;, const string &amp;amp;));
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果函数返回指向函数的指针，那么必须显示的将返回类型指定为指针。&lt;/p&gt;</content><category term="C++"></category></entry><entry><title>回车与换行的区别</title><link href="https://xutree.github.io/pages/2018/10/09/%E5%9B%9E%E8%BD%A6%E4%B8%8E%E6%8D%A2%E8%A1%8C%E7%9A%84%E5%8C%BA%E5%88%AB/" rel="alternate"></link><published>2018-10-09T13:42:30+08:00</published><updated>2018-10-09T13:42:30+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-09:/pages/2018/10/09/回车与换行的区别/</id><summary type="html">&lt;p&gt;转载自：&lt;a href="https://www.pythontab.com/html/2017/linuxkaiyuan_0115/1116.html"&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;关于换行和回车其实平时我们不太在意，所以关于两者的区别也不太清楚，在平时开发时可能会遇到一些文件处理的问题，放到不同的操作系统上出现各种坑。那么回车和换行到底有哪些区别呢？今天咱们就来总结一下。&lt;/p&gt;
&lt;h2&gt;由来&lt;/h2&gt;
&lt;p&gt;在计算机还没有出现之前，有一种叫做电传打字机（Teletype Model 33）的机械打字机，每秒钟可以打10个字符。但是它有一个问题，就是打完一行换行的时候，要用去0.2秒，正好可以打两个字符。要是在这0.2秒里面，又有新的字符传过来，那么这个字符将丢失。&lt;/p&gt;
&lt;p&gt;于是，研制人员想了个办法解决这个问题，就是在每行后面加两个表示结束的字符。一个叫做“回车”，告诉打字机把打印头定位在左边界，不卷动滚筒；另一个叫做“换行”，告诉打字机把滚筒卷一格，不改变水平位置。&lt;/p&gt;
&lt;p&gt;这就是“换行”和“回车”的由来。&lt;/p&gt;
&lt;h2&gt;使用&lt;/h2&gt;
&lt;p&gt;后来，计算机发明了，这两个概念也就被般到了计算机上。那时，存储器很贵，一些科学家认为在每行结尾加两个字符太浪费了，加一个就可以。于是 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;转载自：&lt;a href="https://www.pythontab.com/html/2017/linuxkaiyuan_0115/1116.html"&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;关于换行和回车其实平时我们不太在意，所以关于两者的区别也不太清楚，在平时开发时可能会遇到一些文件处理的问题，放到不同的操作系统上出现各种坑。那么回车和换行到底有哪些区别呢？今天咱们就来总结一下。&lt;/p&gt;
&lt;h2&gt;由来&lt;/h2&gt;
&lt;p&gt;在计算机还没有出现之前，有一种叫做电传打字机（Teletype Model 33）的机械打字机，每秒钟可以打10个字符。但是它有一个问题，就是打完一行换行的时候，要用去0.2秒，正好可以打两个字符。要是在这0.2秒里面，又有新的字符传过来，那么这个字符将丢失。&lt;/p&gt;
&lt;p&gt;于是，研制人员想了个办法解决这个问题，就是在每行后面加两个表示结束的字符。一个叫做“回车”，告诉打字机把打印头定位在左边界，不卷动滚筒；另一个叫做“换行”，告诉打字机把滚筒卷一格，不改变水平位置。&lt;/p&gt;
&lt;p&gt;这就是“换行”和“回车”的由来。&lt;/p&gt;
&lt;h2&gt;使用&lt;/h2&gt;
&lt;p&gt;后来，计算机发明了，这两个概念也就被般到了计算机上。那时，存储器很贵，一些科学家认为在每行结尾加两个字符太浪费了，加一个就可以。于是，就出现了分歧。&lt;/p&gt;
&lt;p&gt;回车&lt;code&gt;\r&lt;/code&gt;本义是光标重新回到本行开头，r 的英文 return，控制字符可以写成&lt;code&gt;CR&lt;/code&gt;，即 Carriage Return。&lt;/p&gt;
&lt;p&gt;换行&lt;code&gt;\n&lt;/code&gt;本义是光标往下一行（不一定到下一行行首），n 的英文 newline，控制字符可以写成&lt;code&gt;LF&lt;/code&gt;，即 Line Feed。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;符号&lt;/th&gt;
&lt;th align="left"&gt;ASCII 码&lt;/th&gt;
&lt;th align="left"&gt;意义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;\n&lt;/td&gt;
&lt;td align="left"&gt;10&lt;/td&gt;
&lt;td align="left"&gt;换行 LF&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;\r&lt;/td&gt;
&lt;td align="left"&gt;13&lt;/td&gt;
&lt;td align="left"&gt;回车 CR&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;在不同的操作系统这几个字符表现不同，比如在 WIN 系统下，这两个字符就是表现的本义，在 UNIX 类系统，换行&lt;code&gt;\n&lt;/code&gt;就表现为光标下一行并回到行首，在 MAC 上，&lt;code&gt;\r&lt;/code&gt;就表现为回到本行开头并往下一行，至于&lt;code&gt;ENTER&lt;/code&gt;键的定义是与操作系统有关的。通常用的&lt;code&gt;Enter&lt;/code&gt;是两个加起来。&lt;/p&gt;
&lt;p&gt;不同操作系统下的含义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;\n&lt;/code&gt;：UNIX 系统行末结束符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\n\r&lt;/code&gt;：window 系统行末结束符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\r&lt;/code&gt;：MAC OS 系统行末结束符&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们经常遇到的一个问题就是，Unix/Mac 系统下的文件在 Windows 里打开的话，所有文字会变成一行；而 Windows 里的文件在 Unix/Mac 下打开的话，在每行的结尾可能会多出一个&lt;code&gt;^M&lt;/code&gt;符号。&lt;/p&gt;
&lt;h2&gt;软回车和硬回车&lt;/h2&gt;
&lt;p&gt;硬回车就是普通我们按回车产生的，它在换行的同时也起着段落分隔的作用。&lt;/p&gt;
&lt;p&gt;软回车是用&lt;code&gt;Shift + Enter&lt;/code&gt;产生的，它换行，但是并不换段，即前后两段文字在 Word 中属于同一“段”。在应用格式时你会体会到这一点。&lt;/p&gt;
&lt;p&gt;软回车能使前后两行的行间距大幅度缩小，因为它不是段落标记，要和法定的段落标记——硬回车区别出来。硬回车的 html 代码是&lt;code&gt;&amp;lt;p&amp;gt;..&amp;lt;/p&amp;gt;&lt;/code&gt;，段落的内容就夹在里面，而软回车的代码很精悍：&lt;code&gt;&amp;lt;br&amp;gt;&lt;/code&gt;。网页的文字如果复制到 word 中，则硬回车变为弯曲的箭头，软回车变为向下的箭头。&lt;/p&gt;</content></entry><entry><title>C++ Primer 第五章 语句</title><link href="https://xutree.github.io/pages/2018/10/09/C++_Primer_Chapter_5/" rel="alternate"></link><published>2018-10-09T12:06:33+08:00</published><updated>2018-10-09T12:06:33+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-09:/pages/2018/10/09/C++_Primer_Chapter_5/</id><summary type="html">&lt;h2&gt;空语句&lt;/h2&gt;
&lt;p&gt;使用空语句时应该加上注释，从而令读这段代码的知道该语句是有意省略的。&lt;/p&gt;
&lt;h2&gt;悬垂 else&lt;/h2&gt;
&lt;p&gt;C++ 规定&lt;code&gt;else&lt;/code&gt;与离它最近的尚未匹配的&lt;code&gt;if&lt;/code&gt;匹配。&lt;/p&gt;
&lt;h2&gt;switch 语句&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;switch&lt;/code&gt;语句中的&lt;code&gt;case&lt;/code&gt;标签必须是&lt;strong&gt;整型常量表达式&lt;/strong&gt;或者&lt;strong&gt;可以转换成整型常量表达式的类型&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果某个&lt;code&gt;case&lt;/code&gt;标签匹配成功，将从该标签处开始往后顺序执行所有&lt;code&gt;case&lt;/code&gt;分支，除非程序显示的中断了这一过程，否则直到&lt;code&gt;switch&lt;/code&gt;结尾处才停下来。在大多说情况下，在下一个&lt;code&gt;case&lt;/code&gt;标签之前应该有一条&lt;code&gt;break&lt;/code&gt;语句用于中断。&lt;/p&gt;
&lt;p&gt;标签不应该孤零零的出现，它后面必须跟上一条语句或者另一个&lt;code&gt;case&lt;/code&gt;标签。如果&lt;code&gt;switch&lt;/code&gt;结构以一个空的&lt;code&gt;default&lt;/code&gt;标签作为结束，则该&lt;code&gt;default&lt;/code&gt;标签后面必须跟上一条空语句或一个空块。&lt;/p&gt;
&lt;p&gt;不允许跨过变量的初始化语句直接跳转到该变量作用域内的另一个位置。&lt;/p&gt;
&lt;h2&gt;范围 …&lt;/h2&gt;</summary><content type="html">&lt;h2&gt;空语句&lt;/h2&gt;
&lt;p&gt;使用空语句时应该加上注释，从而令读这段代码的知道该语句是有意省略的。&lt;/p&gt;
&lt;h2&gt;悬垂 else&lt;/h2&gt;
&lt;p&gt;C++ 规定&lt;code&gt;else&lt;/code&gt;与离它最近的尚未匹配的&lt;code&gt;if&lt;/code&gt;匹配。&lt;/p&gt;
&lt;h2&gt;switch 语句&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;switch&lt;/code&gt;语句中的&lt;code&gt;case&lt;/code&gt;标签必须是&lt;strong&gt;整型常量表达式&lt;/strong&gt;或者&lt;strong&gt;可以转换成整型常量表达式的类型&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果某个&lt;code&gt;case&lt;/code&gt;标签匹配成功，将从该标签处开始往后顺序执行所有&lt;code&gt;case&lt;/code&gt;分支，除非程序显示的中断了这一过程，否则直到&lt;code&gt;switch&lt;/code&gt;结尾处才停下来。在大多说情况下，在下一个&lt;code&gt;case&lt;/code&gt;标签之前应该有一条&lt;code&gt;break&lt;/code&gt;语句用于中断。&lt;/p&gt;
&lt;p&gt;标签不应该孤零零的出现，它后面必须跟上一条语句或者另一个&lt;code&gt;case&lt;/code&gt;标签。如果&lt;code&gt;switch&lt;/code&gt;结构以一个空的&lt;code&gt;default&lt;/code&gt;标签作为结束，则该&lt;code&gt;default&lt;/code&gt;标签后面必须跟上一条空语句或一个空块。&lt;/p&gt;
&lt;p&gt;不允许跨过变量的初始化语句直接跳转到该变量作用域内的另一个位置。&lt;/p&gt;
&lt;h2&gt;范围 for&lt;/h2&gt;
&lt;p&gt;在范围&lt;code&gt;for&lt;/code&gt;语句中，预存了&lt;code&gt;end()&lt;/code&gt;的值，一旦程序中添加（删除）元素，&lt;code&gt;end&lt;/code&gt;函数的值就可能变得无效，所以不能通过范围&lt;code&gt;for&lt;/code&gt;语句增加或删除容器的元素。&lt;/p&gt;
&lt;h2&gt;do while 语句&lt;/h2&gt;
&lt;p&gt;应该在括号包围起来的条件后面用一个分号表示语句结束。&lt;/p&gt;
&lt;h2&gt;跳转语句&lt;/h2&gt;
&lt;h3&gt;break 语句&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;break&lt;/code&gt;语句负责终止离它最近的&lt;code&gt;while&lt;/code&gt;、&lt;code&gt;do while&lt;/code&gt;、&lt;code&gt;for&lt;/code&gt;或&lt;code&gt;switch&lt;/code&gt;语句，并从这些语句之后的第一条语句开始继续执行。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;break&lt;/code&gt;语句只能出现在迭代语句或者&lt;code&gt;switch&lt;/code&gt;语句内部（包括嵌套在此类循环里的语句或块的内部）。&lt;code&gt;break&lt;/code&gt;语句的作用范围仅限于最近的循环或者&lt;code&gt;switch&lt;/code&gt;。&lt;/p&gt;
&lt;h3&gt;continue 语句&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;continu&lt;/code&gt;e语句终止最近的循环中的当前迭代并立即开始下一次迭代。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;continue&lt;/code&gt;语句只能出现在&lt;code&gt;for&lt;/code&gt;、&lt;code&gt;while&lt;/code&gt;和&lt;code&gt;do while&lt;/code&gt;的循环的内部，或者嵌套在此类循环里的语句或块的内部。&lt;/p&gt;
&lt;p&gt;和&lt;code&gt;break&lt;/code&gt;语句类似的是，出现在嵌套循环中的&lt;code&gt;continue&lt;/code&gt;语句也仅作用于离它最近的循环。&lt;/p&gt;
&lt;p&gt;和&lt;code&gt;break&lt;/code&gt;语句不同的是，只有当&lt;code&gt;switch&lt;/code&gt;语句嵌套在迭代语句内部时，才能在&lt;code&gt;switch&lt;/code&gt;里使用&lt;code&gt;continue&lt;/code&gt;。&lt;/p&gt;
&lt;h3&gt;goto 语句&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;goto&lt;/code&gt;语句的作用是从&lt;code&gt;goto&lt;/code&gt;语句无条件跳转到同一函数内的另一条语句。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;goto&lt;/code&gt;语句和控制权转向的那条带标签的语句必须位于同一函数之内。&lt;/p&gt;
&lt;h2&gt;异常处理&lt;/h2&gt;
&lt;h3&gt;throw 表达式&lt;/h3&gt;
&lt;p&gt;异常检测部分使用&lt;code&gt;throw&lt;/code&gt;表达式来表示它遇到了无法处理的问题。我们说&lt;code&gt;throw&lt;/code&gt;引发了异常，例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;throw runtime_error(&amp;quot;Data must refer to same ISBN&amp;quot;);
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;try 语句块&lt;/h3&gt;
&lt;p&gt;异常处理部分使用&lt;code&gt;try&lt;/code&gt;语句处理异常。&lt;code&gt;try&lt;/code&gt;语句块以关键字&lt;code&gt;try&lt;/code&gt;开始，并以一个或多个&lt;code&gt;catch&lt;/code&gt;字句结束。&lt;code&gt;try&lt;/code&gt;语句块中代码抛出的异常通常会被某个catch字句处理，这些字句称为异常处理代码。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;try{
    program-statements
} catch (exception-declaration) {
    handler-statements
} catch (exception-declaration) {
    handler-statements
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;跟在&lt;code&gt;try&lt;/code&gt;块之后的是一个或多个&lt;code&gt;catch&lt;/code&gt;子句。&lt;code&gt;catch&lt;/code&gt;子句包括三个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关键字&lt;code&gt;catch&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;括号内一个（可能未命名的）对象的声明（称作异常声明）&lt;/li&gt;
&lt;li&gt;一个块&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;try&lt;/code&gt;语句块中 program-statements 组成程序的正常逻辑，像其他任何块一样，可以有包含声明在内的任意 C++ 语句。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;try&lt;/code&gt;语句块内声明的变量在块外部无法访问，特别是在&lt;code&gt;catch子&lt;/code&gt;句内也无法访问。&lt;/p&gt;
&lt;p&gt;函数在寻找代码处理的过程中退出，如果最终没能找到任何匹配的&lt;code&gt;catch&lt;/code&gt;子句，程序转到名为&lt;code&gt;terminate&lt;/code&gt;的标准库函数。该函数的行为与系统有关，一般情况下，执行该函数将导致程序非正常退出。&lt;/p&gt;
&lt;h3&gt;标准异常&lt;/h3&gt;
&lt;p&gt;C++ 标准库定义了一组类，用于报告标准库函数遇到的问题，这些异常类也可以在用户别写的程序中使用，它们分别定义在4个头文件中：&lt;/p&gt;
&lt;h4&gt;exception 头文件&lt;/h4&gt;
&lt;p&gt;定义了最通用的异常类&lt;code&gt;exception&lt;/code&gt;。它只报告异常的发生，不提供任何异常信息&lt;/p&gt;
&lt;h4&gt;stdexcept 头文件定义了几种常见的异常类&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;异常类&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;exception&lt;/td&gt;
&lt;td&gt;最常见的问题&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;runtime_error&lt;/td&gt;
&lt;td&gt;只有在运行时才能检测出的问题&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;range_error&lt;/td&gt;
&lt;td&gt;运行时错误：生成的结果超出了有意义的值域范围&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;overflow_error&lt;/td&gt;
&lt;td&gt;运行时错误：计算上溢&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;underflow_error&lt;/td&gt;
&lt;td&gt;运行时错误：计算下溢&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;logic_error&lt;/td&gt;
&lt;td&gt;程序逻辑错误&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;domain_error&lt;/td&gt;
&lt;td&gt;逻辑错误：参数对应的结果值不存在&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;invalid_argument&lt;/td&gt;
&lt;td&gt;逻辑错误：无效参数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;length_error&lt;/td&gt;
&lt;td&gt;逻辑错误：试图创建一个超出该类型最大长度的对象&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;out_of_range&lt;/td&gt;
&lt;td&gt;逻辑错误：使用一个超出有效范围的值&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4&gt;new 头文件&lt;/h4&gt;
&lt;p&gt;定义了&lt;code&gt;bad_alloc&lt;/code&gt;异常类型&lt;/p&gt;
&lt;h4&gt;type_info 头文件&lt;/h4&gt;
&lt;p&gt;定义了&lt;code&gt;bad_cast&lt;/code&gt;异常类型&lt;/p&gt;
&lt;p&gt;标准异常库只定义了几种运算，包括创建和拷贝异常类型的对象，以及为异常类型的对象赋值。我们只能以默认初始化的方式初始化&lt;code&gt;exception&lt;/code&gt;、&lt;code&gt;bad_alloc&lt;/code&gt;和&lt;code&gt;bad_cas&lt;/code&gt;t对象，不允许为这些对象提供初始值。&lt;/p&gt;
&lt;p&gt;其他异常类型的行为则刚好相反。应该使用&lt;code&gt;string&lt;/code&gt;对象或者 C 风格字符串初始化这些类型的对象，但是不允许使用默认初始化的方式。当创建此类对象时，必须提供初始值，该初始值含有错误相关的信息。&lt;/p&gt;
&lt;p&gt;异常类型只定义了一个名为&lt;code&gt;what&lt;/code&gt;的成员函数，该函数没有任何参数，返回值是一个指向 C 风格字符串的&lt;code&gt;const char *&lt;/code&gt;。该字符串的目的是提供关于异常的一些文本信息。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;what&lt;/code&gt;函数返回的 C 风格字符串的内容与异常对象的类型有关。如果异常类型只有一个字符串初始值，则&lt;code&gt;what&lt;/code&gt;返回该字符串。对于其他无初始值的异常类型来说，&lt;code&gt;what&lt;/code&gt;返回的内容由编译器决定。&lt;/p&gt;</content><category term="C++"></category></entry><entry><title>几个奇葩的 Linux 命令</title><link href="https://xutree.github.io/pages/2018/10/08/%E5%87%A0%E4%B8%AA%E5%A5%87%E8%91%A9%E7%9A%84Linux%E5%91%BD%E4%BB%A4/" rel="alternate"></link><published>2018-10-08T22:58:12+08:00</published><updated>2018-10-09T11:39:49+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-08:/pages/2018/10/08/几个奇葩的Linux命令/</id><summary type="html">&lt;p&gt;Linux 中有一些很奇葩的命令，可能你的发行版默认没有安装，你可以自己安装：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;[me@linuxbox ~]$ apt-get install 命令          (Debian)
[me@linuxbox ~]$ yum install 命令              (Red Hat）
[me@linuxbox ~]$ brew install 命令            （Mac）
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;rev&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;rev&lt;/code&gt;命令反转输入的内容（来自文件或者标准输入或者管道）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;[me@linuxbox ~]$ echo Hello, World! | rev
!dlroW ,olleH
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;tac&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;cat&lt;/code&gt;命令的反写，执行效果也和&lt;code&gt;cat&lt;/code&gt;相反，即，将文件列表中的每一个文件输出到标准输出，行号大的优先。&lt;/p&gt;
&lt;h2&gt;sl&lt;/h2&gt;
&lt;p&gt;你可能知道命令&lt;code&gt;ls&lt;/code&gt;,并经常使用它来查看文件夹的内容。但是由于错误输入有时会导致&lt;code&gt;sl …&lt;/code&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;Linux 中有一些很奇葩的命令，可能你的发行版默认没有安装，你可以自己安装：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;[me@linuxbox ~]$ apt-get install 命令          (Debian)
[me@linuxbox ~]$ yum install 命令              (Red Hat）
[me@linuxbox ~]$ brew install 命令            （Mac）
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;rev&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;rev&lt;/code&gt;命令反转输入的内容（来自文件或者标准输入或者管道）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;[me@linuxbox ~]$ echo Hello, World! | rev
!dlroW ,olleH
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;tac&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;cat&lt;/code&gt;命令的反写，执行效果也和&lt;code&gt;cat&lt;/code&gt;相反，即，将文件列表中的每一个文件输出到标准输出，行号大的优先。&lt;/p&gt;
&lt;h2&gt;sl&lt;/h2&gt;
&lt;p&gt;你可能知道命令&lt;code&gt;ls&lt;/code&gt;,并经常使用它来查看文件夹的内容。但是由于错误输入有时会导致&lt;code&gt;sl&lt;/code&gt;，如何在终端获得一点乐趣而不是“command not found”？&lt;code&gt;sl&lt;/code&gt;命令！&lt;/p&gt;
&lt;p&gt;当你把&lt;code&gt;ls&lt;/code&gt;错误打成&lt;code&gt;sl&lt;/code&gt;时，一辆蒸汽机车（&lt;strong&gt;s&lt;/strong&gt;team &lt;strong&gt;l&lt;/strong&gt;ocomotive）会在屏幕上驶过...&lt;/p&gt;
&lt;p&gt;&lt;img alt="图1 一辆蒸汽机车（steam locomotive）会在屏幕上驶过" src="https://xutree.github.io/images/linux_1.png"&gt;&lt;/p&gt;
&lt;h2&gt;yes&lt;/h2&gt;
&lt;p&gt;yes命令将进入一个循环，一遍又一遍地重复相同的字符串。默认重复“y”，你可以指定其他字符串。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;[me@linuxbox ~]$ yes &amp;quot;这是一个测试&amp;quot;
这是一个测试
这是一个测试
这是一个测试
这是一个测试
这是一个测试
这是一个测试
这是一个测试
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;利用&lt;code&gt;Ctrl C&lt;/code&gt;终止。&lt;/p&gt;
&lt;h2&gt;cowsay&lt;/h2&gt;
&lt;p&gt;屏幕上会出现一只 ASCII 码拼成的奶牛。。。你可以指定奶牛要说的话。这个命令还有其他版本，如&lt;code&gt;xcowsay&lt;/code&gt;，&lt;code&gt;cowthink&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img alt="图2 一只 ASCII 码拼成的奶牛" src="https://xutree.github.io/images/linux_2.png"&gt;&lt;/p&gt;
&lt;h2&gt;figlet&lt;/h2&gt;
&lt;p&gt;这个算不上奇葩，他它利用 ASCII 码拼成你输出字符串的横幅，而且有许多参数可以定制。还有个&lt;code&gt;toilet&lt;/code&gt;命令和&lt;code&gt;figlet&lt;/code&gt;很类似。比如，&lt;code&gt;figlet good&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img alt="图3 利用 ASCII 码拼成你输出字符串的横幅" src="https://xutree.github.io/images/linux_3.png"&gt;&lt;/p&gt;
&lt;h2&gt;fortune&lt;/h2&gt;
&lt;p&gt;会显示你的未来（ 😆 )。可以试试：&lt;code&gt;[me@linuxbox ~]$ fortune | cowsay&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="图4 显示未来的奶牛" src="https://xutree.github.io/images/linux_4.png"&gt;&lt;/p&gt;
&lt;h2&gt;cmatrix&lt;/h2&gt;
&lt;p&gt;会像《黑客帝国》里那样显示。&lt;/p&gt;
&lt;p&gt;&lt;img alt="图5 黑客帝国" src="https://xutree.github.io/images/linux_5.png"&gt;&lt;/p&gt;
&lt;h2&gt;Fork 炸弹&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;[me@linuxbox ~]$ :(){ :|:&amp;amp; }:
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;不要尝试不要尝试不要尝试...&lt;/p&gt;
&lt;h2&gt;asciiquarium 水族馆&lt;/h2&gt;
&lt;p&gt;&lt;img alt="图6 水族馆" src="https://xutree.github.io/images/linux_6.png"&gt;&lt;/p&gt;
&lt;h2&gt;lolcat&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;lolcat&lt;/code&gt;可以在终端产生彩虹。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;lolcat&lt;/code&gt;是一个 RubyGem 因此它必须有你的系统上安装了 Ruby 的最新版本。利用文章开头部分的方法安装好&lt;code&gt;lolcat&lt;/code&gt;
后，在终端执行&lt;code&gt;gem install lolcat&lt;/code&gt;安装。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;[me@linuxbox ~]$ git log -1 | cowsay -f dragon-and-cow | lolcat&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="图7 lolcat" src="https://xutree.github.io/images/linux_7.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;lolcat&lt;/code&gt;接受管道输入，所以你可以试试：&lt;code&gt;[me@linuxbox ~]$ sl | lolcat&lt;/code&gt;&lt;/p&gt;</content><category term="Linux"></category></entry><entry><title>Linux 中的扩展和引用</title><link href="https://xutree.github.io/pages/2018/10/08/linux%E4%B8%AD%E7%9A%84%E6%89%A9%E5%B1%95%E5%92%8C%E5%BC%95%E7%94%A8/" rel="alternate"></link><published>2018-10-08T16:25:59+08:00</published><updated>2018-10-09T13:22:26+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-08:/pages/2018/10/08/linux中的扩展和引用/</id><summary type="html">&lt;h2&gt;扩展&lt;/h2&gt;
&lt;p&gt;当我们每次在命令行按下&lt;code&gt;Enter&lt;/code&gt;键时，bash 会在执行命令之前对文本进行多重处理。产生这个结果的处理过程称为扩展（expansion）。&lt;/p&gt;
&lt;p&gt;一个 🌰 :&lt;code&gt;echo *&lt;/code&gt;会将当前目录下所有的非隐藏文件名打印出来。&lt;/p&gt;
&lt;h3&gt;单词分隔&lt;/h3&gt;
&lt;p&gt;单词分隔会先查找是否存在空格、制表符以及换行，然后把它们作为单词的界定符（delimiter）。所以下面的命令后面跟着4个不同的参数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;[me@linuxbox ~]$ echo this is a test
this is a test
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;路径名扩展&lt;/h3&gt;
&lt;p&gt;通过使用通配符来实现扩展的机制称为路径名扩展（pathname expansion）。&lt;/p&gt;
&lt;h3&gt;波浪线扩展（~）&lt;/h3&gt;
&lt;p&gt;如果把它用在一个单词的开头，那么它将被扩展为指定用户的主目录名；如果没有指定用户名，则扩展为当前用户的主目录：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;[me@linuxbox ~]$ ech ~
/home/me
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;[me@linuxbox ~]$ ech ~foo
/home/foo
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;算术扩展 …&lt;/h3&gt;</summary><content type="html">&lt;h2&gt;扩展&lt;/h2&gt;
&lt;p&gt;当我们每次在命令行按下&lt;code&gt;Enter&lt;/code&gt;键时，bash 会在执行命令之前对文本进行多重处理。产生这个结果的处理过程称为扩展（expansion）。&lt;/p&gt;
&lt;p&gt;一个 🌰 :&lt;code&gt;echo *&lt;/code&gt;会将当前目录下所有的非隐藏文件名打印出来。&lt;/p&gt;
&lt;h3&gt;单词分隔&lt;/h3&gt;
&lt;p&gt;单词分隔会先查找是否存在空格、制表符以及换行，然后把它们作为单词的界定符（delimiter）。所以下面的命令后面跟着4个不同的参数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;[me@linuxbox ~]$ echo this is a test
this is a test
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;路径名扩展&lt;/h3&gt;
&lt;p&gt;通过使用通配符来实现扩展的机制称为路径名扩展（pathname expansion）。&lt;/p&gt;
&lt;h3&gt;波浪线扩展（~）&lt;/h3&gt;
&lt;p&gt;如果把它用在一个单词的开头，那么它将被扩展为指定用户的主目录名；如果没有指定用户名，则扩展为当前用户的主目录：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;[me@linuxbox ~]$ ech ~
/home/me
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;[me@linuxbox ~]$ ech ~foo
/home/foo
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;算术扩展&lt;/h3&gt;
&lt;p&gt;shell 支持通过扩展来运行算术表达式。这允许我们把 shell 提示符当做计算器来使用：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;[me@linuxbox ~]$ echo $((2+2))
4
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;算术扩展使用形式：&lt;strong&gt;$((expression))&lt;/strong&gt;，其中 expression 是包含数值和算术操作符的算术表达式。算术扩展&lt;strong&gt;只支持整数&lt;/strong&gt;。&lt;/p&gt;
&lt;h4&gt;运算符&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;运算符&lt;/th&gt;
&lt;th align="left"&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;+&lt;/td&gt;
&lt;td align="left"&gt;加&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;-&lt;/td&gt;
&lt;td align="left"&gt;减&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;*&lt;/td&gt;
&lt;td align="left"&gt;乘&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;/&lt;/td&gt;
&lt;td align="left"&gt;除（结果为整数）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;%&lt;/td&gt;
&lt;td align="left"&gt;取余&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;**&lt;/td&gt;
&lt;td align="left"&gt;取幂&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;空格在算术表达式中无意义，表达式可以嵌套：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;[me@linuxbox ~]$ echo $(($((5**2)) * 3))
75
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;还可以使用一对括号来组合多个子表达式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;[me@linuxbox ~]$ echo $(((5**2) * 3))
75
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;数字进制&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;符号&lt;/th&gt;
&lt;th align="left"&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;number&lt;/td&gt;
&lt;td align="left"&gt;默认情况下，number 没有任何符号，将作为十进制数字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;0number&lt;/td&gt;
&lt;td align="left"&gt;在数字表达式中，以0开始的数字被视为八进制数字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;0xnumber&lt;/td&gt;
&lt;td align="left"&gt;十六进制数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;base#number&lt;/td&gt;
&lt;td align="left"&gt;base 进制的 number&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;🌰 ：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;[me@linuxbox ~]$ echo $((0xff))
255
[me@linuxbox ~]$ echo $((3#11))
4
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;花括号扩展&lt;/h3&gt;
&lt;p&gt;花括号扩展可以用于创建多种文本字符串，例如&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;[me@linuxbox ~]$ echo Front-{A,B,C}-Back
Front-A-Back Front-B-Back Front-C-Back
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;用于花括号扩展的模式信息可以包含一个称为&lt;strong&gt;前导字符&lt;/strong&gt;的开头部分和一个称为&lt;strong&gt;附言&lt;/strong&gt;的结尾部分。花括号表达式本身可以包含一些列逗号分隔的字符串，也可以包含一系列整数或者单个字符。&lt;/p&gt;
&lt;p&gt;模式信息不能包含内嵌的空白。&lt;/p&gt;
&lt;p&gt;花括号扩展最普遍的应用是创建一系列的文件或者目录：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;[me@linuxbox ~]$ mkdir {2009..2011}-0{1..9} {2009..2010}-{10..12}
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;参数扩展&lt;/h3&gt;
&lt;p&gt;shell 提供了多种参数扩展的形式。&lt;/p&gt;
&lt;h4&gt;基本参数&lt;/h4&gt;
&lt;p&gt;参数扩展的最简单形式体现在平时对变量的使用中。举例来说，&lt;code&gt;$a&lt;/code&gt;扩展后成为变量 a 所包含的内容，无论 a 包含什么。&lt;/p&gt;
&lt;p&gt;简单参数可以被括号包围，如&lt;code&gt;${a}&lt;/code&gt;，当变量相邻与其他文本时，必须使用括号，否则可能让 shell 混淆。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;[me@linuxbox ~]$ a=&amp;quot;foo&amp;quot;
[me@linuxbox ~]$ echo &amp;quot;&lt;span class="nv"&gt;$a_file&lt;/span&gt;&amp;quot;

[me@linuxbox ~]$ echo &amp;quot;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;_file&amp;quot;
foo_file
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;因为不存在 a_file 变量，所以 shell 输出空。&lt;/p&gt;
&lt;p&gt;同样，对于大于9的位置参数可以通过给相应数字加上括号来访问，例如访问第11个位置参数：&lt;code&gt;${11}&lt;/code&gt;&lt;/p&gt;
&lt;h4&gt;空变量扩展的管理&lt;/h4&gt;
&lt;p&gt;有的参数扩展用于处理不存在的变量和空变量。这些参数扩展在处理缺失的位置参数和给参数赋默认值时很有用。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;${parameter:-word}&lt;/code&gt;：如果 parameter 未被设定或者是空参数，则其扩展为 word 的值。如果 parameter 非空，则扩展为 parameter 的值。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s s-Atom"&gt;me@linuxbox&lt;/span&gt; &lt;span class="s s-Atom"&gt;~&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="s s-Atom"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s s-Atom"&gt;me@linuxbox&lt;/span&gt; &lt;span class="s s-Atom"&gt;~&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="s s-Atom"&gt;echo&lt;/span&gt; &lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nn"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s s-Atom"&gt;-&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;substitute value if unset&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="s s-Atom"&gt;substitute&lt;/span&gt; &lt;span class="s s-Atom"&gt;value&lt;/span&gt; &lt;span class="s s-Atom"&gt;if&lt;/span&gt; &lt;span class="s s-Atom"&gt;unset&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s s-Atom"&gt;me@linuxbox&lt;/span&gt; &lt;span class="s s-Atom"&gt;~&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="s s-Atom"&gt;echo&lt;/span&gt; &lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="s s-Atom"&gt;foo&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s s-Atom"&gt;me@linuxbox&lt;/span&gt; &lt;span class="s s-Atom"&gt;~&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="s s-Atom"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s s-Atom"&gt;bar&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s s-Atom"&gt;me@linuxbox&lt;/span&gt; &lt;span class="s s-Atom"&gt;~&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="s s-Atom"&gt;echo&lt;/span&gt; &lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nn"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s s-Atom"&gt;-&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;substitute value if unset&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="s s-Atom"&gt;bar&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s s-Atom"&gt;me@linuxbox&lt;/span&gt; &lt;span class="s s-Atom"&gt;~&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="s s-Atom"&gt;echo&lt;/span&gt; &lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="s s-Atom"&gt;foo&lt;/span&gt;
&lt;span class="s s-Atom"&gt;bar&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;${parameter:=word}&lt;/code&gt;：如果 parameter 未被设定或者是空参数，则其扩展为 word 的值；此外，word 的值也将赋给 parameter。如果 parameter 非空，则扩展为 parameter 的值。注意：位置参数和其他特殊参数不能以这种方式赋值。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s s-Atom"&gt;me@linuxbox&lt;/span&gt; &lt;span class="s s-Atom"&gt;~&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="s s-Atom"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s s-Atom"&gt;me@linuxbox&lt;/span&gt; &lt;span class="s s-Atom"&gt;~&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="s s-Atom"&gt;echo&lt;/span&gt; &lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nn"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s s-Atom"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;deafult value if unset&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="s s-Atom"&gt;deafult&lt;/span&gt; &lt;span class="s s-Atom"&gt;value&lt;/span&gt; &lt;span class="s s-Atom"&gt;if&lt;/span&gt; &lt;span class="s s-Atom"&gt;unset&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s s-Atom"&gt;me@linuxbox&lt;/span&gt; &lt;span class="s s-Atom"&gt;~&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="s s-Atom"&gt;echo&lt;/span&gt; &lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="s s-Atom"&gt;foo&lt;/span&gt;
&lt;span class="s s-Atom"&gt;deafult&lt;/span&gt; &lt;span class="s s-Atom"&gt;value&lt;/span&gt; &lt;span class="s s-Atom"&gt;if&lt;/span&gt; &lt;span class="s s-Atom"&gt;unset&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s s-Atom"&gt;me@linuxbox&lt;/span&gt; &lt;span class="s s-Atom"&gt;~&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="s s-Atom"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s s-Atom"&gt;bar&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s s-Atom"&gt;me@linuxbox&lt;/span&gt; &lt;span class="s s-Atom"&gt;~&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="s s-Atom"&gt;echo&lt;/span&gt; &lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nn"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s s-Atom"&gt;-&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;deafult value if unset&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="s s-Atom"&gt;bar&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s s-Atom"&gt;me@linuxbox&lt;/span&gt; &lt;span class="s s-Atom"&gt;~&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="s s-Atom"&gt;echo&lt;/span&gt; &lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="s s-Atom"&gt;foo&lt;/span&gt;
&lt;span class="s s-Atom"&gt;bar&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;${parameter:？word}&lt;/code&gt;：如果 parameter 未被设定或者是空参数，这样扩展会致使脚本出错而退出，并且 word 的内容输出到标准错误。如果 parameter 非空，则扩展为 parameter 的值。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;[me@linuxbox ~]$ foo=
[me@linuxbox ~]$ echo &lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="err"&gt;?&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;parameter is empty&amp;quot;&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
bash: foo: parameter is empty
[me@linuxbox ~]$ echo $?
1
[me@linuxbox ~]$ foo=bar
[me@linuxbox ~]$ echo &lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="err"&gt;?&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;parameter is empty&amp;quot;&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
bar
[me@linuxbox ~]$ echo $?
0
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;${parameter:+word}&lt;/code&gt;：如果 parameter 未被设定或者是空参数，则不产生任何扩展。若 parameter 非空，word 的值将取代 parameter 的值产生扩展；然而，parameter 的值并不发生变化。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;[me@linuxbox ~]$ foo=
[me@linuxbox ~]$ echo &lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;substitute value if unset&amp;quot;&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
[me@linuxbox ~]$ foo=bar

[me@linuxbox ~]$ echo &lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;substitute value if unset&amp;quot;&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
substitute value if unset
[me@linuxbox ~]$ echo &lt;span class="nv"&gt;$foo&lt;/span&gt;
bar
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;返回变量名的扩展&lt;/h4&gt;
&lt;p&gt;shell 具有返回变量名的扩展。这种功能在相当特殊的情况下才会使用。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="err"&gt;!&lt;/span&gt;&lt;span class="n"&gt;prefix&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="err"&gt;!&lt;/span&gt;&lt;span class="n"&gt;prefix&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;该扩展返回当前以 prefix 开通的变量名。根据 bash 文档，这两种形式的扩展形式执行的效果一模一样。&lt;/p&gt;
&lt;h4&gt;字符串操作&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;${#parameter}&lt;/code&gt;：扩展为 parameter 内包含的字符串的长度。如果 parameter 是 “@” 或 “*”，那么扩展的结果就是位置参数的个数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;[me@linuxbox ~]$ foo=&amp;quot;This string is long.&amp;quot;
[me@linuxbox ~]$ echo &amp;quot;&amp;#39;&lt;span class="nv"&gt;$foo&lt;/span&gt;&amp;#39; is &lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="c1"&gt;#foo&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt; characters long.&amp;quot;
&amp;#39;This string is long.&amp;#39; is 20 characters long.
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;{parameter:offset}&lt;/code&gt;和&lt;code&gt;{parameter:offset:length}&lt;/code&gt;：这个扩展提取一部分字符串。扩展以 offset 字符开始，直到字符串末尾，除非 length 特别指定它。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;[me@linuxbox ~]$ foo=&amp;quot;This string is long.&amp;quot;
[me@linuxbox ~]$ echo &lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
string is long.
[me@linuxbox ~]$ echo &lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
string
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果 offset 为负，默认表示从字符串末尾开始。&lt;strong&gt;注意，负值前必须有一个空格&lt;/strong&gt;，以防和&lt;code&gt;${parameter:-word}&lt;/code&gt;扩展混淆。length 不能小于0。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;[me@linuxbox ~]$ foo=&amp;quot;This string is long.&amp;quot;
[me@linuxbox ~]$ echo &lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
long.
[me@linuxbox ~]$ echo &lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
lo
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果参数是 “@”，扩展的结果则是从 offset 开始，length 为位置参数。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;${parameter#pattern}&lt;/code&gt;和&lt;code&gt;${parameter##pattern}&lt;/code&gt;：pattern 是一个通配符模式，“#” 去除最短匹配，”##” 去除最长匹配。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;[me@linuxbox ~]$ foo=file.txt.zip
[me@linuxbox ~]$ echo &lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="c1"&gt;#*.&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
txt.zip
[me@linuxbox ~]$ echo &lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="c1"&gt;##*.&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
zip
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;${parameter%pattern}&lt;/code&gt;和&lt;code&gt;${parameter%%pattern}&lt;/code&gt;：从尾部去除。pattern 是一个通配符模式，“%” 去除最短匹配，”%%” 去除最长匹配。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;[me@linuxbox ~]$ foo=file.txt.zip
[me@linuxbox ~]$ echo &lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;%*.&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
file.txt
[me@linuxbox ~]$ echo &lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;%%*.&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
file
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;${parameter/pattern/string}&lt;/code&gt;：查找替换，只替换第一个出现的&lt;/p&gt;
&lt;p&gt;&lt;code&gt;${parameter//pattern/string}&lt;/code&gt;：替换所有的&lt;/p&gt;
&lt;p&gt;&lt;code&gt;${parameter/#pattern/string}&lt;/code&gt;：要求匹配出现在字符串开头&lt;/p&gt;
&lt;p&gt;&lt;code&gt;${parameter/%pattern/string}&lt;/code&gt;：要求匹配出现在字符串末尾&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/string&lt;/code&gt;可以省略，此时匹配到的字符被删除&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;[me@linuxbox ~]$ foo=JPG.JPG
[me@linuxbox ~]$ echo &lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;JPG&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;jpg&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
jpg.JPG
[me@linuxbox ~]$ echo &lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="n"&gt;JPG&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;jpg&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
jpg.jpg
[me@linuxbox ~]$ echo &lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="c1"&gt;#JPG/jpg&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
jpg.JPG
[me@linuxbox ~]$ echo &lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;/%&lt;/span&gt;&lt;span class="n"&gt;JPG&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;jpg&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
JPG.jpg
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;命令替换&lt;/h3&gt;
&lt;p&gt;命令替换可以把一个命令的输出作为一个扩展模式使用：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;[me@linuxbox ~]$ ls -l $(which cp)
-rwxr-xr-x  1 root  wheel  29008 10 26  2017 /bin/cp
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在早期的 shell 程序中，存在命令替换的另一种语法，bash 也支持这种格式。它用反引号代替美元符号和括号：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;[me@linuxbox ~]$ ls -l `which cp`
-rwxr-xr-x  1 root  wheel  29008 10 26  2017 /bin/cp
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;引用&lt;/h2&gt;
&lt;p&gt;引用主要用于控制扩展。&lt;/p&gt;
&lt;h3&gt;双引号&lt;/h3&gt;
&lt;p&gt;如果把文本放在双引号中，那么 shell 使用的所有特殊字符都被看成普通字符，除了 “$（美元符号）”，“\（反斜杠）”，“`（反引号）” 除外。&lt;/p&gt;
&lt;p&gt;单词分隔、路径名扩展、波浪线扩展、花括号扩展都失效。&lt;/p&gt;
&lt;p&gt;参数扩展、算术扩展、命令替换仍然有效。&lt;/p&gt;
&lt;p&gt;使用双引号可以阻止单词分隔，这可以用来处理包含空白的文件名。&lt;/p&gt;
&lt;h3&gt;单引号&lt;/h3&gt;
&lt;p&gt;抑制所有扩展。&lt;/p&gt;
&lt;h3&gt;转义字符&lt;/h3&gt;
&lt;p&gt;转义字符通常用在双引号中用来有选择性的阻止扩展。&lt;/p&gt;
&lt;h2&gt;关于反斜杠转义字符（backslash escape sequence）&lt;/h2&gt;
&lt;p&gt;反斜杠除了作为转义字符外，也是一种表示法的一部分。ASCII 码表的前32个字符用来向电传打字类设备传送命令。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;转义字符&lt;/th&gt;
&lt;th align="left"&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;\a&lt;/td&gt;
&lt;td align="left"&gt;响铃（警告声——计算机发出哔哔声）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;\b&lt;/td&gt;
&lt;td align="left"&gt;退格&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;\n&lt;/td&gt;
&lt;td align="left"&gt;新的一行（在类 UNIX 系统中，产生的是换行效果&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;\r&lt;/td&gt;
&lt;td align="left"&gt;回车&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;\t&lt;/td&gt;
&lt;td align="left"&gt;制表&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;在&lt;code&gt;echo&lt;/code&gt;命令中带上 -e 选项，就能够解释转义字符序列，也可以将其放在 “$''”中。下面的例子，实现一个简单的倒计时计时器：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;[me@linuxbox ~]$ sleep 10; echo -e &amp;quot;Time&amp;#39;s up\a&amp;quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;也可以这样做：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;[me@linuxbox ~]$ sleep 10; echo -e &amp;quot;Time&amp;#39;s up&amp;quot; $&amp;#39;\a&amp;#39;
&lt;/pre&gt;&lt;/div&gt;</content><category term="Linux"></category></entry><entry><title>CSS 入门</title><link href="https://xutree.github.io/pages/2018/10/07/css_overview/" rel="alternate"></link><published>2018-10-07T11:24:03+08:00</published><updated>2018-10-07T12:29:23+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-07:/pages/2018/10/07/css_overview/</id><summary type="html">&lt;h2&gt;什么是 CSS&lt;/h2&gt;
&lt;p&gt;CSS（&lt;strong&gt;C&lt;/strong&gt; ascading &lt;strong&gt;S&lt;/strong&gt; tyle &lt;strong&gt;S&lt;/strong&gt; heets），即层叠样式表。&lt;/p&gt;
&lt;p&gt;层叠是指 CSS 将一种样式应用于另一种样式的方式。样式表控制 Web 文档的外观。&lt;/p&gt;
&lt;h2&gt;为什么使用 CSS&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;CSS 允许你将特定样式应用于特定 HTML 元素&lt;/li&gt;
&lt;li&gt;CSS 的主要好处是它允许您将样式与内容分开&lt;/li&gt;
&lt;li&gt;仅使用 HTML，所有样式和格式都在同一个地方，随着页面的增长，这变得相当难以维护&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;CSS 三种形式&lt;/h2&gt;
&lt;h3&gt;内联 CSS：inline CSS&lt;/h3&gt;
&lt;p&gt;使用内联样式是插入样式表的方法之一。 使用内联样式，将独特的样式应用于单个元素。&lt;/p&gt;
&lt;p&gt;要使用内联样式，请将style属性添加到相关标记。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;p&lt;/span&gt; &lt;span class="na"&gt;style=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;color:white; background-color:gray;&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
    This is an example …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;h2&gt;什么是 CSS&lt;/h2&gt;
&lt;p&gt;CSS（&lt;strong&gt;C&lt;/strong&gt; ascading &lt;strong&gt;S&lt;/strong&gt; tyle &lt;strong&gt;S&lt;/strong&gt; heets），即层叠样式表。&lt;/p&gt;
&lt;p&gt;层叠是指 CSS 将一种样式应用于另一种样式的方式。样式表控制 Web 文档的外观。&lt;/p&gt;
&lt;h2&gt;为什么使用 CSS&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;CSS 允许你将特定样式应用于特定 HTML 元素&lt;/li&gt;
&lt;li&gt;CSS 的主要好处是它允许您将样式与内容分开&lt;/li&gt;
&lt;li&gt;仅使用 HTML，所有样式和格式都在同一个地方，随着页面的增长，这变得相当难以维护&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;CSS 三种形式&lt;/h2&gt;
&lt;h3&gt;内联 CSS：inline CSS&lt;/h3&gt;
&lt;p&gt;使用内联样式是插入样式表的方法之一。 使用内联样式，将独特的样式应用于单个元素。&lt;/p&gt;
&lt;p&gt;要使用内联样式，请将style属性添加到相关标记。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;p&lt;/span&gt; &lt;span class="na"&gt;style=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;color:white; background-color:gray;&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
    This is an example of inline styling.
&lt;span class="nt"&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;嵌入式/内部 CSS：Embedded/Internal CSS&lt;/h3&gt;
&lt;p&gt;内部样式在 HTML 页面的&lt;code&gt;head&lt;/code&gt;部分内的&lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt;元素中定义。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;style&amp;gt;&lt;/span&gt;
      p {
         color:white;
         background-color:gray;
      }
      &lt;span class="nt"&gt;&amp;lt;/style&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;p&amp;gt;&lt;/span&gt;This is my first paragraph. &lt;span class="nt"&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;p&amp;gt;&lt;/span&gt;This is my second paragraph. &lt;span class="nt"&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;外部 CSS：External CSS&lt;/h3&gt;
&lt;p&gt;使用此方法，所有样式规则都包含在单个文本文件中，该文件以 .css 扩展名保存。&lt;/p&gt;
&lt;p&gt;然后使用&lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt;标记在 HTML 中引用此 CSS 文件。&lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt;元素位于&lt;code&gt;head&lt;/code&gt;部分内部。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;link&lt;/span&gt; &lt;span class="na"&gt;rel=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;stylesheet&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;href=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;example.css&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;p&amp;gt;&lt;/span&gt;This is my first paragraph.&lt;span class="nt"&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;p&amp;gt;&lt;/span&gt;This is my second paragraph. &lt;span class="nt"&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;p&amp;gt;&lt;/span&gt;This is my third paragraph. &lt;span class="nt"&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;CSS 语法&lt;/h2&gt;
&lt;p&gt;CSS 由浏览器解释的样式规则组成，然后应用于文档中的相应元素。样式规则有三个部分：&lt;code&gt;selector&lt;/code&gt;，&lt;code&gt;property&lt;/code&gt;和&lt;code&gt;value&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;例如，标题颜色可以定义为：&lt;code&gt;h1 { color: orange; }&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;选择器指向要设置样式的HTML元素。声明块包含一个或多个声明，以分号分隔。每个声明都包含一个属性名称和一个以冒号分隔的值。CSS 声明始终以分号结尾，声明组由大括号括起。&lt;/p&gt;
&lt;h3&gt;类型选择器&lt;/h3&gt;
&lt;p&gt;最常见且易于理解的选择器是类型选择器。 此选择器针对页面上的元素类型。&lt;/p&gt;
&lt;p&gt;例如，要定位页面上的所有段落：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
   &lt;span class="k"&gt;color&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="kc"&gt;red&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
   &lt;span class="k"&gt;font-size&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;130&lt;/span&gt;&lt;span class="kt"&gt;%&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;id 和 clss 选择器&lt;/h3&gt;
&lt;p&gt;id 选择器允许您设置具有 id 属性的 HTML 元素的样式，而不管它们在文档树中的位置如何。 以下是 id 选择器的示例：&lt;/p&gt;
&lt;p&gt;HTML 文件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;div&lt;/span&gt; &lt;span class="na"&gt;id=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;intro&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;p&amp;gt;&lt;/span&gt; This paragraph is in the intro section.&lt;span class="nt"&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;p&amp;gt;&lt;/span&gt; This paragraph is not in the intro section.&lt;span class="nt"&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;CSS 文件:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;#&lt;/span&gt;&lt;span class="nn"&gt;intro&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
   &lt;span class="k"&gt;color&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="kc"&gt;white&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
   &lt;span class="k"&gt;background-color&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="kc"&gt;gray&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;要选择具有特定 id 的元素，请使用井号 &lt;strong&gt;#&lt;/strong&gt; 字符，然后使用元素的 id 跟随它。&lt;/p&gt;
&lt;p&gt;类选择器以类似的方式工作。 主要区别在于 id 每页只能应用一次，而类可以根据需要在页面上多次使用。&lt;/p&gt;
&lt;p&gt;在下面的示例中，具有“first”类的两个段落都将受到 CSS 的影响：&lt;/p&gt;
&lt;p&gt;HTML 文件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;div&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;p&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;first&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;This is a paragraph&lt;span class="nt"&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;p&amp;gt;&lt;/span&gt; This is the second paragraph. &lt;span class="nt"&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;p&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;first&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt; This is not in the intro section&lt;span class="nt"&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;p&amp;gt;&lt;/span&gt; The second paragraph is not in the intro section. &lt;span class="nt"&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;CSS 文件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="na"&gt;.first&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;font-size&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;200&lt;/span&gt;&lt;span class="err"&gt;%&lt;/span&gt;&lt;span class="c"&gt;;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;要选择具有特定类的元素，请使用句点 &lt;strong&gt;.&lt;/strong&gt; 字符，后跟类的名称。不要用数字开始一个类或 id 名称。&lt;/p&gt;
&lt;h3&gt;后代选择器&lt;/h3&gt;
&lt;p&gt;这些选择器用于选择作为另一个元素的后代的元素。 选择级别时，您可以根据需要选择多个级别。&lt;/p&gt;
&lt;p&gt;例如，要仅定位“intro”部分第一段中的 &amp;lt;em&gt; 元素：&lt;/p&gt;
&lt;p&gt;HTML 文件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;div&lt;/span&gt; &lt;span class="na"&gt;id=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;intro&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;p&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;first&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;This is a &lt;span class="nt"&gt;&amp;lt;em&amp;gt;&lt;/span&gt; paragraph.&lt;span class="nt"&gt;&amp;lt;/em&amp;gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;p&amp;gt;&lt;/span&gt; This is the second paragraph. &lt;span class="nt"&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;p&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;first&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt; This is not in the intro section.&lt;span class="nt"&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;p&amp;gt;&lt;/span&gt; The second paragraph is not in the intro section. &lt;span class="nt"&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;CSS 文件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;#&lt;/span&gt;&lt;span class="nn"&gt;intro&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;first&lt;/span&gt; &lt;span class="nt"&gt;em&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
   &lt;span class="k"&gt;color&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="kc"&gt;pink&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
   &lt;span class="k"&gt;background-color&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="kc"&gt;gray&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;后代选择器匹配作为指定元素后代的所有元素。&lt;/p&gt;
&lt;h2&gt;注释&lt;/h2&gt;
&lt;p&gt;注释用于解释你的代码，浏览器会忽略。&lt;code&gt;/* Comment goes here */&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;层叠&lt;/h2&gt;
&lt;p&gt;网页的最终外观是不同样式规则的结果。形成层叠的三种主要风格来源是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;页面作者创建的样式表&lt;/li&gt;
&lt;li&gt;浏览器的默认样式&lt;/li&gt;
&lt;li&gt;用户指定的样式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;继承是指属性在页面中流动的方式。 除非另有定义，否则子元素通常会采用父元素的特征。&lt;/p&gt;</content><category term="CSS"></category></entry><entry><title>C++ Primer 第四章 表达式</title><link href="https://xutree.github.io/pages/2018/10/07/C++_Primer_Chapter_4/" rel="alternate"></link><published>2018-10-07T10:44:38+08:00</published><updated>2018-10-07T11:08:56+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-07:/pages/2018/10/07/C++_Primer_Chapter_4/</id><summary type="html">&lt;p&gt;重载运算符时，其包括运算对象的类型和返回值的类型，都是由该运算符定义的；但是运算对象的个数、运算符的优先级和结合律都是无法改变的。&lt;/p&gt;
&lt;h2&gt;左值和右值&lt;/h2&gt;
&lt;p&gt;当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。&lt;/p&gt;
&lt;p&gt;一个重要的原则：在需要右值的地方可以用左值来代替，但是不能把右值当成左值（也就是位置）使用。当一个左值被当成右值使用时，实际使用的是它的内容（值）。&lt;/p&gt;
&lt;p&gt;要用到左值的运算符：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;赋值运算符需要一个左值作为其左侧运算对象，得到的结果也仍然是一个左值&lt;/li&gt;
&lt;li&gt;取地址符作用于一个左值运算对象，返回一个指向该运算对象的指针，这个指针是一个右值&lt;/li&gt;
&lt;li&gt;内置解引用运算符、下标运算符、迭代器解引用运算符、&lt;code&gt;string&lt;/code&gt;和&lt;code&gt;vector&lt;/code&gt;的下标运算符的求值结果都是左值&lt;/li&gt;
&lt;li&gt;内置类型和迭代器的递增递减运算符作用于左值运算对象&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;求值顺序&lt;/h2&gt;
&lt;p&gt;优先级规定了运算对象的组合方式，但是没有说明运算对象按照什么顺序求值。对于那些没有指定执行顺序的运算符来说，如果表达式指向并修改了同一个对象，将会引发错误并产生未定义的行为。&lt;/p&gt;
&lt;p&gt;例如，下面的输出表达式是未定义的，我们无法推测编译器是先求 ++i 还是先输出：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int i = 0;
cout &amp;lt;&amp;lt; i …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;重载运算符时，其包括运算对象的类型和返回值的类型，都是由该运算符定义的；但是运算对象的个数、运算符的优先级和结合律都是无法改变的。&lt;/p&gt;
&lt;h2&gt;左值和右值&lt;/h2&gt;
&lt;p&gt;当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。&lt;/p&gt;
&lt;p&gt;一个重要的原则：在需要右值的地方可以用左值来代替，但是不能把右值当成左值（也就是位置）使用。当一个左值被当成右值使用时，实际使用的是它的内容（值）。&lt;/p&gt;
&lt;p&gt;要用到左值的运算符：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;赋值运算符需要一个左值作为其左侧运算对象，得到的结果也仍然是一个左值&lt;/li&gt;
&lt;li&gt;取地址符作用于一个左值运算对象，返回一个指向该运算对象的指针，这个指针是一个右值&lt;/li&gt;
&lt;li&gt;内置解引用运算符、下标运算符、迭代器解引用运算符、&lt;code&gt;string&lt;/code&gt;和&lt;code&gt;vector&lt;/code&gt;的下标运算符的求值结果都是左值&lt;/li&gt;
&lt;li&gt;内置类型和迭代器的递增递减运算符作用于左值运算对象&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;求值顺序&lt;/h2&gt;
&lt;p&gt;优先级规定了运算对象的组合方式，但是没有说明运算对象按照什么顺序求值。对于那些没有指定执行顺序的运算符来说，如果表达式指向并修改了同一个对象，将会引发错误并产生未定义的行为。&lt;/p&gt;
&lt;p&gt;例如，下面的输出表达式是未定义的，我们无法推测编译器是先求 ++i 还是先输出：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int i = 0;
cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; ++i &amp;lt;&amp;lt; endl;    //未定义的
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;有4种运算符明确规定了运算对象的求值顺序。&amp;amp;&amp;amp;、||、?:、和逗号（，）运算符。&lt;/p&gt;
&lt;p&gt;对于f()+g()*h()+j()的表达式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优先级规定，g() 的返回值和 h() 的返回值相乘&lt;/li&gt;
&lt;li&gt;结合律规定，f() 的返回值先与 g() 和 h() 的乘积相加，所得结果再与 j() 的返回值相加&lt;/li&gt;
&lt;li&gt;对于这些函数的调用顺序没有明确规定&lt;/li&gt;
&lt;li&gt;如果 f、g、h 和 j 是无关函数，它们既不会改变同一对象的状态也不执行 IO 任务，那么函数的调用顺序不受限制。反之，如果其中某几个函数影响同一对象，则它是一条错误的表达式，将产生未定义的行为&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;算术运算符&lt;/h2&gt;
&lt;p&gt;+(正号)、-(负号)、*(乘)、/(除),%(求余)，+(加)、-(减)&lt;/p&gt;
&lt;p&gt;算术运算符的运算对象和求值结果都是右值。&lt;/p&gt;
&lt;p&gt;一元正号负号运算符对运算对象作用后，返回一个（提升后的）副本：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int i = 1024;
int k = -i;
bool b = true;
bool b2 = -b;   //b2 是 true
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;对大多数运算符来说，布尔类型的运算对象将被提升为&lt;code&gt;int&lt;/code&gt;类型。如上，b 参与运算时被提升成整数值1，对它求负-1，转换为布尔值将其作为 b2 的初始值。&lt;/p&gt;
&lt;p&gt;在除法运算中，如果两个运算对象的符号相同则商为正，否则商为负。C++ 语言的早期版本允许结果为负值的商向上或向下取整，C++11 新标准则规定商一律向0取整（即直接切除小数部分）。&lt;/p&gt;
&lt;h2&gt;逻辑和关系运算符&lt;/h2&gt;
&lt;p&gt;运算对象和求值结果都是右值；短路求值；进行比较运算符时，除非比较的对象是布尔类型，否则不要使用布尔字面值&lt;code&gt;true&lt;/code&gt;和&lt;code&gt;false&lt;/code&gt;作为运算对象&lt;/p&gt;
&lt;h2&gt;赋值运算符&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;赋值运算符的左侧运算对象必须是一个可修改的左值&lt;/li&gt;
&lt;li&gt;赋值运算的结果是它的左侧运算对象，并且是一个左值，结果的类型就是左侧运算对象的类型&lt;/li&gt;
&lt;li&gt;如果赋值运算符的左右两个运算对象类型不同，则右侧运算对象将转换成左侧运算对象的类型&lt;/li&gt;
&lt;li&gt;赋值运算满足右结合律：ival = jval = 0；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;++ 和 -- 运算符&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;前置版本将对象本身作为左值返回，后置版本则将对象原始值的副本作为右值返回&lt;/li&gt;
&lt;li&gt;建议：除非必须，否则不用递增递减算符的后置版本&lt;/li&gt;
&lt;li&gt;后置递增运算符的优先级高于解引用运算符，因此 *pbeg++ 等价于 *(pbeg++)，pbeg++ 把 pbeg 的值加1，然后返回 pbeg 的初始值的副本作为其求值结果&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;成员访问运算符&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;由于解引用运算符的优先级低于逗号运算符，因此要对解引用运算符加括号&lt;/li&gt;
&lt;li&gt;箭头运算符作用于一个指针类型的运算对象，结果是一个左值&lt;/li&gt;
&lt;li&gt;点运算符分成两种情况：如果成员所属的对象是左值，那么结果就是左值；反之，如果成员所属的对象是右值，那么结果是右值&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;条件运算符&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;当条件运算符的两个表达式都是左值或者能转换成同一种左值类型时，运算的结果是左值；否则运算的结果是右值&lt;/li&gt;
&lt;li&gt;条件运算符满足右结合律&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;位运算符&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;位运算符作用于整数类型的运算对象&lt;/li&gt;
&lt;li&gt;关于符号位如何处理没有明确的规定，所以强烈建议仅将位运算符作用于处理无符号类型&lt;/li&gt;
&lt;li&gt;移位运算符&lt;ul&gt;
&lt;li&gt;首先令左侧运算对象的内容按照右侧运算对象的要求移动指定位数，然后将经过移动的（可能还进行了提升）左侧运算对象的拷贝作为求值结果。其中，右侧的运算对象一定不能为负，而且值必须严格小于结果的位数，否则就会产生未定义的行为。移出边界之外的位就被舍弃掉了&lt;/li&gt;
&lt;li&gt;移位运算符满足左结合律&lt;/li&gt;
&lt;li&gt;移位运算符的优先级比算术运算符低，比关系运算符、赋值运算符和条件运算符高&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;sizeof运算符&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;sizeof&lt;/code&gt;运算符返回一条表达式或一个类型名字所占的字节数。&lt;code&gt;sizeof&lt;/code&gt;运算符满足右结合律，其所得的值是一个&lt;code&gt;size_t&lt;/code&gt;类型的常量表达式&lt;/p&gt;
&lt;p&gt;两种形式&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sizeof (type)
sizeof expr
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;sizeof&lt;/code&gt;并不直接计算其运算对象的值。&lt;/p&gt;
&lt;p&gt;对于&lt;code&gt;sizeof *p&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因为&lt;code&gt;sizeof&lt;/code&gt;满足右结合律并且与 * 的运算符的优先级一样，所以表达式按照从右到左的顺序结合，等价于：&lt;code&gt;sizeof (*p)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;其次，因为&lt;code&gt;sizeof&lt;/code&gt;不实际求运算对象的值，所以即使 p 是一个无效（即未初始化）的指针也不会有什么影响&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;sizeof&lt;/code&gt;的运算对象中解引用一个无效的指针仍然是一种安全的行为，因为指针实际上并没有被真正使用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sizeof&lt;/code&gt;运算符的结果部分地依赖于其作用的类型：&lt;ul&gt;
&lt;li&gt;对&lt;code&gt;char&lt;/code&gt;或者类型为&lt;code&gt;char&lt;/code&gt;的表达式执行&lt;code&gt;sizeof&lt;/code&gt;运算，结果得1&lt;/li&gt;
&lt;li&gt;对引用类型执行&lt;code&gt;sizeof&lt;/code&gt;运算得到被引用对象所占空间的大小&lt;/li&gt;
&lt;li&gt;对指针执行&lt;code&gt;sizeof&lt;/code&gt;运算得到指针本身所占空间的大小&lt;/li&gt;
&lt;li&gt;对解引用指针执行&lt;code&gt;sizeof&lt;/code&gt;运算得到指针指向的对象所占空间的大小，指针不需有效&lt;/li&gt;
&lt;li&gt;对数值执行&lt;code&gt;sizeof&lt;/code&gt;运算符得到整个数组所占空间的大小。&lt;code&gt;sizeof&lt;/code&gt;运算不会把数组转换成指针来处理&lt;/li&gt;
&lt;li&gt;对&lt;code&gt;string&lt;/code&gt;对象或者&lt;code&gt;vector&lt;/code&gt;对象执行&lt;code&gt;sizeof&lt;/code&gt;运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。即只取决于里面存放的数据类型，与元素的个数无关，是个编译器相关的值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;逗号运算符&lt;/h2&gt;
&lt;p&gt;首先对左侧的表达式求值，然后将求值结果丢弃掉。逗号表达式真正的结果是右侧表达式的值。如果右侧运算对象是左值，那么最终的求值结果也是左值。&lt;/p&gt;
&lt;h2&gt;类型转换&lt;/h2&gt;
&lt;h3&gt;何时发生隐式类型转换&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;在大多数表达式中，比&lt;code&gt;int&lt;/code&gt;类型小的整数值首先提升为较大的整数类型&lt;/li&gt;
&lt;li&gt;在条件中，非布尔值转换成布尔类型&lt;/li&gt;
&lt;li&gt;初始化过程中，初始值转换成变量的类型；在赋值语句中，右侧运算对象装换成左侧运算对象的类型&lt;/li&gt;
&lt;li&gt;如果算术运算或关系运算的运算对象有多种类型，需要转换成同一种类型&lt;/li&gt;
&lt;li&gt;函数调用时也会发生类型转换&lt;/li&gt;
&lt;li&gt;数组转换成指针（当数组被用作&lt;code&gt;decltype&lt;/code&gt;关键字的参数，或者作为取地址符、&lt;code&gt;sizeof&lt;/code&gt;即&lt;code&gt;typeid&lt;/code&gt;等运算符的运算对象时，上述转换不会发生，如果用一个引用来初始化数组，上述转换也不会发生）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;指针的转换&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;常量整数值0或者字面值&lt;code&gt;nullptr&lt;/code&gt;能转换成任意指针类型&lt;/li&gt;
&lt;li&gt;指向任意非常量的指针能转换成&lt;code&gt;void *&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;指向任意对象的指针能转换成&lt;code&gt;const void *&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;转换成常量：允许将指向非常量类型的指针转换成指向相应的常量类型的指针，对于引用也是这样。相反的转换并不存在，因为它试图删掉底层&lt;code&gt;const&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;类类型定义的转换&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;类类型能定义由编译器自动执行的转换，不过编译器每次只能执行一种类类型的转换，如果同时提出多个转换请求，这些请求将被拒绝&lt;/li&gt;
&lt;li&gt;之前遇到过的类类型转换&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;string s, t = &amp;quot;a value&amp;quot;;    //字符串字面值转换成 string 类型
wile( cin &amp;gt;&amp;gt; s)     //while 的条件部分把 cin 转换成布尔值
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;显示转换&lt;/h3&gt;
&lt;p&gt;虽然有时不得不使用强制类型转换，但这种方法本质上是非常危险的。&lt;/p&gt;
&lt;h3&gt;命名的强制类型转换&lt;/h3&gt;
&lt;p&gt;一个命名的强制类型转换具有如下格式：&lt;code&gt;cast-name&amp;lt;type&amp;gt;(expression);&lt;/code&gt;type 是转换的目标类型。如果 type 是引用类型，则结果是左值；expression 是要转换的值；cast-name 是&lt;code&gt;static_cast&lt;/code&gt;、&lt;code&gt;dynamic_cast&lt;/code&gt;、&lt;code&gt;const_cast&lt;/code&gt;和&lt;code&gt;reinterpret_cast&lt;/code&gt;中的一种。&lt;code&gt;dynamic_cast&lt;/code&gt;支持运行时类型识别。&lt;/p&gt;
&lt;h3&gt;static_cast&lt;/h3&gt;
&lt;p&gt;任何具有明确定义的类型转换，只要不包含底层&lt;code&gt;const&lt;/code&gt;，都可以使用&lt;code&gt;static_cast&lt;/code&gt;。当需要把一个较大的算术类型赋给较小的类型时，&lt;code&gt;static_cast&lt;/code&gt;非常有用。此时，强制类型转换告诉程序的读者和编译器：我们知道并且不在乎潜在的精度损失。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;static_cast&lt;/code&gt;对于编译器无法自动执行的类型转换也非常有用。例如，我们可以使用它找回&lt;code&gt;void *&lt;/code&gt;指针中的值:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;void *p = &amp;amp;d;
double *dp = static_cast&amp;lt;double *&amp;gt;(p);
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;const_cast&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;const_cast&lt;/code&gt;只能改变运算对象的底层&lt;code&gt;const&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;const char *pc;
char *p = const_cast&amp;lt;char*&amp;gt;(pc);//正确，但通过p写值是未定义的行为
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;只有&lt;code&gt;const_cast&lt;/code&gt;能改变表达式的常量属性。&lt;/p&gt;
&lt;h3&gt;reinterpret_cast&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;einterpret_cast&lt;/code&gt;通常为运算对象的位模式提供较低层次上的重新解释。&lt;/p&gt;
&lt;p&gt;假如有以下转换：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int *ip;
char *pc = reinterpret_cast&amp;lt;char*&amp;gt;(ip);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们必须牢记 pc 所指的真实对象是一个 int 而非字符，如果把 pc 当成普通的字符指针使用就可能在运行时发生错误。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;string str(pc);     //可能导致异常的运行时行为
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;reinterpret_cast&lt;/code&gt;本质上依赖于机器。要想安全地使用&lt;code&gt;reinterpret_cast&lt;/code&gt;必须对涉及的类型和编译器实现转换的过程都非常了解。&lt;/p&gt;
&lt;p&gt;强制类型转换干扰了正常的类型检查，因此强烈建议避免使用强制类型转换。&lt;/p&gt;
&lt;h3&gt;旧式的强制类型转换&lt;/h3&gt;
&lt;p&gt;在早期版本的 C++ 语言中，显示地进行强制类型转换包含两种形式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;type (expr);    //函数形式的强制类型转换
(type) expr;    //C 语言风格的强制类型转换
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;根据所设计的类型不同，旧式的强制类型转换分别具有与&lt;code&gt;const_cast&lt;/code&gt;，&lt;code&gt;static_cast&lt;/code&gt;或&lt;code&gt;reinterpret_cast&lt;/code&gt;相似的行为。当我们在某处执行旧式的强制类型转换时，如果换成&lt;code&gt;const_cast&lt;/code&gt;和&lt;code&gt;static_cast&lt;/code&gt;也合法，则其行为与相应的命名转换一致。如果替换后不合法，则旧式强制类型转换执行与&lt;code&gt;reinterpret_cast&lt;/code&gt;类似的功能。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;char *pc = (char*) ip;  //ip是指向整数的指针
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上述代码的效果与&lt;code&gt;reinterpret_cast&lt;/code&gt;一样。&lt;/p&gt;</content><category term="C++"></category></entry><entry><title>C++ Primer 第三章 字符串、向量和数组</title><link href="https://xutree.github.io/pages/2018/10/06/C++_Primer_Chapter_3/" rel="alternate"></link><published>2018-10-06T22:31:16+08:00</published><updated>2018-10-07T10:48:54+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-06:/pages/2018/10/06/C++_Primer_Chapter_3/</id><summary type="html">&lt;p&gt;&lt;code&gt;string&lt;/code&gt;表示可变长的字符数组。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vector&lt;/code&gt;存放的是某种给定类型对象的可变长序列。&lt;/p&gt;
&lt;p&gt;数组和其他内置类型一样，实现与硬件密切相关，在灵活性上稍显不足。&lt;/p&gt;
&lt;p&gt;命名空间&lt;code&gt;using&lt;/code&gt;声明：&lt;code&gt;using namespace::name;&lt;/code&gt;例如：&lt;code&gt;using std::cin;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;头文件不应包含&lt;code&gt;using&lt;/code&gt;声明，防止名字冲突。&lt;/p&gt;
&lt;h2&gt;标准库类型 string&lt;/h2&gt;
&lt;h3&gt;头文件和声明&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="n"&gt;using&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kr"&gt;string&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;定义和初始化&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;string s1;  //默认初始化，空字符串
string s2 = s1; //s2是s1的副本，等价于 s2(s1)
string s3 = &amp;quot;hiya&amp;quot;; //s3是字符串字面值的副本，等价于s3(&amp;quot;hiya&amp;quot;)
string s4(10 …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;&lt;code&gt;string&lt;/code&gt;表示可变长的字符数组。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vector&lt;/code&gt;存放的是某种给定类型对象的可变长序列。&lt;/p&gt;
&lt;p&gt;数组和其他内置类型一样，实现与硬件密切相关，在灵活性上稍显不足。&lt;/p&gt;
&lt;p&gt;命名空间&lt;code&gt;using&lt;/code&gt;声明：&lt;code&gt;using namespace::name;&lt;/code&gt;例如：&lt;code&gt;using std::cin;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;头文件不应包含&lt;code&gt;using&lt;/code&gt;声明，防止名字冲突。&lt;/p&gt;
&lt;h2&gt;标准库类型 string&lt;/h2&gt;
&lt;h3&gt;头文件和声明&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="n"&gt;using&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kr"&gt;string&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;定义和初始化&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;string s1;  //默认初始化，空字符串
string s2 = s1; //s2是s1的副本，等价于 s2(s1)
string s3 = &amp;quot;hiya&amp;quot;; //s3是字符串字面值的副本，等价于s3(&amp;quot;hiya&amp;quot;)
string s4(10, &amp;#39;c&amp;#39;); //s4的内容是cccccccccc
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;string 对象上的操作&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;操作&lt;/th&gt;
&lt;th&gt;意义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;os &amp;lt;&amp;lt; s&lt;/td&gt;
&lt;td&gt;将 s 写到输出流 os 中，返回 os&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;is &amp;gt;&amp;gt; s&lt;/td&gt;
&lt;td&gt;从 is 中读取字符串赋给 s，字符串以空白分隔，返回 is&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;getline(is, s)&lt;/td&gt;
&lt;td&gt;从 is 中读取一行赋给 s，返回 is&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s.empty()&lt;/td&gt;
&lt;td&gt;s 为空返回 true，否则返回 false&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s.size()&lt;/td&gt;
&lt;td&gt;返回 s 中字符的个数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s[n]&lt;/td&gt;
&lt;td&gt;返回 s 中第 n 个字符的引用，位置 n 从0记起&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s1 + s2&lt;/td&gt;
&lt;td&gt;返回连接后的结果&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s1 = s2&lt;/td&gt;
&lt;td&gt;用 s2 的副本代替 s1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s1 == s2&lt;/td&gt;
&lt;td&gt;如果 s1 和 s2 中所含的字符完全一样，则他们相等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s1 != s2&lt;/td&gt;
&lt;td&gt;string 对象的相等性判断对大小写敏感&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;lt;, &amp;lt;=, &amp;gt;, &amp;gt;=&lt;/td&gt;
&lt;td&gt;利用字符在字典里的顺序进行比较，大小写敏感&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;读取未知数量的 string 对象&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int main()
{
    string word;
    while (cin &amp;gt;&amp;gt; word)
        cout &amp;lt;&amp;lt; word &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;直到遇到结束标记或者非法输入才会停止&lt;/p&gt;
&lt;h3&gt;使用 getline 读取一整行&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int main()
{
    string line;
    while (getline(cin,line))
        cout &amp;lt;&amp;lt; line &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;getline&lt;/code&gt;函数的参数是一个输入流和一个&lt;code&gt;string&lt;/code&gt;对象，&lt;code&gt;getline&lt;/code&gt;从给定的输入流中读入内容，直到遇到换行符为止（注意换行符也被读进来了），然后把所读的内容存入&lt;code&gt;string&lt;/code&gt;对象中（注意不存换行符）。如果输入一开始就是换行符，那么所得的结果是个空&lt;code&gt;string&lt;/code&gt;。&lt;/p&gt;
&lt;h3&gt;string::size_type 类型&lt;/h3&gt;
&lt;p&gt;是一个无符号类型的值。如果一个表达式中已经有&lt;code&gt;size&lt;/code&gt;函数就不要再使用&lt;code&gt;int&lt;/code&gt;了，这样可以避免混用&lt;code&gt;int&lt;/code&gt;和&lt;code&gt;unsigned&lt;/code&gt;可能带来的问题。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;string&lt;/code&gt;对象可以和字符字符串字面值相加，只要保证 + 号两侧的运算对象至少有一个&lt;code&gt;string&lt;/code&gt;对象即可。&lt;/p&gt;
&lt;p&gt;由于某些历史原因，也为了和 C 兼容，所以 C++ 中的字符串字面值并不是标准库&lt;code&gt;string&lt;/code&gt;类型。&lt;/p&gt;
&lt;h3&gt;处理 string 对象里的字符&lt;/h3&gt;
&lt;p&gt;包含在&lt;code&gt;cctype&lt;/code&gt;头文件中：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;意义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;isalunm(c)&lt;/td&gt;
&lt;td&gt;当 c 是字母或数字时为真&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;isalpha(c)&lt;/td&gt;
&lt;td&gt;当 c 是字母时为真&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;iscntrl(c)&lt;/td&gt;
&lt;td&gt;当 c 是控制字符时为真&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;isdigit(c)&lt;/td&gt;
&lt;td&gt;当 c 是数字时为真&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;isgraph(c)&lt;/td&gt;
&lt;td&gt;当 c 不是空格但可打印时为真&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;islower(c)&lt;/td&gt;
&lt;td&gt;当 c 是小写字母时为真&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;isprint(c)&lt;/td&gt;
&lt;td&gt;当 c 是可打印字符时为真（即 c 是空格或 c 具有可视形式）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ispunct(c)&lt;/td&gt;
&lt;td&gt;当 c 是标点符号时为真（即 c 不是控制字符、数字、字母、可打印空白中的一种）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;isspace(c)&lt;/td&gt;
&lt;td&gt;当 c 是空白时为真（即 c 是空格、横向制表符、纵向制表符、回车符、换行符、进纸符中的一种）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;isupper(c)&lt;/td&gt;
&lt;td&gt;当 c 是大写字母时为真&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;isxdigit(c)&lt;/td&gt;
&lt;td&gt;当 c 是十六进制数字时为真&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;tolower(c)&lt;/td&gt;
&lt;td&gt;输出 c 的小写&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;toupper(c)&lt;/td&gt;
&lt;td&gt;输出 c 的大写&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;C++ 标准库除了定义 C++ 语言特有的功能外，也兼容了 C 语言的标准库。C 语言的头文件形如 name.h，C++ 则将这些文件命名为 cname。因此&lt;code&gt;cctype&lt;/code&gt;头文件和&lt;code&gt;ctype.h&lt;/code&gt; 头文件的内容是一样的，只不过从命名规范上来讲更符合 C++ 语言的要求。特别地，在名为 cname 的头文件中定义的名字从属于命名空间&lt;code&gt;std&lt;/code&gt;。&lt;/p&gt;
&lt;h3&gt;范围 for&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;for (declaration: expression)
        statement
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;expression 是一个对象，用于表示一个序列；declaration 负责定义一个变量，该变量将被用于访问序列中的基础元素，每次迭代，declaration 部分的变量会被初始化为 expression 部分的下一个元素值。&lt;/p&gt;
&lt;p&gt;使用范围for输出&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;string str(&amp;quot;some string&amp;quot;);
        for (auto c : str)
cout &amp;lt;&amp;lt; c &amp;lt;&amp;lt; endl;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;使用范围for修改&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;string s(&amp;quot;Hello World!&amp;quot;);
for (auto &amp;amp;c : s)
        c = toupper(c);
cout &amp;lt;&amp;lt; s &amp;lt;&amp;lt; endl;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;下标运算符 [ ]&lt;/h3&gt;
&lt;p&gt;[ ]接收的输入参数是&lt;code&gt;string:size_type&lt;/code&gt;类型的值，这个参数表示要访问的字符的位置，返回值是该位置上字符的引用。&lt;code&gt;string&lt;/code&gt;对象的下标必须大于等于0而小于&lt;code&gt;s.size()&lt;/code&gt;。&lt;/p&gt;
&lt;h2&gt;标准库类型 vector&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;vector&lt;/code&gt;表示对象的集合，其中所有对象的类型都相同，也常被称作容器，是一种类模板&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;vector&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="n"&gt;using&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;编译器根据模板创建类或函数的过程称为实例化，对于类模板，我们通过提供一些额外信息来指定模板到底实例化成什么样的类：在模板名字后面跟一对尖括号，在括号内放上信息&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;vector&amp;lt;int&amp;gt; ivec;
vector&amp;lt;Sales_item&amp;gt; Sales_vec;
vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; file;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在早期版本的 C++ 标准中如果&lt;code&gt;vector&lt;/code&gt;的元素还是&lt;code&gt;vector&lt;/code&gt;（或者其他模板类型），则其定义的形式与现在的 C++11 新标准略有不同。过去，必须在外层&lt;code&gt;vector&lt;/code&gt;对象的右尖括号和其元素类型之间添加一个空格，如应写成&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;初始化&lt;/h3&gt;
&lt;p&gt;默认初始化。&lt;/p&gt;
&lt;p&gt;列表初始化。&lt;/p&gt;
&lt;p&gt;值初始化：通常情况下，可以只提供vector对象容纳的元素数量而略去初始值。此时库会创建一个值初始化的元素初值，并把它赋给容器中的所有元素。这个初值由vector对象中元素的类型决定。内置类型：0；类类型：由类默认初始化。&lt;/p&gt;
&lt;h3&gt;添加元素&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;push_back&lt;/code&gt;：负责把一个值当成&lt;code&gt;vector&lt;/code&gt;对象的尾元素压到&lt;code&gt;vector&lt;/code&gt;对象的尾端&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;vector&amp;lt;int&amp;gt; v2;
for (int i = 0; i != 100; ++i)
        v2.push_back(i);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果循环内部包含有向&lt;code&gt;vector&lt;/code&gt;对象添加元素的语句，则不能使用范围&lt;code&gt;for&lt;/code&gt;循环。&lt;/p&gt;
&lt;h3&gt;其他vector操作&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;v.empty()&lt;/td&gt;
&lt;td&gt;如果 v 不含有任何元素，返回真；否则返回假&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;v.size()&lt;/td&gt;
&lt;td&gt;返回 v 中元素的个数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;v.push_back(t)&lt;/td&gt;
&lt;td&gt;向 v 的尾端添加一个值为 t 的元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;v[n]&lt;/td&gt;
&lt;td&gt;返回 v 中第 n 个位置上元素的引用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;v1 = v2&lt;/td&gt;
&lt;td&gt;用 v2 中的元素拷贝替换 v1 中的元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td a，b，c...&gt;v1 = &lt;/td&gt;
&lt;td&gt;用列表中元素的拷贝替换 v1 中的元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;v1 == v2&lt;/td&gt;
&lt;td&gt;v1 和 v2 相等当且仅当它们的元素数量相同且对应位置的元素值都相同&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;v1 != v2&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;lt;,&amp;lt;=,&amp;gt;,&amp;gt;=&lt;/td&gt;
&lt;td&gt;以字典顺序进行比较&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;vector 的 size_type&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;vector&amp;lt;int&amp;gt;::size_type      //正确
vector::size_type           //错误
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;和&lt;code&gt;string&lt;/code&gt;一样，&lt;code&gt;vector&lt;/code&gt;对象的下标也是从0开始计算，&lt;code&gt;vector&lt;/code&gt;对象（以及&lt;code&gt;string&lt;/code&gt;对象）的下标运算符可用于访问已存在的元素，而不能用于添加元素。&lt;/p&gt;
&lt;h2&gt;迭代器&lt;/h2&gt;
&lt;p&gt;所有标准库容器都可以使用迭代器，但只有少数的几种才同时支持下标运算符。&lt;/p&gt;
&lt;p&gt;严格来讲，&lt;code&gt;string&lt;/code&gt;不属于容器类型，但是&lt;code&gt;string&lt;/code&gt;支持很多与容器类型相似的操作。&lt;code&gt;vector&lt;/code&gt;支持下标运算符，这点和&lt;code&gt;string&lt;/code&gt;一样。&lt;/p&gt;
&lt;p&gt;和指针不一样，获取迭代器不是使用取地址符，有迭代器的类型同时拥有返回迭代器的成员。&lt;code&gt;begin&lt;/code&gt;和&lt;code&gt;end&lt;/code&gt;：&lt;code&gt;auto b = v.begin(), e = v.end();&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;end&lt;/code&gt;成员负责返回指向容器“尾元素的下一位置”的迭代器。常被称作尾后迭代器或尾迭代器。&lt;/p&gt;
&lt;p&gt;如果容器为空，则&lt;code&gt;begin&lt;/code&gt;和&lt;code&gt;end&lt;/code&gt;返回的是同一个迭代器，都是尾后迭代器。&lt;/p&gt;
&lt;h3&gt;标准容器迭代器的运算符&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;符号&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;*iter&lt;/td&gt;
&lt;td&gt;返回迭代器 iter 所指元素的引用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;iter-&amp;gt;mem&lt;/td&gt;
&lt;td&gt;解引用 iter 并获取该元素的名为 mem 的成员，等价于(*iter).mem&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;++iter&lt;/td&gt;
&lt;td&gt;令 iter 指向容器中的下一个元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;--iter&lt;/td&gt;
&lt;td&gt;令 iter 指向容器中的上一个元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;iter1 == iter2&lt;/td&gt;
&lt;td&gt;判断两个迭代器是否相等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;iter1 != iter2&lt;/td&gt;
&lt;td&gt;如果指向同一元素或者他们是同一容器的尾后迭代器&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;因为&lt;code&gt;end&lt;/code&gt;返回的迭代器并不实际指向某个元素，所以不能对其进行递增或解引用操作。C++ 程序员习惯性地使用&lt;code&gt;!=&lt;/code&gt;，其原因和他们更愿意使用迭代器而非下标的原因一样：这种编程风格在标准库提供的所有容器上都有效，因为所有标准库容器都定义了&lt;code&gt;==&lt;/code&gt;和&lt;code&gt;!=&lt;/code&gt;。&lt;/p&gt;
&lt;h3&gt;迭代器类型&lt;/h3&gt;
&lt;p&gt;拥有迭代器的标准库类型使用&lt;code&gt;iterator&lt;/code&gt;和&lt;code&gt;const_iterator&lt;/code&gt;来表示迭代器的类型&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nd"&gt;iterator&lt;/span&gt; &lt;span class="nt"&gt;it&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;   &lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="nt"&gt;it&lt;/span&gt; &lt;span class="nt"&gt;能读写&lt;/span&gt; &lt;span class="nt"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nt"&gt;的元素&lt;/span&gt;
&lt;span class="nt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nd"&gt;iterator&lt;/span&gt; &lt;span class="nt"&gt;it2&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;       &lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="nt"&gt;it2&lt;/span&gt; &lt;span class="nt"&gt;能读写&lt;/span&gt; &lt;span class="nt"&gt;string&lt;/span&gt; &lt;span class="nt"&gt;对象中的元素&lt;/span&gt;
&lt;span class="nt"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="nt"&gt;const_iterator&lt;/span&gt; &lt;span class="nt"&gt;it3&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;  &lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="nt"&gt;it3&lt;/span&gt; &lt;span class="nt"&gt;只能读元素&lt;/span&gt;&lt;span class="err"&gt;，&lt;/span&gt;&lt;span class="nt"&gt;不能写元素&lt;/span&gt;
&lt;span class="nt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nd"&gt;const_iterator&lt;/span&gt; &lt;span class="nt"&gt;it4&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;     &lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="nt"&gt;it4&lt;/span&gt; &lt;span class="nt"&gt;只能读字符&lt;/span&gt;&lt;span class="err"&gt;，&lt;/span&gt;&lt;span class="nt"&gt;不能写字符&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;begin&lt;/code&gt;和&lt;code&gt;end&lt;/code&gt;返回的具体类型由对象是否是常量决定，如果对象是常量，&lt;code&gt;begin&lt;/code&gt;和&lt;code&gt;end&lt;/code&gt;返回&lt;code&gt;const_iterator&lt;/code&gt;；如果对象不是常量，返回&lt;code&gt;iterator&lt;/code&gt;。如果对象只需读操作而无需写操作的话最好使用常量类型迭代器。为了专门得到&lt;code&gt;const_iterator&lt;/code&gt;，C++11 标准引入两个新函数：&lt;code&gt;cbegin&lt;/code&gt;和&lt;code&gt;cend&lt;/code&gt;。任何一种可能改变容器容量的操作，都会是迭代器失效。&lt;/p&gt;
&lt;h3&gt;迭代器运算&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;string&lt;/code&gt;和&lt;code&gt;vector&lt;/code&gt;的迭代器提供了更多额外的运算符：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;iter + n&lt;/code&gt;：迭代器加上一个整数值仍得到一个迭代器，迭代器指示的新位置与原来相比向前移动了若干个元素。结果迭代器或者指示容器内的一个元素，或者指示容器尾元素的下一位置。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;iter - n&lt;/code&gt;：迭代器减去一个整数值仍得一个迭代器，迭代器指示的新位置与原来相比向后移动了若干位置。结果迭代器或者指示容器内的一个元素，或者指示容器尾元素的下一位置。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;iter1 - iter2&lt;/code&gt;：两个迭代器相减的结果是它们之间的距离，也就是说，将运算符右侧的迭代器向前移动差值个元素后将得到左侧的迭代器。参与运算的两个迭代器必须指向的是同一容器中的元素或者尾元素的下一位置。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;gt;, &amp;gt;=, &amp;lt;, &amp;lt;=&lt;/code&gt;：迭代器的关系运算符，如果迭代器指向的容器位置在另一个迭代器所指位置之前，则说前者小于后者。&lt;/p&gt;
&lt;h2&gt;数组&lt;/h2&gt;
&lt;p&gt;因为数组的大小固定，因此在对某些特殊的应用来说程序的运行时性能较好，但是相应的也损失了一些灵活性。&lt;/p&gt;
&lt;p&gt;数组的维度必须是一个常量表达式。&lt;/p&gt;
&lt;p&gt;默认情况下数组的元素被默认初始化。&lt;/p&gt;
&lt;p&gt;和内置类型的变量一样，如果在函数内部定义了某种内置类型的数组，那么默认初始化会令数组含有未定义的值。&lt;/p&gt;
&lt;p&gt;定义数组的时候必须指定数组的类型，不允许用auto关键字由初始值的列表推断类型。&lt;/p&gt;
&lt;p&gt;字符数组可以利用字符串字面值初始化，此时注意字符串字面值末尾的空字符，也会被拷贝到字符数组中。&lt;/p&gt;
&lt;p&gt;不允许拷贝和赋值。一些编译器支持数组的赋值，这就是所谓的编译器扩展，但一般来说，最好避免使用非标准特性，因为可能在其他编译器上无法正常工作。&lt;/p&gt;
&lt;p&gt;理解复杂的数组声明：由内向外阅读&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int *ptrs[10];   //ptrs 是含有10个整型指针的数组
int (*Parray)[10] = &amp;amp;arr;   //Parray 是指针，指向一个含有10个整数的数组
int (&amp;amp;arrRef)[10] = arr;    //arrRef 是引用，引用一个含有10个整数的数组
int *(&amp;amp;arry)[10] = ptrs;    //arry 是引用，引用一个含有10个整型指针的数组
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;访问数组元素&lt;/h3&gt;
&lt;p&gt;数组的索引从0开始。&lt;/p&gt;
&lt;p&gt;在使用数组下标的时候，通常将其定义为&lt;code&gt;size_t&lt;/code&gt;类型。&lt;code&gt;size_t&lt;/code&gt;是一种机器相关的无符号类型，它被设计的足够大以便能表示内存中任意对象的大小。&lt;/p&gt;
&lt;p&gt;在 cstddef 头文件中定义了&lt;code&gt;size_t&lt;/code&gt;类型，这个文件是 C 标准库 stddef.h 头文件的 C++ 版本。&lt;/p&gt;
&lt;p&gt;使用数组的时候编译器一般会把它转换成指针。&lt;/p&gt;
&lt;p&gt;通常情况下，使用取地址符来获取指向某个对象的指针，取地址符可以用于任何对象。数组的元素也是对象，对数组使用下标运算符得到该数组指定位置的元素，对数组元素应用取地址符就能得到指向该元素的指针。&lt;/p&gt;
&lt;p&gt;数组还有一个特性：在很多时候用到数组名字的地方，编译器都会自动地将其替换为一个指向数组首元素的指针&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;string *p2 = nums;  //等价于 p2 = &amp;amp;nums[0]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;所以如果使用数组作为一个auto变量的初始值时，推断的类型是指针而非数组&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int ia[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9,};
auto ia2(ia);       // ia2 是一个整型指针，指向 ia 的第一个元素
ia2 = 42;       //错误，ia2 是一个指针，不能用 int 赋值
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当使用&lt;code&gt;decltype&lt;/code&gt;关键字时上述转换不会发生，&lt;code&gt;decltype(ia)&lt;/code&gt;返回的类型是由10个整数构成的数组&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;decltype(ia) ia3 = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
ia3 = p;        //错误，不能用整型指针给数组赋值
ia3[4] = i;     //正确：把 i 的值赋给 ia3 的一个元素
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;为了让指针的使用更简单、更安全，C++11 新标准引入两个名为&lt;code&gt;begin&lt;/code&gt;和&lt;code&gt;end&lt;/code&gt;的函数，不过数组毕竟不是类类型，因此这两个函数不是成员函数。正确的使用形式是将数组作为它们的参数&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int ia[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};
int *beg = begin(ia);
int *last = end(ia);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;begin&lt;/code&gt;函数返回指向 ia 首元素的指针，&lt;code&gt;end&lt;/code&gt;函数返回指向 ia 尾元素下一位置的指针，这两个函数定义在 iterator 头文件中&lt;/p&gt;
&lt;p&gt;两个指针相减结果的类型是一种名为&lt;code&gt;ptrdiff_t&lt;/code&gt;的类型，和&lt;code&gt;size_t&lt;/code&gt;一样，它也是定义在 cstddef 头文件中的机器相关的类型。因为差值可能是负值，所以它是一种带符号类型。&lt;/p&gt;
&lt;p&gt;内置的下标运算符所用的索引值不是无符号类型，这一点和&lt;code&gt;vector&lt;/code&gt;和&lt;code&gt;string&lt;/code&gt;不一样&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int *p = &amp;amp;ia[2];
int k = p[-2];      //k 是 ia[0] 那个元素
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;C 风格字符串&lt;/h3&gt;
&lt;p&gt;按此习惯书写的字符串存放在字符数组中并以空字符结束。&lt;/p&gt;
&lt;p&gt;C 语言标准库提供了一组函数用于操作 C 风格字符串，它们定义在 cstring 头文件中，cstring 是 C 语言头文件 string.h 的 C++ 版本。&lt;/p&gt;
&lt;h3&gt;与旧代码的接口&lt;/h3&gt;
&lt;p&gt;任何出现字符串字面值的地方都可以用空字符结尾的字符数组来代替。不能用string对象直接初始化指向字符的指针，为了完成该功能，string专门提供了一个名为c_str的成员函数&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;char *str = s;      //错误，不能用 string 对象初始化 char*
const char *str = s.c_str();    //正确
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们无法保证 c_str 函数返回的数组一直有效，事实上，如果后续的操作改变了 s 的值就可能让之前返回的数组失去效用&lt;/p&gt;
&lt;p&gt;使用数组初始化&lt;code&gt;vector&lt;/code&gt;对象&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int int_arr[] = {0, 1, 2, 3, 4, 5};
vector&amp;lt;int&amp;gt; ivec(begin(int_arr),end(int_arr));
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;现代的 C++ 程序员应当尽量使用&lt;code&gt;vector&lt;/code&gt;和迭代器，避免使用内置的数组和指针，应该尽量使用&lt;code&gt;string&lt;/code&gt;，避免使用 C 风格的基于数组的字符串。&lt;/p&gt;
&lt;p&gt;多维数组：要使用范围 for 语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型。&lt;/p&gt;
&lt;p&gt;缓冲区溢出：主要原因是试图通过一个越界的索引访问容器内容。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;difference_type&lt;/code&gt;：由&lt;code&gt;string&lt;/code&gt;和&lt;code&gt;vector&lt;/code&gt;定义的一种带符号整数类型，表示两个迭代器之间的距离。&lt;/p&gt;</content><category term="C++"></category></entry><entry><title>C++ Primer 第二章 变量和基本类型</title><link href="https://xutree.github.io/pages/2018/10/06/C++_Primer_Chapter_2/" rel="alternate"></link><published>2018-10-06T22:02:54+08:00</published><updated>2018-10-07T10:48:38+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-06:/pages/2018/10/06/C++_Primer_Chapter_2/</id><summary type="html">&lt;h2&gt;类型&lt;/h2&gt;
&lt;p&gt;下表列出了 C++ 标准规定的数据类型尺寸的最小值，同时允许编译器赋予这些类型更大的尺寸&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;th&gt;最小尺寸&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;bool&lt;/td&gt;
&lt;td&gt;布尔类型&lt;/td&gt;
&lt;td&gt;未定义&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;char&lt;/td&gt;
&lt;td&gt;字符&lt;/td&gt;
&lt;td&gt;8位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;wchar_t&lt;/td&gt;
&lt;td&gt;宽字符&lt;/td&gt;
&lt;td&gt;16位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;char16_t&lt;/td&gt;
&lt;td&gt;Unicode 字符&lt;/td&gt;
&lt;td&gt;16位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;char32_t&lt;/td&gt;
&lt;td&gt;Unicode 字符&lt;/td&gt;
&lt;td&gt;32位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;short&lt;/td&gt;
&lt;td&gt;短整型&lt;/td&gt;
&lt;td&gt;16位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;整型&lt;/td&gt;
&lt;td&gt;16位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;long&lt;/td&gt;
&lt;td&gt;长整型&lt;/td&gt;
&lt;td&gt;32位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;long long&lt;/td&gt;
&lt;td&gt;长整型&lt;/td&gt;
&lt;td&gt;64位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;float&lt;/td&gt;
&lt;td&gt;单精度浮点数&lt;/td&gt;
&lt;td&gt;6位有效数字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;double&lt;/td&gt;
&lt;td&gt;双精度浮点数&lt;/td&gt;
&lt;td&gt;10位有效数字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;long double&lt;/td&gt;
&lt;td&gt;扩展精度浮点数&lt;/td&gt;
&lt;td&gt;10位有效数字&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;一个&lt;code&gt;char …&lt;/code&gt;&lt;/p&gt;</summary><content type="html">&lt;h2&gt;类型&lt;/h2&gt;
&lt;p&gt;下表列出了 C++ 标准规定的数据类型尺寸的最小值，同时允许编译器赋予这些类型更大的尺寸&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;th&gt;最小尺寸&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;bool&lt;/td&gt;
&lt;td&gt;布尔类型&lt;/td&gt;
&lt;td&gt;未定义&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;char&lt;/td&gt;
&lt;td&gt;字符&lt;/td&gt;
&lt;td&gt;8位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;wchar_t&lt;/td&gt;
&lt;td&gt;宽字符&lt;/td&gt;
&lt;td&gt;16位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;char16_t&lt;/td&gt;
&lt;td&gt;Unicode 字符&lt;/td&gt;
&lt;td&gt;16位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;char32_t&lt;/td&gt;
&lt;td&gt;Unicode 字符&lt;/td&gt;
&lt;td&gt;32位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;short&lt;/td&gt;
&lt;td&gt;短整型&lt;/td&gt;
&lt;td&gt;16位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;整型&lt;/td&gt;
&lt;td&gt;16位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;long&lt;/td&gt;
&lt;td&gt;长整型&lt;/td&gt;
&lt;td&gt;32位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;long long&lt;/td&gt;
&lt;td&gt;长整型&lt;/td&gt;
&lt;td&gt;64位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;float&lt;/td&gt;
&lt;td&gt;单精度浮点数&lt;/td&gt;
&lt;td&gt;6位有效数字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;double&lt;/td&gt;
&lt;td&gt;双精度浮点数&lt;/td&gt;
&lt;td&gt;10位有效数字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;long double&lt;/td&gt;
&lt;td&gt;扩展精度浮点数&lt;/td&gt;
&lt;td&gt;10位有效数字&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;一个&lt;code&gt;char&lt;/code&gt;的空间应确保可以存放机器基本字符集中任意字符对应的数字值。也就是说，一个&lt;code&gt;char&lt;/code&gt;的大小和一个机器字节一样。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;wchar_t&lt;/code&gt;类型用于确保可以存放机器最大扩展字符集中的任意一个字符。&lt;/p&gt;
&lt;p&gt;C++ 语言规定，一个&lt;code&gt;int&lt;/code&gt;至少和一个&lt;code&gt;short&lt;/code&gt;一样大，一个&lt;code&gt;long&lt;/code&gt;至少和一个&lt;code&gt;int&lt;/code&gt;一样大，一个&lt;code&gt;long long&lt;/code&gt;至少和一个&lt;code&gt;long&lt;/code&gt;一样大。&lt;/p&gt;
&lt;p&gt;可寻址的最小内存块成称为“字节（byte）”，存储的基本单元称为“字（word）”，它通常有几个字节组成。&lt;/p&gt;
&lt;p&gt;在 C++ 语言中，一个字节至少能容纳机器基本字符串中的字符。大多数机器的字节由8比特构成，字则由32或64比特构成，也就是4字节或8字节。&lt;/p&gt;
&lt;p&gt;C++ 标准指定了一个浮点数有效位数的最小值，然而大多数编译器都实现了更高的精度。通常，&lt;code&gt;float&lt;/code&gt;以1个字（32比特）来表示，&lt;code&gt;double&lt;/code&gt;以2个字（64位）来表示，&lt;code&gt;long double&lt;/code&gt;以3或4个字（96或128比特）来表示。一般来说，&lt;code&gt;float&lt;/code&gt;和&lt;code&gt;double&lt;/code&gt;分别有7和16个有效位；类型&lt;code&gt;long double&lt;/code&gt;则常常被用于有特殊浮点要求的硬件，它的具体实现不同，精度也各不相同。&lt;/p&gt;
&lt;p&gt;类型&lt;code&gt;int&lt;/code&gt;、&lt;code&gt;short&lt;/code&gt;、&lt;code&gt;long&lt;/code&gt;和&lt;code&gt;long long&lt;/code&gt;都是带符号的，通过在这些类型名前添加&lt;code&gt;unsigned&lt;/code&gt;就可以得到无符号类型。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;char&lt;/code&gt;、&lt;code&gt;signed char&lt;/code&gt;和&lt;code&gt;unsigned char&lt;/code&gt;，&lt;code&gt;char&lt;/code&gt;是否等于&lt;code&gt;signed char&lt;/code&gt;由编译器决定。&lt;/p&gt;
&lt;p&gt;C++ 标准并没有规定带符号类型应如何表示，但是约定了在表示范围内正值和负值的量应该平衡。因此，8比特的&lt;code&gt;signed char&lt;/code&gt;理论上可以表示-127至127区间内的值，大多数现代计算机将实际的表示范围定为-128至127。&lt;/p&gt;
&lt;h2&gt;如何选择类型&lt;/h2&gt;
&lt;p&gt;明知数值不可能为负数，选用无符号类型。&lt;/p&gt;
&lt;p&gt;如果数值超过了&lt;code&gt;int&lt;/code&gt;的表示范围，选用&lt;code&gt;long long&lt;/code&gt;，因为&lt;code&gt;long&lt;/code&gt;一般和&lt;code&gt;int&lt;/code&gt;有一样的尺寸。&lt;/p&gt;
&lt;p&gt;算术表达式中不要使用&lt;code&gt;bool&lt;/code&gt;或&lt;code&gt;char&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;执行浮点数运算选用&lt;code&gt;double&lt;/code&gt;。因为&lt;code&gt;float&lt;/code&gt;通常精度不够而且计算代价相差无几。&lt;code&gt;long double&lt;/code&gt;提供的精度一般情况下是没有必要的而且计算代价大。&lt;/p&gt;
&lt;h2&gt;类型转换&lt;/h2&gt;
&lt;p&gt;非布尔 -&amp;gt; 布尔：0 -&amp;gt; &lt;code&gt;false&lt;/code&gt;，其他 -&amp;gt; &lt;code&gt;ture&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;布尔 -&amp;gt; 非布尔：&lt;code&gt;false&lt;/code&gt;-&amp;gt; 0，&lt;code&gt;ture&lt;/code&gt; -&amp;gt; 1。&lt;/p&gt;
&lt;p&gt;浮点 -&amp;gt; 整型：仅保留小数点前。&lt;/p&gt;
&lt;p&gt;整型 -&amp;gt; 浮点：小数部分记为0，如果该整数所占的空间超过浮点类型的容量，精度可能损失。&lt;/p&gt;
&lt;p&gt;当我们赋给无符号类型一个超过它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。&lt;/p&gt;
&lt;p&gt;当我们赋给带符号类型一个超出它表示范围的值时，结果是未定义的。此时，程序可能继续工作、可能崩溃，也可能生成垃圾数据。&lt;/p&gt;
&lt;p&gt;当一个算术表达式中既有无符号数又有&lt;code&gt;int&lt;/code&gt;值时，那个&lt;code&gt;int&lt;/code&gt;会转换成无符号数。把&lt;code&gt;int&lt;/code&gt;转换成无符号数的过程和把&lt;code&gt;int&lt;/code&gt;赋值给无符号变量一样。&lt;/p&gt;
&lt;p&gt;当从一个无符号数中减去一个值时，我们必须确保结果不是负值，否则实际结果会是取模后的值。&lt;/p&gt;
&lt;h2&gt;字面值常量&lt;/h2&gt;
&lt;p&gt;整型和浮点型字面值。&lt;/p&gt;
&lt;p&gt;字符和字符串字面值：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;‘a’ 和“a”，字符串字面值最后补’\0’&lt;/li&gt;
&lt;li&gt;如果两个字符串字面值位置紧邻且仅由空格、缩进和换行分隔，则它们是一个整体&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;布尔字面值：&lt;code&gt;true&lt;/code&gt;、&lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;指针字面值：&lt;code&gt;nullptr&lt;/code&gt;。&lt;/p&gt;
&lt;h2&gt;指定字面值的类型&lt;/h2&gt;
&lt;p&gt;字符和字符串字面值&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;前缀&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;u&lt;/td&gt;
&lt;td&gt;char16_t&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;U&lt;/td&gt;
&lt;td&gt;char32_t&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;L&lt;/td&gt;
&lt;td&gt;wchar_t&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;u8&lt;/td&gt;
&lt;td&gt;char&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;整型字面值&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;后缀&lt;/th&gt;
&lt;th&gt;最小匹配类型&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;u 或 U&lt;/td&gt;
&lt;td&gt;unsigned&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;l 或 L&lt;/td&gt;
&lt;td&gt;long&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ll 或 LL&lt;/td&gt;
&lt;td&gt;long long&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;浮点型字面值&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;后缀&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;f 或 F&lt;/td&gt;
&lt;td&gt;float&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;l 或 L&lt;/td&gt;
&lt;td&gt;long double&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;列表初始化&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;int units_sold{0}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;列表初始化的重要特点：如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将报错。&lt;/p&gt;
&lt;h2&gt;默认初始化&lt;/h2&gt;
&lt;p&gt;内置类型变量&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定义于任何函数之外，初始化为0&lt;/li&gt;
&lt;li&gt;定义于函数体内的局部静态变量，初始化为0&lt;/li&gt;
&lt;li&gt;定义于函数体内的非局部静态变量，不被初始化，试图拷贝或以其他方式访问此类值将引发错误&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每个类各自决定其初始化对象的方式。&lt;/p&gt;
&lt;h2&gt;分离式编译&lt;/h2&gt;
&lt;p&gt;将程序分割为若干个文件，每个文件可被独立编译&lt;/p&gt;
&lt;h2&gt;声明&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;extern int i;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;extern&lt;/code&gt;语句如果包含初始值就不再是声明，而变成定义了：&lt;code&gt;extern int i = 0;&lt;/code&gt;在函数体内部，试图初始化一个由&lt;code&gt;extern&lt;/code&gt;关键字标记的变量将引发错误。&lt;/p&gt;
&lt;p&gt;静态类型语言：在编译阶段执行类型检查&lt;/p&gt;
&lt;h2&gt;C++ 标识符&lt;/h2&gt;
&lt;p&gt;字母、数字、下划线，必须以字母或下划线开头，长度无限制，大小写敏感。&lt;/p&gt;
&lt;p&gt;C++ 为标准库保留了一些名字&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自定义标识符中不能连续出现两个下划线&lt;/li&gt;
&lt;li&gt;不能以下划线紧接大写字母开头&lt;/li&gt;
&lt;li&gt;定义在函数体外的函数不能以下划线开头&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;作用域操作符 ::&lt;/h2&gt;
&lt;p&gt;若左侧为空，则指代全局作用域&lt;/p&gt;
&lt;h2&gt;复合类型&lt;/h2&gt;
&lt;h3&gt;引用&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;int &amp;amp;b = a;&lt;/code&gt;b指向a。&lt;/p&gt;
&lt;p&gt;引用必须初始化。&lt;/p&gt;
&lt;p&gt;引用本身不是一个对象，不能定义引用的引用。&lt;/p&gt;
&lt;p&gt;引用必须绑定到对象上，不能绑定到字面值或者某个表达式的计算结果上。&lt;/p&gt;
&lt;p&gt;除了两种例外，所有引用的类型都要和它所绑定的对象严格匹配：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可&lt;/li&gt;
&lt;li&gt;允许将基类的引用绑定到派生类上&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;指针&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;int *b = &amp;amp;a;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;指针是一个对象。&lt;/p&gt;
&lt;p&gt;在块作用域内定义的指针如果未初始化，将拥有一个不确定的值。&lt;/p&gt;
&lt;p&gt;除了两种例外，所有指针的类型都要和它所指向的对象严格匹配：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;允许一个指向常量的指针指向一个非常量对象&lt;/li&gt;
&lt;li&gt;允许将基类的指针绑定到派生类上&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;试图拷贝或以其他方式访问无效指针的值将引起错误，编译器不负责检查此类错误。&lt;/p&gt;
&lt;p&gt;任何非零的指针对应的条件值都是true。&lt;/p&gt;
&lt;p&gt;合法指针可以比较大小：== 或 !=。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;void *&lt;/code&gt;是一个特殊的指针类型，可用于存放任意对象的地址，只支持有限的操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;拿它和别的指针比较&lt;/li&gt;
&lt;li&gt;作为函数的输入或输出&lt;/li&gt;
&lt;li&gt;赋给另外一个&lt;code&gt;void *&lt;/code&gt;指针&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;理解复合类型的声明&lt;/h2&gt;
&lt;p&gt;变量的定义包括一个基本数据类型和一组声明符。&lt;/p&gt;
&lt;p&gt;一条定义语句可能定义出不同类型的变量：&lt;code&gt;int i = 1024, *p = &amp;amp;i, &amp;amp;r =i;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;面对一条比较复杂的指针或者引用的声明语句时，从右往左阅读有助于弄清楚它的真实含义，例如：&lt;code&gt;int \*&amp;amp;r;&lt;/code&gt;首先 r 是一个引用，其次 r 是一个指针的引用，再次 r 是一个指向整型指针的引用。&lt;/p&gt;
&lt;h2&gt;const 限定符&lt;/h2&gt;
&lt;p&gt;因为&lt;code&gt;const&lt;/code&gt;对象一旦创建就无法改变其值，所以必须初始化。&lt;/p&gt;
&lt;p&gt;当用一个对象去初始化另外一个对象，它们是不是&lt;code&gt;const&lt;/code&gt;都无关紧要，常量的特性仅仅在执行改变其值的操作时才会发挥作用。&lt;/p&gt;
&lt;p&gt;默认情况下，&lt;code&gt;const&lt;/code&gt;对象仅在文件内有效。&lt;/p&gt;
&lt;p&gt;如果想在多个文件之间共享&lt;code&gt;const&lt;/code&gt;对象，必须在变量的定义之前添加&lt;code&gt;extern&lt;/code&gt;关键字。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;const&lt;/code&gt;的引用，常量引用的初始化：初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。尤其，允许为一个常量引用绑定非常量的对象、字面值甚至是一个表达式。实际上是通过绑定到一个临时量对象上实现的。&lt;/p&gt;
&lt;p&gt;对&lt;code&gt;const&lt;/code&gt;的引用可能引用一个并非&lt;code&gt;const&lt;/code&gt;的对象，常量引用仅对引用可参与的操作做了限制，对于引用的对象本身是不是常量未做限制。&lt;/p&gt;
&lt;h2&gt;指针和 const&lt;/h2&gt;
&lt;h3&gt;指向常量的指针&lt;/h3&gt;
&lt;p&gt;允许一个指向常量的指针指向一个非常量对象。&lt;/p&gt;
&lt;p&gt;仅对指向常量的指针可参与的操作做了限制，对于指向的对象本身是不是常量未做限制。&lt;/p&gt;
&lt;h3&gt;const 指针&lt;/h3&gt;
&lt;p&gt;指针是对象，可以把指针本身定为常量。&lt;/p&gt;
&lt;p&gt;常量指针必须初始化，一经初始化就不能再改变。&lt;/p&gt;
&lt;p&gt;把*放在&lt;code&gt;const&lt;/code&gt;关键字之前说明指针是一个常量。&lt;/p&gt;
&lt;h3&gt;顶层和底层 const&lt;/h3&gt;
&lt;p&gt;顶层&lt;code&gt;const&lt;/code&gt;：指针本身是个常量。&lt;/p&gt;
&lt;p&gt;底层&lt;code&gt;const&lt;/code&gt;：指针所值的对象是一个常量。&lt;/p&gt;
&lt;p&gt;更一般的，顶层&lt;code&gt;const&lt;/code&gt;可以表示任意的对象是常量，这一点对任意数据类型都适用。底层&lt;code&gt;const&lt;/code&gt;则与指针和引用等复合类型的基本类型部分有关。&lt;/p&gt;
&lt;p&gt;执行对象的拷贝操作时，顶层&lt;code&gt;const&lt;/code&gt;不受影响；拷入和拷出的对象必须具有相同的底层&lt;code&gt;const&lt;/code&gt;资格，或者两个对象的数据类型必须能够转换。一般来说，非常量可以转换成常量，反之不行。&lt;/p&gt;
&lt;h3&gt;constexpr 和常量表达式&lt;/h3&gt;
&lt;p&gt;常量表达式：值不会改变并且在编译过程就能得到计算结果的表达式。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;constexpr&lt;/code&gt;变量：由编译器来验证变量的值是否是一个常量表达式，声明为&lt;code&gt;constexpr&lt;/code&gt;的变量一定是一个常量，并且必须用常量表达式初始化。&lt;/p&gt;
&lt;p&gt;字面值类型：算术类型、引用、指针、字面值常量类、枚举。&lt;/p&gt;
&lt;p&gt;声明&lt;code&gt;constexpr&lt;/code&gt;用到的类型为字面值类型。&lt;/p&gt;
&lt;p&gt;一个&lt;code&gt;constexpr&lt;/code&gt;指针的初始值必须是&lt;code&gt;nullptr&lt;/code&gt;或者0，或者是存储于某个固定地址中的对象：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函数体内定义的变量一般并非存放在固定地址中，&lt;code&gt;constexpr&lt;/code&gt;指针不能指向这样的变量（局部静态对象除外）&lt;/li&gt;
&lt;li&gt;定义于所有函数体之外的对象地址固定不变，能用来初始化&lt;code&gt;constexpr&lt;/code&gt;指针&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在&lt;code&gt;constexpr&lt;/code&gt;声明中如果定义了一个指针，限定符&lt;code&gt;constexpr&lt;/code&gt;仅对指针有效，与指针所指的对象无关。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;constexpr&lt;/code&gt;把它所定义的对象置为顶层&lt;code&gt;const&lt;/code&gt;。&lt;/p&gt;
&lt;h2&gt;处理类型&lt;/h2&gt;
&lt;h3&gt;类型别名&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;typedef double wages;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;using SI = Sales_item;&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;auto 类型说明符&lt;/h3&gt;
&lt;p&gt;让编译器自己去分析表达式所属的类型。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;auto&lt;/code&gt;也能在一条语句中声明多个变量。因为一条声明语句只能有一个基本数据类型，所以该语句中所有变量的基本数据类型都必须一样。&lt;/p&gt;
&lt;p&gt;当引用被用作初始化&lt;code&gt;auto&lt;/code&gt;变量时，编译器以引用所引用对象的类型作为&lt;code&gt;auto&lt;/code&gt;的类型。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;auto&lt;/code&gt;一般会忽略顶层&lt;code&gt;const&lt;/code&gt;，同时底层&lt;code&gt;const&lt;/code&gt;会保留下来。&lt;/p&gt;
&lt;p&gt;如果希望推断出的&lt;code&gt;auto&lt;/code&gt;类型是一个顶层&lt;code&gt;const&lt;/code&gt;，需要明确指出。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;auto&lt;/code&gt;引用&lt;code&gt;auto &amp;amp;b = a;&lt;/code&gt;初始值 a 的顶层&lt;code&gt;const&lt;/code&gt;会保留。&lt;/p&gt;
&lt;h3&gt;decltype 类型指示符&lt;/h3&gt;
&lt;p&gt;选择并返回操作数的数据类型，编译器分析表达式得到它的类型，却不实际计算表达式的值，编译器并不实际调用f。&lt;/p&gt;
&lt;p&gt;如果&lt;code&gt;decltype&lt;/code&gt;使用的表达式是一个变量，则&lt;code&gt;decltype&lt;/code&gt;返回该变量的类型（包括顶层&lt;code&gt;const&lt;/code&gt;和引用在内），需要指出的是，引用从来都作为其所指对象的同义词出现，只有在&lt;code&gt;decltype&lt;/code&gt;处是一个例外。&lt;/p&gt;
&lt;p&gt;如果&lt;code&gt;decltype&lt;/code&gt;使用的表达式不是一个变量，则&lt;code&gt;decltype&lt;/code&gt;返回该表达式的结果对应的类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因为 r 是一个引用，&lt;code&gt;decltype(r)&lt;/code&gt;的结果是引用类型，如果想让结果类型是 r 所指的类型，可以把 r 作为表达式的一部分，显然这个表达式的结果是一个具体的值而非一个引用&lt;/li&gt;
&lt;li&gt;如果表达式的内容是解引用操作，则&lt;code&gt;decltype&lt;/code&gt;将得到引用类型&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果&lt;code&gt;decltype&lt;/code&gt;使用的表达式是一个变量：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不加括号，得到该变量的类型&lt;/li&gt;
&lt;li&gt;加括号，得到引用类型&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;自定义数据结构：结构体和类&lt;/h2&gt;
&lt;p&gt;记得定义末尾的分号。可以类内初始化。&lt;/p&gt;
&lt;h2&gt;头文件保护符&lt;/h2&gt;
&lt;p&gt;头文件保护符依赖于预处理变量。&lt;/p&gt;
&lt;p&gt;预处理变量由两个状态：已定义和未定义。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;#define&lt;/code&gt;指令把一个名字设定为预处理变量。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;#ifdef&lt;/code&gt;当且仅当变量已定义时为真。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;#ifndef&lt;/code&gt;当且仅当变量未定义时为真。&lt;/p&gt;
&lt;p&gt;一旦检查结果为真，则执行后续操作直到遇到&lt;code&gt;#endif&lt;/code&gt;指令为止&lt;/p&gt;</content><category term="C++"></category></entry><entry><title>利用 Mac stat 添加文件创建时间、最后修改时间</title><link href="https://xutree.github.io/pages/2018/10/06/mac-stat/" rel="alternate"></link><published>2018-10-06T19:07:36+08:00</published><updated>2018-10-07T10:38:50+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-06:/pages/2018/10/06/mac-stat/</id><summary type="html">&lt;p&gt;Pelican 根据 &lt;strong&gt;.md&lt;/strong&gt; 文件生成网页的时候需要 metadata，所以写个命令行自动添加文件创建时间、最后修改时间，这样写博客的时候只需要把 title、category 和 tags 标签填上就行了，其中用了 &lt;code&gt;stat&lt;/code&gt;命令。&lt;/p&gt;
&lt;h2&gt;自动添加文件创建时间、最后修改时间&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;stat&lt;/code&gt;命令的 &lt;em&gt;a, m, c, B&lt;/em&gt; 参数分别代表上次访问或修改时间文件，上次更改 inode 的时间或 inode 的生成时间（ UNIX 时间戳），所以我们可以通过提取这些信息实现想要的功能。唯一需要注意的是，结果是UNIX时间戳，我们需要将其转换为普通时间。&lt;/p&gt;
&lt;p&gt;UNIX 时间，或称 POSIX 时间是 UNIX 或类 UNIX 系统使用的时间表示方式：从协调世界时1970年1月1日0时0分0秒起至现在的总秒数，不考虑闰秒。在多数 UNIX 系统上 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Pelican 根据 &lt;strong&gt;.md&lt;/strong&gt; 文件生成网页的时候需要 metadata，所以写个命令行自动添加文件创建时间、最后修改时间，这样写博客的时候只需要把 title、category 和 tags 标签填上就行了，其中用了 &lt;code&gt;stat&lt;/code&gt;命令。&lt;/p&gt;
&lt;h2&gt;自动添加文件创建时间、最后修改时间&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;stat&lt;/code&gt;命令的 &lt;em&gt;a, m, c, B&lt;/em&gt; 参数分别代表上次访问或修改时间文件，上次更改 inode 的时间或 inode 的生成时间（ UNIX 时间戳），所以我们可以通过提取这些信息实现想要的功能。唯一需要注意的是，结果是UNIX时间戳，我们需要将其转换为普通时间。&lt;/p&gt;
&lt;p&gt;UNIX 时间，或称 POSIX 时间是 UNIX 或类 UNIX 系统使用的时间表示方式：从协调世界时1970年1月1日0时0分0秒起至现在的总秒数，不考虑闰秒。在多数 UNIX 系统上 UNIX 时间可以通过&lt;code&gt;date +%s&lt;/code&gt;指令来检查。&lt;/p&gt;
&lt;p&gt;在 Mac 系统是由 UNIX 时间戳转化为普通时间的指令为：
&lt;img alt="UNIX 时间戳转化为普通时间" src="https://xutree.github.io/images/fig7.png"&gt;&lt;/p&gt;
&lt;p&gt;所以我们先根据&lt;code&gt;stat&lt;/code&gt;获得文件的创建时间：
&lt;img alt="根据stat获得文件的创建时间" src="https://xutree.github.io/images/fig8.png"&gt;&lt;/p&gt;
&lt;p&gt;然后转化为普通时间：
&lt;img alt="转化为普通时间" src="https://xutree.github.io/images/fig9.png"&gt;&lt;/p&gt;
&lt;p&gt;以下为脚本：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#! /bin/bash&lt;/span&gt;

&lt;span class="c1"&gt;# 输入：需要修改的文件&lt;/span&gt;
&lt;span class="nv"&gt;filename&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nv"&gt;$1&lt;/span&gt;

&lt;span class="c1"&gt;# 提取创建时间&lt;/span&gt;
&lt;span class="nv"&gt;create_time&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;date  -r&lt;span class="k"&gt;$(&lt;/span&gt;stat -f &lt;span class="s2"&gt;&amp;quot;%B&amp;quot;&lt;/span&gt; &lt;span class="nv"&gt;$filename&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;+%Y-%m-%d %H:%M:%S&amp;quot;&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;# 提取修改时间&lt;/span&gt;
&lt;span class="nv"&gt;modify_time&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;date  -r&lt;span class="k"&gt;$(&lt;/span&gt;stat -f &lt;span class="s2"&gt;&amp;quot;%m&amp;quot;&lt;/span&gt; &lt;span class="nv"&gt;$filename&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;+%Y-%m-%d %H:%M:%S&amp;quot;&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;# 查找Date标签的行号&lt;/span&gt;
&lt;span class="nv"&gt;num1&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;head -5 &lt;span class="nv"&gt;$filename&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; grep -n &lt;span class="s1"&gt;&amp;#39;Date&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; cut -d &lt;span class="s2"&gt;&amp;quot;:&amp;quot;&lt;/span&gt; -f &lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;# 查找Modified标签的行号&lt;/span&gt;
&lt;span class="nv"&gt;num2&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;head -5 &lt;span class="nv"&gt;$filename&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; grep -n &lt;span class="s1"&gt;&amp;#39;Modified&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt; cut -d &lt;span class="s2"&gt;&amp;quot;:&amp;quot;&lt;/span&gt; -f &lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;# 如果Date标签行号为空，说明不存在Date标签，则插入Date&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; -z &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$num1&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;then&lt;/span&gt;
    sed -i &lt;span class="s1"&gt;&amp;#39;&amp;#39;&lt;/span&gt; -e &lt;span class="s2"&gt;&amp;quot;2s/^//p; 2s/^.*/Date: &lt;/span&gt;&lt;span class="nv"&gt;$create_time&lt;/span&gt;&lt;span class="s2"&gt;/&amp;quot;&lt;/span&gt; &lt;span class="nv"&gt;$filename&lt;/span&gt;   
&lt;span class="k"&gt;fi&lt;/span&gt;
&lt;span class="c1"&gt;# 如果Modified标签行号为空，插入Modified&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; -z &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$num2&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;then&lt;/span&gt;
    sed -i &lt;span class="s1"&gt;&amp;#39;&amp;#39;&lt;/span&gt; -e &lt;span class="s2"&gt;&amp;quot;3s/^//p; 3s/^.*/Modified: &lt;/span&gt;&lt;span class="nv"&gt;$modify_time&lt;/span&gt;&lt;span class="s2"&gt;/&amp;quot;&lt;/span&gt; &lt;span class="nv"&gt;$filename&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;
    &lt;span class="c1"&gt;# 否则，替换Modified标签到最新时间&lt;/span&gt;
    sed -i &lt;span class="s1"&gt;&amp;#39;&amp;#39;&lt;/span&gt; &lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;num2&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;d &lt;span class="nv"&gt;$filename&lt;/span&gt;
    sed -i &lt;span class="s1"&gt;&amp;#39;&amp;#39;&lt;/span&gt; -e &lt;span class="s2"&gt;&amp;quot;3s/^//p; 3s/^.*/Modified: &lt;/span&gt;&lt;span class="nv"&gt;$modify_time&lt;/span&gt;&lt;span class="s2"&gt;/&amp;quot;&lt;/span&gt; &lt;span class="nv"&gt;$filename&lt;/span&gt;
&lt;span class="k"&gt;fi&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h2&gt;附：stat 命令详情&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;stat&lt;/code&gt;显示有关文件的信息。 不需要读取，写入或执行指定文件的权限，但必须可搜索通向该文件的路径名中列出的所有目录。 如果没有给出参数，&lt;code&gt;stat&lt;/code&gt;将显示有关标准输入的文件描述符（stdin）的信息。&lt;/p&gt;
&lt;p&gt;当作为&lt;code&gt;readlink&lt;/code&gt;调用时，仅打印符号链接的目标。 如果给定的参数不是符号链接，则&lt;code&gt;readlink&lt;/code&gt;将不打印任何内容并退出并显示错误。&lt;/p&gt;
&lt;p&gt;显示的信息是通过使用给定参数调用&lt;code&gt;lstat&lt;/code&gt;系统调用并解释返回的结构来获得的。&lt;/p&gt;
&lt;h3&gt;参数&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;-F&lt;/strong&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;与&lt;code&gt;ls&lt;/code&gt;命令的 &lt;strong&gt;-F&lt;/strong&gt; 参数一样，在作为目录的每个路径名之后显示斜杠（'/'），在每个可执行的路径名后面显示星号（'*'），在每个符号链接后显示at符号（'@'）， 在每个without文件后面显示百分号（'％'），每个套接字后显示等号（'='），以及在每个FIFO文件后面显示一个垂直条（'|'）。 &lt;strong&gt;-F&lt;/strong&gt; 的使用意味着 &lt;strong&gt;-l&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;-f&lt;/strong&gt; &lt;em&gt;format&lt;/em&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;使用指定的格式显示信息&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;-L&lt;/strong&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;使用&lt;code&gt;stat&lt;/code&gt;而不是&lt;code&gt;lstat&lt;/code&gt;。 如果文件是符号链接，则stat给出的信息是链接文件目标文件的信息，而不是链接文件本身&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;-l&lt;/strong&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;将输出以&lt;code&gt;ls -lT&lt;/code&gt;格式显示，即显示文件的完整时间信息，包括月，日，小时，分钟，秒和年&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;-n&lt;/strong&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;输出不强制换行&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;-q&lt;/strong&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;如果对&lt;code&gt;stat&lt;/code&gt;或&lt;code&gt;lstat&lt;/code&gt;的调用失败，则不显示失败消息。以&lt;code&gt;readlink&lt;/code&gt;方式运行时，会自动禁止错误消息&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;-r&lt;/strong&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;显示原始信息。即，对于stat结构（UNIX/Linux系统中定义的结构体）中的所有字段，显示原始数值（例如，自纪元以来的秒数等）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;-s&lt;/strong&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在“shell输出”中显示信息，适用于初始化变量&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;-t&lt;/strong&gt; &lt;em&gt;timefmt&lt;/em&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;使用指定的格式显示时间戳。 此格式直接传递给&lt;code&gt;strftime&lt;/code&gt;命令&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;-x&lt;/strong&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;从某些Linux发行版中以更详细的方式显示信息&lt;/p&gt;
&lt;h3&gt;格式&lt;/h3&gt;
&lt;p&gt;格式字符串类似于&lt;code&gt;printf&lt;/code&gt;格式，因为它们以 ％ 开头，然后是一系列格式化字符，最后是一个字符，用于选择要格式化的 struct stat 字段。 如果 ％ 后面紧跟 n，t，％ 或 @ 之一，则会打印换行符，制表符，百分号或当前文件号，否则将检查字符串是否包含以下内容：&lt;/p&gt;
&lt;p&gt;以下是任何可选标志：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;#&lt;/strong&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;为八进制和十六进制输出选择备用输出形式。 非零八进制输出将具有前导零，并且非零十六进制输出将具有前缀“0x”&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;+&lt;/strong&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;断言应始终打印指示数字是正数还是负数的符号。 非负数通常不打印带符号&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;-&lt;/strong&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;将字符串输出对齐到字段的左侧，而不是右侧&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;0&lt;/strong&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;将左边距的填充字符设置为“0”字符，而不是空格&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;space&lt;/strong&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在非负有符号输出字段的前面保留一个空格。 如果同时使用&lt;strong&gt;‘+’&lt;/strong&gt; ，则&lt;strong&gt;‘+’&lt;/strong&gt; 将覆盖空格&lt;/p&gt;
&lt;p&gt;以下是任何可选字段：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;size&lt;/em&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;可选的十进制数字字符串，指定最小字段宽度&lt;/p&gt;
&lt;p&gt;&lt;em&gt;prec&lt;/em&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;由小数点'.'和十进制数字字符串组成的可选精度，指示最大字符串长度，浮点输出中小数点后出现的位数，或数字输出中显示的最小位数&lt;/p&gt;
&lt;p&gt;&lt;em&gt;fmt&lt;/em&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;可选的输出格式说明符，它是D，O，U，X，F 或 S 之一。它们分别表示带符号的十进制输出，八进制输出，无符号十进制输出，十六进制输出，浮点输出和字符串输出。 某些输出格式不适用于所有字段。 浮点输出仅适用于 timespec 字段（a，m 和 c 字段）。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;特殊输出说明符S可用于指示输出（如果适用）应为字符串格式。 可与以下标志结合使用：&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;em&gt;amc&lt;/em&gt; 以&lt;code&gt;strftime&lt;/code&gt;格式显示日期&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;em&gt;dr&lt;/em&gt; 显示实际设备名称&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;em&gt;gu&lt;/em&gt; 显示组或用户名&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;em&gt;p&lt;/em&gt; 以&lt;code&gt;ls -lTd&lt;/code&gt;显示文件模式&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;em&gt;N&lt;/em&gt; 显示文件名&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;em&gt;T&lt;/em&gt; 显示文件类型&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;em&gt;Y&lt;/em&gt; 在输出中插入“ -&amp;gt; ”。 请注意，&lt;em&gt;Y&lt;/em&gt; 的默认输出格式是字符串，但如果明确指定，则会预先添加这四个字符&lt;/p&gt;
&lt;p&gt;&lt;em&gt;sub&lt;/em&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;可选的子字段说明符（高，中，低）。仅适用于 p，d，r 和 T 输出格式。 它可以是以下之一：&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;em&gt;H&lt;/em&gt; “高”，指定来自 r 或 d 的设备的主要编号，来自 p 的字符串形式的权限的“用户”位，来自 p 的数字形式的文件“type”位，以及 T 的长输出形式&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;em&gt;L&lt;/em&gt; “低”，指定来自 r 或 d 的设备的次要编号，来自 p 的字符串形式的权限的“其他”位，来自 p 的数字形式的“用户”，“组”和“其他”位， 当与 T 一起使用时，文件类型的&lt;code&gt;ls -F&lt;/code&gt;样式输出字符（对此使用 L 是可选的）&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;em&gt;M&lt;/em&gt; “中”，指定 p 的字符串输出形式的权限的“组”位，或 p 的数字形式的 “suid”，“sgid” 和 “sticky” 位&lt;/p&gt;
&lt;p&gt;&lt;em&gt;datum&lt;/em&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;必填字段说明符，是以下之一：&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;em&gt;d&lt;/em&gt; 文件所在的设备&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;em&gt;i&lt;/em&gt; 文件的inode编号&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;em&gt;p&lt;/em&gt; 文件类型和权限&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;em&gt;l&lt;/em&gt; 文件的硬链接数&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;em&gt;u, g&lt;/em&gt; 文件所有者的用户ID和组ID&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;em&gt;r&lt;/em&gt; 字符和块设备专用文件的设备编号&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;em&gt;a, m, c, B&lt;/em&gt; 上次访问或修改时间文件，上次更改 inode 的时间或 inode 的生成时间（UNIX时间戳）&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;em&gt;z&lt;/em&gt; 文件大小（以字节为单位）&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;em&gt;b&lt;/em&gt; 分配给文件的块数&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;em&gt;k&lt;/em&gt; 最佳文件系统I / O操作块大小&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;em&gt;f&lt;/em&gt; 用户定义的文件标志&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;em&gt;v&lt;/em&gt; Inode 生成号&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;以下四个字段说明符不是直接从struct stat中的数据中提取的，而是：&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;em&gt;N&lt;/em&gt; 文件的名称&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;em&gt;T&lt;/em&gt; 文件类型，类似&lt;code&gt;ls -F&lt;/code&gt;，如果给出子字段说明符H，则采用更具描述性的形式。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;em&gt;Y&lt;/em&gt; 符号链接的目标&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;em&gt;Z&lt;/em&gt; 从字符或块特殊设备的rdev字段扩展为“major，minor”，并为所有其他设备提供大小输出&lt;/p&gt;
&lt;p&gt;只有 ％ 和字段说明符是必需的。大多数字段说明符默认为 U 作为输出形式；p 默认输出形式是 O；a、m、c 默认输出形式是 D，Y、T、N 默认输出形式是 S。&lt;/p&gt;</content><category term="Mac"></category></entry><entry><title>C++ Primer 第一章 开始</title><link href="https://xutree.github.io/pages/2018/10/05/C++_Primer_Chapter_1/" rel="alternate"></link><published>2018-10-05T23:11:35+08:00</published><updated>2018-10-07T10:48:26+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-05:/pages/2018/10/05/C++_Primer_Chapter_1/</id><summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;code&gt;g++ -std=c++14  -Wall -o test test.cpp&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iostream&lt;/code&gt; &lt;code&gt;cin&lt;/code&gt; &lt;code&gt;cout&lt;/code&gt; &lt;code&gt;cerr&lt;/code&gt; &lt;code&gt;clog&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;运算符返回其左侧的运算对象&lt;/li&gt;
&lt;li&gt;写入&lt;code&gt;endl&lt;/code&gt;的效果是结束当前行，并将与设备关联的缓冲区中的内容刷到设备中。缓冲刷新操作可以保证到目前为止程序所产生的所有输出都真正写入到输出流中，而不是仅停留在内存中等待写入流&lt;/li&gt;
&lt;li&gt;小心程序崩溃，输出可能还留在缓冲区的情况，利用&lt;code&gt;endl&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;标准库定义的所有名字都在命名空间&lt;code&gt;std&lt;/code&gt;中&lt;/li&gt;
&lt;li&gt;当我们使用一个&lt;code&gt;istream&lt;/code&gt;对象作为条件时，其效果是检测流的状态。流有效，即流未遇到错误，那么检测成功。当遇到文件结束符（end of file），或遇到一个无效输入时，&lt;code&gt;istream&lt;/code&gt;对象的状态会变为无效。无效的&lt;code&gt;istream&lt;/code&gt;对象会使条件为假&lt;/li&gt;
&lt;li&gt;文件结束符：Windows 先Ctrl + Z，后Enter …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;ul&gt;
&lt;li&gt;&lt;code&gt;g++ -std=c++14  -Wall -o test test.cpp&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iostream&lt;/code&gt; &lt;code&gt;cin&lt;/code&gt; &lt;code&gt;cout&lt;/code&gt; &lt;code&gt;cerr&lt;/code&gt; &lt;code&gt;clog&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;运算符返回其左侧的运算对象&lt;/li&gt;
&lt;li&gt;写入&lt;code&gt;endl&lt;/code&gt;的效果是结束当前行，并将与设备关联的缓冲区中的内容刷到设备中。缓冲刷新操作可以保证到目前为止程序所产生的所有输出都真正写入到输出流中，而不是仅停留在内存中等待写入流&lt;/li&gt;
&lt;li&gt;小心程序崩溃，输出可能还留在缓冲区的情况，利用&lt;code&gt;endl&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;标准库定义的所有名字都在命名空间&lt;code&gt;std&lt;/code&gt;中&lt;/li&gt;
&lt;li&gt;当我们使用一个&lt;code&gt;istream&lt;/code&gt;对象作为条件时，其效果是检测流的状态。流有效，即流未遇到错误，那么检测成功。当遇到文件结束符（end of file），或遇到一个无效输入时，&lt;code&gt;istream&lt;/code&gt;对象的状态会变为无效。无效的&lt;code&gt;istream&lt;/code&gt;对象会使条件为假&lt;/li&gt;
&lt;li&gt;文件结束符：Windows 先Ctrl + Z，后Enter 或 Return；UNIX：Ctrl +D&lt;/li&gt;
&lt;li&gt;标准库文件通常不带后缀。编译器一般不关心头文件名的形式，但有的IDE对此有特定要求&lt;/li&gt;
&lt;li&gt;头文件包含：标准库头文件 &amp;lt;&amp;gt;     非标准库头文件 ""&lt;/li&gt;
&lt;li&gt;文件重定向：从文件读入\&amp;lt;infile，输出到文件&gt;outfile&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cerr&lt;/code&gt;(无缓冲标准错误) 没有缓冲，发送给它的内容立即被输出&lt;/li&gt;
&lt;li&gt;&lt;code&gt;clog&lt;/code&gt;(缓冲标准错误)  有缓冲，缓冲区满时输出&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cout&lt;/code&gt;标准输出&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cout&lt;/code&gt;是在终端显示器输出，&lt;code&gt;cout&lt;/code&gt;流在内存中对应开辟了一个缓冲区，用来存放流中的数据，当向&lt;code&gt;cout&lt;/code&gt;流插入一个&lt;code&gt;endl&lt;/code&gt;，不论缓冲区是否满了，都立即输出流中所有数据，然后插入一个换行符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cerr&lt;/code&gt;流对象是标准错误流，指定为和显示器关联，和&lt;code&gt;cout&lt;/code&gt;作用差不多，有点不同就是&lt;code&gt;cout&lt;/code&gt;通常是传到显示器输出，但可以被重定向输出到文件，而&lt;code&gt;cerr&lt;/code&gt;流中的信息只能在显示器输出&lt;/li&gt;
&lt;li&gt;&lt;code&gt;clog&lt;/code&gt;流也是标准错误流，作用和&lt;code&gt;cerr&lt;/code&gt;一样，区别在于&lt;code&gt;cerr&lt;/code&gt;不经过缓冲区，直接向显示器输出信息，而&lt;code&gt;clog&lt;/code&gt;中的信息存放在缓冲区，缓冲区满或者遇到&lt;code&gt;endl&lt;/code&gt;时才输出&lt;/li&gt;
&lt;li&gt;对于为什么有&lt;code&gt;cerr&lt;/code&gt;和&lt;code&gt;clog&lt;/code&gt;？比如，你的程序遇到调用栈用完了的威胁（无限，没有出口的递归。你说，你到什么地方借内存，存放你的错误信息？所以有了&lt;code&gt;cerr&lt;/code&gt;。其目的，就是在你最需要它的紧急情况下，还能得到输出功能的支持&lt;/li&gt;
&lt;li&gt;缓冲区的目的，就是减少刷屏的次数——比如，你的程序输出圣经中的一篇文章。不带缓冲的话，就会每写一个字母，就输出一个字母，然后刷屏。有了缓冲，你将看到若干句子“同时”就出现在了屏幕上（由内存翻新到显存，然后刷新屏幕）&lt;/li&gt;
&lt;/ul&gt;</content><category term="C++"></category></entry><entry><title>HTML 入门</title><link href="https://xutree.github.io/pages/2018/10/05/html-overview/" rel="alternate"></link><published>2018-10-05T17:23:00+08:00</published><updated>2018-10-06T21:20:21+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-05:/pages/2018/10/05/html-overview/</id><summary type="html">&lt;p&gt;&lt;strong&gt;HTML&lt;/strong&gt;，即超文本标记语言（&lt;strong&gt;H&lt;/strong&gt;yper&lt;strong&gt;T&lt;/strong&gt;ext &lt;strong&gt;M&lt;/strong&gt;arkup &lt;strong&gt;L&lt;/strong&gt;anguage）。与脚本或编程语言不同，标记语言使用标记（&lt;strong&gt;tag&lt;/strong&gt;）来标识内容。&lt;/p&gt;
&lt;p&gt;下面是一个 HTML tag 的例子：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;p&amp;gt; 这是一个段落。&amp;lt;/p&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt;称为开始标签，&lt;code&gt;&amp;lt;/p&amp;gt;&lt;/code&gt;称为结束标签。&lt;/p&gt;
&lt;h2&gt;网页的结构&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;HTML：结构&lt;/li&gt;
&lt;li&gt;CSS：样式&lt;/li&gt;
&lt;li&gt;JavaScript：行为&lt;/li&gt;
&lt;li&gt;PHP 或类似语言：后端&lt;/li&gt;
&lt;li&gt;CMS：内容管理&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;基本 HTML 文件结构&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;标签&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;html&amp;gt;&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;HTML文件的所有内容都包含在其中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;head&amp;gt;&amp;lt;/head&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;HTML文件的头部包含有助于使页面工作的所有非可视元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;body&amp;gt;&amp;lt;/body …&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</summary><content type="html">&lt;p&gt;&lt;strong&gt;HTML&lt;/strong&gt;，即超文本标记语言（&lt;strong&gt;H&lt;/strong&gt;yper&lt;strong&gt;T&lt;/strong&gt;ext &lt;strong&gt;M&lt;/strong&gt;arkup &lt;strong&gt;L&lt;/strong&gt;anguage）。与脚本或编程语言不同，标记语言使用标记（&lt;strong&gt;tag&lt;/strong&gt;）来标识内容。&lt;/p&gt;
&lt;p&gt;下面是一个 HTML tag 的例子：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;p&amp;gt; 这是一个段落。&amp;lt;/p&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt;称为开始标签，&lt;code&gt;&amp;lt;/p&amp;gt;&lt;/code&gt;称为结束标签。&lt;/p&gt;
&lt;h2&gt;网页的结构&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;HTML：结构&lt;/li&gt;
&lt;li&gt;CSS：样式&lt;/li&gt;
&lt;li&gt;JavaScript：行为&lt;/li&gt;
&lt;li&gt;PHP 或类似语言：后端&lt;/li&gt;
&lt;li&gt;CMS：内容管理&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;基本 HTML 文件结构&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;标签&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;html&amp;gt;&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;HTML文件的所有内容都包含在其中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;head&amp;gt;&amp;lt;/head&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;HTML文件的头部包含有助于使页面工作的所有非可视元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;body&amp;gt;&amp;lt;/body&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;所有可视化元素都包含在body标签中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;包含网页选项卡上现实的标题内容&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;下面是 HTML 版本的“Hello, World！”程序：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
      Hello World!
   &lt;span class="nt"&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;字体标签&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;标签&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;p&amp;gt;&amp;lt;/p&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;段落标签（浏览器会在段落前后自动添加空行）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;br /&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;换行而不开启新段落（它没有结束标记）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;b&amp;gt;&amp;lt;/b&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;粗体&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;big&amp;gt;&amp;lt;/big&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;大号文本&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;i&amp;gt;&amp;lt;/i&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;斜体&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;small&amp;gt;&amp;lt;/small&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;小号文本&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;strong&amp;gt;&amp;lt;/strong&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;强调（一种phrase tag）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;sub&amp;gt;&amp;lt;/sub&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;下标&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;sup&amp;gt;&amp;lt;/sup&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;上标&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;ins&amp;gt;&amp;lt;/ins&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;插入线&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;del&amp;gt;&amp;lt;/del&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;删除线&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;浏览器将&lt;code&gt;&amp;lt;strong&amp;gt;&lt;/code&gt;显示为&lt;code&gt;&amp;lt;b&amp;gt;&lt;/code&gt;，将&lt;code&gt;&amp;lt;em&amp;gt;&lt;/code&gt;显示为&lt;code&gt;&amp;lt;i&amp;gt;&lt;/code&gt;。但是，这些标记的含义不同：&lt;code&gt;&amp;lt;b&amp;gt;&lt;/code&gt;和&lt;code&gt;&amp;lt;i&amp;gt;&lt;/code&gt;分别定义粗体和斜体文本，而&lt;code&gt;&amp;lt;strong&amp;gt;&lt;/code&gt;和&lt;code&gt;&amp;lt;em&amp;gt;&lt;/code&gt;表示文本“重要”。&lt;/p&gt;
&lt;h2&gt;标题标签&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;h1&amp;gt;&amp;lt;/h1&amp;gt;&lt;/code&gt;，&lt;code&gt;&amp;lt;h2&amp;gt;&amp;lt;/h2&amp;gt;&lt;/code&gt;，&lt;code&gt;&amp;lt;h3&amp;gt;&amp;lt;/h3&amp;gt;&lt;/code&gt;，&lt;code&gt;&amp;lt;h4&amp;gt;&amp;lt;/h4&amp;gt;&lt;/code&gt;，&lt;code&gt;&amp;lt;h5&amp;gt;&amp;lt;/h5&amp;gt;&lt;/code&gt;，&lt;code&gt;&amp;lt;h6&amp;gt;&amp;lt;/h6&amp;gt;&lt;/code&gt;六种标题，&lt;code&gt;&amp;lt;h1&amp;gt;&amp;lt;/h1&amp;gt;&lt;/code&gt;字号最大。&lt;/p&gt;
&lt;h2&gt;标签属性&lt;/h2&gt;
&lt;p&gt;属性提供有关元素或标记的附加信息，同时还可以修改它们。例如&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;p&lt;/span&gt; &lt;span class="na"&gt;align=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;center&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
   This text is aligned to center
&lt;span class="nt"&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;会将段落居中显示（&lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt;标签的align属性在HTML5中不再支持）。&lt;/p&gt;
&lt;p&gt;属性的数值可以通过像素或百分比指定，如&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;hr width=&amp;quot;50px&amp;quot; /&amp;gt;
&amp;lt;hr width=&amp;quot;50%&amp;quot; /&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;图像标签&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;img src="" height="" width="" border="" alt=""/&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;src：图像名称&lt;/p&gt;
&lt;p&gt;height：图像高&lt;/p&gt;
&lt;p&gt;width：图像宽&lt;/p&gt;
&lt;p&gt;border：边界宽度&lt;/p&gt;
&lt;p&gt;alt：如果无法显示图像，则alt属性指定以单词形式描述图像的替代文本&lt;/p&gt;
&lt;h2&gt;链接标签&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;a href="" target=""&amp;gt;&amp;lt;/a&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;href：目标网址&lt;/p&gt;
&lt;p&gt;target：指定打开链接文档的位置，_blank值将在新窗口或新标签中打开链接&lt;/p&gt;
&lt;h2&gt;列表标签&lt;/h2&gt;
&lt;h3&gt;有序列表&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;title&amp;gt;&lt;/span&gt;first page&lt;span class="nt"&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;ol&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;li&amp;gt;&lt;/span&gt;Red&lt;span class="nt"&gt;&amp;lt;/li&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;li&amp;gt;&lt;/span&gt;Blue&lt;span class="nt"&gt;&amp;lt;/li&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;li&amp;gt;&lt;/span&gt;Green&lt;span class="nt"&gt;&amp;lt;/li&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;/ol&amp;gt;&lt;/span&gt;  
   &lt;span class="nt"&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;无序列表&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;title&amp;gt;&lt;/span&gt;first page&lt;span class="nt"&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;        
   &lt;span class="nt"&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;ul&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;li&amp;gt;&lt;/span&gt;Red&lt;span class="nt"&gt;&amp;lt;/li&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;li&amp;gt;&lt;/span&gt;Blue&lt;span class="nt"&gt;&amp;lt;/li&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;li&amp;gt;&lt;/span&gt;Green&lt;span class="nt"&gt;&amp;lt;/li&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;/ul&amp;gt;&lt;/span&gt;  
   &lt;span class="nt"&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;表格标签&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;table&lt;/span&gt;  &lt;span class="na"&gt;border=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;align=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;tr&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;td&lt;/span&gt; &lt;span class="na"&gt;bgcolor=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;red&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;Red&lt;span class="nt"&gt;&amp;lt;/td&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;td&amp;gt;&lt;/span&gt;Blue&lt;span class="nt"&gt;&amp;lt;/td&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;td&amp;gt;&lt;/span&gt;Green&lt;span class="nt"&gt;&amp;lt;/td&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;tr&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;td&amp;gt;&lt;/span&gt;Yellow&lt;span class="nt"&gt;&amp;lt;/td&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;td&lt;/span&gt; &lt;span class="na"&gt;colspan=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;2&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;Orange&lt;span class="nt"&gt;&amp;lt;/td&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/table&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;其他&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;标签&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;hr /&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;水平线&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;!--...--&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;注释&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;HTML 元素类型&lt;/h2&gt;
&lt;p&gt;在 HTML 中，大多数元素被定义为块级或内联元素。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;块级元素从新行开始，如&lt;code&gt;&amp;lt;h1&amp;gt;, &amp;lt;form&amp;gt;, &amp;lt;li&amp;gt;, &amp;lt;ol&amp;gt;, &amp;lt;ul&amp;gt;, &amp;lt;p&amp;gt;, &amp;lt;pre&amp;gt;, &amp;lt;table&amp;gt;, &amp;lt;div&amp;gt;&lt;/code&gt;等&lt;/li&gt;
&lt;li&gt;内联元素通常显示没有换行符，如&lt;code&gt;&amp;lt;b&amp;gt;, &amp;lt;a&amp;gt;, &amp;lt;strong&amp;gt;, &amp;lt;img&amp;gt;, &amp;lt;input&amp;gt;, &amp;lt;em&amp;gt;, &amp;lt;span&amp;gt;&lt;/code&gt;等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;元素是一个块级元素，通常用作其他 HTML 元素的容器。与一些 CSS 样式一起使用时，&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;元素可用于设置内容块的样式。&lt;/p&gt;
&lt;p&gt;同样，&lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;元素是一个内联元素，通常用作某些文本的容器。与 CSS 一起使用时，&lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;元素可用于设置文本的部分样式。&lt;/p&gt;
&lt;p&gt;其他元素可以用作块级元素或内联元素。 这包括以下这些：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;APPLET - 嵌入式 Java 小程序&lt;/li&gt;
&lt;li&gt;IFRAME - 内联框架&lt;/li&gt;
&lt;li&gt;INS - 插入文本&lt;/li&gt;
&lt;li&gt;MAP - 图像映射&lt;/li&gt;
&lt;li&gt;OBJECT - 嵌入对象&lt;/li&gt;
&lt;li&gt;SCRIPT - HTML 文档中的脚本&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你可以在块元素内插入内联元素。 例如，可以在&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;元素中包含多个&lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;元素。反之不行。&lt;/p&gt;
&lt;h2&gt;表单标签&lt;/h2&gt;
&lt;p&gt;HTML 表单用于从用户收集信息。使用&lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt;元素及其开始和结束标记定义表单，使用 action 属性指向将在用户提交表单后加载的网页：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;form&lt;/span&gt; &lt;span class="na"&gt;action=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;method=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;…&lt;span class="nt"&gt;&amp;lt;/form&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;method 属性指定在提交表单时使用的 HTTP 方法（GET 或 POST）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 GET 时，表单数据将显示在页面地址中&lt;/li&gt;
&lt;li&gt;如果表单正在更新数据，请使用 POST，或者包含敏感信息（密码）。POST 提供了更好的安全性，因为提交的数据在页面地址中不可见&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;要接受用户输入，需要相应的表单元素，例如文本字段。 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;元素有许多变体，具体取决于 type 属性。 它可以是文本，密码，广播，URL，提交等。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;form&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;input&lt;/span&gt; &lt;span class="na"&gt;type=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;text&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;username&amp;quot;&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&amp;lt;br&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;input&lt;/span&gt; &lt;span class="na"&gt;type=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;password&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;password&amp;quot;&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/form&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;标签&lt;/h1&gt;
&lt;p&gt;可以使用特殊帧文档将页面划分为帧。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;标签定义&lt;code&gt;&amp;lt;frameset&amp;gt;&lt;/code&gt;中的一个特定窗口（框架）。&lt;code&gt;&amp;lt;frameset&amp;gt;&lt;/code&gt;中的每个&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;可以具有不同的属性，例如边框，滚动，调整大小的能力等。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;frameset&amp;gt;&lt;/code&gt;元素指定框架集中的列数或行数，以及每个框架占空间像素的百分比或数量。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;frameset&lt;/span&gt; &lt;span class="na"&gt;cols=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;25%,50%,25%&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;frame&lt;/span&gt; &lt;span class="na"&gt;src=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;a.htm&amp;quot;&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;frame&lt;/span&gt; &lt;span class="na"&gt;src=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;b.htm&amp;quot;&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;frame&lt;/span&gt; &lt;span class="na"&gt;src=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;c.htm&amp;quot;&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;noframes&amp;gt;&lt;/span&gt;Frames not supported!&lt;span class="nt"&gt;&amp;lt;/noframes&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/frameset&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;使用&lt;code&gt;&amp;lt;noresize&amp;gt;&lt;/code&gt;属性指定用户无法调整&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;元素的大小：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;frame noresize="noresize"&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;HTML5 中不支持&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;标签。&lt;/p&gt;
&lt;h2&gt;颜色&lt;/h2&gt;
&lt;h3&gt;颜色值&lt;/h3&gt;
&lt;p&gt;HTML 颜色表示为十六进制值，0~F。零表示最低值，F表示最高值。&lt;/p&gt;
&lt;h3&gt;颜色模式&lt;/h3&gt;
&lt;p&gt;颜色以红色，绿色和蓝色光（RGB）的组合显示。&lt;/p&gt;
&lt;p&gt;十六进制值使用＃标签符号，后跟六个十六进制字符。所有浏览器都支持 RGB 颜色值。&lt;/p&gt;</content><category term="HTML"></category></entry><entry><title>X3DOM 图像和视频纹理</title><link href="https://xutree.github.io/pages/2018/10/05/X3DOM%E5%9B%BE%E5%83%8F%E5%92%8C%E8%A7%86%E9%A2%91%E7%BA%B9%E7%90%86/" rel="alternate"></link><published>2018-10-05T17:14:00+08:00</published><updated>2018-10-06T21:02:53+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-05:/pages/2018/10/05/X3DOM图像和视频纹理/</id><summary type="html">&lt;p&gt;本章你将知道哪些图像类型和视频格式可以用作 X3DOM 的纹理，以及纹理的特性和限制。&lt;/p&gt;
&lt;p&gt;你可以使用 &lt;a href="http://en.wikipedia.org/wiki/Portable_Network_Graphics"&gt;&lt;em&gt;PNG&lt;/em&gt;&lt;/a&gt;，&lt;a href="http://en.wikipedia.org/wiki/Jpeg"&gt;&lt;em&gt;LPEG&lt;/em&gt;&lt;/a&gt; 或者 &lt;a href="https://en.wikipedia.org/wiki/Gif"&gt;&lt;em&gt;GIF&lt;/em&gt;&lt;/a&gt; 来编码你的静态纹理数据。&lt;em&gt;JPG&lt;/em&gt; 图像需要的内存少但是存在压缩损失而且没有 &lt;em&gt;alpha&lt;/em&gt; 通道。&lt;em&gt;PNG&lt;/em&gt; 图像属于无损压缩并且有 &lt;em&gt;alpha&lt;/em&gt; 通道，&lt;em&gt;GIF&lt;/em&gt; 也是无损压缩并且有 &lt;em&gt;alpha&lt;/em&gt; 通道。一般来讲：如果你不需要 &lt;em&gt;alpha&lt;/em&gt; 通道并且图像中不包含硬边界(例如：文本)，使用 &lt;em&gt;JPG&lt;/em&gt;，否则使用 &lt;em&gt;PNG&lt;/em&gt;。你应该避免使用 &lt;em&gt;GIF&lt;/em&gt;。&lt;/p&gt;
&lt;h2&gt;图像&lt;/h2&gt;
&lt;p&gt;利用 &lt;em&gt;ImageTexture&lt;/em&gt; 节点把图像作为纹理：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;x3d&lt;/span&gt; &lt;span class="na"&gt;width=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;500px&amp;#39;&lt;/span&gt; &lt;span class="na"&gt;height=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;400px&amp;#39;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;scene&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;shape&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;appearance&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;ImageTexture&lt;/span&gt; &lt;span class="na"&gt;url=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;myTexture.png …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;本章你将知道哪些图像类型和视频格式可以用作 X3DOM 的纹理，以及纹理的特性和限制。&lt;/p&gt;
&lt;p&gt;你可以使用 &lt;a href="http://en.wikipedia.org/wiki/Portable_Network_Graphics"&gt;&lt;em&gt;PNG&lt;/em&gt;&lt;/a&gt;，&lt;a href="http://en.wikipedia.org/wiki/Jpeg"&gt;&lt;em&gt;LPEG&lt;/em&gt;&lt;/a&gt; 或者 &lt;a href="https://en.wikipedia.org/wiki/Gif"&gt;&lt;em&gt;GIF&lt;/em&gt;&lt;/a&gt; 来编码你的静态纹理数据。&lt;em&gt;JPG&lt;/em&gt; 图像需要的内存少但是存在压缩损失而且没有 &lt;em&gt;alpha&lt;/em&gt; 通道。&lt;em&gt;PNG&lt;/em&gt; 图像属于无损压缩并且有 &lt;em&gt;alpha&lt;/em&gt; 通道，&lt;em&gt;GIF&lt;/em&gt; 也是无损压缩并且有 &lt;em&gt;alpha&lt;/em&gt; 通道。一般来讲：如果你不需要 &lt;em&gt;alpha&lt;/em&gt; 通道并且图像中不包含硬边界(例如：文本)，使用 &lt;em&gt;JPG&lt;/em&gt;，否则使用 &lt;em&gt;PNG&lt;/em&gt;。你应该避免使用 &lt;em&gt;GIF&lt;/em&gt;。&lt;/p&gt;
&lt;h2&gt;图像&lt;/h2&gt;
&lt;p&gt;利用 &lt;em&gt;ImageTexture&lt;/em&gt; 节点把图像作为纹理：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;x3d&lt;/span&gt; &lt;span class="na"&gt;width=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;500px&amp;#39;&lt;/span&gt; &lt;span class="na"&gt;height=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;400px&amp;#39;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;scene&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;shape&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;appearance&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;ImageTexture&lt;/span&gt; &lt;span class="na"&gt;url=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;myTexture.png&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&amp;lt;ImageTexture/&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/appearance&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;box&amp;gt;&lt;/span&gt; &lt;span class="nt"&gt;&amp;lt;/box&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/shape&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/scene&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/x3d&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;视频&lt;/h2&gt;
&lt;p&gt;利用 &lt;em&gt;MovieTexture&lt;/em&gt; 节点可以把视频作为纹理。但是目前还没有哪一种视频格式支持所有的用户。可以使用 X3DOM 格式&lt;a href="https://x3dom.org/x3dom/example/x3dom_video.xhtml"&gt;示例&lt;/a&gt;来确定你的浏览器支持的格式。目前最好的解决方法是将你的视频编码成 &lt;em&gt;MP4&lt;/em&gt; 和 &lt;em&gt;OGV&lt;/em&gt; 格式并在 &lt;em&gt;MovieTexture&lt;/em&gt; 节点中提供这两个选项：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;x3d&lt;/span&gt; &lt;span class="na"&gt;width=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;500px&amp;#39;&lt;/span&gt; &lt;span class="na"&gt;height=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;400px&amp;#39;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;scene&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;shape&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;appearance&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;MovieTexture&lt;/span&gt; &lt;span class="na"&gt;url=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;”foo.mp4″,”foo.ogv”&amp;#39;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&amp;lt;MovieTexture/&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/appearance&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;box&amp;gt;&lt;/span&gt; &lt;span class="nt"&gt;&amp;lt;/box&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/shape&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/scene&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/x3d&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</content><category term="X3DOM"></category></entry><entry><title>X3DOM，HTML，CSS 和 JavaScript</title><link href="https://xutree.github.io/pages/2018/10/05/X3DOMHTMLCSS%E5%92%8CJavaScript/" rel="alternate"></link><published>2018-10-05T11:22:00+08:00</published><updated>2018-10-06T21:02:31+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-05:/pages/2018/10/05/X3DOMHTMLCSS和JavaScript/</id><summary type="html">&lt;p&gt;本节，你将学习关于 X3DOM, HTML 和 CSS的更多知识，以及怎么利用 HTML 和 CSS 技术构建出强大的 3D 应用。在本节最后，你讲学习怎么在你的应用中使用 JavaScript。我们将继续使用前一节的例子。拷贝 HelloX3DOM.html 文件并重命名为 HTMLEventsCSS.html。&lt;/p&gt;
&lt;h2&gt;X3DOM 和 CSS&lt;/h2&gt;
&lt;p&gt;我们首先来看下怎么通过 CSS 操控 X3DOM 元素。你可能已经注意到，在 HelloX3DOM.html 中，3D 内容位于一个被黑色边界包围的白色区域中。X3DOM 有一个单独的 css 文件，自从版本1.3以后，名字一直为 x3dom.css，在这个文件中可以找到关于 X3DOM 元素的所有 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;本节，你将学习关于 X3DOM, HTML 和 CSS的更多知识，以及怎么利用 HTML 和 CSS 技术构建出强大的 3D 应用。在本节最后，你讲学习怎么在你的应用中使用 JavaScript。我们将继续使用前一节的例子。拷贝 HelloX3DOM.html 文件并重命名为 HTMLEventsCSS.html。&lt;/p&gt;
&lt;h2&gt;X3DOM 和 CSS&lt;/h2&gt;
&lt;p&gt;我们首先来看下怎么通过 CSS 操控 X3DOM 元素。你可能已经注意到，在 HelloX3DOM.html 中，3D 内容位于一个被黑色边界包围的白色区域中。X3DOM 有一个单独的 css 文件，自从版本1.3以后，名字一直为 x3dom.css，在这个文件中可以找到关于 X3DOM 元素的所有 css 定义以及 debug 信息。假设你的页面使用灰色和橙色作为主要颜色。你可以通过许多方式改变 X3DOM 默认的 CSS 属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 x3dom.css 后包含你自己的 CSS 文件(External Style Sheet)&lt;/li&gt;
&lt;li&gt;在 x3dom.css 之后，利用 &lt;em&gt;style&lt;/em&gt; 标签定制 css(Internal
Style Sheet)&lt;/li&gt;
&lt;li&gt;直接操纵相关元素的 &lt;em&gt;style&lt;/em&gt; 属性(Inline Styles)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关于 CSS 有很多网上教程，例如&lt;a href="http://www.w3schools.com/css/css_howto.asp"&gt;这里&lt;/a&gt;。我们现在利用第二种方法改变 css，通常不推荐第三种方法。为了定制 x3d 代表的 X3DOM 边界，在你的 HTML 文件头部 x3dom.css 之后插入 &lt;em&gt;style&lt;/em&gt; 标签：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;title&amp;gt;&lt;/span&gt;My first X3DOM page&lt;span class="nt"&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;script&lt;/span&gt; &lt;span class="na"&gt;type=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;text/javascript&amp;#39;&lt;/span&gt; &lt;span class="na"&gt;src=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;http://www.x3dom.org/download/x3dom.js&amp;#39;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nt"&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;link&lt;/span&gt; &lt;span class="na"&gt;rel=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;stylesheet&amp;#39;&lt;/span&gt; &lt;span class="na"&gt;type=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;text/css&amp;#39;&lt;/span&gt; &lt;span class="na"&gt;href=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;http://www.x3dom.org/download/x3dom.css&amp;#39;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&amp;lt;/link&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;style&amp;gt;&lt;/span&gt;
        x3d
        {
            border:2px solid darkorange;
        }
    &lt;span class="nt"&gt;&amp;lt;/style&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;h1&amp;gt;&lt;/span&gt;Hello, X3DOM!&lt;span class="nt"&gt;&amp;lt;/h1&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;p&amp;gt;&lt;/span&gt;
    This is my first html page with some 3d objects.
    &lt;span class="nt"&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;x3d&lt;/span&gt; &lt;span class="na"&gt;width=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;600px&amp;#39;&lt;/span&gt; &lt;span class="na"&gt;height=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;400px&amp;#39;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
    ...
    &lt;span class="nt"&gt;&amp;lt;/x3d&amp;gt;&lt;/span&gt;

&lt;span class="nt"&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;现在，X3DOM 的边界颜色已经改变了。假设你的网页已经有了橙色和灰色风格，使用 &lt;em&gt;pattern.png&lt;/em&gt; 作为背景(背景图片在&lt;a href="https://doc.x3dom.org/tutorials/basics/htmlCSS/pattern.png"&gt;这里&lt;/a&gt;)。那么完整的 &lt;em&gt;style sheet&lt;/em&gt; 如下所示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;x3d&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;border&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="kt"&gt;px&lt;/span&gt; &lt;span class="kc"&gt;solid&lt;/span&gt; &lt;span class="kc"&gt;darkorange&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="nt"&gt;body&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;font-size&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;110&lt;/span&gt;&lt;span class="kt"&gt;%&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;font-family&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;verdana&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kc"&gt;sans-serif&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;background-image&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;url&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;pattern.png&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;margin&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="kt"&gt;em&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;color&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="kc"&gt;lightgray&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="nt"&gt;h1&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;color&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="kc"&gt;darkorange&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;现在你的网页看起来如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="图1  默认情况下，X3DOM使用与网页相同的背景" src="https://xutree.github.io/images/fig5.png"&gt;&lt;/p&gt;
&lt;p&gt;从图中可以看出，X3DOM 使用与网页相同的背景。这是一个很重要的行为：你的 X3DOM &lt;em&gt;scene&lt;/em&gt; 是在 HTML 之上进行渲染的。让我们设置 &lt;em&gt;x3d&lt;/em&gt; 元素为半透明背景：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;x3d&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;border&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="kt"&gt;px&lt;/span&gt; &lt;span class="kc"&gt;solid&lt;/span&gt; &lt;span class="kc"&gt;darkorange&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;background&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;rgba&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;128&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;128&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;128&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;0.4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;现在结果看起来如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="图2  具有半透明背景的X3DOM" src="https://xutree.github.io/images/fig6.png"&gt;&lt;/p&gt;
&lt;h2&gt;X3DOM, HTML 事件和 JavaScript&lt;/h2&gt;
&lt;p&gt;使用 HTML 和 JavaScript，你可以使用大量有用的回调函数来操纵大多数 DOM 元素。X3DOM 为 &lt;em&gt;node&lt;/em&gt; 提供了相似的函数。例如，当我们点击红色立方体的时候，可以弹出一个文本信息，在 &lt;em&gt;shape&lt;/em&gt; 里插入一个 &lt;em&gt;onclick&lt;/em&gt; 函数就可以实现这个功能：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;shape&lt;/span&gt; &lt;span class="na"&gt;onclick=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;alert(&amp;#39;Hello, click!&amp;#39;);&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;appearance&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;material&lt;/span&gt; &lt;span class="na"&gt;diffuseColor=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;1 0 0&amp;#39;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&amp;lt;/material&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/appearance&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;box&amp;gt;&amp;lt;/box&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/shape&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;目前，你可以对 X3DOM 使用 &lt;em&gt;onmousemove&lt;/em&gt;，&lt;em&gt;onmousedown&lt;/em&gt;， &lt;em&gt;onmouseup&lt;/em&gt;，&lt;em&gt;onmouseover&lt;/em&gt; 和 &lt;em&gt;onmouseout&lt;/em&gt; 事件。你不仅可以在 &lt;em&gt;shape&lt;/em&gt; 节点插入事件，也可以在组节点，例如 &lt;em&gt;transform&lt;/em&gt; 插入事件。这样你就可以使用一个回调函数捕捉多个节点的事件。&lt;/p&gt;
&lt;p&gt;你可以在每个 DOM 元素上使用 JavaScript，所以你可以随心所欲的操纵 &lt;em&gt;node&lt;/em&gt;。你已经知道怎么使用 &lt;em&gt;onclick&lt;/em&gt; 事件，让我们尝试当点击时，改变立方体的颜色。如果你从没使用过 JavaScript，这个&lt;a href="http://www.w3schools.com/js/default.asp"&gt;网站&lt;/a&gt;或许可以帮助你。&lt;/p&gt;
&lt;p&gt;首先，给你想操纵的节点一个 &lt;em&gt;id&lt;/em&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;shape&lt;/span&gt; &lt;span class="na"&gt;onclick=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;alert(&amp;#39;Hello, click!&amp;#39;);&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;appearance&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;material&lt;/span&gt; &lt;span class="na"&gt;id=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;color&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;diffuseColor=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;1 0 0&amp;#39;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&amp;lt;/material&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/appearance&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;box&amp;gt;&amp;lt;/box&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/shape&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后，你就可以通过下面这个函数改变颜色：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;script&amp;gt;&lt;/span&gt;
    function changeColor()
    {
        if(document.getElementById(&amp;quot;color&amp;quot;).getAttribute(&amp;#39;diffuseColor&amp;#39;)==&amp;quot;1 0 0&amp;quot;)
            document.getElementById(&amp;quot;color&amp;quot;).setAttribute(&amp;#39;diffuseColor&amp;#39;, &amp;#39;0 0 1&amp;#39;);
        else
            document.getElementById(&amp;quot;color&amp;quot;).setAttribute(&amp;#39;diffuseColor&amp;#39;, &amp;#39;1 0 0&amp;#39;);
    }
&lt;span class="nt"&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;shape onclick=&amp;quot;changeColor();&amp;quot;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;下一步：自动创建 (X)HTML&lt;/h2&gt;
&lt;p&gt;如果你有大量的模型数据，你想把这些数据分配到不同的页面上。那么自动生成实际的页面而不是手动编写代码将更加有趣。你可以使用自动化工具，例如 XSLT，允许你直接将 X3DOM 文件转化为 XHTML 网页。&lt;a href="http://www.web3d.org/x3d/stylesheets/X3dToXhtmlStylesheetExamples.zip"&gt;这里&lt;/a&gt;是一个例子。&lt;/p&gt;</content><category term="X3DOM"></category></entry><entry><title>Hello，X3DOM！</title><link href="https://xutree.github.io/pages/2018/10/04/X3DOM-hello/" rel="alternate"></link><published>2018-10-04T18:29:00+08:00</published><updated>2018-10-06T20:59:55+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-04:/pages/2018/10/04/X3DOM-hello/</id><summary type="html">&lt;p&gt;本教程将教会你怎么配置和运行你的第一个 X3DOM 应用。你只需要一个相容于 WebGL 的浏览器和一个文本编辑器。整个 X3DOM 应用是常规网页的一部分，并且编写方式也与HTML很相似，所以如果你的编辑器支持HTML或者XML的语法高亮那将更好，像&lt;a href="http://www.jetbrains.com/webstorm/"&gt;WebStorm&lt;/a&gt;这种 Web 编程 IDE 也是可以的。如果你手头有一个网页浏览器和一个文本编辑器，并且你知道怎么在浏览器中打开网页(参考&lt;a href="https://doc.x3dom.org/gettingStarted/index.html"&gt;这里&lt;/a&gt;)，那么你可以开始你的第一个 X3DOM 应用了。&lt;/p&gt;
&lt;p&gt;首先，创建一个新文件 &lt;em&gt;HelloX3DOM.html&lt;/em&gt;。然后将下面的内容复制粘贴进这个空文件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;title&amp;gt;&lt;/span&gt;My first X3DOM page&lt;span class="nt"&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;script&lt;/span&gt; &lt;span class="na"&gt;type=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;text/javascript&amp;#39;&lt;/span&gt; &lt;span class="na"&gt;src=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;http://www.x3dom.org/download/x3dom.js …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;本教程将教会你怎么配置和运行你的第一个 X3DOM 应用。你只需要一个相容于 WebGL 的浏览器和一个文本编辑器。整个 X3DOM 应用是常规网页的一部分，并且编写方式也与HTML很相似，所以如果你的编辑器支持HTML或者XML的语法高亮那将更好，像&lt;a href="http://www.jetbrains.com/webstorm/"&gt;WebStorm&lt;/a&gt;这种 Web 编程 IDE 也是可以的。如果你手头有一个网页浏览器和一个文本编辑器，并且你知道怎么在浏览器中打开网页(参考&lt;a href="https://doc.x3dom.org/gettingStarted/index.html"&gt;这里&lt;/a&gt;)，那么你可以开始你的第一个 X3DOM 应用了。&lt;/p&gt;
&lt;p&gt;首先，创建一个新文件 &lt;em&gt;HelloX3DOM.html&lt;/em&gt;。然后将下面的内容复制粘贴进这个空文件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;title&amp;gt;&lt;/span&gt;My first X3DOM page&lt;span class="nt"&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;script&lt;/span&gt; &lt;span class="na"&gt;type=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;text/javascript&amp;#39;&lt;/span&gt; &lt;span class="na"&gt;src=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;http://www.x3dom.org/download/x3dom.js&amp;#39;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nt"&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;link&lt;/span&gt; &lt;span class="na"&gt;rel=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;stylesheet&amp;#39;&lt;/span&gt; &lt;span class="na"&gt;type=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;text/css&amp;#39;&lt;/span&gt; &lt;span class="na"&gt;href=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;http://www.x3dom.org/download/x3dom.css&amp;#39;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&amp;lt;/link&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;h1&amp;gt;&lt;/span&gt;Hello, X3DOM!&lt;span class="nt"&gt;&amp;lt;/h1&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;p&amp;gt;&lt;/span&gt;
        This is my first html page with some 3d objects.
    &lt;span class="nt"&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果你在浏览器中打开这个文件，你会看到一个包含一个文本信息的常规HTML页面。你可能已经注意到，我们已经在我们的网页中添加了一些 X3DOM 元素，因为我们已经包含 X3DOM 作为一个 JaveScript 库，还包含了 X3DOM CSS 文件，用于规则的显示 X3DOM 元素。在上面的 HTML 代码中，我们通过 &lt;em&gt;script&lt;/em&gt; 和 &lt;em&gt;link&lt;/em&gt; 标签是用了 &lt;em&gt;development&lt;/em&gt; 版本的 X3DOM。&lt;/p&gt;
&lt;p&gt;让我们继续添加一些 3D 内容。首先，我们需要一个 &lt;em&gt;x3d&lt;/em&gt; 元素，用来描述 X3DOM 内容在哪个 &lt;em&gt;scene&lt;/em&gt; 显示。和 HTML 元素 &lt;em&gt;p&lt;/em&gt;、&lt;em&gt;div&lt;/em&gt; 类似，&lt;em&gt;x3d&lt;/em&gt; 在 HTML 里定义了一个矩形范围。整个 X3DOM 的 3D 内容用 &lt;em&gt;scene&lt;/em&gt; 描述，所以我们在 &lt;em&gt;x3d&lt;/em&gt; 标签里添加一个 &lt;em&gt;scene&lt;/em&gt; 标签。这种结构是来自于X3D标准。一个 &lt;em&gt;scene&lt;/em&gt; 可以包含很多不同的 &lt;em&gt;node&lt;/em&gt;，例如，&lt;em&gt;lights&lt;/em&gt;、&lt;em&gt;groups&lt;/em&gt;、&lt;em&gt;viewpoint&lt;/em&gt; 和 &lt;em&gt;objects&lt;/em&gt;。在第一个例子里，我们通过 &lt;em&gt;shape&lt;/em&gt; 简单地定义一个3D物体。我们用 &lt;em&gt;box&lt;/em&gt; 定义这个物体的几何形状。现在，你可以将下面的代码添加在你的 HTML 文件闭合 &lt;em&gt;p&lt;/em&gt; 标签之后：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;x3d&lt;/span&gt; &lt;span class="na"&gt;width=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;600px&amp;#39;&lt;/span&gt; &lt;span class="na"&gt;height=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;400px&amp;#39;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;scene&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;shape&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;box&amp;gt;&amp;lt;/box&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/shape&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/scene&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/x3d&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果你现在在浏览器中打开这个文件，会像下面这样：&lt;/p&gt;
&lt;p&gt;&lt;img alt="图1    注意box标签没有颜色，所以无法在图中看到" src="https://xutree.github.io/images/fig1.png"&gt;&lt;/p&gt;
&lt;p&gt;由于 &lt;em&gt;box&lt;/em&gt; 目前没有颜色，所以无法看到它，为了看到它我们需要声明 &lt;em&gt;material&lt;/em&gt;，X3DOM 基于 X3D 标准选择了一个白色的 &lt;em&gt;material&lt;/em&gt;，由于网页的背景也是白色的，所以我们看不到它。为了改变 &lt;em&gt;material&lt;/em&gt; 的颜色，我们首先需要在 &lt;em&gt;shape&lt;/em&gt; 中插入 &lt;em&gt;appearance&lt;/em&gt;。在 &lt;em&gt;appearance&lt;/em&gt; 里面，我们就可以插入 &lt;em&gt;material&lt;/em&gt;，利用 &lt;em&gt;material&lt;/em&gt; 的 &lt;em&gt;diffuseColor&lt;/em&gt; 我们可以定义 &lt;em&gt;material&lt;/em&gt; 的颜色，我们现在将它定义为 RGB 颜色的红色：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;shape&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;appearance&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;material&lt;/span&gt; &lt;span class="na"&gt;diffuseColor=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;1 0 0&amp;#39;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&amp;lt;/material&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/appearance&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;box&amp;gt;&amp;lt;/box&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/shape&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;现在，在你的浏览器中，网页将变成：&lt;/p&gt;
&lt;p&gt;&lt;img alt="图2    现在 *box* 具有红色的 *material*" src="https://xutree.github.io/images/fig2.png"&gt;&lt;/p&gt;
&lt;p&gt;现在，你可以利用鼠标进行交互了。按住鼠标左键并移动鼠标，你可以旋转视角，按住鼠标右键并移动鼠标，你可以放大和缩小。&lt;/p&gt;
&lt;p&gt;我们继续在这个 &lt;em&gt;scene&lt;/em&gt; 中添加两个物体：一个蓝色的球体和一个绿色的圆锥。这和我们添加 &lt;em&gt;box&lt;/em&gt; 类似，但是，在 &lt;em&gt;sphere&lt;/em&gt; 和 &lt;em&gt;cone&lt;/em&gt; 节点处，我们需要移动球和圆锥以避免他们相互重叠，因为所有的 3D 物体都默认不进行任何的坐标转换，也就是说它们会重叠在一起。像X3D和其他的图像相关标准(例如，OpenGL)一样，X3DOM 的坐标系统 Y 轴指向上，X 轴指向右，Z 轴指向外：&lt;/p&gt;
&lt;p&gt;&lt;img alt="图3  X3DOM的坐标系统" src="https://xutree.github.io/images/fig3.png"&gt;&lt;/p&gt;
&lt;p&gt;在添加绿色圆锥之前，我们将坐标往左移动3个单位；在添加蓝色球之前，我们将坐标往右移动3个单位。如下所示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;shape&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;appearance&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;material&lt;/span&gt; &lt;span class="na"&gt;diffuseColor=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;1 0 0&amp;#39;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&amp;lt;/material&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/appearance&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;box&amp;gt;&amp;lt;/box&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/shape&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;transform&lt;/span&gt; &lt;span class="na"&gt;translation=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;-3 0 0&amp;#39;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;shape&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;appearance&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;material&lt;/span&gt; &lt;span class="na"&gt;diffuseColor=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;0 1 0&amp;#39;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&amp;lt;/material&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/appearance&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;cone&amp;gt;&amp;lt;/cone&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/shape&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/transform&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;transform&lt;/span&gt; &lt;span class="na"&gt;translation=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;3 0 0&amp;#39;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;shape&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;appearance&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;material&lt;/span&gt; &lt;span class="na"&gt;diffuseColor=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;0 0 1&amp;#39;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&amp;lt;/material&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/appearance&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;sphere&amp;gt;&amp;lt;/sphere&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/shape&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/transform&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;现在，在你的浏览器中，你将看到如下内容：&lt;/p&gt;
&lt;p&gt;&lt;img alt="图4 三个物体" src="https://xutree.github.io/images/fig4.png"&gt;&lt;/p&gt;
&lt;p&gt;如果你在浏览器中看到了上图的结果，恭喜你！你刚刚使用了一系列的 X3D &lt;em&gt;node&lt;/em&gt; 创建了你的第一个 X3DOM &lt;em&gt;scene&lt;/em&gt;。&lt;/p&gt;</content><category term="X3DOM"></category></entry><entry><title>X3DOM 第一课</title><link href="https://xutree.github.io/pages/2018/10/04/X3DOM%E7%AC%AC%E4%B8%80%E8%AF%BE/" rel="alternate"></link><published>2018-10-04T11:31:00+08:00</published><updated>2018-10-06T21:13:34+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-04:/pages/2018/10/04/X3DOM第一课/</id><summary type="html">&lt;p&gt;下面的指南可以作为 X3DOM 使用者和开发者的入门资料。本指南包括许多重要的内容，例如怎么配置你的环境去运行 X3DOM 的示例。如果你没有足够的时间阅读这篇入门文章，又或许你已经熟悉一点关于 X3D 的知识，你可以迅速的浏览下第3部分和第4部分的一些内容去设置你的环境，然后根据&lt;a href="https://doc.x3dom.org/tutorials/index.html"&gt;tutorials&lt;/a&gt;的指导去完成你的第一个 X3DOM 应用。&lt;/p&gt;
&lt;h2&gt;背景：什么是X3DOM，它可以用来做什么？&lt;/h2&gt;
&lt;h3&gt;无需插件即可在浏览器中显示的3D场景&lt;/h3&gt;
&lt;p&gt;X3DOM（发音：“X-Freedom”）是一个开源的 JaveScript 框架，用于在网页中创建 declarative 3D 场景。由于它基于标准的浏览器技术，你的浏览器不需要其他任何插件就可以显示 X3DOM 场景。概括地说，declarative 3D 意味着你可以使用结构化的文本表示去创建和显示 3D 场景，而不需要去编写代码。在 X3DOM 中，这种文本表示是表示网页的 HTML 文件的一部分。也就是说，3D …&lt;/p&gt;</summary><content type="html">&lt;p&gt;下面的指南可以作为 X3DOM 使用者和开发者的入门资料。本指南包括许多重要的内容，例如怎么配置你的环境去运行 X3DOM 的示例。如果你没有足够的时间阅读这篇入门文章，又或许你已经熟悉一点关于 X3D 的知识，你可以迅速的浏览下第3部分和第4部分的一些内容去设置你的环境，然后根据&lt;a href="https://doc.x3dom.org/tutorials/index.html"&gt;tutorials&lt;/a&gt;的指导去完成你的第一个 X3DOM 应用。&lt;/p&gt;
&lt;h2&gt;背景：什么是X3DOM，它可以用来做什么？&lt;/h2&gt;
&lt;h3&gt;无需插件即可在浏览器中显示的3D场景&lt;/h3&gt;
&lt;p&gt;X3DOM（发音：“X-Freedom”）是一个开源的 JaveScript 框架，用于在网页中创建 declarative 3D 场景。由于它基于标准的浏览器技术，你的浏览器不需要其他任何插件就可以显示 X3DOM 场景。概括地说，declarative 3D 意味着你可以使用结构化的文本表示去创建和显示 3D 场景，而不需要去编写代码。在 X3DOM 中，这种文本表示是表示网页的 HTML 文件的一部分。也就是说，3D 内容成为了网页元素的一部分，就像网页中的文本、链接、图片和视频一样。&lt;/p&gt;
&lt;h3&gt;X3DOM = X3D + DOM&lt;/h3&gt;
&lt;p&gt;X3DOM 这个名字是由两个缩写组合而成。第一个缩写是&lt;a href="http://www.web3d.org/x3d/what-x3d"&gt;X3D&lt;/a&gt;（“Extensible 3D Graphics”），指代一个 3D 图形的免版税 ISO 标准。第二个缩写是&lt;a href="https://www.w3.org/DOM/"&gt;DOM&lt;/a&gt;（“Document Object Model”），描述与HTML文档的内容相关联的交互概念和分层表示。X3DOM 使用 X3D 的一个专门的子集（所谓的&lt;a href="https://www.x3dom.org/nodes-2/"&gt;HTML Profile&lt;/a&gt;）来作为网页内 3D 内容的描述语言。X3D（OM)元素可以通过 DOM 操作，就像其他的 HTML 元素一样。例如，你可以动态地改变一个 3D 物体的颜色通过 JavaScript 调用相应 DOM 元素的 &lt;em&gt;setAttribute(...)&lt;/em&gt; 函数，这就像你可以动态改变一个普通网页里一个标签的内容一样。&lt;/p&gt;
&lt;h3&gt;使用 X3DOM 的原因&lt;/h3&gt;
&lt;p&gt;使用 X3DOM 而不是其他的基于浏览器的库或者 X3D 播放器是因为 X3DOM 具有以下几个优势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;显示 X3DOM 场景不需要额外插件，因为 X3DOM 是完全基于标准浏览器技术，例如&lt;a href="http://www.w3schools.com/html/html5_intro.asp"&gt;HTML5&lt;/a&gt;和&lt;a href="http://get.webgl.org/"&gt;WebGL&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;基于 ISO 标准 X3D 的一种新的 HTML 配置，X3DOM 绝大部分都是标准一致的。这大大方便了 X3DOM 的学习&lt;/li&gt;
&lt;li&gt;从2009年至今，X3DOM 已经具有了很大的使用者和开发者群体&lt;/li&gt;
&lt;li&gt;如果你知道怎么创建简单的网页，你就可以利用你现有的关于 HTML 和 DOM 的知识，而不需要学习新的 API&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;怎么做？&lt;/h3&gt;
&lt;p&gt;如果你想开发你的第一个 X3DOM 应用，你只需要一个浏览器和一个文本编辑器。当然，你也可以选择功能更多的 HTML 和 JavaScript 开发环境，比如&lt;a href="http://www.jetbrains.com/webstorm/"&gt;WebStorm&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;一些基本 X3D 概念：Nodes、Components 和 Profiles&lt;/h2&gt;
&lt;h3&gt;X3D Nodes&lt;/h3&gt;
&lt;p&gt;X3D 定义每一个 3D 场景都是由一组 node 组成。每一个 node 代表 3D 场景中一个确定的部分：光线、物体、物体表面的材质等等。场景里的所用 node 排列成树结构或者图结构，整体结构被叫做 &lt;em&gt;scene-graph&lt;/em&gt;。每一个 node 的行为，比如材质的颜色，可以通过node的 &lt;em&gt;fields&lt;/em&gt; 设置。例如，一个用来设置某物体表面颜色为红色（RGB编码 1 0 0）的node的 XML 描述为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;Material&lt;/span&gt; &lt;span class="na"&gt;diffuseColor=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;1 0 0&amp;#39;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&amp;lt;/Material&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;你可能已经意识到，描述 X3D node 的 XML 很像常规的 HTML 代码，属性值 &lt;em&gt;diffuseColor&lt;/em&gt; 的设置也像 HTML 属性的设置一样。事实上，如果你熟悉 HTML，那么就很容易理解 X3DOM 中的 node 了。你可以在&lt;a href="https://doc.x3dom.org/tutorials/index.html"&gt;tutorials&lt;/a&gt;中学习怎样使用 node。如果你想了解更多 X3D 中 node 的概念，可以参考&lt;a href="https://doc.x3dom.org/index.html#X3DExternalDoc"&gt;external X3D documentation resources&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;X3D Components&lt;/h3&gt;
&lt;p&gt;一组具有相同功能的 node 称为 components。例如定义光线的 node，&lt;em&gt;PointLight&lt;/em&gt; 和 &lt;em&gt;SpotLight&lt;/em&gt;，在 &lt;em&gt;Lighting&lt;/em&gt; component 里。关于 Components 的全部信息可以在&lt;a href="https://doc.x3dom.org/node/Components.html"&gt;这里&lt;/a&gt;找到。&lt;/p&gt;
&lt;h3&gt;X3D Profiles 和 X3DOM HTML Profile&lt;/h3&gt;
&lt;p&gt;X3D 标准定义了大量的 node，一些特殊用途的 node 对大多说用户来说并不重要。因此，X3D 引入了 profile 的概念，把许多组 node 放在一起成为一个包，每一个包代表一类特殊的应用。例如，&lt;em&gt;CAD&lt;/em&gt; 包，&lt;em&gt;Immersive&lt;/em&gt; 包是用于交互环境的。profile 是在 component 之上的一个概念。&lt;/p&gt;
&lt;p&gt;X3DOM 使用的 X3D component 经过十分仔细的选择，以提供一个最合适的 X3D 子集来满足现代 HTML 应用的需要。X3DOM 通过定义一个特殊的 profile，即 HTML profile，来解决这一问题。这个 HTML profile 也包括一些处于试验阶段的 X3D 没有的 node 和 filed，这些 node 和 filed 是专门为 X3DOM 设计的。具体来说，有些 X3D node 在 X3DOM 里没有，而有些 node X3DOM 里有但是 X3D 里没有。你可以在&lt;a href="https://doc.x3dom.org/author/index.html"&gt;这里&lt;/a&gt;找到每个 node 的起源。如果你想学习更多关于 HTML profile 的知识以及它与现有的 X3D component、profile 的关系，可以查看&lt;a href="http://www.x3dom.org/?page_id=158"&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;最后，X3DOM 也提供一些不在原始HTML profile 中的 X3D node。这些 node 不在 X3DOM 的标准发行版本中，只在 &lt;em&gt;X3DOM-Full&lt;/em&gt; 版本中。&lt;/p&gt;
&lt;h2&gt;选择一个 X3DOM 版本&lt;/h2&gt;
&lt;h3&gt;版本和 Components&lt;/h3&gt;
&lt;p&gt;有许多可供选择的 X3DOM 版本，你可能想知道对特殊的目的哪一个才是最好的。一般来讲，我们推荐最新的 release 版本。但是，如果你需要采用的新特性在 release 版中没有，那么 dev 版本可能更适合你。当你完成了网页应用的主要开发工作进而部署时，你可能需要用来开发的 X3DOM 的版本信息。你也可能，出于某种原因需要老版本的 X3DOM，比如你的网页应用包含了一些试验特性只在老版本出现，而在新版本中被移除了。&lt;/p&gt;
&lt;p&gt;所有的 X3DOM release 版本，包括 dev 版本，都被打包好了，里面包括一个 JavaScript 文件（如 x3dom.js），一个 css文件（如 x3dom.css）和一个可选的 shockwave 文件（如 x3dom.swf，对于那些支持 flash 的版本），可在&lt;a href="http://x3dom.org/download/"&gt;这里&lt;/a&gt;下载：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;版本1.0到1.2的文件以 x3dom-v 标记，后面跟着版本号（如&lt;a href="http://x3dom.org/download/x3dom-v1.1.js"&gt; http://x3dom.org/download/x3dom-v1.1.js&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;从版本1.3开始，x3dom.js, x3dom.css, x3dom.swf 和一个 .zip 存档文件b被放置在一个以版本号为名字的子文件夹里（如&lt;a href="http://x3dom.org/download/1.3/x3dom.js"&gt; http://x3dom.org/download/1.3/x3dom.js&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;从版本1.3开始，一些 HTML profile 之外的 component 出现了。这些 component 在文件 x3dom-full.js 中。如果你只需要使用其中一个 component，你也可以考虑仍使用 x3dom.js 然后包含所需的 component 的文件（如&lt;a href="http://x3dom.org/download/1.3/components/"&gt; http://x3dom.org/download/1.3/components/&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;最新的稳定 release 版总是位于：&lt;a href="http://x3dom.org/release/x3dom.js"&gt;http://x3dom.org/release/x3dom.js&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;目前的 development 版本总是位于 dec 子文件夹：&lt;a href="http://x3dom.org/download/dev/x3dom.js"&gt;http://x3dom.org/download/dev/x3dom.js&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为使用最新版本 release X3DOM，你可以在你的HTML页面中包含下面的标签：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;script&lt;/span&gt; &lt;span class="na"&gt;src=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;http://www.x3dom.org/release/x3dom.js&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;link&lt;/span&gt; &lt;span class="na"&gt;rel=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;stylesheet&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;href=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;http://www.x3dom.org/release/x3dom.css&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;为使用最新的 development 版本，使用下面的标签：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;script&lt;/span&gt; &lt;span class="na"&gt;src=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;http://www.x3dom.org/download/dev/x3dom.js&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;link&lt;/span&gt; &lt;span class="na"&gt;rel=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;stylesheet&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;href=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;http://www.x3dom.org/download/dev/x3dom.css&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;为使用版本1.5的 X3DOM-Full 版本，使用下面的标签：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;script&lt;/span&gt; &lt;span class="na"&gt;src=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;http://www.x3dom.org/download/1.5/x3dom-full.js&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;link&lt;/span&gt; &lt;span class="na"&gt;rel=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;stylesheet&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;href=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;http://www.x3dom.org/download/1.5/x3dom.css&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;最后，为使用1.3版本的 release X3DOM 和额外的 Geospatial component 和另外的 flash 支持，使用下面的标签：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;script&lt;/span&gt; &lt;span class="na"&gt;src=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;http://www.x3dom.org/download/1.3/x3dom.js&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;script&lt;/span&gt; &lt;span class="na"&gt;src=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;http://www.x3dom.org/download/1.3/components/Geospatial.js&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;script&lt;/span&gt; &lt;span class="na"&gt;src=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;http://www.x3dom.org/download/1.3/x3dom.swf&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;link&lt;/span&gt; &lt;span class="na"&gt;rel=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;stylesheet&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;href=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;http://www.x3dom.org/download/1.3/x3dom.css&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Debugging&lt;/h3&gt;
&lt;p&gt;如果在 debug 你的应用的时候你想看到 X3DOM 的源码，只需将 x3dom.js 替换成 x3dom.debug.js 或者将 x3dom-full.js 替换成 x3dom-full.debug.js。其注意，此特性只适用于版本1.4以后的 X3DOM。相比于常规版本，debug 版本包含缩进和注释，所以比较大。所以，当你最终发布你的 Web 应用时，请不要使用 debug 版本的 js。&lt;/p&gt;
&lt;h2&gt;运行 X3DOM 应用&lt;/h2&gt;
&lt;h3&gt;通过简单的 Python 服务器&lt;/h3&gt;
&lt;p&gt;一个简便的方法在服务器上来测试你的 Web 应用是使用 Python 的 HTTP 服务器模块。你只需要安装一个 Python 解释器。你可以在&lt;a href="http://python.org/"&gt;这里&lt;/a&gt;下载。你可以用 Python 做许多有趣的事情。首先，打开命令行窗口，定位到 X3DOM 文件夹。如果你的 Python 是2.X版本，你可以使用 &lt;em&gt;SimpleHTTP&lt;/em&gt; 服务器模块如下所示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;python -m SimpleHTTPServer
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果你的 Python 是3.x版本，如下所示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;python3 -m http.server
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;默认情况下，服务器使用8000端口。如果你想改变端口，直接在命令后面加上端口号即可，例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;python -m SimpleHTTPServer 8023
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后，通过浏览器输入如下地址就可以到达你的服务器：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;http://localhost:8023
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果你在启动 Python 服务器的文件夹里放置了 index.html 文件，那么这个文件的内容就会显示在浏览器窗口里。否则，你会看到服务器所在文件夹内的文件列表。&lt;/p&gt;
&lt;h3&gt;在 Web 服务器上运行 X3DOM&lt;/h3&gt;
&lt;p&gt;通常，你会在Web服务器上运行你的 X3DOM 应用，本节针对一些普通的 Web 服务器，如 Apache 和 IIS，给出具体的方法。&lt;/p&gt;
&lt;p&gt;Apache 是使用最多的 Web 服务器。它是开源的可以在&lt;a href="http://httpd.apache.org/"&gt;这里&lt;/a&gt;下载。最新版本是2.4，但是版本2.2仍然被支持。&lt;/p&gt;
&lt;p&gt;如果你的应用需要一整套 Web 服务器组件，我们推荐&lt;a href="https://www.apachefriends.org/index.html"&gt;XAMPP&lt;/a&gt;，它包含 Apache、MySQL、PHP 和 Perl 的最新发行版。&lt;/p&gt;
&lt;p&gt;互联网信息服务（IIS）被集成在微软的任何的最新版本的 Windows 当中。但是，对于非服务器操作系统，同时连接数会受到限制。&lt;/p&gt;</content><category term="X3DOM"></category></entry><entry><title>安装 Pelican</title><link href="https://xutree.github.io/pages/2018/10/04/%E5%9C%A8mac%E4%B8%8A%E5%AE%89%E8%A3%85Pelican/" rel="alternate"></link><published>2018-10-04T10:20:00+08:00</published><updated>2018-10-06T21:15:21+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-04:/pages/2018/10/04/在mac上安装Pelican/</id><summary type="html">&lt;h2&gt;安装 Pelican&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://blog.getpelican.com/"&gt;Pelican&lt;/a&gt;目前支持最好的是 Python 2.7 和 3.3+，早期版本的 Python 已经不支持了。有许多不同的方法可以安装 Pelican，最简单的方法是使用 pip，在终端输入：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    pip install pelican
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面是最简单的方法，官方更为推荐的方法是利用 &lt;a href="http://www.virtualenv.org/"&gt;virtualenv&lt;/a&gt; 为 Pelican 建立一个虚拟环境。假设你已经安装好了 virtualenv，下面打开终端，开始为 Pelican 新建一个虚拟环境：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    virtualenv ~/virtualenv/pelican
    cd ~/virtualenv/pelican
    source bin/activate
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当虚拟环境被创建并激活以后，然后利用&lt;code&gt;pip install pelican&lt;/code&gt;安装 Pelican。&lt;/p&gt;
&lt;p&gt;当 …&lt;/p&gt;</summary><content type="html">&lt;h2&gt;安装 Pelican&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://blog.getpelican.com/"&gt;Pelican&lt;/a&gt;目前支持最好的是 Python 2.7 和 3.3+，早期版本的 Python 已经不支持了。有许多不同的方法可以安装 Pelican，最简单的方法是使用 pip，在终端输入：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    pip install pelican
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面是最简单的方法，官方更为推荐的方法是利用 &lt;a href="http://www.virtualenv.org/"&gt;virtualenv&lt;/a&gt; 为 Pelican 建立一个虚拟环境。假设你已经安装好了 virtualenv，下面打开终端，开始为 Pelican 新建一个虚拟环境：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    virtualenv ~/virtualenv/pelican
    cd ~/virtualenv/pelican
    source bin/activate
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当虚拟环境被创建并激活以后，然后利用&lt;code&gt;pip install pelican&lt;/code&gt;安装 Pelican。&lt;/p&gt;
&lt;p&gt;当 Pelican 安装好以后，你可以在终端输入&lt;code&gt;pelican --help&lt;/code&gt;查看使用选项。&lt;/p&gt;
&lt;h2&gt;可选的 Packages&lt;/h2&gt;
&lt;p&gt;如果你计划用 &lt;a href="http://pypi.python.org/pypi/Markdown"&gt;Markdown&lt;/a&gt; 来书写你的网页的话，你需要安装 Markdown：&lt;code&gt;pip install Markdown&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;通过设置 Pelican 的 pelicanconf.py 文件，你可以对生成的 HTML 文件启用增强语法。但是首先你需要安装 &lt;a href="https://pypi.org/project/typogrify/"&gt;Typogrify&lt;/a&gt;：&lt;code&gt;pip install typorify&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;更新&lt;/h2&gt;
&lt;p&gt;更新到最新的稳定版本，使用：
&lt;code&gt;pip install --upgrade pelican&lt;/code&gt;&lt;/p&gt;</content><category term="Pelican"></category></entry></feed>