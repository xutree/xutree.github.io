<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>You Know Nothing</title><link href="https://xutree.github.io/" rel="alternate"></link><link href="https://xutree.github.io/feeds/all.atom.xml" rel="self"></link><id>https://xutree.github.io/</id><updated>2018-10-06T22:25:35+08:00</updated><entry><title>【读书笔记】C++ Primer 第二章</title><link href="https://xutree.github.io/pages/2018/10/06/C++_Primer_Chapter_2/" rel="alternate"></link><published>2018-10-06T22:02:54+08:00</published><updated>2018-10-06T22:25:35+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-06:/pages/2018/10/06/C++_Primer_Chapter_2/</id><summary type="html">&lt;ul&gt;
&lt;li&gt;下表列出了 C++ 标准规定的数据类型尺寸的最小值，同时允许编译器赋予这些类型更大的尺寸&lt;ul&gt;
&lt;li&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;th&gt;最小尺寸&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;bool&lt;/td&gt;
&lt;td&gt;布尔类型&lt;/td&gt;
&lt;td&gt;未定义&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;char&lt;/td&gt;
&lt;td&gt;字符&lt;/td&gt;
&lt;td&gt;8位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;wchar_t&lt;/td&gt;
&lt;td&gt;宽字符&lt;/td&gt;
&lt;td&gt;16位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;char16_t&lt;/td&gt;
&lt;td&gt;Unicode 字符&lt;/td&gt;
&lt;td&gt;16位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;char32_t&lt;/td&gt;
&lt;td&gt;Unicode 字符&lt;/td&gt;
&lt;td&gt;32位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;short&lt;/td&gt;
&lt;td&gt;短整型&lt;/td&gt;
&lt;td&gt;16位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;整型&lt;/td&gt;
&lt;td&gt;16位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;long&lt;/td&gt;
&lt;td&gt;长整型&lt;/td&gt;
&lt;td&gt;32位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;long long&lt;/td&gt;
&lt;td&gt;长整型&lt;/td&gt;
&lt;td&gt;64位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;float&lt;/td&gt;
&lt;td&gt;单精度浮点数&lt;/td&gt;
&lt;td&gt;6位有效数字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;double&lt;/td&gt;
&lt;td&gt;双精度浮点数&lt;/td&gt;
&lt;td&gt;10位有效数字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;long double&lt;/td&gt;
&lt;td&gt;扩展精度浮点数&lt;/td&gt;
&lt;td&gt;10位有效数字&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;一个&lt;code&gt;char&lt;/code&gt;的空间应确保可以存放机器基本字符集中任意字符对应的数字值 …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;ul&gt;
&lt;li&gt;下表列出了 C++ 标准规定的数据类型尺寸的最小值，同时允许编译器赋予这些类型更大的尺寸&lt;ul&gt;
&lt;li&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;th&gt;最小尺寸&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;bool&lt;/td&gt;
&lt;td&gt;布尔类型&lt;/td&gt;
&lt;td&gt;未定义&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;char&lt;/td&gt;
&lt;td&gt;字符&lt;/td&gt;
&lt;td&gt;8位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;wchar_t&lt;/td&gt;
&lt;td&gt;宽字符&lt;/td&gt;
&lt;td&gt;16位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;char16_t&lt;/td&gt;
&lt;td&gt;Unicode 字符&lt;/td&gt;
&lt;td&gt;16位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;char32_t&lt;/td&gt;
&lt;td&gt;Unicode 字符&lt;/td&gt;
&lt;td&gt;32位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;short&lt;/td&gt;
&lt;td&gt;短整型&lt;/td&gt;
&lt;td&gt;16位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;整型&lt;/td&gt;
&lt;td&gt;16位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;long&lt;/td&gt;
&lt;td&gt;长整型&lt;/td&gt;
&lt;td&gt;32位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;long long&lt;/td&gt;
&lt;td&gt;长整型&lt;/td&gt;
&lt;td&gt;64位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;float&lt;/td&gt;
&lt;td&gt;单精度浮点数&lt;/td&gt;
&lt;td&gt;6位有效数字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;double&lt;/td&gt;
&lt;td&gt;双精度浮点数&lt;/td&gt;
&lt;td&gt;10位有效数字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;long double&lt;/td&gt;
&lt;td&gt;扩展精度浮点数&lt;/td&gt;
&lt;td&gt;10位有效数字&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;一个&lt;code&gt;char&lt;/code&gt;的空间应确保可以存放机器基本字符集中任意字符对应的数字值。也就是说，一个&lt;code&gt;char&lt;/code&gt;的大小和一个机器字节一样&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wchar_t&lt;/code&gt;类型用于确保可以存放机器最大扩展字符集中的任意一个字符&lt;/li&gt;
&lt;li&gt;C++ 语言规定，一个&lt;code&gt;int&lt;/code&gt;至少和一个&lt;code&gt;short&lt;/code&gt;一样大，一个&lt;code&gt;long&lt;/code&gt;至少和一个&lt;code&gt;int&lt;/code&gt;一样大，一个&lt;code&gt;long long&lt;/code&gt;至少和一个&lt;code&gt;long&lt;/code&gt;一样大&lt;/li&gt;
&lt;li&gt;可寻址的最小内存块成称为“字节（byte）”，存储的基本单元称为“字（word）”，它通常有几个字节组成&lt;/li&gt;
&lt;li&gt;在 C++ 语言中，一个字节至少能容纳机器基本字符串中的字符&lt;/li&gt;
&lt;li&gt;大多数机器的字节由8比特构成，字则由32或64比特构成，也就是4字节或8字节&lt;/li&gt;
&lt;li&gt;C++ 标准指定了一个浮点数有效位数的最小值，然而大多数编译器都实现了更高的精度。通常，&lt;code&gt;float&lt;/code&gt;以1个字（32比特）来表示，&lt;code&gt;double&lt;/code&gt;以2个字（64位）来表示，&lt;code&gt;long double&lt;/code&gt;以3或4个字（96或128比特）来表示&lt;/li&gt;
&lt;li&gt;一般来说，&lt;code&gt;float&lt;/code&gt;和&lt;code&gt;double&lt;/code&gt;分别有7和16个有效位；类型&lt;code&gt;long double&lt;/code&gt;则常常被用于有特殊浮点要求的硬件，它的具体实现不同，精度也各不相同&lt;/li&gt;
&lt;li&gt;类型&lt;code&gt;int&lt;/code&gt;、&lt;code&gt;short&lt;/code&gt;、&lt;code&gt;long&lt;/code&gt;和&lt;code&gt;long long&lt;/code&gt;都是带符号的，通过在这些类型名前添加&lt;code&gt;unsigned&lt;/code&gt;就可以得到无符号类型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;char&lt;/code&gt;、&lt;code&gt;signed char&lt;/code&gt;和&lt;code&gt;unsigned char&lt;/code&gt;，&lt;code&gt;char&lt;/code&gt;是否等于&lt;code&gt;signed char&lt;/code&gt;由编译器决定&lt;/li&gt;
&lt;li&gt;C++ 标准并没有规定带符号类型应如何表示，但是约定了在表示范围内正值和负值的量应该平衡。因此，8比特的&lt;code&gt;signed char&lt;/code&gt;理论上可以表示-127至127区间内的值，大多数现代计算机将实际的表示范围定为-128至127&lt;/li&gt;
&lt;li&gt;如何选择类型&lt;ul&gt;
&lt;li&gt;明知数值不可能为负数，选用无符号类型&lt;/li&gt;
&lt;li&gt;如果数值超过了&lt;code&gt;int&lt;/code&gt;的表示范围，选用&lt;code&gt;long long&lt;/code&gt;，因为&lt;code&gt;long&lt;/code&gt;一般和&lt;code&gt;int&lt;/code&gt;有一样的尺寸&lt;/li&gt;
&lt;li&gt;算术表达式中不要使用&lt;code&gt;bool&lt;/code&gt;或&lt;code&gt;char&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;执行浮点数运算选用&lt;code&gt;double&lt;/code&gt;。因为&lt;code&gt;float&lt;/code&gt;通常精度不够而且计算代价相差无几。&lt;code&gt;long double&lt;/code&gt;提供的精度一般情况下是没有必要的而且计算代价大&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;类型转换&lt;ul&gt;
&lt;li&gt;非布尔 -&amp;gt; 布尔：0 -&amp;gt; &lt;code&gt;false&lt;/code&gt;，其他 -&amp;gt; &lt;code&gt;ture&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;布尔 -&amp;gt; 非布尔：&lt;code&gt;false&lt;/code&gt;-&amp;gt; 0，&lt;code&gt;ture&lt;/code&gt; -&amp;gt; 1&lt;/li&gt;
&lt;li&gt;浮点 -&amp;gt; 整型：仅保留小数点前&lt;/li&gt;
&lt;li&gt;整型 -&amp;gt; 浮点：小数部分记为0，如果该整数所占的空间超过浮点类型的容量，精度可能损失&lt;/li&gt;
&lt;li&gt;当我们赋给无符号类型一个超过它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数&lt;/li&gt;
&lt;li&gt;当我们赋给带符号类型一个超出它表示范围的值时，结果是未定义的。此时，程序可能继续工作、可能崩溃，也可能生成垃圾数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;当一个算术表达式中既有无符号数又有&lt;code&gt;int&lt;/code&gt;值时，那个&lt;code&gt;int&lt;/code&gt;会转换成无符号数。把&lt;code&gt;int&lt;/code&gt;转换成无符号数的过程和把&lt;code&gt;int&lt;/code&gt;赋值给无符号变量一样&lt;/li&gt;
&lt;li&gt;当从一个无符号数中减去一个值时，我们必须确保结果不是负值，否则实际结果会是取模后的值&lt;/li&gt;
&lt;li&gt;字面值常量&lt;ul&gt;
&lt;li&gt;整型和浮点型字面值&lt;/li&gt;
&lt;li&gt;字符和字符串字面值&lt;ul&gt;
&lt;li&gt;‘a’ 和“a”，字符串字面值最后补’\0’&lt;/li&gt;
&lt;li&gt;如果两个字符串字面值位置紧邻且仅由空格、缩进和换行分隔，则它们是一个整体&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;布尔字面值：&lt;code&gt;true&lt;/code&gt;、&lt;code&gt;false&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;指针字面值：&lt;code&gt;nullptr&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;指定字面值的类型&lt;ul&gt;
&lt;li&gt;字符和字符串字面值&lt;ul&gt;
&lt;li&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;前缀&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;u&lt;/td&gt;
&lt;td&gt;char16_t&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;U&lt;/td&gt;
&lt;td&gt;char32_t&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;L&lt;/td&gt;
&lt;td&gt;wchar_t&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;u8&lt;/td&gt;
&lt;td&gt;char&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;整型字面值&lt;ul&gt;
&lt;li&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;后缀&lt;/th&gt;
&lt;th&gt;最小匹配类型&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;u或U&lt;/td&gt;
&lt;td&gt;unsigned&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;l或L&lt;/td&gt;
&lt;td&gt;long&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ll或LL&lt;/td&gt;
&lt;td&gt;long long&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;浮点型字面值&lt;ul&gt;
&lt;li&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;后缀&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;f或F&lt;/td&gt;
&lt;td&gt;float&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;l或L&lt;/td&gt;
&lt;td&gt;long double&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;列表初始化： &lt;code&gt;int units_sold{0}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;列表初始化的重要特点：如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将报错&lt;/li&gt;
&lt;li&gt;默认初始化&lt;ul&gt;
&lt;li&gt;内置类型变量&lt;ul&gt;
&lt;li&gt;定义于任何函数之外，初始化为0&lt;/li&gt;
&lt;li&gt;定义于函数体内的局部静态变量，初始化为0&lt;/li&gt;
&lt;li&gt;定义于函数体内的非局部静态变量，不被初始化，试图拷贝或以其他方式访问此类值将引发错误&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;每个类各自决定其初始化对象的方式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;分离式编译：将程序分割为若干个文件，每个文件可被独立编译&lt;/li&gt;
&lt;li&gt;声明：&lt;code&gt;extern int i;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;extern语句如果包含初始值就不再是声明，而变成定义了：&lt;code&gt;extern int i = 0;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在函数体内部，试图初始化一个由&lt;code&gt;extern&lt;/code&gt;关键字标记的变量将引发错误&lt;/li&gt;
&lt;li&gt;静态类型语言：在编译阶段执行类型检查&lt;/li&gt;
&lt;li&gt;C++ 标识符：字母、数字、下划线，必须以字母或下划线开头，长度无限制，大小写敏感&lt;/li&gt;
&lt;li&gt;C++ 为标准库保留了一些名字&lt;ul&gt;
&lt;li&gt;自定义标识符中不能连续出现两个下划线&lt;/li&gt;
&lt;li&gt;不能以下划线紧接大写字母开头&lt;/li&gt;
&lt;li&gt;定义在函数体外的函数不能以下划线开头&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;作用域操作符 ::，若左侧为空，则指代全局作用域&lt;/li&gt;
&lt;li&gt;复合类型：&lt;ul&gt;
&lt;li&gt;引用&lt;ul&gt;
&lt;li&gt;&lt;code&gt;int &amp;amp;b = a;&lt;/code&gt;b指向a&lt;/li&gt;
&lt;li&gt;引用必须初始化&lt;/li&gt;
&lt;li&gt;引用本身不是一个对象，不能定义引用的引用&lt;/li&gt;
&lt;li&gt;引用必须绑定到对象上，不能绑定到字面值或者某个表达式的计算结果上&lt;/li&gt;
&lt;li&gt;除了两种例外，所有引用的类型都要和它所绑定的对象严格匹配&lt;ul&gt;
&lt;li&gt;初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可&lt;/li&gt;
&lt;li&gt;允许将基类的引用绑定到派生类上&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;指针&lt;ul&gt;
&lt;li&gt;&lt;code&gt;int *b = &amp;amp;a;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;指针是一个对象&lt;/li&gt;
&lt;li&gt;在块作用域内定义的指针如果未初始化，将拥有一个不确定的值&lt;/li&gt;
&lt;li&gt;除了两种例外，所有指针的类型都要和它所指向的对象严格匹配&lt;ul&gt;
&lt;li&gt;允许一个指向常量的指针指向一个非常量对象&lt;/li&gt;
&lt;li&gt;允许将基类的指针绑定到派生类上&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;试图拷贝或以其他方式访问无效指针的值将引起错误，编译器不负责检查此类错误&lt;/li&gt;
&lt;li&gt;任何非零的指针对应的条件值都是true&lt;/li&gt;
&lt;li&gt;合法指针可以比较大小：== 或 !=&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void *&lt;/code&gt;是一个特殊的指针类型，可用于存放任意对象的地址&lt;ul&gt;
&lt;li&gt;拿它和别的指针比较&lt;/li&gt;
&lt;li&gt;作为函数的输入或输出&lt;/li&gt;
&lt;li&gt;赋给另外一个&lt;code&gt;void *&lt;/code&gt;指针&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;理解复合类型的声明&lt;ul&gt;
&lt;li&gt;变量的定义包括一个基本数据类型和一组声明符&lt;/li&gt;
&lt;li&gt;一条定义语句可能定义出不同类型的变量：&lt;code&gt;int i = 1024, *p = &amp;amp;i, &amp;amp;r =i;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;面对一条比较复杂的指针或者引用的声明语句时，从右往左阅读有助于弄清楚它的真实含义，例如：&lt;code&gt;int \*&amp;amp;r;&lt;/code&gt;首先 r 是一个引用，其次 r 是一个指针的引用，再次 r 是一个指向整型指针的引用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const&lt;/code&gt;限定符&lt;ul&gt;
&lt;li&gt;因为&lt;code&gt;const&lt;/code&gt;对象一旦创建就无法改变其值，所以必须初始化&lt;/li&gt;
&lt;li&gt;当用一个对象去初始化另外一个对象，它们是不是&lt;code&gt;const&lt;/code&gt;都无关紧要，常量的特性仅仅在执行改变其值的操作时才会发挥作用&lt;/li&gt;
&lt;li&gt;默认情况下，&lt;code&gt;const&lt;/code&gt;对象仅在文件内有效&lt;/li&gt;
&lt;li&gt;如果想在多个文件之间共享&lt;code&gt;const&lt;/code&gt;对象，必须在变量的定义之前添加&lt;code&gt;extern&lt;/code&gt;关键字&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const&lt;/code&gt;的引用（常量引用）&lt;/li&gt;
&lt;li&gt;常量引用的初始化：初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。尤其，允许为一个常量引用绑定非常量的对象、字面值甚至是一个表达式。实际上是通过绑定到一个临时量对象上实现的&lt;/li&gt;
&lt;li&gt;对&lt;code&gt;const&lt;/code&gt;的引用可能引用一个并非&lt;code&gt;const&lt;/code&gt;的对象，常量引用仅对引用可参与的操作做了限制，对于引用的对象本身是不是常量未做限制&lt;/li&gt;
&lt;li&gt;指针和&lt;code&gt;const&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;指向常量的指针&lt;ul&gt;
&lt;li&gt;允许一个指向常量的指针指向一个非常量对象&lt;/li&gt;
&lt;li&gt;仅对指向常量的指针可参与的操作做了限制，对于指向的对象本身是不是常量未做限制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const&lt;/code&gt;指针&lt;ul&gt;
&lt;li&gt;指针是对象，可以把指针本身定为常量&lt;/li&gt;
&lt;li&gt;常量指针必须初始化，一经初始化就不能再改变&lt;/li&gt;
&lt;li&gt;把*放在&lt;code&gt;const&lt;/code&gt;关键字之前说明指针是一个常量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;顶层和底层&lt;code&gt;const&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;顶层&lt;code&gt;const&lt;/code&gt;：指针本身是个常量&lt;/li&gt;
&lt;li&gt;底层&lt;code&gt;const&lt;/code&gt;：指针所值的对象是一个常量&lt;/li&gt;
&lt;li&gt;更一般的，顶层&lt;code&gt;const&lt;/code&gt;可以表示任意的对象是常量，这一点对任意数据类型都适用。底层&lt;code&gt;const&lt;/code&gt;则与指针和引用等复合类型的基本类型部分有关&lt;/li&gt;
&lt;li&gt;执行对象的拷贝操作时&lt;ul&gt;
&lt;li&gt;顶层&lt;code&gt;const&lt;/code&gt;不受影响&lt;/li&gt;
&lt;li&gt;拷入和拷出的对象必须具有相同的底层&lt;code&gt;const&lt;/code&gt;资格，或者两个对象的数据类型必须能够转换。一般来说，非常量可以转换成常量，反之不行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;constexpr&lt;/code&gt;和常量表达式&lt;ul&gt;
&lt;li&gt;常量表达式：值不会改变并且在编译过程就能得到计算结果的表达式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;constexpr&lt;/code&gt;变量：由编译器来验证变量的值是否是一个常量表达式，声明为&lt;code&gt;constexpr&lt;/code&gt;的变量一定是一个常量，并且必须用常量表达式初始化&lt;/li&gt;
&lt;li&gt;字面值类型：算术类型、引用、指针、字面值常量类、枚举&lt;/li&gt;
&lt;li&gt;声明&lt;code&gt;constexpr&lt;/code&gt;用到的类型为字面值类型&lt;/li&gt;
&lt;li&gt;一个&lt;code&gt;constexpr&lt;/code&gt;指针的初始值必须是&lt;code&gt;nullptr&lt;/code&gt;或者0，或者是存储于某个固定地址中的对象&lt;ul&gt;
&lt;li&gt;函数体内定义的变量一般并非存放在固定地址中，&lt;code&gt;constexpr&lt;/code&gt;指针不能指向这样的变量（局部静态对象除外）&lt;/li&gt;
&lt;li&gt;定义于所有函数体之外的对象地址固定不变，能用来初始化&lt;code&gt;constexpr&lt;/code&gt;指针&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;constexpr&lt;/code&gt;声明中如果定义了一个指针，限定符&lt;code&gt;constexpr&lt;/code&gt;仅对指针有效，与指针所指的对象无关&lt;/li&gt;
&lt;li&gt;&lt;code&gt;constexpr&lt;/code&gt;把它所定义的对象置为顶层&lt;code&gt;const&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;处理类型&lt;ul&gt;
&lt;li&gt;类型别名&lt;ul&gt;
&lt;li&gt;&lt;code&gt;typedef double wages;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;using SI = Sales_item;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;下面两条声明语句的基本数据类型都是&lt;code&gt;const pstring&lt;/code&gt;，&lt;code&gt;const&lt;/code&gt;是对给定类型的修饰，&lt;code&gt;pstring&lt;/code&gt;实际上是指向&lt;code&gt;char&lt;/code&gt;的指针，所以&lt;code&gt;const pstring&lt;/code&gt;是指向&lt;code&gt;char&lt;/code&gt;的常量指针&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;auto&lt;/code&gt;类型说明符&lt;ul&gt;
&lt;li&gt;让编译器自己去分析表达式所属的类型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;auto&lt;/code&gt;也能在一条语句中声明多个变量。因为一条声明语句只能有一个基本数据类型，所以该语句中所有变量的基本数据类型都必须一样&lt;/li&gt;
&lt;li&gt;当引用被用作初始化&lt;code&gt;auto&lt;/code&gt;变量时，编译器以引用所引用对象的类型作为&lt;code&gt;auto&lt;/code&gt;的类型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;auto&lt;/code&gt;一般会忽略顶层&lt;code&gt;const&lt;/code&gt;，同时底层&lt;code&gt;const&lt;/code&gt;会保留下来&lt;/li&gt;
&lt;li&gt;如果希望推断出的&lt;code&gt;auto&lt;/code&gt;类型是一个顶层&lt;code&gt;const&lt;/code&gt;，需要明确指出&lt;/li&gt;
&lt;li&gt;&lt;code&gt;auto&lt;/code&gt;引用&lt;code&gt;auto &amp;amp;b = a;&lt;/code&gt;初始值 a 的顶层&lt;code&gt;const&lt;/code&gt;会保留&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;decltype&lt;/code&gt;类型指示符&lt;ul&gt;
&lt;li&gt;选择并返回操作数的数据类型，编译器分析表达式得到它的类型，却不实际计算表达式的值，编译器并不实际调用f&lt;/li&gt;
&lt;li&gt;如果&lt;code&gt;decltype&lt;/code&gt;使用的表达式是一个变量，则&lt;code&gt;decltype&lt;/code&gt;返回该变量的类型（包括顶层&lt;code&gt;const&lt;/code&gt;和引用在内），需要指出的是，引用从来都作为其所指对象的同义词出现，只有在&lt;code&gt;decltype&lt;/code&gt;处是一个例外&lt;/li&gt;
&lt;li&gt;如果&lt;code&gt;decltype&lt;/code&gt;使用的表达式不是一个变量，则&lt;code&gt;decltype&lt;/code&gt;返回该表达式的结果对应的类型&lt;ul&gt;
&lt;li&gt;因为 r 是一个引用，&lt;code&gt;decltype(r)&lt;/code&gt;的结果是引用类型，如果想让结果类型是 r 所指的类型，可以把 r 作为表达式的一部分，显然这个表达式的结果是一个具体的值而非一个引用&lt;/li&gt;
&lt;li&gt;如果表达式的内容是解引用操作，则&lt;code&gt;decltype&lt;/code&gt;将得到引用类型&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果&lt;code&gt;decltype&lt;/code&gt;使用的表达式是一个变量&lt;ul&gt;
&lt;li&gt;不加括号，得到该变量的类型&lt;/li&gt;
&lt;li&gt;加括号，得到引用类型&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;自定义数据结构&lt;ul&gt;
&lt;li&gt;结构体&lt;/li&gt;
&lt;li&gt;类&lt;/li&gt;
&lt;li&gt;记得定义末尾的分号；&lt;/li&gt;
&lt;li&gt;可以类内初始化&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;头文件保护符&lt;ul&gt;
&lt;li&gt;头文件保护符依赖于预处理变量&lt;/li&gt;
&lt;li&gt;预处理变量由两个状态：已定义和未定义&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#define&lt;/code&gt;指令把一个名字设定为预处理变量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#ifdef&lt;/code&gt;当且仅当变量已定义时为真&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#ifndef&lt;/code&gt;当且仅当变量未定义时为真&lt;/li&gt;
&lt;li&gt;一旦检查结果为真，则执行后续操作直到遇到&lt;code&gt;#endif&lt;/code&gt;指令为止&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</content><category term="C++"></category></entry><entry><title>利用 Mac stat 添加文件创建时间、最后修改时间</title><link href="https://xutree.github.io/pages/2018/10/06/mac-stat/" rel="alternate"></link><published>2018-10-06T19:07:36+08:00</published><updated>2018-10-06T21:34:20+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-06:/pages/2018/10/06/mac-stat/</id><summary type="html">&lt;p&gt;Pelican 根据 &lt;strong&gt;.md&lt;/strong&gt; 文件生成网页的时候需要 metadata，所以写个命令行自动添加文件创建时间、最后修改时间，这样写博客的时候只需要把 title、category 和 tags 标签填上就行了，其中用了 &lt;code&gt;stat&lt;/code&gt;命令。&lt;/p&gt;
&lt;h2&gt;自动添加文件创建时间、最后修改时间&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;stat&lt;/code&gt;命令的 &lt;em&gt;a, m, c, B&lt;/em&gt; 参数分别代表上次访问或修改时间文件，上次更改 inode 的时间或 inode 的生成时间（ UNIX 时间戳），所以我们可以通过提取这些信息实现想要的功能。唯一需要注意的是，结果是UNIX时间戳，我们需要将其转换为普通时间。&lt;/p&gt;
&lt;p&gt;UNIX 时间，或称 POSIX 时间是 UNIX 或类 UNIX 系统使用的时间表示方式：从协调世界时1970年1月1日0时0分0秒起至现在的总秒数，不考虑闰秒。在多数 UNIX 系统上 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Pelican 根据 &lt;strong&gt;.md&lt;/strong&gt; 文件生成网页的时候需要 metadata，所以写个命令行自动添加文件创建时间、最后修改时间，这样写博客的时候只需要把 title、category 和 tags 标签填上就行了，其中用了 &lt;code&gt;stat&lt;/code&gt;命令。&lt;/p&gt;
&lt;h2&gt;自动添加文件创建时间、最后修改时间&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;stat&lt;/code&gt;命令的 &lt;em&gt;a, m, c, B&lt;/em&gt; 参数分别代表上次访问或修改时间文件，上次更改 inode 的时间或 inode 的生成时间（ UNIX 时间戳），所以我们可以通过提取这些信息实现想要的功能。唯一需要注意的是，结果是UNIX时间戳，我们需要将其转换为普通时间。&lt;/p&gt;
&lt;p&gt;UNIX 时间，或称 POSIX 时间是 UNIX 或类 UNIX 系统使用的时间表示方式：从协调世界时1970年1月1日0时0分0秒起至现在的总秒数，不考虑闰秒。在多数 UNIX 系统上 UNIX 时间可以通过&lt;code&gt;date +%s&lt;/code&gt;指令来检查。&lt;/p&gt;
&lt;p&gt;在 Mac 系统是由 UNIX 时间戳转化为普通时间的指令为：
&lt;img alt="UNIX 时间戳转化为普通时间" src="https://xutree.github.io/images/fig7.png"&gt;&lt;/p&gt;
&lt;p&gt;所以我们先根据&lt;code&gt;stat&lt;/code&gt;获得文件的创建时间：
&lt;img alt="根据stat获得文件的创建时间" src="https://xutree.github.io/images/fig8.png"&gt;&lt;/p&gt;
&lt;p&gt;然后转化为普通时间：
&lt;img alt="转化为普通时间" src="https://xutree.github.io/images/fig9.png"&gt;&lt;/p&gt;
&lt;p&gt;以下为脚本：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#! /bin/bash&lt;/span&gt;

&lt;span class="c1"&gt;# 输入：需要修改的文件&lt;/span&gt;
&lt;span class="nv"&gt;filename&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nv"&gt;$1&lt;/span&gt;

&lt;span class="c1"&gt;# 提取创建时间&lt;/span&gt;
&lt;span class="nv"&gt;create_time&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;date  -r&lt;span class="k"&gt;$(&lt;/span&gt;stat -f &lt;span class="s2"&gt;&amp;quot;%B&amp;quot;&lt;/span&gt; &lt;span class="nv"&gt;$filename&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;+%Y-%m-%d %H:%M:%S&amp;quot;&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;# 提取修改时间&lt;/span&gt;
&lt;span class="nv"&gt;modify_time&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;date  -r&lt;span class="k"&gt;$(&lt;/span&gt;stat -f &lt;span class="s2"&gt;&amp;quot;%m&amp;quot;&lt;/span&gt; &lt;span class="nv"&gt;$filename&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;+%Y-%m-%d %H:%M:%S&amp;quot;&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;# 查找Date标签的行号&lt;/span&gt;
&lt;span class="nv"&gt;num1&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;head -5 &lt;span class="nv"&gt;$filename&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; grep -n &lt;span class="s1"&gt;&amp;#39;Date&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; cut -d &lt;span class="s2"&gt;&amp;quot;:&amp;quot;&lt;/span&gt; -f &lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;# 查找Modified标签的行号&lt;/span&gt;
&lt;span class="nv"&gt;num2&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;$(&lt;/span&gt;head -5 &lt;span class="nv"&gt;$filename&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; grep -n &lt;span class="s1"&gt;&amp;#39;Modified&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;|&lt;/span&gt; cut -d &lt;span class="s2"&gt;&amp;quot;:&amp;quot;&lt;/span&gt; -f &lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="k"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;# 如果Date标签行号为空，说明不存在Date标签，则插入Date&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; -z &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$num1&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;then&lt;/span&gt;
    sed -i &lt;span class="s1"&gt;&amp;#39;&amp;#39;&lt;/span&gt; -e &lt;span class="s2"&gt;&amp;quot;2s/^//p; 2s/^.*/Date: &lt;/span&gt;&lt;span class="nv"&gt;$create_time&lt;/span&gt;&lt;span class="s2"&gt;/&amp;quot;&lt;/span&gt; &lt;span class="nv"&gt;$filename&lt;/span&gt;   
&lt;span class="k"&gt;fi&lt;/span&gt;
&lt;span class="c1"&gt;# 如果Modified标签行号为空，插入Modified&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; -z &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$num2&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;then&lt;/span&gt;
    sed -i &lt;span class="s1"&gt;&amp;#39;&amp;#39;&lt;/span&gt; -e &lt;span class="s2"&gt;&amp;quot;3s/^//p; 3s/^.*/Modified: &lt;/span&gt;&lt;span class="nv"&gt;$modify_time&lt;/span&gt;&lt;span class="s2"&gt;/&amp;quot;&lt;/span&gt; &lt;span class="nv"&gt;$filename&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;
    &lt;span class="c1"&gt;# 否则，替换Modified标签到最新时间&lt;/span&gt;
    sed -i &lt;span class="s1"&gt;&amp;#39;&amp;#39;&lt;/span&gt; &lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;num2&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;d &lt;span class="nv"&gt;$filename&lt;/span&gt;
    sed -i &lt;span class="s1"&gt;&amp;#39;&amp;#39;&lt;/span&gt; -e &lt;span class="s2"&gt;&amp;quot;3s/^//p; 3s/^.*/Modified: &lt;/span&gt;&lt;span class="nv"&gt;$modify_time&lt;/span&gt;&lt;span class="s2"&gt;/&amp;quot;&lt;/span&gt; &lt;span class="nv"&gt;$filename&lt;/span&gt;
&lt;span class="k"&gt;fi&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

&lt;h2&gt;附：stat 命令详情&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;stat&lt;/code&gt;显示有关文件的信息。 不需要读取，写入或执行指定文件的权限，但必须可搜索通向该文件的路径名中列出的所有目录。 如果没有给出参数，&lt;code&gt;stat&lt;/code&gt;将显示有关标准输入的文件描述符（stdin）的信息。&lt;/p&gt;
&lt;p&gt;当作为&lt;code&gt;readlink&lt;/code&gt;调用时，仅打印符号链接的目标。 如果给定的参数不是符号链接，则&lt;code&gt;readlink&lt;/code&gt;将不打印任何内容并退出并显示错误。&lt;/p&gt;
&lt;p&gt;显示的信息是通过使用给定参数调用&lt;code&gt;lstat&lt;/code&gt;系统调用并解释返回的结构来获得的。&lt;/p&gt;
&lt;h3&gt;参数&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;-F&lt;/strong&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;与&lt;code&gt;ls&lt;/code&gt;命令的 &lt;strong&gt;-F&lt;/strong&gt; 参数一样，在作为目录的每个路径名之后显示斜杠（'/'），在每个可执行的路径名后面显示星号（'*'），在每个符号链接后显示at符号（'@'）， 在每个without文件后面显示百分号（'％'），每个套接字后显示等号（'='），以及在每个FIFO文件后面显示一个垂直条（'|'）。 &lt;strong&gt;-F&lt;/strong&gt; 的使用意味着 &lt;strong&gt;-l&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;-f&lt;/strong&gt; &lt;em&gt;format&lt;/em&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;使用指定的格式显示信息&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;-L&lt;/strong&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;使用&lt;code&gt;stat&lt;/code&gt;而不是&lt;code&gt;lstat&lt;/code&gt;。 如果文件是符号链接，则stat给出的信息是链接文件目标文件的信息，而不是链接文件本身&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;-l&lt;/strong&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;将输出以&lt;code&gt;ls -lT&lt;/code&gt;格式显示，即显示文件的完整时间信息，包括月，日，小时，分钟，秒和年&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;-n&lt;/strong&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;输出不强制换行&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;-q&lt;/strong&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;如果对&lt;code&gt;stat&lt;/code&gt;或&lt;code&gt;lstat&lt;/code&gt;的调用失败，则不显示失败消息。以&lt;code&gt;readlink&lt;/code&gt;方式运行时，会自动禁止错误消息&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;-r&lt;/strong&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;显示原始信息。即，对于stat结构（UNIX/Linux系统中定义的结构体）中的所有字段，显示原始数值（例如，自纪元以来的秒数等）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;-s&lt;/strong&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在“shell输出”中显示信息，适用于初始化变量&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;-t&lt;/strong&gt; &lt;em&gt;timefmt&lt;/em&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;使用指定的格式显示时间戳。 此格式直接传递给&lt;code&gt;strftime&lt;/code&gt;命令&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;-x&lt;/strong&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;从某些Linux发行版中以更详细的方式显示信息&lt;/p&gt;
&lt;h3&gt;格式&lt;/h3&gt;
&lt;p&gt;格式字符串类似于&lt;code&gt;printf&lt;/code&gt;格式，因为它们以 ％ 开头，然后是一系列格式化字符，最后是一个字符，用于选择要格式化的 struct stat 字段。 如果 ％ 后面紧跟 n，t，％ 或 @ 之一，则会打印换行符，制表符，百分号或当前文件号，否则将检查字符串是否包含以下内容：&lt;/p&gt;
&lt;p&gt;以下是任何可选标志：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;#&lt;/strong&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;为八进制和十六进制输出选择备用输出形式。 非零八进制输出将具有前导零，并且非零十六进制输出将具有前缀“0x”&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;+&lt;/strong&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;断言应始终打印指示数字是正数还是负数的符号。 非负数通常不打印带符号&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;-&lt;/strong&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;将字符串输出对齐到字段的左侧，而不是右侧&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;0&lt;/strong&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;将左边距的填充字符设置为“0”字符，而不是空格&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;space&lt;/strong&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;在非负有符号输出字段的前面保留一个空格。 如果同时使用&lt;strong&gt;‘+’&lt;/strong&gt; ，则&lt;strong&gt;‘+’&lt;/strong&gt; 将覆盖空格&lt;/p&gt;
&lt;p&gt;以下是任何可选字段：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;size&lt;/em&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;可选的十进制数字字符串，指定最小字段宽度&lt;/p&gt;
&lt;p&gt;&lt;em&gt;prec&lt;/em&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;由小数点'.'和十进制数字字符串组成的可选精度，指示最大字符串长度，浮点输出中小数点后出现的位数，或数字输出中显示的最小位数&lt;/p&gt;
&lt;p&gt;&lt;em&gt;fmt&lt;/em&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;可选的输出格式说明符，它是D，O，U，X，F 或 S 之一。它们分别表示带符号的十进制输出，八进制输出，无符号十进制输出，十六进制输出，浮点输出和字符串输出。 某些输出格式不适用于所有字段。 浮点输出仅适用于 timespec 字段（a，m 和 c 字段）。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;特殊输出说明符S可用于指示输出（如果适用）应为字符串格式。 可与以下标志结合使用：&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;em&gt;amc&lt;/em&gt; 以&lt;code&gt;strftime&lt;/code&gt;格式显示日期&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;em&gt;dr&lt;/em&gt; 显示实际设备名称&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;em&gt;gu&lt;/em&gt; 显示组或用户名&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;em&gt;p&lt;/em&gt; 以&lt;code&gt;ls -lTd&lt;/code&gt;显示文件模式&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;em&gt;N&lt;/em&gt; 显示文件名&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;em&gt;T&lt;/em&gt; 显示文件类型&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;em&gt;Y&lt;/em&gt; 在输出中插入“ -&amp;gt; ”。 请注意，&lt;em&gt;Y&lt;/em&gt; 的默认输出格式是字符串，但如果明确指定，则会预先添加这四个字符&lt;/p&gt;
&lt;p&gt;&lt;em&gt;sub&lt;/em&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;可选的子字段说明符（高，中，低）。仅适用于 p，d，r 和 T 输出格式。 它可以是以下之一：&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;em&gt;H&lt;/em&gt; “高”，指定来自 r 或 d 的设备的主要编号，来自 p 的字符串形式的权限的“用户”位，来自 p 的数字形式的文件“type”位，以及 T 的长输出形式&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;em&gt;L&lt;/em&gt; “低”，指定来自 r 或 d 的设备的次要编号，来自 p 的字符串形式的权限的“其他”位，来自 p 的数字形式的“用户”，“组”和“其他”位， 当与 T 一起使用时，文件类型的&lt;code&gt;ls -F&lt;/code&gt;样式输出字符（对此使用 L 是可选的）&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;em&gt;M&lt;/em&gt; “中”，指定 p 的字符串输出形式的权限的“组”位，或 p 的数字形式的 “suid”，“sgid” 和 “sticky” 位&lt;/p&gt;
&lt;p&gt;&lt;em&gt;datum&lt;/em&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;必填字段说明符，是以下之一：&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;em&gt;d&lt;/em&gt; 文件所在的设备&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;em&gt;i&lt;/em&gt; 文件的inode编号&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;em&gt;p&lt;/em&gt; 文件类型和权限&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;em&gt;l&lt;/em&gt; 文件的硬链接数&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;em&gt;u, g&lt;/em&gt; 文件所有者的用户ID和组ID&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;em&gt;r&lt;/em&gt; 字符和块设备专用文件的设备编号&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;em&gt;a, m, c, B&lt;/em&gt; 上次访问或修改时间文件，上次更改 inode 的时间或 inode 的生成时间（UNIX时间戳）&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;em&gt;z&lt;/em&gt; 文件大小（以字节为单位）&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;em&gt;b&lt;/em&gt; 分配给文件的块数&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;em&gt;k&lt;/em&gt; 最佳文件系统I / O操作块大小&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;em&gt;f&lt;/em&gt; 用户定义的文件标志&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;em&gt;v&lt;/em&gt; Inode 生成号&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;以下四个字段说明符不是直接从struct stat中的数据中提取的，而是：&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;em&gt;N&lt;/em&gt; 文件的名称&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;em&gt;T&lt;/em&gt; 文件类型，类似&lt;code&gt;ls -F&lt;/code&gt;，如果给出子字段说明符H，则采用更具描述性的形式。&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;em&gt;Y&lt;/em&gt; 符号链接的目标&lt;/p&gt;
&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;em&gt;Z&lt;/em&gt; 从字符或块特殊设备的rdev字段扩展为“major，minor”，并为所有其他设备提供大小输出&lt;/p&gt;
&lt;p&gt;只有 ％ 和字段说明符是必需的。大多数字段说明符默认为 U 作为输出形式；p 默认输出形式是 O；a、m、c 默认输出形式是 D，Y、T、N 默认输出形式是 S。&lt;/p&gt;</content><category term="Mac"></category><category term="UNIX"></category></entry><entry><title>【读书笔记】C++ Primer 第一章</title><link href="https://xutree.github.io/pages/2018/10/05/C++_Primer_Chapter_1/" rel="alternate"></link><published>2018-10-05T23:11:35+08:00</published><updated>2018-10-06T22:02:49+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-05:/pages/2018/10/05/C++_Primer_Chapter_1/</id><summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;code&gt;main&lt;/code&gt;函数的返回类型必须为&lt;code&gt;int&lt;/code&gt;，返回值0表示成功，非0的含义由系统定义，通常用来指出错误类型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;g++ -std=c++14  -Wall -o test test.cpp&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iostream&lt;/code&gt; &lt;code&gt;cin&lt;/code&gt; &lt;code&gt;cout&lt;/code&gt; &lt;code&gt;cerr&lt;/code&gt; &lt;code&gt;clog&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;运算符返回其左侧的运算对象&lt;/li&gt;
&lt;li&gt;写入&lt;code&gt;endl&lt;/code&gt;的效果是结束当前行，并将与设备关联的缓冲区中的内容刷到设备中。缓冲刷新操作可以保证到目前为止程序所产生的所有输出都真正写入到输出流中，而不是仅停留在内存中等待写入流&lt;/li&gt;
&lt;li&gt;小心程序崩溃，输出可能还留在缓冲区的情况，利用&lt;code&gt;endl&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;标准库定义的所有名字都在命名空间&lt;code&gt;std&lt;/code&gt;中&lt;/li&gt;
&lt;li&gt;当我们使用一个&lt;code&gt;istream&lt;/code&gt;对象作为条件时，其效果是检测流的状态。流有效，即流未遇到错误，那么检测成功。当遇到文件结束符（end of file），或遇到一个无效输入时，&lt;code&gt;istream&lt;/code&gt;对象的状态会变为无效。无效的&lt;code&gt;istream …&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;ul&gt;
&lt;li&gt;&lt;code&gt;main&lt;/code&gt;函数的返回类型必须为&lt;code&gt;int&lt;/code&gt;，返回值0表示成功，非0的含义由系统定义，通常用来指出错误类型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;g++ -std=c++14  -Wall -o test test.cpp&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iostream&lt;/code&gt; &lt;code&gt;cin&lt;/code&gt; &lt;code&gt;cout&lt;/code&gt; &lt;code&gt;cerr&lt;/code&gt; &lt;code&gt;clog&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;运算符返回其左侧的运算对象&lt;/li&gt;
&lt;li&gt;写入&lt;code&gt;endl&lt;/code&gt;的效果是结束当前行，并将与设备关联的缓冲区中的内容刷到设备中。缓冲刷新操作可以保证到目前为止程序所产生的所有输出都真正写入到输出流中，而不是仅停留在内存中等待写入流&lt;/li&gt;
&lt;li&gt;小心程序崩溃，输出可能还留在缓冲区的情况，利用&lt;code&gt;endl&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;标准库定义的所有名字都在命名空间&lt;code&gt;std&lt;/code&gt;中&lt;/li&gt;
&lt;li&gt;当我们使用一个&lt;code&gt;istream&lt;/code&gt;对象作为条件时，其效果是检测流的状态。流有效，即流未遇到错误，那么检测成功。当遇到文件结束符（end of file），或遇到一个无效输入时，&lt;code&gt;istream&lt;/code&gt;对象的状态会变为无效。无效的&lt;code&gt;istream&lt;/code&gt;对象会使条件为假&lt;/li&gt;
&lt;li&gt;文件结束符：Windows 先Ctrl + Z，后Enter 或 Return；UNIX：Ctrl +D&lt;/li&gt;
&lt;li&gt;标准库文件通常不带后缀。编译器一般不关心头文件名的形式，但有的IDE对此有特定要求&lt;/li&gt;
&lt;li&gt;头文件包含：标准库头文件 &amp;lt;&amp;gt;     非标准库头文件 ""&lt;/li&gt;
&lt;li&gt;文件重定向：从文件读入\&amp;lt;infile，输出到文件&gt;outfile&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;C++里关于&lt;code&gt;cerr&lt;/code&gt;, &lt;code&gt;clog&lt;/code&gt;, &lt;code&gt;cout&lt;/code&gt;三者的区别:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cerr&lt;/code&gt;(无缓冲标准错误) 没有缓冲，发送给它的内容立即被输出&lt;/li&gt;
&lt;li&gt;&lt;code&gt;clog&lt;/code&gt;(缓冲标准错误)  有缓冲，缓冲区满时输出&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cout&lt;/code&gt;标准输出&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cout&lt;/code&gt;是在终端显示器输出，&lt;code&gt;cout&lt;/code&gt;流在内存中对应开辟了一个缓冲区，用来存放流中的数据，当向&lt;code&gt;cout&lt;/code&gt;流插入一个&lt;code&gt;endl&lt;/code&gt;，不论缓冲区是否满了，都立即输出流中所有数据，然后插入一个换行符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cerr&lt;/code&gt;流对象是标准错误流，指定为和显示器关联，和&lt;code&gt;cout&lt;/code&gt;作用差不多，有点不同就是&lt;code&gt;cout&lt;/code&gt;通常是传到显示器输出，但可以被重定向输出到文件，而&lt;code&gt;cerr&lt;/code&gt;流中的信息只能在显示器输出&lt;/li&gt;
&lt;li&gt;&lt;code&gt;clog&lt;/code&gt;流也是标准错误流，作用和&lt;code&gt;cerr&lt;/code&gt;一样，区别在于&lt;code&gt;cerr&lt;/code&gt;不经过缓冲区，直接向显示器输出信息，而&lt;code&gt;clog&lt;/code&gt;中的信息存放在缓冲区，缓冲区满或者遇到&lt;code&gt;endl&lt;/code&gt;时才输出&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于为什么有&lt;code&gt;cerr&lt;/code&gt;和&lt;code&gt;clog&lt;/code&gt;？比如，你的程序遇到调用栈用完了的威胁（无限，没有出口的递归。你说，你到什么地方借内存，存放你的错误信息？所以有了&lt;code&gt;cerr&lt;/code&gt;。其目的，就是在你最需要它的紧急情况下，还能得到输出功能的支持&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;缓冲区的目的，就是减少刷屏的次数——比如，你的程序输出圣经中的一篇文章。不带缓冲的话，就会每写一个字母，就输出一个字母，然后刷屏。有了缓冲，你将看到若干句子“同时”就出现在了屏幕上（由内存翻新到显存，然后刷新屏幕）&lt;/li&gt;
&lt;/ul&gt;</content><category term="C++"></category></entry><entry><title>HTML 入门</title><link href="https://xutree.github.io/pages/2018/10/05/html-overview/" rel="alternate"></link><published>2018-10-05T17:23:00+08:00</published><updated>2018-10-06T21:20:21+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-05:/pages/2018/10/05/html-overview/</id><summary type="html">&lt;p&gt;&lt;strong&gt;HTML&lt;/strong&gt;，即超文本标记语言（&lt;strong&gt;H&lt;/strong&gt;yper&lt;strong&gt;T&lt;/strong&gt;ext &lt;strong&gt;M&lt;/strong&gt;arkup &lt;strong&gt;L&lt;/strong&gt;anguage）。与脚本或编程语言不同，标记语言使用标记（&lt;strong&gt;tag&lt;/strong&gt;）来标识内容。&lt;/p&gt;
&lt;p&gt;下面是一个 HTML tag 的例子：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;p&amp;gt; 这是一个段落。&amp;lt;/p&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt;称为开始标签，&lt;code&gt;&amp;lt;/p&amp;gt;&lt;/code&gt;称为结束标签。&lt;/p&gt;
&lt;h2&gt;网页的结构&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;HTML：结构&lt;/li&gt;
&lt;li&gt;CSS：样式&lt;/li&gt;
&lt;li&gt;JavaScript：行为&lt;/li&gt;
&lt;li&gt;PHP 或类似语言：后端&lt;/li&gt;
&lt;li&gt;CMS：内容管理&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;基本 HTML 文件结构&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;标签&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;html&amp;gt;&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;HTML文件的所有内容都包含在其中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;head&amp;gt;&amp;lt;/head&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;HTML文件的头部包含有助于使页面工作的所有非可视元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;body&amp;gt;&amp;lt;/body …&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</summary><content type="html">&lt;p&gt;&lt;strong&gt;HTML&lt;/strong&gt;，即超文本标记语言（&lt;strong&gt;H&lt;/strong&gt;yper&lt;strong&gt;T&lt;/strong&gt;ext &lt;strong&gt;M&lt;/strong&gt;arkup &lt;strong&gt;L&lt;/strong&gt;anguage）。与脚本或编程语言不同，标记语言使用标记（&lt;strong&gt;tag&lt;/strong&gt;）来标识内容。&lt;/p&gt;
&lt;p&gt;下面是一个 HTML tag 的例子：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;p&amp;gt; 这是一个段落。&amp;lt;/p&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt;称为开始标签，&lt;code&gt;&amp;lt;/p&amp;gt;&lt;/code&gt;称为结束标签。&lt;/p&gt;
&lt;h2&gt;网页的结构&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;HTML：结构&lt;/li&gt;
&lt;li&gt;CSS：样式&lt;/li&gt;
&lt;li&gt;JavaScript：行为&lt;/li&gt;
&lt;li&gt;PHP 或类似语言：后端&lt;/li&gt;
&lt;li&gt;CMS：内容管理&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;基本 HTML 文件结构&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;标签&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;html&amp;gt;&amp;lt;/html&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;HTML文件的所有内容都包含在其中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;head&amp;gt;&amp;lt;/head&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;HTML文件的头部包含有助于使页面工作的所有非可视元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;body&amp;gt;&amp;lt;/body&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;所有可视化元素都包含在body标签中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;包含网页选项卡上现实的标题内容&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;下面是 HTML 版本的“Hello, World！”程序：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
      Hello World!
   &lt;span class="nt"&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;字体标签&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;标签&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;p&amp;gt;&amp;lt;/p&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;段落标签（浏览器会在段落前后自动添加空行）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;br /&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;换行而不开启新段落（它没有结束标记）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;b&amp;gt;&amp;lt;/b&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;粗体&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;big&amp;gt;&amp;lt;/big&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;大号文本&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;i&amp;gt;&amp;lt;/i&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;斜体&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;small&amp;gt;&amp;lt;/small&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;小号文本&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;strong&amp;gt;&amp;lt;/strong&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;强调（一种phrase tag）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;sub&amp;gt;&amp;lt;/sub&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;下标&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;sup&amp;gt;&amp;lt;/sup&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;上标&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;ins&amp;gt;&amp;lt;/ins&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;插入线&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;del&amp;gt;&amp;lt;/del&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;删除线&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;浏览器将&lt;code&gt;&amp;lt;strong&amp;gt;&lt;/code&gt;显示为&lt;code&gt;&amp;lt;b&amp;gt;&lt;/code&gt;，将&lt;code&gt;&amp;lt;em&amp;gt;&lt;/code&gt;显示为&lt;code&gt;&amp;lt;i&amp;gt;&lt;/code&gt;。但是，这些标记的含义不同：&lt;code&gt;&amp;lt;b&amp;gt;&lt;/code&gt;和&lt;code&gt;&amp;lt;i&amp;gt;&lt;/code&gt;分别定义粗体和斜体文本，而&lt;code&gt;&amp;lt;strong&amp;gt;&lt;/code&gt;和&lt;code&gt;&amp;lt;em&amp;gt;&lt;/code&gt;表示文本“重要”。&lt;/p&gt;
&lt;h2&gt;标题标签&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;h1&amp;gt;&amp;lt;/h1&amp;gt;&lt;/code&gt;，&lt;code&gt;&amp;lt;h2&amp;gt;&amp;lt;/h2&amp;gt;&lt;/code&gt;，&lt;code&gt;&amp;lt;h3&amp;gt;&amp;lt;/h3&amp;gt;&lt;/code&gt;，&lt;code&gt;&amp;lt;h4&amp;gt;&amp;lt;/h4&amp;gt;&lt;/code&gt;，&lt;code&gt;&amp;lt;h5&amp;gt;&amp;lt;/h5&amp;gt;&lt;/code&gt;，&lt;code&gt;&amp;lt;h6&amp;gt;&amp;lt;/h6&amp;gt;&lt;/code&gt;六种标题，&lt;code&gt;&amp;lt;h1&amp;gt;&amp;lt;/h1&amp;gt;&lt;/code&gt;字号最大。&lt;/p&gt;
&lt;h2&gt;标签属性&lt;/h2&gt;
&lt;p&gt;属性提供有关元素或标记的附加信息，同时还可以修改它们。例如&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;p&lt;/span&gt; &lt;span class="na"&gt;align=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;center&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
   This text is aligned to center
&lt;span class="nt"&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;会将段落居中显示（&lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt;标签的align属性在HTML5中不再支持）。&lt;/p&gt;
&lt;p&gt;属性的数值可以通过像素或百分比指定，如&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;hr width=&amp;quot;50px&amp;quot; /&amp;gt;
&amp;lt;hr width=&amp;quot;50%&amp;quot; /&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;图像标签&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;img src="" height="" width="" border="" alt=""/&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;src：图像名称&lt;/p&gt;
&lt;p&gt;height：图像高&lt;/p&gt;
&lt;p&gt;width：图像宽&lt;/p&gt;
&lt;p&gt;border：边界宽度&lt;/p&gt;
&lt;p&gt;alt：如果无法显示图像，则alt属性指定以单词形式描述图像的替代文本&lt;/p&gt;
&lt;h2&gt;链接标签&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;a href="" target=""&amp;gt;&amp;lt;/a&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;href：目标网址&lt;/p&gt;
&lt;p&gt;target：指定打开链接文档的位置，_blank值将在新窗口或新标签中打开链接&lt;/p&gt;
&lt;h2&gt;列表标签&lt;/h2&gt;
&lt;h3&gt;有序列表&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;title&amp;gt;&lt;/span&gt;first page&lt;span class="nt"&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;ol&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;li&amp;gt;&lt;/span&gt;Red&lt;span class="nt"&gt;&amp;lt;/li&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;li&amp;gt;&lt;/span&gt;Blue&lt;span class="nt"&gt;&amp;lt;/li&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;li&amp;gt;&lt;/span&gt;Green&lt;span class="nt"&gt;&amp;lt;/li&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;/ol&amp;gt;&lt;/span&gt;  
   &lt;span class="nt"&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;无序列表&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;title&amp;gt;&lt;/span&gt;first page&lt;span class="nt"&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;        
   &lt;span class="nt"&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;ul&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;li&amp;gt;&lt;/span&gt;Red&lt;span class="nt"&gt;&amp;lt;/li&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;li&amp;gt;&lt;/span&gt;Blue&lt;span class="nt"&gt;&amp;lt;/li&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;li&amp;gt;&lt;/span&gt;Green&lt;span class="nt"&gt;&amp;lt;/li&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;/ul&amp;gt;&lt;/span&gt;  
   &lt;span class="nt"&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;表格标签&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;table&lt;/span&gt;  &lt;span class="na"&gt;border=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;align=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;tr&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;td&lt;/span&gt; &lt;span class="na"&gt;bgcolor=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;red&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;Red&lt;span class="nt"&gt;&amp;lt;/td&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;td&amp;gt;&lt;/span&gt;Blue&lt;span class="nt"&gt;&amp;lt;/td&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;td&amp;gt;&lt;/span&gt;Green&lt;span class="nt"&gt;&amp;lt;/td&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;tr&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;td&amp;gt;&lt;/span&gt;Yellow&lt;span class="nt"&gt;&amp;lt;/td&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;td&lt;/span&gt; &lt;span class="na"&gt;colspan=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;2&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;Orange&lt;span class="nt"&gt;&amp;lt;/td&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;/tr&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/table&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;其他&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;标签&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;hr /&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;水平线&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;!--...--&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;注释&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;HTML 元素类型&lt;/h2&gt;
&lt;p&gt;在 HTML 中，大多数元素被定义为块级或内联元素。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;块级元素从新行开始，如&lt;code&gt;&amp;lt;h1&amp;gt;, &amp;lt;form&amp;gt;, &amp;lt;li&amp;gt;, &amp;lt;ol&amp;gt;, &amp;lt;ul&amp;gt;, &amp;lt;p&amp;gt;, &amp;lt;pre&amp;gt;, &amp;lt;table&amp;gt;, &amp;lt;div&amp;gt;&lt;/code&gt;等&lt;/li&gt;
&lt;li&gt;内联元素通常显示没有换行符，如&lt;code&gt;&amp;lt;b&amp;gt;, &amp;lt;a&amp;gt;, &amp;lt;strong&amp;gt;, &amp;lt;img&amp;gt;, &amp;lt;input&amp;gt;, &amp;lt;em&amp;gt;, &amp;lt;span&amp;gt;&lt;/code&gt;等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;元素是一个块级元素，通常用作其他 HTML 元素的容器。与一些 CSS 样式一起使用时，&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;元素可用于设置内容块的样式。&lt;/p&gt;
&lt;p&gt;同样，&lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;元素是一个内联元素，通常用作某些文本的容器。与 CSS 一起使用时，&lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;元素可用于设置文本的部分样式。&lt;/p&gt;
&lt;p&gt;其他元素可以用作块级元素或内联元素。 这包括以下这些：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;APPLET - 嵌入式 Java 小程序&lt;/li&gt;
&lt;li&gt;IFRAME - 内联框架&lt;/li&gt;
&lt;li&gt;INS - 插入文本&lt;/li&gt;
&lt;li&gt;MAP - 图像映射&lt;/li&gt;
&lt;li&gt;OBJECT - 嵌入对象&lt;/li&gt;
&lt;li&gt;SCRIPT - HTML 文档中的脚本&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你可以在块元素内插入内联元素。 例如，可以在&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;元素中包含多个&lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;元素。反之不行。&lt;/p&gt;
&lt;h2&gt;表单标签&lt;/h2&gt;
&lt;p&gt;HTML 表单用于从用户收集信息。使用&lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt;元素及其开始和结束标记定义表单，使用 action 属性指向将在用户提交表单后加载的网页：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;form&lt;/span&gt; &lt;span class="na"&gt;action=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;method=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;…&lt;span class="nt"&gt;&amp;lt;/form&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;method 属性指定在提交表单时使用的 HTTP 方法（GET 或 POST）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用 GET 时，表单数据将显示在页面地址中&lt;/li&gt;
&lt;li&gt;如果表单正在更新数据，请使用 POST，或者包含敏感信息（密码）。POST 提供了更好的安全性，因为提交的数据在页面地址中不可见&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;要接受用户输入，需要相应的表单元素，例如文本字段。 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;元素有许多变体，具体取决于 type 属性。 它可以是文本，密码，广播，URL，提交等。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;form&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;input&lt;/span&gt; &lt;span class="na"&gt;type=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;text&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;username&amp;quot;&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&amp;lt;br&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;input&lt;/span&gt; &lt;span class="na"&gt;type=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;password&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;password&amp;quot;&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/form&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;标签&lt;/h1&gt;
&lt;p&gt;可以使用特殊帧文档将页面划分为帧。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;标签定义&lt;code&gt;&amp;lt;frameset&amp;gt;&lt;/code&gt;中的一个特定窗口（框架）。&lt;code&gt;&amp;lt;frameset&amp;gt;&lt;/code&gt;中的每个&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;可以具有不同的属性，例如边框，滚动，调整大小的能力等。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;frameset&amp;gt;&lt;/code&gt;元素指定框架集中的列数或行数，以及每个框架占空间像素的百分比或数量。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;frameset&lt;/span&gt; &lt;span class="na"&gt;cols=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;25%,50%,25%&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;frame&lt;/span&gt; &lt;span class="na"&gt;src=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;a.htm&amp;quot;&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;frame&lt;/span&gt; &lt;span class="na"&gt;src=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;b.htm&amp;quot;&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;frame&lt;/span&gt; &lt;span class="na"&gt;src=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;c.htm&amp;quot;&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;noframes&amp;gt;&lt;/span&gt;Frames not supported!&lt;span class="nt"&gt;&amp;lt;/noframes&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/frameset&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;使用&lt;code&gt;&amp;lt;noresize&amp;gt;&lt;/code&gt;属性指定用户无法调整&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;元素的大小：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;frame noresize="noresize"&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;HTML5 中不支持&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;标签。&lt;/p&gt;
&lt;h2&gt;颜色&lt;/h2&gt;
&lt;h3&gt;颜色值&lt;/h3&gt;
&lt;p&gt;HTML 颜色表示为十六进制值，0~F。零表示最低值，F表示最高值。&lt;/p&gt;
&lt;h3&gt;颜色模式&lt;/h3&gt;
&lt;p&gt;颜色以红色，绿色和蓝色光（RGB）的组合显示。&lt;/p&gt;
&lt;p&gt;十六进制值使用＃标签符号，后跟六个十六进制字符。所有浏览器都支持 RGB 颜色值。&lt;/p&gt;</content><category term="HTML"></category></entry><entry><title>X3DOM 图像和视频纹理</title><link href="https://xutree.github.io/pages/2018/10/05/X3DOM%E5%9B%BE%E5%83%8F%E5%92%8C%E8%A7%86%E9%A2%91%E7%BA%B9%E7%90%86/" rel="alternate"></link><published>2018-10-05T17:14:00+08:00</published><updated>2018-10-06T21:02:53+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-05:/pages/2018/10/05/X3DOM图像和视频纹理/</id><summary type="html">&lt;p&gt;本章你将知道哪些图像类型和视频格式可以用作 X3DOM 的纹理，以及纹理的特性和限制。&lt;/p&gt;
&lt;p&gt;你可以使用 &lt;a href="http://en.wikipedia.org/wiki/Portable_Network_Graphics"&gt;&lt;em&gt;PNG&lt;/em&gt;&lt;/a&gt;，&lt;a href="http://en.wikipedia.org/wiki/Jpeg"&gt;&lt;em&gt;LPEG&lt;/em&gt;&lt;/a&gt; 或者 &lt;a href="https://en.wikipedia.org/wiki/Gif"&gt;&lt;em&gt;GIF&lt;/em&gt;&lt;/a&gt; 来编码你的静态纹理数据。&lt;em&gt;JPG&lt;/em&gt; 图像需要的内存少但是存在压缩损失而且没有 &lt;em&gt;alpha&lt;/em&gt; 通道。&lt;em&gt;PNG&lt;/em&gt; 图像属于无损压缩并且有 &lt;em&gt;alpha&lt;/em&gt; 通道，&lt;em&gt;GIF&lt;/em&gt; 也是无损压缩并且有 &lt;em&gt;alpha&lt;/em&gt; 通道。一般来讲：如果你不需要 &lt;em&gt;alpha&lt;/em&gt; 通道并且图像中不包含硬边界(例如：文本)，使用 &lt;em&gt;JPG&lt;/em&gt;，否则使用 &lt;em&gt;PNG&lt;/em&gt;。你应该避免使用 &lt;em&gt;GIF&lt;/em&gt;。&lt;/p&gt;
&lt;h2&gt;图像&lt;/h2&gt;
&lt;p&gt;利用 &lt;em&gt;ImageTexture&lt;/em&gt; 节点把图像作为纹理：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;x3d&lt;/span&gt; &lt;span class="na"&gt;width=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;500px&amp;#39;&lt;/span&gt; &lt;span class="na"&gt;height=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;400px&amp;#39;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;scene&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;shape&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;appearance&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;ImageTexture&lt;/span&gt; &lt;span class="na"&gt;url=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;myTexture.png …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;本章你将知道哪些图像类型和视频格式可以用作 X3DOM 的纹理，以及纹理的特性和限制。&lt;/p&gt;
&lt;p&gt;你可以使用 &lt;a href="http://en.wikipedia.org/wiki/Portable_Network_Graphics"&gt;&lt;em&gt;PNG&lt;/em&gt;&lt;/a&gt;，&lt;a href="http://en.wikipedia.org/wiki/Jpeg"&gt;&lt;em&gt;LPEG&lt;/em&gt;&lt;/a&gt; 或者 &lt;a href="https://en.wikipedia.org/wiki/Gif"&gt;&lt;em&gt;GIF&lt;/em&gt;&lt;/a&gt; 来编码你的静态纹理数据。&lt;em&gt;JPG&lt;/em&gt; 图像需要的内存少但是存在压缩损失而且没有 &lt;em&gt;alpha&lt;/em&gt; 通道。&lt;em&gt;PNG&lt;/em&gt; 图像属于无损压缩并且有 &lt;em&gt;alpha&lt;/em&gt; 通道，&lt;em&gt;GIF&lt;/em&gt; 也是无损压缩并且有 &lt;em&gt;alpha&lt;/em&gt; 通道。一般来讲：如果你不需要 &lt;em&gt;alpha&lt;/em&gt; 通道并且图像中不包含硬边界(例如：文本)，使用 &lt;em&gt;JPG&lt;/em&gt;，否则使用 &lt;em&gt;PNG&lt;/em&gt;。你应该避免使用 &lt;em&gt;GIF&lt;/em&gt;。&lt;/p&gt;
&lt;h2&gt;图像&lt;/h2&gt;
&lt;p&gt;利用 &lt;em&gt;ImageTexture&lt;/em&gt; 节点把图像作为纹理：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;x3d&lt;/span&gt; &lt;span class="na"&gt;width=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;500px&amp;#39;&lt;/span&gt; &lt;span class="na"&gt;height=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;400px&amp;#39;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;scene&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;shape&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;appearance&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;ImageTexture&lt;/span&gt; &lt;span class="na"&gt;url=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;myTexture.png&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&amp;lt;ImageTexture/&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/appearance&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;box&amp;gt;&lt;/span&gt; &lt;span class="nt"&gt;&amp;lt;/box&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/shape&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/scene&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/x3d&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;视频&lt;/h2&gt;
&lt;p&gt;利用 &lt;em&gt;MovieTexture&lt;/em&gt; 节点可以把视频作为纹理。但是目前还没有哪一种视频格式支持所有的用户。可以使用 X3DOM 格式&lt;a href="https://x3dom.org/x3dom/example/x3dom_video.xhtml"&gt;示例&lt;/a&gt;来确定你的浏览器支持的格式。目前最好的解决方法是将你的视频编码成 &lt;em&gt;MP4&lt;/em&gt; 和 &lt;em&gt;OGV&lt;/em&gt; 格式并在 &lt;em&gt;MovieTexture&lt;/em&gt; 节点中提供这两个选项：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;x3d&lt;/span&gt; &lt;span class="na"&gt;width=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;500px&amp;#39;&lt;/span&gt; &lt;span class="na"&gt;height=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;400px&amp;#39;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;scene&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;shape&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;appearance&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;MovieTexture&lt;/span&gt; &lt;span class="na"&gt;url=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;”foo.mp4″,”foo.ogv”&amp;#39;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&amp;lt;MovieTexture/&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/appearance&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;box&amp;gt;&lt;/span&gt; &lt;span class="nt"&gt;&amp;lt;/box&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/shape&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/scene&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/x3d&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</content><category term="X3DOM"></category></entry><entry><title>X3DOM，HTML，CSS 和 JavaScript</title><link href="https://xutree.github.io/pages/2018/10/05/X3DOMHTMLCSS%E5%92%8CJavaScript/" rel="alternate"></link><published>2018-10-05T11:22:00+08:00</published><updated>2018-10-06T21:02:31+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-05:/pages/2018/10/05/X3DOMHTMLCSS和JavaScript/</id><summary type="html">&lt;p&gt;本节，你将学习关于 X3DOM, HTML 和 CSS的更多知识，以及怎么利用 HTML 和 CSS 技术构建出强大的 3D 应用。在本节最后，你讲学习怎么在你的应用中使用 JavaScript。我们将继续使用前一节的例子。拷贝 HelloX3DOM.html 文件并重命名为 HTMLEventsCSS.html。&lt;/p&gt;
&lt;h2&gt;X3DOM 和 CSS&lt;/h2&gt;
&lt;p&gt;我们首先来看下怎么通过 CSS 操控 X3DOM 元素。你可能已经注意到，在 HelloX3DOM.html 中，3D 内容位于一个被黑色边界包围的白色区域中。X3DOM 有一个单独的 css 文件，自从版本1.3以后，名字一直为 x3dom.css，在这个文件中可以找到关于 X3DOM 元素的所有 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;本节，你将学习关于 X3DOM, HTML 和 CSS的更多知识，以及怎么利用 HTML 和 CSS 技术构建出强大的 3D 应用。在本节最后，你讲学习怎么在你的应用中使用 JavaScript。我们将继续使用前一节的例子。拷贝 HelloX3DOM.html 文件并重命名为 HTMLEventsCSS.html。&lt;/p&gt;
&lt;h2&gt;X3DOM 和 CSS&lt;/h2&gt;
&lt;p&gt;我们首先来看下怎么通过 CSS 操控 X3DOM 元素。你可能已经注意到，在 HelloX3DOM.html 中，3D 内容位于一个被黑色边界包围的白色区域中。X3DOM 有一个单独的 css 文件，自从版本1.3以后，名字一直为 x3dom.css，在这个文件中可以找到关于 X3DOM 元素的所有 css 定义以及 debug 信息。假设你的页面使用灰色和橙色作为主要颜色。你可以通过许多方式改变 X3DOM 默认的 CSS 属性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 x3dom.css 后包含你自己的 CSS 文件(External Style Sheet)&lt;/li&gt;
&lt;li&gt;在 x3dom.css 之后，利用 &lt;em&gt;style&lt;/em&gt; 标签定制 css(Internal
Style Sheet)&lt;/li&gt;
&lt;li&gt;直接操纵相关元素的 &lt;em&gt;style&lt;/em&gt; 属性(Inline Styles)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关于 CSS 有很多网上教程，例如&lt;a href="http://www.w3schools.com/css/css_howto.asp"&gt;这里&lt;/a&gt;。我们现在利用第二种方法改变 css，通常不推荐第三种方法。为了定制 x3d 代表的 X3DOM 边界，在你的 HTML 文件头部 x3dom.css 之后插入 &lt;em&gt;style&lt;/em&gt; 标签：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;title&amp;gt;&lt;/span&gt;My first X3DOM page&lt;span class="nt"&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;script&lt;/span&gt; &lt;span class="na"&gt;type=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;text/javascript&amp;#39;&lt;/span&gt; &lt;span class="na"&gt;src=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;http://www.x3dom.org/download/x3dom.js&amp;#39;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nt"&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;link&lt;/span&gt; &lt;span class="na"&gt;rel=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;stylesheet&amp;#39;&lt;/span&gt; &lt;span class="na"&gt;type=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;text/css&amp;#39;&lt;/span&gt; &lt;span class="na"&gt;href=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;http://www.x3dom.org/download/x3dom.css&amp;#39;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&amp;lt;/link&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;style&amp;gt;&lt;/span&gt;
        x3d
        {
            border:2px solid darkorange;
        }
    &lt;span class="nt"&gt;&amp;lt;/style&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;h1&amp;gt;&lt;/span&gt;Hello, X3DOM!&lt;span class="nt"&gt;&amp;lt;/h1&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;p&amp;gt;&lt;/span&gt;
    This is my first html page with some 3d objects.
    &lt;span class="nt"&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;x3d&lt;/span&gt; &lt;span class="na"&gt;width=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;600px&amp;#39;&lt;/span&gt; &lt;span class="na"&gt;height=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;400px&amp;#39;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
    ...
    &lt;span class="nt"&gt;&amp;lt;/x3d&amp;gt;&lt;/span&gt;

&lt;span class="nt"&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;现在，X3DOM 的边界颜色已经改变了。假设你的网页已经有了橙色和灰色风格，使用 &lt;em&gt;pattern.png&lt;/em&gt; 作为背景(背景图片在&lt;a href="https://doc.x3dom.org/tutorials/basics/htmlCSS/pattern.png"&gt;这里&lt;/a&gt;)。那么完整的 &lt;em&gt;style sheet&lt;/em&gt; 如下所示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;x3d&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;border&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="kt"&gt;px&lt;/span&gt; &lt;span class="kc"&gt;solid&lt;/span&gt; &lt;span class="kc"&gt;darkorange&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="nt"&gt;body&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;font-size&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;110&lt;/span&gt;&lt;span class="kt"&gt;%&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;font-family&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;verdana&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kc"&gt;sans-serif&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;background-image&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;url&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;pattern.png&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;margin&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="kt"&gt;em&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;color&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="kc"&gt;lightgray&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="nt"&gt;h1&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;color&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="kc"&gt;darkorange&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;现在你的网页看起来如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="图1  默认情况下，X3DOM使用与网页相同的背景" src="https://xutree.github.io/images/fig5.png"&gt;&lt;/p&gt;
&lt;p&gt;从图中可以看出，X3DOM 使用与网页相同的背景。这是一个很重要的行为：你的 X3DOM &lt;em&gt;scene&lt;/em&gt; 是在 HTML 之上进行渲染的。让我们设置 &lt;em&gt;x3d&lt;/em&gt; 元素为半透明背景：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;x3d&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;border&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="kt"&gt;px&lt;/span&gt; &lt;span class="kc"&gt;solid&lt;/span&gt; &lt;span class="kc"&gt;darkorange&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;background&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="nb"&gt;rgba&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;128&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;128&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;128&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;0.4&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;现在结果看起来如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img alt="图2  具有半透明背景的X3DOM" src="https://xutree.github.io/images/fig6.png"&gt;&lt;/p&gt;
&lt;h2&gt;X3DOM, HTML 事件和 JavaScript&lt;/h2&gt;
&lt;p&gt;使用 HTML 和 JavaScript，你可以使用大量有用的回调函数来操纵大多数 DOM 元素。X3DOM 为 &lt;em&gt;node&lt;/em&gt; 提供了相似的函数。例如，当我们点击红色立方体的时候，可以弹出一个文本信息，在 &lt;em&gt;shape&lt;/em&gt; 里插入一个 &lt;em&gt;onclick&lt;/em&gt; 函数就可以实现这个功能：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;shape&lt;/span&gt; &lt;span class="na"&gt;onclick=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;alert(&amp;#39;Hello, click!&amp;#39;);&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;appearance&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;material&lt;/span&gt; &lt;span class="na"&gt;diffuseColor=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;1 0 0&amp;#39;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&amp;lt;/material&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/appearance&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;box&amp;gt;&amp;lt;/box&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/shape&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;目前，你可以对 X3DOM 使用 &lt;em&gt;onmousemove&lt;/em&gt;，&lt;em&gt;onmousedown&lt;/em&gt;， &lt;em&gt;onmouseup&lt;/em&gt;，&lt;em&gt;onmouseover&lt;/em&gt; 和 &lt;em&gt;onmouseout&lt;/em&gt; 事件。你不仅可以在 &lt;em&gt;shape&lt;/em&gt; 节点插入事件，也可以在组节点，例如 &lt;em&gt;transform&lt;/em&gt; 插入事件。这样你就可以使用一个回调函数捕捉多个节点的事件。&lt;/p&gt;
&lt;p&gt;你可以在每个 DOM 元素上使用 JavaScript，所以你可以随心所欲的操纵 &lt;em&gt;node&lt;/em&gt;。你已经知道怎么使用 &lt;em&gt;onclick&lt;/em&gt; 事件，让我们尝试当点击时，改变立方体的颜色。如果你从没使用过 JavaScript，这个&lt;a href="http://www.w3schools.com/js/default.asp"&gt;网站&lt;/a&gt;或许可以帮助你。&lt;/p&gt;
&lt;p&gt;首先，给你想操纵的节点一个 &lt;em&gt;id&lt;/em&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;shape&lt;/span&gt; &lt;span class="na"&gt;onclick=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;alert(&amp;#39;Hello, click!&amp;#39;);&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;appearance&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;material&lt;/span&gt; &lt;span class="na"&gt;id=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;color&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;diffuseColor=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;1 0 0&amp;#39;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&amp;lt;/material&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/appearance&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;box&amp;gt;&amp;lt;/box&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/shape&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后，你就可以通过下面这个函数改变颜色：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;script&amp;gt;&lt;/span&gt;
    function changeColor()
    {
        if(document.getElementById(&amp;quot;color&amp;quot;).getAttribute(&amp;#39;diffuseColor&amp;#39;)==&amp;quot;1 0 0&amp;quot;)
            document.getElementById(&amp;quot;color&amp;quot;).setAttribute(&amp;#39;diffuseColor&amp;#39;, &amp;#39;0 0 1&amp;#39;);
        else
            document.getElementById(&amp;quot;color&amp;quot;).setAttribute(&amp;#39;diffuseColor&amp;#39;, &amp;#39;1 0 0&amp;#39;);
    }
&lt;span class="nt"&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;lt;shape onclick=&amp;quot;changeColor();&amp;quot;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;下一步：自动创建 (X)HTML&lt;/h2&gt;
&lt;p&gt;如果你有大量的模型数据，你想把这些数据分配到不同的页面上。那么自动生成实际的页面而不是手动编写代码将更加有趣。你可以使用自动化工具，例如 XSLT，允许你直接将 X3DOM 文件转化为 XHTML 网页。&lt;a href="http://www.web3d.org/x3d/stylesheets/X3dToXhtmlStylesheetExamples.zip"&gt;这里&lt;/a&gt;是一个例子。&lt;/p&gt;</content><category term="X3DOM"></category></entry><entry><title>Hello，X3DOM！</title><link href="https://xutree.github.io/pages/2018/10/04/X3DOM-hello/" rel="alternate"></link><published>2018-10-04T18:29:00+08:00</published><updated>2018-10-06T20:59:55+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-04:/pages/2018/10/04/X3DOM-hello/</id><summary type="html">&lt;p&gt;本教程将教会你怎么配置和运行你的第一个 X3DOM 应用。你只需要一个相容于 WebGL 的浏览器和一个文本编辑器。整个 X3DOM 应用是常规网页的一部分，并且编写方式也与HTML很相似，所以如果你的编辑器支持HTML或者XML的语法高亮那将更好，像&lt;a href="http://www.jetbrains.com/webstorm/"&gt;WebStorm&lt;/a&gt;这种 Web 编程 IDE 也是可以的。如果你手头有一个网页浏览器和一个文本编辑器，并且你知道怎么在浏览器中打开网页(参考&lt;a href="https://doc.x3dom.org/gettingStarted/index.html"&gt;这里&lt;/a&gt;)，那么你可以开始你的第一个 X3DOM 应用了。&lt;/p&gt;
&lt;p&gt;首先，创建一个新文件 &lt;em&gt;HelloX3DOM.html&lt;/em&gt;。然后将下面的内容复制粘贴进这个空文件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;title&amp;gt;&lt;/span&gt;My first X3DOM page&lt;span class="nt"&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;script&lt;/span&gt; &lt;span class="na"&gt;type=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;text/javascript&amp;#39;&lt;/span&gt; &lt;span class="na"&gt;src=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;http://www.x3dom.org/download/x3dom.js …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;本教程将教会你怎么配置和运行你的第一个 X3DOM 应用。你只需要一个相容于 WebGL 的浏览器和一个文本编辑器。整个 X3DOM 应用是常规网页的一部分，并且编写方式也与HTML很相似，所以如果你的编辑器支持HTML或者XML的语法高亮那将更好，像&lt;a href="http://www.jetbrains.com/webstorm/"&gt;WebStorm&lt;/a&gt;这种 Web 编程 IDE 也是可以的。如果你手头有一个网页浏览器和一个文本编辑器，并且你知道怎么在浏览器中打开网页(参考&lt;a href="https://doc.x3dom.org/gettingStarted/index.html"&gt;这里&lt;/a&gt;)，那么你可以开始你的第一个 X3DOM 应用了。&lt;/p&gt;
&lt;p&gt;首先，创建一个新文件 &lt;em&gt;HelloX3DOM.html&lt;/em&gt;。然后将下面的内容复制粘贴进这个空文件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;title&amp;gt;&lt;/span&gt;My first X3DOM page&lt;span class="nt"&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;script&lt;/span&gt; &lt;span class="na"&gt;type=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;text/javascript&amp;#39;&lt;/span&gt; &lt;span class="na"&gt;src=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;http://www.x3dom.org/download/x3dom.js&amp;#39;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nt"&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;link&lt;/span&gt; &lt;span class="na"&gt;rel=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;stylesheet&amp;#39;&lt;/span&gt; &lt;span class="na"&gt;type=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;text/css&amp;#39;&lt;/span&gt; &lt;span class="na"&gt;href=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;http://www.x3dom.org/download/x3dom.css&amp;#39;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&amp;lt;/link&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;h1&amp;gt;&lt;/span&gt;Hello, X3DOM!&lt;span class="nt"&gt;&amp;lt;/h1&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;p&amp;gt;&lt;/span&gt;
        This is my first html page with some 3d objects.
    &lt;span class="nt"&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果你在浏览器中打开这个文件，你会看到一个包含一个文本信息的常规HTML页面。你可能已经注意到，我们已经在我们的网页中添加了一些 X3DOM 元素，因为我们已经包含 X3DOM 作为一个 JaveScript 库，还包含了 X3DOM CSS 文件，用于规则的显示 X3DOM 元素。在上面的 HTML 代码中，我们通过 &lt;em&gt;script&lt;/em&gt; 和 &lt;em&gt;link&lt;/em&gt; 标签是用了 &lt;em&gt;development&lt;/em&gt; 版本的 X3DOM。&lt;/p&gt;
&lt;p&gt;让我们继续添加一些 3D 内容。首先，我们需要一个 &lt;em&gt;x3d&lt;/em&gt; 元素，用来描述 X3DOM 内容在哪个 &lt;em&gt;scene&lt;/em&gt; 显示。和 HTML 元素 &lt;em&gt;p&lt;/em&gt;、&lt;em&gt;div&lt;/em&gt; 类似，&lt;em&gt;x3d&lt;/em&gt; 在 HTML 里定义了一个矩形范围。整个 X3DOM 的 3D 内容用 &lt;em&gt;scene&lt;/em&gt; 描述，所以我们在 &lt;em&gt;x3d&lt;/em&gt; 标签里添加一个 &lt;em&gt;scene&lt;/em&gt; 标签。这种结构是来自于X3D标准。一个 &lt;em&gt;scene&lt;/em&gt; 可以包含很多不同的 &lt;em&gt;node&lt;/em&gt;，例如，&lt;em&gt;lights&lt;/em&gt;、&lt;em&gt;groups&lt;/em&gt;、&lt;em&gt;viewpoint&lt;/em&gt; 和 &lt;em&gt;objects&lt;/em&gt;。在第一个例子里，我们通过 &lt;em&gt;shape&lt;/em&gt; 简单地定义一个3D物体。我们用 &lt;em&gt;box&lt;/em&gt; 定义这个物体的几何形状。现在，你可以将下面的代码添加在你的 HTML 文件闭合 &lt;em&gt;p&lt;/em&gt; 标签之后：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;x3d&lt;/span&gt; &lt;span class="na"&gt;width=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;600px&amp;#39;&lt;/span&gt; &lt;span class="na"&gt;height=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;400px&amp;#39;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;scene&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;shape&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;box&amp;gt;&amp;lt;/box&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/shape&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/scene&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/x3d&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果你现在在浏览器中打开这个文件，会像下面这样：&lt;/p&gt;
&lt;p&gt;&lt;img alt="图1    注意box标签没有颜色，所以无法在图中看到" src="https://xutree.github.io/images/fig1.png"&gt;&lt;/p&gt;
&lt;p&gt;由于 &lt;em&gt;box&lt;/em&gt; 目前没有颜色，所以无法看到它，为了看到它我们需要声明 &lt;em&gt;material&lt;/em&gt;，X3DOM 基于 X3D 标准选择了一个白色的 &lt;em&gt;material&lt;/em&gt;，由于网页的背景也是白色的，所以我们看不到它。为了改变 &lt;em&gt;material&lt;/em&gt; 的颜色，我们首先需要在 &lt;em&gt;shape&lt;/em&gt; 中插入 &lt;em&gt;appearance&lt;/em&gt;。在 &lt;em&gt;appearance&lt;/em&gt; 里面，我们就可以插入 &lt;em&gt;material&lt;/em&gt;，利用 &lt;em&gt;material&lt;/em&gt; 的 &lt;em&gt;diffuseColor&lt;/em&gt; 我们可以定义 &lt;em&gt;material&lt;/em&gt; 的颜色，我们现在将它定义为 RGB 颜色的红色：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;shape&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;appearance&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;material&lt;/span&gt; &lt;span class="na"&gt;diffuseColor=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;1 0 0&amp;#39;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&amp;lt;/material&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/appearance&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;box&amp;gt;&amp;lt;/box&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/shape&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;现在，在你的浏览器中，网页将变成：&lt;/p&gt;
&lt;p&gt;&lt;img alt="图2    现在 *box* 具有红色的 *material*" src="https://xutree.github.io/images/fig2.png"&gt;&lt;/p&gt;
&lt;p&gt;现在，你可以利用鼠标进行交互了。按住鼠标左键并移动鼠标，你可以旋转视角，按住鼠标右键并移动鼠标，你可以放大和缩小。&lt;/p&gt;
&lt;p&gt;我们继续在这个 &lt;em&gt;scene&lt;/em&gt; 中添加两个物体：一个蓝色的球体和一个绿色的圆锥。这和我们添加 &lt;em&gt;box&lt;/em&gt; 类似，但是，在 &lt;em&gt;sphere&lt;/em&gt; 和 &lt;em&gt;cone&lt;/em&gt; 节点处，我们需要移动球和圆锥以避免他们相互重叠，因为所有的 3D 物体都默认不进行任何的坐标转换，也就是说它们会重叠在一起。像X3D和其他的图像相关标准(例如，OpenGL)一样，X3DOM 的坐标系统 Y 轴指向上，X 轴指向右，Z 轴指向外：&lt;/p&gt;
&lt;p&gt;&lt;img alt="图3  X3DOM的坐标系统" src="https://xutree.github.io/images/fig3.png"&gt;&lt;/p&gt;
&lt;p&gt;在添加绿色圆锥之前，我们将坐标往左移动3个单位；在添加蓝色球之前，我们将坐标往右移动3个单位。如下所示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;shape&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;appearance&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;material&lt;/span&gt; &lt;span class="na"&gt;diffuseColor=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;1 0 0&amp;#39;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&amp;lt;/material&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/appearance&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;box&amp;gt;&amp;lt;/box&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/shape&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;transform&lt;/span&gt; &lt;span class="na"&gt;translation=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;-3 0 0&amp;#39;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;shape&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;appearance&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;material&lt;/span&gt; &lt;span class="na"&gt;diffuseColor=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;0 1 0&amp;#39;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&amp;lt;/material&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/appearance&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;cone&amp;gt;&amp;lt;/cone&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/shape&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/transform&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;transform&lt;/span&gt; &lt;span class="na"&gt;translation=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;3 0 0&amp;#39;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;shape&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;appearance&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;material&lt;/span&gt; &lt;span class="na"&gt;diffuseColor=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;0 0 1&amp;#39;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&amp;lt;/material&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/appearance&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;sphere&amp;gt;&amp;lt;/sphere&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/shape&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/transform&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;现在，在你的浏览器中，你将看到如下内容：&lt;/p&gt;
&lt;p&gt;&lt;img alt="图4 三个物体" src="https://xutree.github.io/images/fig4.png"&gt;&lt;/p&gt;
&lt;p&gt;如果你在浏览器中看到了上图的结果，恭喜你！你刚刚使用了一系列的 X3D &lt;em&gt;node&lt;/em&gt; 创建了你的第一个 X3DOM &lt;em&gt;scene&lt;/em&gt;。&lt;/p&gt;</content><category term="X3DOM"></category></entry><entry><title>X3DOM 第一课</title><link href="https://xutree.github.io/pages/2018/10/04/X3DOM%E7%AC%AC%E4%B8%80%E8%AF%BE/" rel="alternate"></link><published>2018-10-04T11:31:00+08:00</published><updated>2018-10-06T21:13:34+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-04:/pages/2018/10/04/X3DOM第一课/</id><summary type="html">&lt;p&gt;下面的指南可以作为 X3DOM 使用者和开发者的入门资料。本指南包括许多重要的内容，例如怎么配置你的环境去运行 X3DOM 的示例。如果你没有足够的时间阅读这篇入门文章，又或许你已经熟悉一点关于 X3D 的知识，你可以迅速的浏览下第3部分和第4部分的一些内容去设置你的环境，然后根据&lt;a href="https://doc.x3dom.org/tutorials/index.html"&gt;tutorials&lt;/a&gt;的指导去完成你的第一个 X3DOM 应用。&lt;/p&gt;
&lt;h2&gt;背景：什么是X3DOM，它可以用来做什么？&lt;/h2&gt;
&lt;h3&gt;无需插件即可在浏览器中显示的3D场景&lt;/h3&gt;
&lt;p&gt;X3DOM（发音：“X-Freedom”）是一个开源的 JaveScript 框架，用于在网页中创建 declarative 3D 场景。由于它基于标准的浏览器技术，你的浏览器不需要其他任何插件就可以显示 X3DOM 场景。概括地说，declarative 3D 意味着你可以使用结构化的文本表示去创建和显示 3D 场景，而不需要去编写代码。在 X3DOM 中，这种文本表示是表示网页的 HTML 文件的一部分。也就是说，3D …&lt;/p&gt;</summary><content type="html">&lt;p&gt;下面的指南可以作为 X3DOM 使用者和开发者的入门资料。本指南包括许多重要的内容，例如怎么配置你的环境去运行 X3DOM 的示例。如果你没有足够的时间阅读这篇入门文章，又或许你已经熟悉一点关于 X3D 的知识，你可以迅速的浏览下第3部分和第4部分的一些内容去设置你的环境，然后根据&lt;a href="https://doc.x3dom.org/tutorials/index.html"&gt;tutorials&lt;/a&gt;的指导去完成你的第一个 X3DOM 应用。&lt;/p&gt;
&lt;h2&gt;背景：什么是X3DOM，它可以用来做什么？&lt;/h2&gt;
&lt;h3&gt;无需插件即可在浏览器中显示的3D场景&lt;/h3&gt;
&lt;p&gt;X3DOM（发音：“X-Freedom”）是一个开源的 JaveScript 框架，用于在网页中创建 declarative 3D 场景。由于它基于标准的浏览器技术，你的浏览器不需要其他任何插件就可以显示 X3DOM 场景。概括地说，declarative 3D 意味着你可以使用结构化的文本表示去创建和显示 3D 场景，而不需要去编写代码。在 X3DOM 中，这种文本表示是表示网页的 HTML 文件的一部分。也就是说，3D 内容成为了网页元素的一部分，就像网页中的文本、链接、图片和视频一样。&lt;/p&gt;
&lt;h3&gt;X3DOM = X3D + DOM&lt;/h3&gt;
&lt;p&gt;X3DOM 这个名字是由两个缩写组合而成。第一个缩写是&lt;a href="http://www.web3d.org/x3d/what-x3d"&gt;X3D&lt;/a&gt;（“Extensible 3D Graphics”），指代一个 3D 图形的免版税 ISO 标准。第二个缩写是&lt;a href="https://www.w3.org/DOM/"&gt;DOM&lt;/a&gt;（“Document Object Model”），描述与HTML文档的内容相关联的交互概念和分层表示。X3DOM 使用 X3D 的一个专门的子集（所谓的&lt;a href="https://www.x3dom.org/nodes-2/"&gt;HTML Profile&lt;/a&gt;）来作为网页内 3D 内容的描述语言。X3D（OM)元素可以通过 DOM 操作，就像其他的 HTML 元素一样。例如，你可以动态地改变一个 3D 物体的颜色通过 JavaScript 调用相应 DOM 元素的 &lt;em&gt;setAttribute(...)&lt;/em&gt; 函数，这就像你可以动态改变一个普通网页里一个标签的内容一样。&lt;/p&gt;
&lt;h3&gt;使用 X3DOM 的原因&lt;/h3&gt;
&lt;p&gt;使用 X3DOM 而不是其他的基于浏览器的库或者 X3D 播放器是因为 X3DOM 具有以下几个优势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;显示 X3DOM 场景不需要额外插件，因为 X3DOM 是完全基于标准浏览器技术，例如&lt;a href="http://www.w3schools.com/html/html5_intro.asp"&gt;HTML5&lt;/a&gt;和&lt;a href="http://get.webgl.org/"&gt;WebGL&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;基于 ISO 标准 X3D 的一种新的 HTML 配置，X3DOM 绝大部分都是标准一致的。这大大方便了 X3DOM 的学习&lt;/li&gt;
&lt;li&gt;从2009年至今，X3DOM 已经具有了很大的使用者和开发者群体&lt;/li&gt;
&lt;li&gt;如果你知道怎么创建简单的网页，你就可以利用你现有的关于 HTML 和 DOM 的知识，而不需要学习新的 API&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;怎么做？&lt;/h3&gt;
&lt;p&gt;如果你想开发你的第一个 X3DOM 应用，你只需要一个浏览器和一个文本编辑器。当然，你也可以选择功能更多的 HTML 和 JavaScript 开发环境，比如&lt;a href="http://www.jetbrains.com/webstorm/"&gt;WebStorm&lt;/a&gt;。&lt;/p&gt;
&lt;h2&gt;一些基本 X3D 概念：Nodes、Components 和 Profiles&lt;/h2&gt;
&lt;h3&gt;X3D Nodes&lt;/h3&gt;
&lt;p&gt;X3D 定义每一个 3D 场景都是由一组 node 组成。每一个 node 代表 3D 场景中一个确定的部分：光线、物体、物体表面的材质等等。场景里的所用 node 排列成树结构或者图结构，整体结构被叫做 &lt;em&gt;scene-graph&lt;/em&gt;。每一个 node 的行为，比如材质的颜色，可以通过node的 &lt;em&gt;fields&lt;/em&gt; 设置。例如，一个用来设置某物体表面颜色为红色（RGB编码 1 0 0）的node的 XML 描述为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;Material&lt;/span&gt; &lt;span class="na"&gt;diffuseColor=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;1 0 0&amp;#39;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&amp;lt;/Material&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;你可能已经意识到，描述 X3D node 的 XML 很像常规的 HTML 代码，属性值 &lt;em&gt;diffuseColor&lt;/em&gt; 的设置也像 HTML 属性的设置一样。事实上，如果你熟悉 HTML，那么就很容易理解 X3DOM 中的 node 了。你可以在&lt;a href="https://doc.x3dom.org/tutorials/index.html"&gt;tutorials&lt;/a&gt;中学习怎样使用 node。如果你想了解更多 X3D 中 node 的概念，可以参考&lt;a href="https://doc.x3dom.org/index.html#X3DExternalDoc"&gt;external X3D documentation resources&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;X3D Components&lt;/h3&gt;
&lt;p&gt;一组具有相同功能的 node 称为 components。例如定义光线的 node，&lt;em&gt;PointLight&lt;/em&gt; 和 &lt;em&gt;SpotLight&lt;/em&gt;，在 &lt;em&gt;Lighting&lt;/em&gt; component 里。关于 Components 的全部信息可以在&lt;a href="https://doc.x3dom.org/node/Components.html"&gt;这里&lt;/a&gt;找到。&lt;/p&gt;
&lt;h3&gt;X3D Profiles 和 X3DOM HTML Profile&lt;/h3&gt;
&lt;p&gt;X3D 标准定义了大量的 node，一些特殊用途的 node 对大多说用户来说并不重要。因此，X3D 引入了 profile 的概念，把许多组 node 放在一起成为一个包，每一个包代表一类特殊的应用。例如，&lt;em&gt;CAD&lt;/em&gt; 包，&lt;em&gt;Immersive&lt;/em&gt; 包是用于交互环境的。profile 是在 component 之上的一个概念。&lt;/p&gt;
&lt;p&gt;X3DOM 使用的 X3D component 经过十分仔细的选择，以提供一个最合适的 X3D 子集来满足现代 HTML 应用的需要。X3DOM 通过定义一个特殊的 profile，即 HTML profile，来解决这一问题。这个 HTML profile 也包括一些处于试验阶段的 X3D 没有的 node 和 filed，这些 node 和 filed 是专门为 X3DOM 设计的。具体来说，有些 X3D node 在 X3DOM 里没有，而有些 node X3DOM 里有但是 X3D 里没有。你可以在&lt;a href="https://doc.x3dom.org/author/index.html"&gt;这里&lt;/a&gt;找到每个 node 的起源。如果你想学习更多关于 HTML profile 的知识以及它与现有的 X3D component、profile 的关系，可以查看&lt;a href="http://www.x3dom.org/?page_id=158"&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;最后，X3DOM 也提供一些不在原始HTML profile 中的 X3D node。这些 node 不在 X3DOM 的标准发行版本中，只在 &lt;em&gt;X3DOM-Full&lt;/em&gt; 版本中。&lt;/p&gt;
&lt;h2&gt;选择一个 X3DOM 版本&lt;/h2&gt;
&lt;h3&gt;版本和 Components&lt;/h3&gt;
&lt;p&gt;有许多可供选择的 X3DOM 版本，你可能想知道对特殊的目的哪一个才是最好的。一般来讲，我们推荐最新的 release 版本。但是，如果你需要采用的新特性在 release 版中没有，那么 dev 版本可能更适合你。当你完成了网页应用的主要开发工作进而部署时，你可能需要用来开发的 X3DOM 的版本信息。你也可能，出于某种原因需要老版本的 X3DOM，比如你的网页应用包含了一些试验特性只在老版本出现，而在新版本中被移除了。&lt;/p&gt;
&lt;p&gt;所有的 X3DOM release 版本，包括 dev 版本，都被打包好了，里面包括一个 JavaScript 文件（如 x3dom.js），一个 css文件（如 x3dom.css）和一个可选的 shockwave 文件（如 x3dom.swf，对于那些支持 flash 的版本），可在&lt;a href="http://x3dom.org/download/"&gt;这里&lt;/a&gt;下载：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;版本1.0到1.2的文件以 x3dom-v 标记，后面跟着版本号（如&lt;a href="http://x3dom.org/download/x3dom-v1.1.js"&gt; http://x3dom.org/download/x3dom-v1.1.js&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;从版本1.3开始，x3dom.js, x3dom.css, x3dom.swf 和一个 .zip 存档文件b被放置在一个以版本号为名字的子文件夹里（如&lt;a href="http://x3dom.org/download/1.3/x3dom.js"&gt; http://x3dom.org/download/1.3/x3dom.js&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;从版本1.3开始，一些 HTML profile 之外的 component 出现了。这些 component 在文件 x3dom-full.js 中。如果你只需要使用其中一个 component，你也可以考虑仍使用 x3dom.js 然后包含所需的 component 的文件（如&lt;a href="http://x3dom.org/download/1.3/components/"&gt; http://x3dom.org/download/1.3/components/&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;最新的稳定 release 版总是位于：&lt;a href="http://x3dom.org/release/x3dom.js"&gt;http://x3dom.org/release/x3dom.js&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;目前的 development 版本总是位于 dec 子文件夹：&lt;a href="http://x3dom.org/download/dev/x3dom.js"&gt;http://x3dom.org/download/dev/x3dom.js&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为使用最新版本 release X3DOM，你可以在你的HTML页面中包含下面的标签：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;script&lt;/span&gt; &lt;span class="na"&gt;src=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;http://www.x3dom.org/release/x3dom.js&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;link&lt;/span&gt; &lt;span class="na"&gt;rel=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;stylesheet&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;href=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;http://www.x3dom.org/release/x3dom.css&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;为使用最新的 development 版本，使用下面的标签：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;script&lt;/span&gt; &lt;span class="na"&gt;src=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;http://www.x3dom.org/download/dev/x3dom.js&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;link&lt;/span&gt; &lt;span class="na"&gt;rel=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;stylesheet&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;href=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;http://www.x3dom.org/download/dev/x3dom.css&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;为使用版本1.5的 X3DOM-Full 版本，使用下面的标签：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;script&lt;/span&gt; &lt;span class="na"&gt;src=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;http://www.x3dom.org/download/1.5/x3dom-full.js&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;link&lt;/span&gt; &lt;span class="na"&gt;rel=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;stylesheet&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;href=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;http://www.x3dom.org/download/1.5/x3dom.css&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;最后，为使用1.3版本的 release X3DOM 和额外的 Geospatial component 和另外的 flash 支持，使用下面的标签：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;script&lt;/span&gt; &lt;span class="na"&gt;src=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;http://www.x3dom.org/download/1.3/x3dom.js&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;script&lt;/span&gt; &lt;span class="na"&gt;src=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;http://www.x3dom.org/download/1.3/components/Geospatial.js&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;script&lt;/span&gt; &lt;span class="na"&gt;src=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;http://www.x3dom.org/download/1.3/x3dom.swf&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;link&lt;/span&gt; &lt;span class="na"&gt;rel=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;stylesheet&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;href=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;http://www.x3dom.org/download/1.3/x3dom.css&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Debugging&lt;/h3&gt;
&lt;p&gt;如果在 debug 你的应用的时候你想看到 X3DOM 的源码，只需将 x3dom.js 替换成 x3dom.debug.js 或者将 x3dom-full.js 替换成 x3dom-full.debug.js。其注意，此特性只适用于版本1.4以后的 X3DOM。相比于常规版本，debug 版本包含缩进和注释，所以比较大。所以，当你最终发布你的 Web 应用时，请不要使用 debug 版本的 js。&lt;/p&gt;
&lt;h2&gt;运行 X3DOM 应用&lt;/h2&gt;
&lt;h3&gt;通过简单的 Python 服务器&lt;/h3&gt;
&lt;p&gt;一个简便的方法在服务器上来测试你的 Web 应用是使用 Python 的 HTTP 服务器模块。你只需要安装一个 Python 解释器。你可以在&lt;a href="http://python.org/"&gt;这里&lt;/a&gt;下载。你可以用 Python 做许多有趣的事情。首先，打开命令行窗口，定位到 X3DOM 文件夹。如果你的 Python 是2.X版本，你可以使用 &lt;em&gt;SimpleHTTP&lt;/em&gt; 服务器模块如下所示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;python -m SimpleHTTPServer
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果你的 Python 是3.x版本，如下所示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;python3 -m http.server
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;默认情况下，服务器使用8000端口。如果你想改变端口，直接在命令后面加上端口号即可，例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;python -m SimpleHTTPServer 8023
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后，通过浏览器输入如下地址就可以到达你的服务器：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;http://localhost:8023
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果你在启动 Python 服务器的文件夹里放置了 index.html 文件，那么这个文件的内容就会显示在浏览器窗口里。否则，你会看到服务器所在文件夹内的文件列表。&lt;/p&gt;
&lt;h3&gt;在 Web 服务器上运行 X3DOM&lt;/h3&gt;
&lt;p&gt;通常，你会在Web服务器上运行你的 X3DOM 应用，本节针对一些普通的 Web 服务器，如 Apache 和 IIS，给出具体的方法。&lt;/p&gt;
&lt;p&gt;Apache 是使用最多的 Web 服务器。它是开源的可以在&lt;a href="http://httpd.apache.org/"&gt;这里&lt;/a&gt;下载。最新版本是2.4，但是版本2.2仍然被支持。&lt;/p&gt;
&lt;p&gt;如果你的应用需要一整套 Web 服务器组件，我们推荐&lt;a href="https://www.apachefriends.org/index.html"&gt;XAMPP&lt;/a&gt;，它包含 Apache、MySQL、PHP 和 Perl 的最新发行版。&lt;/p&gt;
&lt;p&gt;互联网信息服务（IIS）被集成在微软的任何的最新版本的 Windows 当中。但是，对于非服务器操作系统，同时连接数会受到限制。&lt;/p&gt;</content><category term="X3DOM"></category></entry><entry><title>安装 Pelican</title><link href="https://xutree.github.io/pages/2018/10/04/%E5%9C%A8mac%E4%B8%8A%E5%AE%89%E8%A3%85Pelican/" rel="alternate"></link><published>2018-10-04T10:20:00+08:00</published><updated>2018-10-06T21:15:21+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-04:/pages/2018/10/04/在mac上安装Pelican/</id><summary type="html">&lt;h2&gt;安装 Pelican&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://blog.getpelican.com/"&gt;Pelican&lt;/a&gt;目前支持最好的是 Python 2.7 和 3.3+，早期版本的 Python 已经不支持了。有许多不同的方法可以安装 Pelican，最简单的方法是使用 pip，在终端输入：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    pip install pelican
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面是最简单的方法，官方更为推荐的方法是利用 &lt;a href="http://www.virtualenv.org/"&gt;virtualenv&lt;/a&gt; 为 Pelican 建立一个虚拟环境。假设你已经安装好了 virtualenv，下面打开终端，开始为 Pelican 新建一个虚拟环境：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    virtualenv ~/virtualenv/pelican
    cd ~/virtualenv/pelican
    source bin/activate
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当虚拟环境被创建并激活以后，然后利用&lt;code&gt;pip install pelican&lt;/code&gt;安装 Pelican。&lt;/p&gt;
&lt;p&gt;当 …&lt;/p&gt;</summary><content type="html">&lt;h2&gt;安装 Pelican&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://blog.getpelican.com/"&gt;Pelican&lt;/a&gt;目前支持最好的是 Python 2.7 和 3.3+，早期版本的 Python 已经不支持了。有许多不同的方法可以安装 Pelican，最简单的方法是使用 pip，在终端输入：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    pip install pelican
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面是最简单的方法，官方更为推荐的方法是利用 &lt;a href="http://www.virtualenv.org/"&gt;virtualenv&lt;/a&gt; 为 Pelican 建立一个虚拟环境。假设你已经安装好了 virtualenv，下面打开终端，开始为 Pelican 新建一个虚拟环境：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    virtualenv ~/virtualenv/pelican
    cd ~/virtualenv/pelican
    source bin/activate
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当虚拟环境被创建并激活以后，然后利用&lt;code&gt;pip install pelican&lt;/code&gt;安装 Pelican。&lt;/p&gt;
&lt;p&gt;当 Pelican 安装好以后，你可以在终端输入&lt;code&gt;pelican --help&lt;/code&gt;查看使用选项。&lt;/p&gt;
&lt;h2&gt;可选的 Packages&lt;/h2&gt;
&lt;p&gt;如果你计划用 &lt;a href="http://pypi.python.org/pypi/Markdown"&gt;Markdown&lt;/a&gt; 来书写你的网页的话，你需要安装 Markdown：&lt;code&gt;pip install Markdown&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;通过设置 Pelican 的 pelicanconf.py 文件，你可以对生成的 HTML 文件启用增强语法。但是首先你需要安装 &lt;a href="https://pypi.org/project/typogrify/"&gt;Typogrify&lt;/a&gt;：&lt;code&gt;pip install typorify&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;更新&lt;/h2&gt;
&lt;p&gt;更新到最新的稳定版本，使用：
&lt;code&gt;pip install --upgrade pelican&lt;/code&gt;&lt;/p&gt;</content><category term="Pelican"></category></entry></feed>