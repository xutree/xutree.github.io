<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>You Know Nothing - 趣闻</title><link href="https://xutree.github.io/" rel="alternate"></link><link href="https://xutree.github.io/feeds/qu-wen.atom.xml" rel="self"></link><id>https://xutree.github.io/</id><updated>2018-10-09T13:42:30+08:00</updated><entry><title>回车与换行的区别</title><link href="https://xutree.github.io/pages/2018/10/09/%E5%9B%9E%E8%BD%A6%E4%B8%8E%E6%8D%A2%E8%A1%8C%E7%9A%84%E5%8C%BA%E5%88%AB/" rel="alternate"></link><published>2018-10-09T13:42:30+08:00</published><updated>2018-10-09T13:42:30+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-09:/pages/2018/10/09/回车与换行的区别/</id><summary type="html">&lt;p&gt;转载自：&lt;a href="https://www.pythontab.com/html/2017/linuxkaiyuan_0115/1116.html"&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;关于换行和回车其实平时我们不太在意，所以关于两者的区别也不太清楚，在平时开发时可能会遇到一些文件处理的问题，放到不同的操作系统上出现各种坑。那么回车和换行到底有哪些区别呢？今天咱们就来总结一下。&lt;/p&gt;
&lt;h2&gt;由来&lt;/h2&gt;
&lt;p&gt;在计算机还没有出现之前，有一种叫做电传打字机（Teletype Model 33）的机械打字机，每秒钟可以打10个字符。但是它有一个问题，就是打完一行换行的时候，要用去0.2秒，正好可以打两个字符。要是在这0.2秒里面，又有新的字符传过来，那么这个字符将丢失。&lt;/p&gt;
&lt;p&gt;于是，研制人员想了个办法解决这个问题，就是在每行后面加两个表示结束的字符。一个叫做“回车”，告诉打字机把打印头定位在左边界，不卷动滚筒；另一个叫做“换行”，告诉打字机把滚筒卷一格，不改变水平位置。&lt;/p&gt;
&lt;p&gt;这就是“换行”和“回车”的由来。&lt;/p&gt;
&lt;h2&gt;使用&lt;/h2&gt;
&lt;p&gt;后来，计算机发明了，这两个概念也就被般到了计算机上。那时，存储器很贵，一些科学家认为在每行结尾加两个字符太浪费了，加一个就可以。于是 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;转载自：&lt;a href="https://www.pythontab.com/html/2017/linuxkaiyuan_0115/1116.html"&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;关于换行和回车其实平时我们不太在意，所以关于两者的区别也不太清楚，在平时开发时可能会遇到一些文件处理的问题，放到不同的操作系统上出现各种坑。那么回车和换行到底有哪些区别呢？今天咱们就来总结一下。&lt;/p&gt;
&lt;h2&gt;由来&lt;/h2&gt;
&lt;p&gt;在计算机还没有出现之前，有一种叫做电传打字机（Teletype Model 33）的机械打字机，每秒钟可以打10个字符。但是它有一个问题，就是打完一行换行的时候，要用去0.2秒，正好可以打两个字符。要是在这0.2秒里面，又有新的字符传过来，那么这个字符将丢失。&lt;/p&gt;
&lt;p&gt;于是，研制人员想了个办法解决这个问题，就是在每行后面加两个表示结束的字符。一个叫做“回车”，告诉打字机把打印头定位在左边界，不卷动滚筒；另一个叫做“换行”，告诉打字机把滚筒卷一格，不改变水平位置。&lt;/p&gt;
&lt;p&gt;这就是“换行”和“回车”的由来。&lt;/p&gt;
&lt;h2&gt;使用&lt;/h2&gt;
&lt;p&gt;后来，计算机发明了，这两个概念也就被般到了计算机上。那时，存储器很贵，一些科学家认为在每行结尾加两个字符太浪费了，加一个就可以。于是，就出现了分歧。&lt;/p&gt;
&lt;p&gt;回车&lt;code&gt;\r&lt;/code&gt;本义是光标重新回到本行开头，r 的英文 return，控制字符可以写成&lt;code&gt;CR&lt;/code&gt;，即 Carriage Return。&lt;/p&gt;
&lt;p&gt;换行&lt;code&gt;\n&lt;/code&gt;本义是光标往下一行（不一定到下一行行首），n 的英文 newline，控制字符可以写成&lt;code&gt;LF&lt;/code&gt;，即 Line Feed。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;符号&lt;/th&gt;
&lt;th align="left"&gt;ASCII 码&lt;/th&gt;
&lt;th align="left"&gt;意义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;\n&lt;/td&gt;
&lt;td align="left"&gt;10&lt;/td&gt;
&lt;td align="left"&gt;换行 LF&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;\r&lt;/td&gt;
&lt;td align="left"&gt;13&lt;/td&gt;
&lt;td align="left"&gt;回车 CR&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;在不同的操作系统这几个字符表现不同，比如在 WIN 系统下，这两个字符就是表现的本义，在 UNIX 类系统，换行&lt;code&gt;\n&lt;/code&gt;就表现为光标下一行并回到行首，在 MAC 上，&lt;code&gt;\r&lt;/code&gt;就表现为回到本行开头并往下一行，至于&lt;code&gt;ENTER&lt;/code&gt;键的定义是与操作系统有关的。通常用的&lt;code&gt;Enter&lt;/code&gt;是两个加起来。&lt;/p&gt;
&lt;p&gt;不同操作系统下的含义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;\n&lt;/code&gt;：UNIX 系统行末结束符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\n\r&lt;/code&gt;：window 系统行末结束符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\r&lt;/code&gt;：MAC OS 系统行末结束符&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们经常遇到的一个问题就是，Unix/Mac 系统下的文件在 Windows 里打开的话，所有文字会变成一行；而 Windows 里的文件在 Unix/Mac 下打开的话，在每行的结尾可能会多出一个&lt;code&gt;^M&lt;/code&gt;符号。&lt;/p&gt;
&lt;h2&gt;软回车和硬回车&lt;/h2&gt;
&lt;p&gt;硬回车就是普通我们按回车产生的，它在换行的同时也起着段落分隔的作用。&lt;/p&gt;
&lt;p&gt;软回车是用&lt;code&gt;Shift + Enter&lt;/code&gt;产生的，它换行，但是并不换段，即前后两段文字在 Word 中属于同一“段”。在应用格式时你会体会到这一点。&lt;/p&gt;
&lt;p&gt;软回车能使前后两行的行间距大幅度缩小，因为它不是段落标记，要和法定的段落标记——硬回车区别出来。硬回车的 html 代码是&lt;code&gt;&amp;lt;p&amp;gt;..&amp;lt;/p&amp;gt;&lt;/code&gt;，段落的内容就夹在里面，而软回车的代码很精悍：&lt;code&gt;&amp;lt;br&amp;gt;&lt;/code&gt;。网页的文字如果复制到 word 中，则硬回车变为弯曲的箭头，软回车变为向下的箭头。&lt;/p&gt;</content></entry><entry><title>几个奇葩的 Linux 命令</title><link href="https://xutree.github.io/pages/2018/10/08/%E5%87%A0%E4%B8%AA%E5%A5%87%E8%91%A9%E7%9A%84Linux%E5%91%BD%E4%BB%A4/" rel="alternate"></link><published>2018-10-08T22:58:12+08:00</published><updated>2018-10-09T11:39:49+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-08:/pages/2018/10/08/几个奇葩的Linux命令/</id><summary type="html">&lt;p&gt;Linux 中有一些很奇葩的命令，可能你的发行版默认没有安装，你可以自己安装：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;[me@linuxbox ~]$ apt-get install 命令          (Debian)
[me@linuxbox ~]$ yum install 命令              (Red Hat）
[me@linuxbox ~]$ brew install 命令            （Mac）
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;rev&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;rev&lt;/code&gt;命令反转输入的内容（来自文件或者标准输入或者管道）：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;[me@linuxbox ~]$ echo Hello, World! | rev
!dlroW ,olleH
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;tac&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;cat&lt;/code&gt;命令的反写，执行效果也和&lt;code&gt;cat&lt;/code&gt;相反，即，将文件列表中的每一个文件输出到标准输出，行号大的优先。&lt;/p&gt;
&lt;h2&gt;sl&lt;/h2&gt;
&lt;p&gt;你可能知道命令&lt;code&gt;ls&lt;/code&gt;,并经常使用它来查看文件夹的内容。但是由于错误输入有时会导致&lt;code&gt;sl …&lt;/code&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;Linux 中有一些很奇葩的命令，可能你的发行版默认没有安装，你可以自己安装：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;[me@linuxbox ~]$ apt-get install 命令          (Debian)
[me@linuxbox ~]$ yum install 命令              (Red Hat）
[me@linuxbox ~]$ brew install 命令            （Mac）
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;rev&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;rev&lt;/code&gt;命令反转输入的内容（来自文件或者标准输入或者管道）：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;[me@linuxbox ~]$ echo Hello, World! | rev
!dlroW ,olleH
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;tac&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;cat&lt;/code&gt;命令的反写，执行效果也和&lt;code&gt;cat&lt;/code&gt;相反，即，将文件列表中的每一个文件输出到标准输出，行号大的优先。&lt;/p&gt;
&lt;h2&gt;sl&lt;/h2&gt;
&lt;p&gt;你可能知道命令&lt;code&gt;ls&lt;/code&gt;,并经常使用它来查看文件夹的内容。但是由于错误输入有时会导致&lt;code&gt;sl&lt;/code&gt;，如何在终端获得一点乐趣而不是“command not found”？&lt;code&gt;sl&lt;/code&gt;命令！&lt;/p&gt;
&lt;p&gt;当你把&lt;code&gt;ls&lt;/code&gt;错误打成&lt;code&gt;sl&lt;/code&gt;时，一辆蒸汽机车（&lt;strong&gt;s&lt;/strong&gt;team &lt;strong&gt;l&lt;/strong&gt;ocomotive）会在屏幕上驶过...&lt;/p&gt;
&lt;p&gt;&lt;img alt="图1 一辆蒸汽机车（steam locomotive）会在屏幕上驶过" src="https://xutree.github.io/images/linux_1.png"&gt;&lt;/p&gt;
&lt;h2&gt;yes&lt;/h2&gt;
&lt;p&gt;yes命令将进入一个循环，一遍又一遍地重复相同的字符串。默认重复“y”，你可以指定其他字符串。&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;[me@linuxbox ~]$ yes &amp;quot;这是一个测试&amp;quot;
这是一个测试
这是一个测试
这是一个测试
这是一个测试
这是一个测试
这是一个测试
这是一个测试
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;利用&lt;code&gt;Ctrl C&lt;/code&gt;终止。&lt;/p&gt;
&lt;h2&gt;cowsay&lt;/h2&gt;
&lt;p&gt;屏幕上会出现一只 ASCII 码拼成的奶牛。。。你可以指定奶牛要说的话。这个命令还有其他版本，如&lt;code&gt;xcowsay&lt;/code&gt;，&lt;code&gt;cowthink&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img alt="图2 一只 ASCII 码拼成的奶牛" src="https://xutree.github.io/images/linux_2.png"&gt;&lt;/p&gt;
&lt;h2&gt;figlet&lt;/h2&gt;
&lt;p&gt;这个算不上奇葩，他它利用 ASCII 码拼成你输出字符串的横幅，而且有许多参数可以定制。还有个&lt;code&gt;toilet&lt;/code&gt;命令和&lt;code&gt;figlet&lt;/code&gt;很类似。比如，&lt;code&gt;figlet good&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img alt="图3 利用 ASCII 码拼成你输出字符串的横幅" src="https://xutree.github.io/images/linux_3.png"&gt;&lt;/p&gt;
&lt;h2&gt;fortune&lt;/h2&gt;
&lt;p&gt;会显示你的未来（ 😆 )。可以试试：&lt;code&gt;[me@linuxbox ~]$ fortune | cowsay&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="图4 显示未来的奶牛" src="https://xutree.github.io/images/linux_4.png"&gt;&lt;/p&gt;
&lt;h2&gt;cmatrix&lt;/h2&gt;
&lt;p&gt;会像《黑客帝国》里那样显示。&lt;/p&gt;
&lt;p&gt;&lt;img alt="图5 黑客帝国" src="https://xutree.github.io/images/linux_5.png"&gt;&lt;/p&gt;
&lt;h2&gt;Fork 炸弹&lt;/h2&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;[me@linuxbox ~]$ :(){ :|:&amp;amp; }:
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;不要尝试不要尝试不要尝试...&lt;/p&gt;
&lt;h2&gt;asciiquarium 水族馆&lt;/h2&gt;
&lt;p&gt;&lt;img alt="图6 水族馆" src="https://xutree.github.io/images/linux_6.png"&gt;&lt;/p&gt;
&lt;h2&gt;lolcat&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;lolcat&lt;/code&gt;可以在终端产生彩虹。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;lolcat&lt;/code&gt;是一个 RubyGem 因此它必须有你的系统上安装了 Ruby 的最新版本。利用文章开头部分的方法安装好&lt;code&gt;lolcat&lt;/code&gt;
后，在终端执行&lt;code&gt;gem install lolcat&lt;/code&gt;安装。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;[me@linuxbox ~]$ git log -1 | cowsay -f dragon-and-cow | lolcat&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="图7 lolcat" src="https://xutree.github.io/images/linux_7.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;lolcat&lt;/code&gt;接受管道输入，所以你可以试试：&lt;code&gt;[me@linuxbox ~]$ sl | lolcat&lt;/code&gt;&lt;/p&gt;</content><category term="Linux"></category></entry></feed>