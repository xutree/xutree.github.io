<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>You Know Nothing - 基础知识</title><link href="https://xutree.github.io/" rel="alternate"></link><link href="https://xutree.github.io/feeds/ji-chu-zhi-shi.atom.xml" rel="self"></link><id>https://xutree.github.io/</id><updated>2018-11-10T15:44:43+08:00</updated><entry><title>方向导数和梯度</title><link href="https://xutree.github.io/pages/2018/11/10/directional_derivative-gradient/" rel="alternate"></link><published>2018-11-10T15:44:43+08:00</published><updated>2018-11-10T15:44:43+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-11-10:/pages/2018/11/10/directional_derivative-gradient/</id><summary type="html">&lt;h2&gt;1. 方向导数&lt;/h2&gt;
&lt;p&gt;多元函数的偏导数反映了函数值沿着坐标轴方向的变化率，方向导数（directional derivative）则表示多元函数沿着某一方向的变化率。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;
定义 1.1（方向导数）设 &lt;span class="math"&gt;\(f\)&lt;/span&gt; 是定义于 &lt;span class="math"&gt;\(\mathbb{R}^n\)&lt;/span&gt; 中某区域 &lt;span class="math"&gt;\(D\)&lt;/span&gt; 上的函数，点 &lt;span class="math"&gt;\(P_0\in D\)&lt;/span&gt;，&lt;span class="math"&gt;\(l\)&lt;/span&gt; 为一给定的非零向量，&lt;span class="math"&gt;\(P\)&lt;/span&gt; 为一动点，向量 &lt;span class="math"&gt;\(\vec{P_0P}\)&lt;/span&gt; 与 &lt;span class="math"&gt;\(l\)&lt;/span&gt; 的方向始终一致。如果极限
&lt;div class="math"&gt;$$\lim_{\|P_0P\|\to0}\frac{f(P)-f(P_0}{\|\vec{P_0P}\|}$$&lt;/div&gt;
存在，则称此极限为函数 &lt;span class="math"&gt;\(f\)&lt;/span&gt; 在 &lt;span class="math"&gt;\(P_0 …&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><content type="html">&lt;h2&gt;1. 方向导数&lt;/h2&gt;
&lt;p&gt;多元函数的偏导数反映了函数值沿着坐标轴方向的变化率，方向导数（directional derivative）则表示多元函数沿着某一方向的变化率。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;
定义 1.1（方向导数）设 &lt;span class="math"&gt;\(f\)&lt;/span&gt; 是定义于 &lt;span class="math"&gt;\(\mathbb{R}^n\)&lt;/span&gt; 中某区域 &lt;span class="math"&gt;\(D\)&lt;/span&gt; 上的函数，点 &lt;span class="math"&gt;\(P_0\in D\)&lt;/span&gt;，&lt;span class="math"&gt;\(l\)&lt;/span&gt; 为一给定的非零向量，&lt;span class="math"&gt;\(P\)&lt;/span&gt; 为一动点，向量 &lt;span class="math"&gt;\(\vec{P_0P}\)&lt;/span&gt; 与 &lt;span class="math"&gt;\(l\)&lt;/span&gt; 的方向始终一致。如果极限
&lt;div class="math"&gt;$$\lim_{\|P_0P\|\to0}\frac{f(P)-f(P_0}{\|\vec{P_0P}\|}$$&lt;/div&gt;
存在，则称此极限为函数 &lt;span class="math"&gt;\(f\)&lt;/span&gt; 在 &lt;span class="math"&gt;\(P_0\)&lt;/span&gt; 处沿 &lt;span class="math"&gt;\(l\)&lt;/span&gt; 方向的方向导数，记作 &lt;span class="math"&gt;\(\frac{\partial f}{\partial l}\)&lt;/span&gt;。
&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;
定义 1.2（方向余弦）设 &lt;span class="math"&gt;\(l\)&lt;/span&gt; 是一个 &lt;span class="math"&gt;\(n\)&lt;/span&gt; 维非零向量，&lt;span class="math"&gt;\(l_0=\frac{l}{\|l\|}，即 $l_0\)&lt;/span&gt; 是与 &lt;span class="math"&gt;\(l\)&lt;/span&gt; 同向的单位向量。取 &lt;span class="math"&gt;\(0\leq\alpha_i\leq\pi\)&lt;/span&gt;，使
&lt;div class="math"&gt;$$l_0=(\cos\alpha_1,\cos\alpha_2,\cdots,\cos\alpha_n)$$&lt;/div&gt;
称
&lt;div class="math"&gt;$$\cos\alpha_1,\cos\alpha_2,\cdots,\cos\alpha_n$$&lt;/div&gt;
为向量 &lt;span class="math"&gt;\(l\)&lt;/span&gt; 的方向余弦。
&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;
定理 1.1（方向导数计算公式）若函数 &lt;span class="math"&gt;\(f\)&lt;/span&gt; 在点 &lt;span class="math"&gt;\(P_0\)&lt;/span&gt; 处可微，向量 &lt;span class="math"&gt;\(l\)&lt;/span&gt; 的方向余弦为 &lt;span class="math"&gt;\(\cos\alpha_1,\cos\alpha_2,\cdots,\cos\alpha_n\)&lt;/span&gt;，则函数 &lt;span class="math"&gt;\(f\)&lt;/span&gt; 在点 &lt;span class="math"&gt;\(P_0\)&lt;/span&gt; 处沿 &lt;span class="math"&gt;\(l\)&lt;/span&gt; 方向的方向导数存在，且
&lt;div class="math"&gt;$$\frac{\partial f}{\partial l}\bigg\rvert_{P_0}=\frac{\partial f}{\partial x_1}\bigg\rvert_{P_0}\cos\alpha_1+\frac{\partial f}{\partial x_2}\bigg\rvert_{P_0}\cos\alpha_2+\cdots+\frac{\partial f}{\partial x_n}\bigg\rvert_{P_0}\cos\alpha_n$$&lt;/div&gt;
&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;证：因为 &lt;span class="math"&gt;\(f\)&lt;/span&gt; 在 &lt;span class="math"&gt;\(P_0\)&lt;/span&gt; 处可微，向量 &lt;span class="math"&gt;\(\vec{P_0P}=(\Delta x_1,\Delta x_2,\cdots,\Delta x_n)\)&lt;/span&gt; 与 &lt;span class="math"&gt;\(l\)&lt;/span&gt; 同向，故
&lt;/p&gt;
&lt;div class="math"&gt;$$f(P)-f(P_0)=\frac{\partial f}{\partial x_1}\bigg\rvert_{P_0}\Delta x_1+\frac{\partial f}{\partial x_2}\bigg\rvert_{P_0}\Delta x_2+\cdots+\frac{\partial f}{\partial x_n}\bigg\rvert_{P_0}\Delta x_n+o(\|\vec{P_0P}\|)$$&lt;/div&gt;
&lt;p&gt;
故
&lt;/p&gt;
&lt;div class="math"&gt;$$\lim_{\|\vec{P_0P}\|\to0}\frac{f(P)-f(P_0)}{\|\vec{P_0P}\|}=\lim_{\|\vec{P_0P}\|\to0}\left[\frac{\partial f}{\partial x_1}\bigg\rvert_{P_0}\frac{\Delta x_1}{\|\vec{P_0P}\|}+\frac{\partial f}{\partial x_2}\bigg\rvert_{P_0}\frac{\Delta x_2}{\|\vec{P_0P}\|}+\cdots+\frac{\partial f}{\partial x_n}\bigg\rvert_{P_0}\frac{\Delta x_n}{\|\vec{P_0P}\|}+\frac{o(\|\vec{P_0P}\|)}{\|\vec{P_0P}\|}\right] \\
=\frac{\partial f}{\partial x_1}\bigg\rvert_{P_0}\cos\alpha_1+\frac{\partial f}{\partial x_2}\bigg\rvert_{P_0}\cos\alpha_2+\cdots+\frac{\partial f}{\partial x_n}\bigg\rvert_{P_0}\cos\alpha_n$$&lt;/div&gt;
&lt;p&gt;
因为 &lt;span class="math"&gt;\(\frac{\partial f}{\partial l}\bigg\rvert_{P_0}\)&lt;/span&gt; 存在，所以
&lt;/p&gt;
&lt;div class="math"&gt;$$\frac{\partial f}{\partial l}\bigg\rvert_{P_0}=\frac{\partial f}{\partial x_1}\bigg\rvert_{P_0}\cos\alpha_1+\frac{\partial f}{\partial x_2}\bigg\rvert_{P_0}\cos\alpha_2+\cdots+\frac{\partial f}{\partial x_n}\bigg\rvert_{P_0}\cos\alpha_n$$&lt;/div&gt;
&lt;p&gt;注意：一个函数即使在某一点处连续，可偏导，且沿所有方向的方向导
数都存在，也不一定在该点可微。所以定义中的可微条件是必须的。&lt;/p&gt;
&lt;h2&gt;2. 梯度&lt;/h2&gt;
&lt;p&gt;设函数 &lt;span class="math"&gt;\(f\)&lt;/span&gt; 定义于 &lt;span class="math"&gt;\(\mathbb{R}^n\)&lt;/span&gt; 的区域 &lt;span class="math"&gt;\(D\)&lt;/span&gt; 上，或者说 &lt;span class="math"&gt;\(f\)&lt;/span&gt; 是区域 &lt;span class="math"&gt;\(D\)&lt;/span&gt; 上的一个数量场。我们的问题是在点 &lt;span class="math"&gt;\(P\in D\)&lt;/span&gt; 处 &lt;span class="math"&gt;\(f\)&lt;/span&gt; 的方向导数沿哪个方向取得最大值，即沿哪个方向数量场的变化率最大？这就是梯度（gradient）问题。&lt;/p&gt;
&lt;p&gt;如果向量 &lt;span class="math"&gt;\(l\)&lt;/span&gt; 的方向余弦为
&lt;/p&gt;
&lt;div class="math"&gt;$$\cos\alpha_1,\cos\alpha_2,\cdots,\cos\alpha_n$$&lt;/div&gt;
&lt;p&gt;
那么 &lt;span class="math"&gt;\(f\)&lt;/span&gt; 在点 &lt;span class="math"&gt;\(P\)&lt;/span&gt; 处沿 &lt;span class="math"&gt;\(l\)&lt;/span&gt; 方向的方向导数为
&lt;/p&gt;
&lt;div class="math"&gt;$$\frac{\partial f}{\partial l}=\frac{\partial f}{\partial x_1}\cos\alpha_1+\cdots+\frac{\partial f}{\partial x_n}\cos\alpha_n$$&lt;/div&gt;
&lt;p&gt;
记 &lt;span class="math"&gt;\(n\)&lt;/span&gt; 维向量
&lt;/p&gt;
&lt;div class="math"&gt;$$\boldsymbol{g}=\left(\frac{\partial f}{\partial x_1},\cdots,\frac{\partial f}{\partial x_n}\right)$$&lt;/div&gt;
&lt;p&gt;
又记 &lt;span class="math"&gt;\(l\)&lt;/span&gt; 方向的单位向量为 &lt;span class="math"&gt;\(\boldsymbol{l_0}\)&lt;/span&gt;，则
&lt;/p&gt;
&lt;div class="math"&gt;$$\boldsymbol{l_0}=\left(\cos\alpha_1,\cdots,\cos\alpha_n\right)$$&lt;/div&gt;
&lt;p&gt;
故
&lt;/p&gt;
&lt;div class="math"&gt;$$\frac{\partial f}{\partial l}=(\boldsymbol{g},\boldsymbol{l_0})$$&lt;/div&gt;
&lt;p&gt;
上式右端表示向量内积，由施瓦兹不等式
&lt;/p&gt;
&lt;div class="math"&gt;$$\left|\frac{\partial f}{\partial l}\right|=|(\boldsymbol{g},\boldsymbol{l_0})|\leq\|\boldsymbol{g}\|\|\boldsymbol{l_0}\|=\|\boldsymbol{g}\|$$&lt;/div&gt;
&lt;p&gt;
当且仅当 &lt;span class="math"&gt;\(\boldsymbol{g}\)&lt;/span&gt; 与 &lt;span class="math"&gt;\(\boldsymbol{l_0}\)&lt;/span&gt; 同向时，等号成立。而且
&lt;/p&gt;
&lt;div class="math"&gt;$$\max\frac{\partial f}{\partial l}=\|\boldsymbol{g}\|=\left[\sum_{i=1}^n\left(\frac{\partial f}{\partial x_i}\right)^2\right]^{\frac{1}{2}}$$&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;
定义 2.1（梯度）设 &lt;span class="math"&gt;\(f\)&lt;/span&gt; 是 &lt;span class="math"&gt;\(\mathbb{R}^n\)&lt;/span&gt; 中区域 &lt;span class="math"&gt;\(D\)&lt;/span&gt; 上的数量场，如果 &lt;span class="math"&gt;\(f\)&lt;/span&gt; 在 &lt;span class="math"&gt;\(P_0\in D\)&lt;/span&gt; 处可微，称向量
&lt;div class="math"&gt;$$\left(\frac{\partial f}{\partial x_1},\frac{\partial f}{\partial x_2},\cdots,\frac{\partial f}{\partial x_n}\right)\bigg\rvert_{P_0}$$&lt;/div&gt;
为 &lt;span class="math"&gt;\(f\)&lt;/span&gt; 在 &lt;span class="math"&gt;\(P_0\)&lt;/span&gt; 处的梯度，记作 &lt;span class="math"&gt;\({\bf grad}f(P_0)\)&lt;/span&gt;。
&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;沿梯度方向，函数值增加最快。同样可知，方向导数的最小值在梯度的相反方向取得。&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="数学"></category></entry><entry><title>梯度下降法</title><link href="https://xutree.github.io/pages/2018/11/10/gradient_descent/" rel="alternate"></link><published>2018-11-10T14:18:44+08:00</published><updated>2018-11-10T14:18:44+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-11-10:/pages/2018/11/10/gradient_descent/</id><summary type="html"></summary><content type="html"></content><category term="数学"></category></entry><entry><title>拉格朗日对偶性</title><link href="https://xutree.github.io/pages/2018/11/10/lagrange_duality/" rel="alternate"></link><published>2018-11-10T13:41:43+08:00</published><updated>2018-11-10T14:16:04+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-11-10:/pages/2018/11/10/lagrange_duality/</id><summary type="html">&lt;h2&gt;1. 原始问题&lt;/h2&gt;
&lt;p&gt;假设 &lt;span class="math"&gt;\(f(x)\)&lt;/span&gt;，&lt;span class="math"&gt;\(c_i(x)\)&lt;/span&gt;，&lt;span class="math"&gt;\(h_j(x)\)&lt;/span&gt; 是定义在 &lt;span class="math"&gt;\(\mathbb{R}^n\)&lt;/span&gt; 上的连续可微函数。考虑约束最优化问题：
&lt;/p&gt;
&lt;div class="math"&gt;$$\min_{x\in\mathbb{R}^n}f(x) \\
\text{s.t.}\ \ \ \ \
\begin{eqnarray}
c_i(x) &amp;amp;\leq&amp;amp; 0,i=1,2,\cdots,k \\
h_j(x) &amp;amp;=&amp;amp; 0,j=1,2,\cdots,l
\end{eqnarray}$$&lt;/div&gt;
&lt;p&gt;
称此优化约束问题为原始最优化问题或原始问题。&lt;/p&gt;
&lt;p&gt;首先 …&lt;/p&gt;&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><content type="html">&lt;h2&gt;1. 原始问题&lt;/h2&gt;
&lt;p&gt;假设 &lt;span class="math"&gt;\(f(x)\)&lt;/span&gt;，&lt;span class="math"&gt;\(c_i(x)\)&lt;/span&gt;，&lt;span class="math"&gt;\(h_j(x)\)&lt;/span&gt; 是定义在 &lt;span class="math"&gt;\(\mathbb{R}^n\)&lt;/span&gt; 上的连续可微函数。考虑约束最优化问题：
&lt;/p&gt;
&lt;div class="math"&gt;$$\min_{x\in\mathbb{R}^n}f(x) \\
\text{s.t.}\ \ \ \ \
\begin{eqnarray}
c_i(x) &amp;amp;\leq&amp;amp; 0,i=1,2,\cdots,k \\
h_j(x) &amp;amp;=&amp;amp; 0,j=1,2,\cdots,l
\end{eqnarray}$$&lt;/div&gt;
&lt;p&gt;
称此优化约束问题为原始最优化问题或原始问题。&lt;/p&gt;
&lt;p&gt;首先，引进广义拉格朗日函数：
&lt;/p&gt;
&lt;div class="math"&gt;$$L(x,\alpha,\beta)=f(x)+\sum_{i=1}^k\alpha_ic_i(x)+\sum_{j=1}^l\beta_jh_j(x)$$&lt;/div&gt;
&lt;p&gt;
这里，&lt;span class="math"&gt;\(x=\left(x^{(1)},x^{(2)},\cdots,x^{(n)}\right)^\text{T}\in\mathbb{R}^n\)&lt;/span&gt;，&lt;span class="math"&gt;\(\alpha_i\)&lt;/span&gt;，&lt;span class="math"&gt;\(\beta_j\)&lt;/span&gt; 是拉格朗日乘子，&lt;span class="math"&gt;\(\alpha_i\geq0\)&lt;/span&gt;，考虑 &lt;span class="math"&gt;\(x\)&lt;/span&gt; 的函数：
&lt;/p&gt;
&lt;div class="math"&gt;$$\theta_P(x)=\max_{\alpha,\beta:\alpha\geq0}L(x,\alpha,\beta)$$&lt;/div&gt;
&lt;p&gt;
这里，下标 &lt;span class="math"&gt;\(P\)&lt;/span&gt; 表示原始问题。&lt;/p&gt;
&lt;p&gt;易知：
&lt;/p&gt;
&lt;div class="math"&gt;$$\theta_P(x)=\begin{cases}
f(x), &amp;amp; x\ 满足原始问题约束 \\
+\infty, &amp;amp; 其他
\end{cases}$$&lt;/div&gt;
&lt;p&gt;
所以如果考虑极小化问题
&lt;/p&gt;
&lt;div class="math"&gt;$$\min_x\theta_P(x)=\min_x\max_{\alpha,\beta:\alpha_i\geq0}L(x,\alpha,\beta)$$&lt;/div&gt;
&lt;p&gt;
它是与原始最优化问题等价的问题。&lt;/p&gt;
&lt;p&gt;为了方便，定义原始问题的最优值
&lt;/p&gt;
&lt;div class="math"&gt;$$p^{\star}=\min_x\theta_P(x)$$&lt;/div&gt;
&lt;p&gt;
称为原始问题的值。&lt;/p&gt;
&lt;h2&gt;2. 对偶问题&lt;/h2&gt;
&lt;p&gt;定义
&lt;/p&gt;
&lt;div class="math"&gt;$$\theta_D(\alpha,\beta)=\min_xL(x,\alpha,\beta)$$&lt;/div&gt;
&lt;p&gt;
再考虑极大化，即
&lt;/p&gt;
&lt;div class="math"&gt;$$\max_{\alpha,\beta:\alpha_i\geq0}\theta_D(\alpha,\beta)=\max_{\alpha,\beta:\alpha_i\geq0}\min_xL(x,\alpha,\beta)$$&lt;/div&gt;
&lt;p&gt;
上述问题称为广义拉格朗日函数的极大极小问题。&lt;/p&gt;
&lt;p&gt;可以将广义拉格朗日函数的极大极小问题表示为约束最优化问题：
&lt;/p&gt;
&lt;div class="math"&gt;$$\max_{\alpha,\beta}\theta_D(\alpha,\beta)=\max_{\alpha,\beta}\min_xL(x,\alpha,\beta) \\
\text{s.t.}\ \ \ \alpha_i\geq0,i=1,2,\cdots,k$$&lt;/div&gt;
&lt;p&gt;
称为原始问题的对偶问题。定义对偶问题的最优值：
&lt;/p&gt;
&lt;div class="math"&gt;$$d^\star=\max_{\alpha,\beta:\alpha_i\geq0}\theta_D(\alpha,\beta)$$&lt;/div&gt;
&lt;p&gt;
称为对偶问题的值。&lt;/p&gt;
&lt;h2&gt;3. 原始问题和对偶问题的关系&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;定理 1&lt;/strong&gt; 若原始问题和对偶问题都有最优值，则
&lt;div class="math"&gt;$$d^\star=\max_{\alpha,\beta:\alpha_i\geq0}\min_xL(x,\alpha,\beta)\leq\min_x\max_{\alpha,\beta:\alpha_i\geq0}L(x,\alpha,\beta)=p^\star$$&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;推论 1&lt;/strong&gt; 设 &lt;span class="math"&gt;\(x^\star\)&lt;/span&gt; 是原始问题的可行解，&lt;span class="math"&gt;\(\alpha^\star\)&lt;/span&gt;，&lt;span class="math"&gt;\(\beta^\star\)&lt;/span&gt; 是对偶问题的可行解，并且 &lt;span class="math"&gt;\(d^\star=p^\star\)&lt;/span&gt;，则它们分别是原始问题和对偶问题的最优解。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;定理 2&lt;/strong&gt; 考虑原始问题和对偶问题。假设函数 &lt;span class="math"&gt;\(f(x)\)&lt;/span&gt; 和 &lt;span class="math"&gt;\(c_i(x)\)&lt;/span&gt; 是凸函数，&lt;span class="math"&gt;\(h_j(x)\)&lt;/span&gt; 是仿射函数；并且假设不等式约束 &lt;span class="math"&gt;\(c_i(x)\)&lt;/span&gt; 是严格可行的，即存在 &lt;span class="math"&gt;\(x\)&lt;/span&gt;，对所有 &lt;span class="math"&gt;\(i\)&lt;/span&gt;，有 &lt;span class="math"&gt;\(c_i&amp;lt;0\)&lt;/span&gt;，则存在 &lt;span class="math"&gt;\(x^\star\)&lt;/span&gt;，&lt;span class="math"&gt;\(\alpha^\star\)&lt;/span&gt;，&lt;span class="math"&gt;\(\beta^\star\)&lt;/span&gt;，使 &lt;span class="math"&gt;\(x^\star\)&lt;/span&gt; 是原始问题的解，&lt;span class="math"&gt;\(\alpha^\star\)&lt;/span&gt;，&lt;span class="math"&gt;\(\beta^\star\)&lt;/span&gt; 是对偶问题的解，并且
&lt;div class="math"&gt;$$p^\star=d^\star=L(x^\star,\alpha^\star,\beta^\star)$$&lt;/div&gt;
&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;定理 3&lt;/strong&gt; 对原始问题和对偶问题，假设函数 &lt;span class="math"&gt;\(f(x)\)&lt;/span&gt; 和 &lt;span class="math"&gt;\(c_i(x)\)&lt;/span&gt; 是凸函数，&lt;span class="math"&gt;\(h_j(x)\)&lt;/span&gt; 是仿射函数，并且假设不等式约束 &lt;span class="math"&gt;\(c_i(x)\)&lt;/span&gt; 是严格可行的，则 &lt;span class="math"&gt;\(x^\star\)&lt;/span&gt;，&lt;span class="math"&gt;\(\alpha^\star\)&lt;/span&gt;，&lt;span class="math"&gt;\(\beta^\star\)&lt;/span&gt; 分别是原始问题和对偶问题的解的充要条件是 &lt;span class="math"&gt;\(x^\star\)&lt;/span&gt;，&lt;span class="math"&gt;\(\alpha^\star\)&lt;/span&gt;，&lt;span class="math"&gt;\(\beta^\star\)&lt;/span&gt; 满足下面的 Karush-Kuhn-Tucker（KKT）条件
&lt;div class="math"&gt;$$\nabla_xL(x^\star,\alpha^\star,\beta^\star)=0 \\
\alpha_i^\star c_i(x^\star)=0,i=1,2,\cdots,k \\
c_i(x^\star)\leq0,i=1,2,\cdots,k \\
\alpha_i^\star\geq0,i=1,2,\cdots,k \\
h_j(x^\star)=0,j=1,2,\cdots,l$$&lt;/div&gt;
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="数学"></category></entry><entry><title>贝叶斯定理</title><link href="https://xutree.github.io/pages/2018/11/05/bayes/" rel="alternate"></link><published>2018-11-05T19:25:38+08:00</published><updated>2018-11-07T12:47:06+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-11-05:/pages/2018/11/05/bayes/</id><summary type="html">&lt;p&gt;贝叶斯定理是关于随机事件 &lt;span class="math"&gt;\(A\)&lt;/span&gt; 和 &lt;span class="math"&gt;\(B\)&lt;/span&gt; 的条件概率的一则定理。
&lt;/p&gt;
&lt;div class="math"&gt;$$P(A|B)=\frac{P(A)\times P(B|A)}{P(B)}$$&lt;/div&gt;
&lt;p&gt;
其中 &lt;span class="math"&gt;\(P(A|B)\)&lt;/span&gt; 是指在事件 &lt;span class="math"&gt;\(B\)&lt;/span&gt; 发生的情况下事件 &lt;span class="math"&gt;\(A\)&lt;/span&gt; 发生的概率。&lt;/p&gt;
&lt;p&gt;在贝叶斯定理中，每个名词都有约定俗成的名称：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(P(A|B)\)&lt;/span&gt; 是已知 &lt;span class="math"&gt;\(B\)&lt;/span&gt; 发生后 &lt;span class="math"&gt;\(A\)&lt;/span&gt; 的条件概率，也由于得自 &lt;span class="math"&gt;\(B\)&lt;/span&gt; 的取值而被称作 &lt;span class="math"&gt;\(A\)&lt;/span&gt; 的后验概率&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(P(A)\)&lt;/span&gt; 是 &lt;span class="math"&gt;\(A\)&lt;/span&gt; 的先验概率（或边缘概率），之所以称为"先验"是因为它不考虑任何 …&lt;/li&gt;&lt;/ul&gt;&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><content type="html">&lt;p&gt;贝叶斯定理是关于随机事件 &lt;span class="math"&gt;\(A\)&lt;/span&gt; 和 &lt;span class="math"&gt;\(B\)&lt;/span&gt; 的条件概率的一则定理。
&lt;/p&gt;
&lt;div class="math"&gt;$$P(A|B)=\frac{P(A)\times P(B|A)}{P(B)}$$&lt;/div&gt;
&lt;p&gt;
其中 &lt;span class="math"&gt;\(P(A|B)\)&lt;/span&gt; 是指在事件 &lt;span class="math"&gt;\(B\)&lt;/span&gt; 发生的情况下事件 &lt;span class="math"&gt;\(A\)&lt;/span&gt; 发生的概率。&lt;/p&gt;
&lt;p&gt;在贝叶斯定理中，每个名词都有约定俗成的名称：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(P(A|B)\)&lt;/span&gt; 是已知 &lt;span class="math"&gt;\(B\)&lt;/span&gt; 发生后 &lt;span class="math"&gt;\(A\)&lt;/span&gt; 的条件概率，也由于得自 &lt;span class="math"&gt;\(B\)&lt;/span&gt; 的取值而被称作 &lt;span class="math"&gt;\(A\)&lt;/span&gt; 的后验概率&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(P(A)\)&lt;/span&gt; 是 &lt;span class="math"&gt;\(A\)&lt;/span&gt; 的先验概率（或边缘概率），之所以称为"先验"是因为它不考虑任何 &lt;span class="math"&gt;\(B\)&lt;/span&gt; 方面的因素&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(P(B|A)\)&lt;/span&gt; 是已知 &lt;span class="math"&gt;\(A\)&lt;/span&gt; 发生后 &lt;span class="math"&gt;\(B\)&lt;/span&gt; 的条件概率，也由于得自 &lt;span class="math"&gt;\(A\)&lt;/span&gt; 的取值而被称作 &lt;span class="math"&gt;\(B\)&lt;/span&gt; 的后验概率&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(P(B)\)&lt;/span&gt; 是 &lt;span class="math"&gt;\(B\)&lt;/span&gt; 的先验概率或边缘概率&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;推导&lt;/h2&gt;
&lt;p&gt;根据条件概率的定义。在事件 &lt;span class="math"&gt;\(B\)&lt;/span&gt; 发生的条件下事件A发生的概率是
&lt;/p&gt;
&lt;div class="math"&gt;$$P(A|B)={\frac {P(A\cap B)}{P(B)}}$$&lt;/div&gt;
&lt;p&gt;
其中 &lt;span class="math"&gt;\(A\)&lt;/span&gt; 与 &lt;span class="math"&gt;\(B\)&lt;/span&gt; 的联合概率表示为 &lt;span class="math"&gt;\(P(A\cap B)\)&lt;/span&gt; 或者 &lt;span class="math"&gt;\(P(A,B)\)&lt;/span&gt; 或者 &lt;span class="math"&gt;\(P(AB)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;同样地，在事件 &lt;span class="math"&gt;\(A\)&lt;/span&gt; 发生的条件下事件 &lt;span class="math"&gt;\(B\)&lt;/span&gt; 发生的概率
&lt;/p&gt;
&lt;div class="math"&gt;$$P(B|A)={\frac {P(A\cap B)}{P(A)}}$$&lt;/div&gt;
&lt;p&gt;整理与合并这两个方程式，我们可以得到
&lt;/p&gt;
&lt;div class="math"&gt;$$P(A|B)\,P(B)=P(A\cap B)=P(B|A)P(A)$$&lt;/div&gt;
&lt;p&gt;
这个引理有时称作概率乘法规则。上式两边同除以 &lt;span class="math"&gt;\(P(B)\)&lt;/span&gt;，若 &lt;span class="math"&gt;\(P(B)\)&lt;/span&gt; 是非零的，我们可以得到贝叶斯定理
&lt;/p&gt;
&lt;div class="math"&gt;$$P(A|B)=\frac{P(B|A)P(A)}{P(B)}$$&lt;/div&gt;
&lt;h2&gt;其他形式&lt;/h2&gt;
&lt;div class="math"&gt;$$P(A|B)={\frac {P(B|A)\,P(A)}{P(B|A)P(A)+P(B|A^{C})P(A^{C})}}$$&lt;/div&gt;
&lt;p&gt;其中 &lt;span class="math"&gt;\(A^C\)&lt;/span&gt; 是 &lt;span class="math"&gt;\(A\)&lt;/span&gt; 的补集（即非 &lt;span class="math"&gt;\(A\)&lt;/span&gt;），因为
&lt;/p&gt;
&lt;div class="math"&gt;$$P(B)=P(A,B)+P(A^{C},B)=P(B|A)P(A)+P(B|A^{C})P(A^{C})$$&lt;/div&gt;
&lt;p&gt;在更一般化的情况，假设 &lt;span class="math"&gt;\(A_i\)&lt;/span&gt; 是事件集合里的部分集合，对于任意的 &lt;span class="math"&gt;\(A_i\)&lt;/span&gt;，贝叶斯定理可用下式表示
&lt;/p&gt;
&lt;div class="math"&gt;$$P(A_{i}|B)={\frac {P(B|A_{i})\,P(A_{i})}{\sum_{j}P(B|A_{j})\,P(A_{j})}}$$&lt;/div&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="概率"></category><category term="数学"></category></entry><entry><title>矩阵微积分</title><link href="https://xutree.github.io/pages/2018/10/23/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC/" rel="alternate"></link><published>2018-10-23T20:42:45+08:00</published><updated>2018-10-24T11:57:17+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-23:/pages/2018/10/23/矩阵求导/</id><summary type="html">&lt;p&gt;矩阵求导，本质是多元函数求导，仅仅是把函数的⾃变量以及求导的结果排列成了矩阵的形式，⽅便表达与计算。类似地，复合函数的求导法则本质上也是多元函数求导的链式法则，只是将结果整理成了矩阵的形式。从原理上讲，可以对矩阵的每个分量逐元素地求导，得到最终结果；但是这样做太繁琐，极其容易出错，因此推导并记住⼀些常⽤的结论在实践中是⾮常必要的。&lt;/p&gt;
&lt;p&gt;不同的矩阵求导方法采取不同的导数排列方法，以便于所求导数可以方便后续计算。主要存在两种符号约定。&lt;/p&gt;
&lt;h2&gt;1. 概述&lt;/h2&gt;
&lt;p&gt;矩阵微积分的自变量可以是标量，向量，或者是一个矩阵，因变量也可以是上述的三者之一。每一种不同的自变量和因变量的组合都有不同的一套运算规则。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="center"&gt;&lt;/th&gt;
&lt;th align="center"&gt;标量&lt;/th&gt;
&lt;th align="center"&gt;向量&lt;/th&gt;
&lt;th align="center"&gt;矩阵&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="center"&gt;标量&lt;/td&gt;
&lt;td align="center"&gt;&lt;span class="math"&gt;\(\frac{\partial y}{\partial x}\)&lt;/span&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;span class="math"&gt;\(\frac{\partial {\boldsymbol y}}{\partial x}\)&lt;/span&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;span class="math"&gt;\(\frac{\partial {\bf Y}}{\partial x}\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;向量&lt;/td&gt;
&lt;td align="center"&gt;&lt;span class="math"&gt;\(\frac …&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><content type="html">&lt;p&gt;矩阵求导，本质是多元函数求导，仅仅是把函数的⾃变量以及求导的结果排列成了矩阵的形式，⽅便表达与计算。类似地，复合函数的求导法则本质上也是多元函数求导的链式法则，只是将结果整理成了矩阵的形式。从原理上讲，可以对矩阵的每个分量逐元素地求导，得到最终结果；但是这样做太繁琐，极其容易出错，因此推导并记住⼀些常⽤的结论在实践中是⾮常必要的。&lt;/p&gt;
&lt;p&gt;不同的矩阵求导方法采取不同的导数排列方法，以便于所求导数可以方便后续计算。主要存在两种符号约定。&lt;/p&gt;
&lt;h2&gt;1. 概述&lt;/h2&gt;
&lt;p&gt;矩阵微积分的自变量可以是标量，向量，或者是一个矩阵，因变量也可以是上述的三者之一。每一种不同的自变量和因变量的组合都有不同的一套运算规则。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="center"&gt;&lt;/th&gt;
&lt;th align="center"&gt;标量&lt;/th&gt;
&lt;th align="center"&gt;向量&lt;/th&gt;
&lt;th align="center"&gt;矩阵&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="center"&gt;标量&lt;/td&gt;
&lt;td align="center"&gt;&lt;span class="math"&gt;\(\frac{\partial y}{\partial x}\)&lt;/span&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;span class="math"&gt;\(\frac{\partial {\boldsymbol y}}{\partial x}\)&lt;/span&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;span class="math"&gt;\(\frac{\partial {\bf Y}}{\partial x}\)&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;向量&lt;/td&gt;
&lt;td align="center"&gt;&lt;span class="math"&gt;\(\frac{\partial y}{\partial {\boldsymbol x}}\)&lt;/span&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;span class="math"&gt;\(\frac{\partial {\boldsymbol y}}{\partial {\boldsymbol x}}\)&lt;/span&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="center"&gt;矩阵&lt;/td&gt;
&lt;td align="center"&gt;&lt;span class="math"&gt;\(\frac{\partial y}{\partial {\bf X}}\)&lt;/span&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;/td&gt;
&lt;td align="center"&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;向量和标量可以看作矩阵的特殊形式。表中用粗体小写字母代表向量，粗体大写字母代表矩阵。&lt;/p&gt;
&lt;p&gt;上表中空白的部分求导结果维度太高，而且没有统一的符号约定。&lt;/p&gt;
&lt;p&gt;以下说明采用“分子布局”。&lt;/p&gt;
&lt;h2&gt;2. 分子布局下的求导&lt;/h2&gt;
&lt;h3&gt;2.1 向量对标量求导&lt;/h3&gt;
&lt;div class="math"&gt;$${\boldsymbol y}=\begin{bmatrix}
y_{1}\\
y_{2}\\
\vdots\\
y_{m}
\end{bmatrix}
\Longrightarrow\frac{\partial {\boldsymbol y}}{\partial x}=\begin{bmatrix}
\frac{\partial y_1}{\partial x}\\
\frac{\partial y_2}{\partial x}\\
\vdots\\
\frac{\partial y_m}{\partial x}\\
\end{bmatrix}$$&lt;/div&gt;
&lt;p&gt;在向量微积分中，向量 &lt;span class="math"&gt;\({\boldsymbol y}\)&lt;/span&gt; 相对于标量 &lt;span class="math"&gt;\(x\)&lt;/span&gt; 的导数被称为向量 &lt;span class="math"&gt;\({\boldsymbol y}\)&lt;/span&gt; 的切向量。&lt;/p&gt;
&lt;h3&gt;2.2 标量对向量求导&lt;/h3&gt;
&lt;div class="math"&gt;$${\boldsymbol x} =
\begin{bmatrix}
x_1 \\
x_2 \\
\vdots \\
x_n \\
\end{bmatrix}\Longrightarrow
\frac{\partial y}{\partial {\boldsymbol x}^{\text{T}}} =
\left[
\frac{\partial y}{\partial x_1}
\frac{\partial y}{\partial x_2}
\cdots
\frac{\partial y}{\partial x_n}
\right]$$&lt;/div&gt;
&lt;p&gt;这是标量函数 &lt;span class="math"&gt;\(f({\boldsymbol x})\)&lt;/span&gt; 梯度的转置。&lt;/p&gt;
&lt;h3&gt;2.3 向量对向量的求导&lt;/h3&gt;
&lt;div class="math"&gt;$${\boldsymbol y} =
\begin{bmatrix}
y_1 \\
y_2 \\
\vdots \\
y_m \\
\end{bmatrix},{\boldsymbol x} =
\begin{bmatrix}
x_1 \\
x_2 \\
\vdots \\
x_n \\
\end{bmatrix}\Longrightarrow
\frac{\partial {\boldsymbol y}}{\partial {\boldsymbol x}} =
\begin{bmatrix}
\frac{\partial y_1}{\partial x_1} &amp;amp; \frac{\partial y_1}{\partial x_2} &amp;amp; \cdots &amp;amp; \frac{\partial y_1}{\partial x_n}\\
\frac{\partial y_2}{\partial x_1} &amp;amp; \frac{\partial y_2}{\partial x_2} &amp;amp; \cdots &amp;amp; \frac{\partial y_2}{\partial x_n}\\
\vdots &amp;amp; \vdots &amp;amp; \ddots &amp;amp; \vdots\\
\frac{\partial y_m}{\partial x_1} &amp;amp; \frac{\partial y_m}{\partial x_2} &amp;amp; \cdots &amp;amp; \frac{\partial y_m}{\partial x_n}\\
\end{bmatrix}$$&lt;/div&gt;
&lt;p&gt;此即雅可比矩阵。&lt;/p&gt;
&lt;h3&gt;2.5 矩阵对标量求导&lt;/h3&gt;
&lt;div class="math"&gt;$$\frac{\partial {\bf Y}}{\partial x} =
\begin{bmatrix}
\frac{\partial y_{11}}{\partial x} &amp;amp; \frac{\partial y_{12}}{\partial x} &amp;amp; \cdots &amp;amp; \frac{\partial y_{1n}}{\partial x}\\
\frac{\partial y_{21}}{\partial x} &amp;amp; \frac{\partial y_{22}}{\partial x} &amp;amp; \cdots &amp;amp; \frac{\partial y_{2n}}{\partial x}\\
\vdots &amp;amp; \vdots &amp;amp; \ddots &amp;amp; \vdots\\
\frac{\partial y_{m1}}{\partial x} &amp;amp; \frac{\partial y_{m2}}{\partial x} &amp;amp; \cdots &amp;amp; \frac{\partial y_{mn}}{\partial x}\\
\end{bmatrix}$$&lt;/div&gt;
&lt;p&gt;称为切矩阵。&lt;/p&gt;
&lt;h3&gt;2.6 标量对矩阵求导&lt;/h3&gt;
&lt;div class="math"&gt;$$\frac{\partial y}{\partial {\bf X}} =
\begin{bmatrix}
\frac{\partial y}{\partial x_{11}} &amp;amp; \frac{\partial y}{\partial x_{21}} &amp;amp; \cdots &amp;amp; \frac{\partial y}{\partial x_{p1}}\\
\frac{\partial y}{\partial x_{12}} &amp;amp; \frac{\partial y}{\partial x_{22}} &amp;amp; \cdots &amp;amp; \frac{\partial y}{\partial x_{p2}}\\
\vdots &amp;amp; \vdots &amp;amp; \ddots &amp;amp; \vdots\\
\frac{\partial y}{\partial x_{1q}} &amp;amp; \frac{\partial y}{\partial x_{2q}} &amp;amp; \cdots &amp;amp; \frac{\partial y}{\partial x_{pq}}\\
\end{bmatrix}$$&lt;/div&gt;
&lt;p&gt;矩阵标量 &lt;span class="math"&gt;\(f({\bf X})\)&lt;/span&gt; 在矩阵 &lt;span class="math"&gt;\({\bf Y}\)&lt;/span&gt; 方向上的方向导数为：&lt;/p&gt;
&lt;div class="math"&gt;$$\nabla_{\bf Y} f = \operatorname{tr} \left(\frac{\partial f}{\partial {\bf X}} {\bf Y}\right)$$&lt;/div&gt;
&lt;h3&gt;2.7 其他矩阵求导&lt;/h3&gt;
&lt;p&gt;对于向量对矩阵求导，矩阵对向量求导，矩阵对矩阵求导。它们没有统一的符号，也没有统一的应用。&lt;/p&gt;
&lt;p&gt;与向量相关的两种矩阵导数，可以被看作是一个只有一列的矩阵和另一个矩阵导数的特例。下面只考虑如何写出一个矩阵对另一个矩阵求导的导数结果。&lt;/p&gt;
&lt;h2&gt;3. 标量对矩阵求导计算方法&lt;/h2&gt;
&lt;h3&gt;3.1 全微分公式&lt;/h3&gt;
&lt;p&gt;
对于实值函数对矩阵求导，我们可以写出：&lt;/p&gt;
&lt;div class="math"&gt;$$df=\sum_{i=1}^m\sum_{j=1}^n\frac{\partial f}{\partial x_{ij}}dx_{ij}=\text{tr}\left(\left(\frac{\partial f}{\partial x}\right)^\text{T}dx\right)$$&lt;/div&gt;
&lt;h3&gt;3.2 微分法则&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;加减：&lt;span class="math"&gt;\(d({\bf X}\pm{\bf Y})=d{\bf X}\pm d{\bf Y}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;乘法：&lt;span class="math"&gt;\(d({\bf XY})=(d{\bf X}){\bf Y}+{\bf X}(d{\bf Y})\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;转置：&lt;span class="math"&gt;\(d({\bf X}^\text{T})=(d{\bf X})^\text{T}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;迹：&lt;span class="math"&gt;\(d\text{tr}({\bf X})=\text{tr}(d{\bf X})\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;逆：&lt;span class="math"&gt;\(d{\bf X}^{-1}=-{\bf X}^{-1}d{\bf X}{\bf X}^{-1}\)&lt;/span&gt;，利用 &lt;span class="math"&gt;\({\bf X}{\bf X}^{-1}=\mathbb{I}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;行列式：&lt;span class="math"&gt;\(d|{\bf X}|=\text{tr}({\bf X}^*d{\bf X})\)&lt;/span&gt;，其中 &lt;span class="math"&gt;\({\bf X}^*\)&lt;/span&gt; 表示 &lt;span class="math"&gt;\({\bf X}\)&lt;/span&gt; 的伴随矩阵，在 &lt;span class="math"&gt;\({\bf X}\)&lt;/span&gt; 可逆时又可以写做：&lt;span class="math"&gt;\(d|{\bf X}|=|{\bf X}|\text{tr}({\bf X}^{-1}d{\bf X})\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;逐元素乘：&lt;span class="math"&gt;\(d({\bf X}\odot{\bf Y})=d{\bf X}\odot{\bf Y}+{\bf X}\odot d{\bf Y}\)&lt;/span&gt;，&lt;span class="math"&gt;\(\odot\)&lt;/span&gt; 表示尺寸相同的矩阵逐元素相乘&lt;/li&gt;
&lt;li&gt;逐元素函数：&lt;span class="math"&gt;\(dw({\bf X})=w'({\bf X})\odot d{\bf X}\)&lt;/span&gt;，&lt;span class="math"&gt;\(w({\bf X})\)&lt;/span&gt; 是逐元素标量运算，&lt;span class="math"&gt;\(w'({\bf X})\)&lt;/span&gt;是逐元素求导&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;3.3 其他公式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(\text{tr}(a)=a\)&lt;/span&gt;，&lt;span class="math"&gt;\(a\)&lt;/span&gt; 为标量&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(\text{tr}({\bf A}^\text{T})=\text{tr}({\bf A})\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(\text{tr}({\bf A}+{\bf B})=\text{tr}({\bf A})+\text{tr}({\bf B})\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(\text{tr}({\bf AB})=\text{tr}({\bf BA})\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(\text{tr}\left({\bf A}^{\text{T}}({\bf B}\odot{\bf C})\right)=\text{tr}\left(({\bf A}\odot {\bf B})^{\text{T}}{\bf C}\right)\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;3.4 求导方法&lt;/h3&gt;
&lt;p&gt;若标量函数 &lt;span class="math"&gt;\(f\)&lt;/span&gt; 是矩阵&lt;span class="math"&gt;\({\bf X}\)&lt;/span&gt; 经加减乘法、行列式、逆、逐元素函数等运算构成，则使用相应的运算法则对 &lt;span class="math"&gt;\(f\)&lt;/span&gt; 求微分，再使用迹变换给 &lt;span class="math"&gt;\(df\)&lt;/span&gt; 套上迹并将其它项交换至 &lt;span class="math"&gt;\(d{\bf X}\)&lt;/span&gt; 左侧，即能得到导数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;例题1&lt;/strong&gt;：&lt;span class="math"&gt;\(f={\boldsymbol a}^{\text{T}}{\bf X}{\boldsymbol b}\)&lt;/span&gt;，求：&lt;span class="math"&gt;\(\frac{\partial f}{\partial {\bf X}}\)&lt;/span&gt;。其中 &lt;span class="math"&gt;\({\boldsymbol a}\)&lt;/span&gt; 是 &lt;span class="math"&gt;\(m\times 1\)&lt;/span&gt; 列向量，&lt;span class="math"&gt;\({\bf X}\)&lt;/span&gt; 是 &lt;span class="math"&gt;\(m\times n\)&lt;/span&gt; 矩阵，&lt;span class="math"&gt;\({\boldsymbol b}\)&lt;/span&gt; 是 &lt;span class="math"&gt;\(n\times 1\)&lt;/span&gt; 列向量，&lt;span class="math"&gt;\(f\)&lt;/span&gt; 是标量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解答&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;全微分：&lt;/p&gt;
&lt;div class="math"&gt;$$df={\boldsymbol a}^{\text{T}}d{\bf X}{\boldsymbol b}$$&lt;/div&gt;
&lt;p&gt;两边取迹：&lt;/p&gt;
&lt;div class="math"&gt;$$df=\text{tr}({\boldsymbol a}^{\text{T}}d{\bf X}{\boldsymbol b})=\text{tr}({\boldsymbol b}{\boldsymbol a}^{\text{T}}d{\bf X})$$&lt;/div&gt;
&lt;p&gt;对照全微分公式：&lt;/p&gt;
&lt;div class="math"&gt;$$(\frac{\partial f}{\partial {\bf X}})^{\text{T}}={\boldsymbol b}{\boldsymbol a}^{\text{T}}$$&lt;/div&gt;
&lt;p&gt;得到：&lt;/p&gt;
&lt;div class="math"&gt;$$\frac{\partial f}{\partial {\bf X}}=({\boldsymbol b}{\boldsymbol a}^{\text{T}})^{\text{T}}={\boldsymbol a}{\boldsymbol b}^{\text{T}}$$&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;例题2&lt;/strong&gt;：&lt;span class="math"&gt;\(f={\boldsymbol a}^{\text{T}}\text{exp}({\bf X}{\boldsymbol b})\)&lt;/span&gt;，求：&lt;span class="math"&gt;\(\frac{\partial f}{\partial {\bf X}}\)&lt;/span&gt;。其中 &lt;span class="math"&gt;\(\boldsymbol{a}\)&lt;/span&gt; 是 &lt;span class="math"&gt;\(m\times 1\)&lt;/span&gt; 列向量，&lt;span class="math"&gt;\({\bf X}\)&lt;/span&gt; 是 &lt;span class="math"&gt;\(m\times n\)&lt;/span&gt; 矩阵，&lt;span class="math"&gt;\(\boldsymbol{b}\)&lt;/span&gt; 是 &lt;span class="math"&gt;\(n\times 1\)&lt;/span&gt; 列向量，&lt;span class="math"&gt;\(\text{exp}\)&lt;/span&gt; 表示逐元素求指数，&lt;span class="math"&gt;\(f\)&lt;/span&gt; 是标量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解答&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;全微分：&lt;/p&gt;
&lt;div class="math"&gt;$$df=\boldsymbol{a}^{\text{T}}\left(\text{exp}({\bf X}{\boldsymbol b})\odot(d{\bf X}{\boldsymbol b})\right)$$&lt;/div&gt;
&lt;p&gt;两边取迹：&lt;/p&gt;
&lt;div class="math"&gt;$$df = \text{tr}( \boldsymbol{a}^{\text{T}}(\exp({\bf X}\boldsymbol{b})\odot (d{\bf X}\boldsymbol{b}))) \\
=\text{tr}((\boldsymbol{a}\odot \exp({\bf X}\boldsymbol{b}))^{\text{T}}dX \boldsymbol{b}) \\
= \text{tr}(\boldsymbol{b}(\boldsymbol{a}\odot \exp({\bf X}\boldsymbol{b}))^\text{T}d{\bf X})$$&lt;/div&gt;
&lt;p&gt;对照全微分公式得到：&lt;/p&gt;
&lt;div class="math"&gt;$$\frac{\partial f}{\partial {\bf X}} = (\boldsymbol{b}(\boldsymbol{a}\odot \exp({\bf X}\boldsymbol{b}))^{\text{T}})^{\text{T}}= (\boldsymbol{a}\odot \exp({\bf X}\boldsymbol{b}))\boldsymbol{b}^{\text{T}}$$&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;例题3&lt;/strong&gt;：线性回归问题。&lt;span class="math"&gt;\(l = \|{\bf X}\boldsymbol{w}- \boldsymbol{y}\|^2\)&lt;/span&gt;。求 &lt;span class="math"&gt;\(\boldsymbol{w}\)&lt;/span&gt; 的最小二乘估计，即求 &lt;span class="math"&gt;\(\frac{\partial l}{\partial \boldsymbol{w}}\)&lt;/span&gt; 的零点。其中 &lt;span class="math"&gt;\(\boldsymbol{y}\)&lt;/span&gt; 是 &lt;span class="math"&gt;\(m\times 1\)&lt;/span&gt; 列向量，&lt;span class="math"&gt;\({\bf X}\)&lt;/span&gt; 是 &lt;span class="math"&gt;\(m\times n\)&lt;/span&gt; 矩阵，&lt;span class="math"&gt;\(\boldsymbol{w}\)&lt;/span&gt; 是 &lt;span class="math"&gt;\(n\times 1\)&lt;/span&gt; 列向量，&lt;span class="math"&gt;\(l\)&lt;/span&gt; 是标量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解答&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;改写模平方表达式：&lt;/p&gt;
&lt;div class="math"&gt;$$l = ({\bf X}\boldsymbol{w}- \boldsymbol{y})^{\text{T}}({\bf X}\boldsymbol{w}- \boldsymbol{y})$$&lt;/div&gt;
&lt;p&gt;全微分：&lt;/p&gt;
&lt;div class="math"&gt;$$dl = ({\bf X}d\boldsymbol{w})^\text{T}({\bf X}\boldsymbol{w}-\boldsymbol{y})+({\bf X}\boldsymbol{w}-\boldsymbol{y})^\text{T}({\bf X}d\boldsymbol{w}) = 2({\bf X}\boldsymbol{w}-\boldsymbol{y})^\text{T}{\bf X}d\boldsymbol{w}$$&lt;/div&gt;
&lt;p&gt;对照全微分公式得到：&lt;/p&gt;
&lt;div class="math"&gt;$$\frac{\partial l}{\partial \boldsymbol{w}}= (2({\bf X}\boldsymbol{w}-\boldsymbol{y})^\text{T}{\bf X})^\text{T} = 2{\boldsymbol X}^\text{T}({\bf X}\boldsymbol{w}-\boldsymbol{y})$$&lt;/div&gt;
&lt;p&gt;&lt;span class="math"&gt;\(\frac{\partial l}{\partial \boldsymbol{w}}\)&lt;/span&gt; 的零点即 &lt;span class="math"&gt;\(\frac{\partial l}{\partial \boldsymbol{w}}\)&lt;/span&gt; 的最小二乘估计 &lt;span class="math"&gt;\(\boldsymbol{w} = ({\bf X^\text{T}X})^{-1}{\bf X}^\text{T}\boldsymbol{y}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;例题4&lt;/strong&gt;：方差的最大似然估计。样本 &lt;span class="math"&gt;\(\boldsymbol{x}_1,\dots, \boldsymbol{x}_n\sim N(\boldsymbol{\mu}, \Sigma)\)&lt;/span&gt;，求方差 &lt;span class="math"&gt;\(\Sigma\)&lt;/span&gt; 的最大似然估计。写成数学式是：&lt;span class="math"&gt;\(l =\log|\Sigma|+\frac{1}{n}\sum_{i=1}^n(\boldsymbol{x}_i-\boldsymbol{\bar{x}})^\text{T}\Sigma^{-1}(\boldsymbol{x}_i-\boldsymbol{\bar{x}})\)&lt;/span&gt;，求 &lt;span class="math"&gt;\(\frac{\partial l }{\partial \Sigma}\)&lt;/span&gt; 的零点。其中 &lt;span class="math"&gt;\(\boldsymbol{x}_i\)&lt;/span&gt; 是 &lt;span class="math"&gt;\(m\times 1\)&lt;/span&gt; 列向量，&lt;span class="math"&gt;\(\overline{\boldsymbol{x}}=\frac{1}{n}\sum_{i=1}^n \boldsymbol{x}_i\)&lt;/span&gt; 是样本均值，&lt;span class="math"&gt;\(\Sigma\)&lt;/span&gt; 是 &lt;span class="math"&gt;\(m\times m\)&lt;/span&gt; 对称正定矩阵，&lt;span class="math"&gt;\(l\)&lt;/span&gt; 是标量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解答&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;第一项：&lt;/p&gt;
&lt;div class="math"&gt;$$d\log|\Sigma| = |\Sigma|^{-1}d|\Sigma| = \text{tr}(\Sigma^{-1}d\Sigma)$$&lt;/div&gt;
&lt;p&gt;第二项：&lt;/p&gt;
&lt;div class="math"&gt;$$\frac{1}{n}\sum_{i=1}^n(\boldsymbol{x}_i-\boldsymbol{\bar{x}})^\text{T}d\Sigma^{-1}(\boldsymbol{x}_i-\boldsymbol{\bar{x}}) = -\frac{1}{n}\sum_{i=1}^n(\boldsymbol{x}_i-\boldsymbol{\bar{x}})^\text{T}\Sigma^{-1}d\Sigma\Sigma^{-1}(\boldsymbol{x}_i-\boldsymbol{\bar{x}})$$&lt;/div&gt;
&lt;p&gt;第二项求迹：&lt;/p&gt;
&lt;div class="math"&gt;$$\text{tr}\left(\frac{1}{n}\sum_{i=1}^n(\boldsymbol{x}_i-\boldsymbol{\bar{x}})^\text{T}\Sigma^{-1}d\Sigma\Sigma^{-1}(\boldsymbol{x}_i-\boldsymbol{\bar{x}})\right)\\
=\frac{1}{n} \sum_{i=1}^n \text{tr}((\boldsymbol{x}_i-\boldsymbol{\bar{x}})^\text{T}\Sigma^{-1} d\Sigma \Sigma^{-1}(\boldsymbol{x}_i-\boldsymbol{\bar{x}}))\\
= \frac{1}{n}\sum_{i=1}^n\text{tr}\left(\Sigma^{-1}(\boldsymbol{x}_i-\boldsymbol{\bar{x}})(\boldsymbol{x}_i-\boldsymbol{\bar{x}})^\text{T}\Sigma^{-1}d\Sigma\right)=\text{tr}(\Sigma^{-1}S\Sigma^{-1}d\Sigma)$$&lt;/div&gt;
&lt;p&gt;定义：&lt;/p&gt;
&lt;div class="math"&gt;$$S = \frac{1}{n}\sum_{i=1}^n(\boldsymbol{x}_i-\boldsymbol{\bar{x}})(\boldsymbol{x}_i-\boldsymbol{\bar{x}})^\text{T}$$&lt;/div&gt;
&lt;p&gt; 为样本方差矩阵&lt;/p&gt;
&lt;p&gt;得到：&lt;/p&gt;
&lt;div class="math"&gt;$$dl = \text{tr}\left(\left(\Sigma^{-1}-\Sigma^{-1}S\Sigma^{-1}\right)d\Sigma\right)$$&lt;/div&gt;
&lt;p&gt;对照全微分公式得到：&lt;/p&gt;
&lt;div class="math"&gt;$$\frac{\partial l }{\partial \Sigma}=(\Sigma^{-1}-\Sigma^{-1}S\Sigma^{-1})^\text{T}$$&lt;/div&gt;
&lt;p&gt;其零点即 &lt;span class="math"&gt;\(\Sigma\)&lt;/span&gt; 的最大似然估计为 &lt;span class="math"&gt;\(\Sigma = S\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;例题5&lt;/strong&gt;：多元 logistic 回归。&lt;span class="math"&gt;\(l = -\boldsymbol{y}^\text{T}\ln\text{softmax}({\bf W}\boldsymbol{x})\)&lt;/span&gt;，求 &lt;span class="math"&gt;\(\frac{\partial l}{\partial W}\)&lt;/span&gt;。其中 &lt;span class="math"&gt;\(\boldsymbol{y}\)&lt;/span&gt; 是除一个元素为1外其它元素为0的 &lt;span class="math"&gt;\(m\times 1\)&lt;/span&gt; 列向量，&lt;span class="math"&gt;\({\bf W}\)&lt;/span&gt; 是 &lt;span class="math"&gt;\(m\times n\)&lt;/span&gt; 矩阵，&lt;span class="math"&gt;\(\boldsymbol{x}\)&lt;/span&gt; 是 &lt;span class="math"&gt;\(n\times 1\)&lt;/span&gt; 列向量，&lt;span class="math"&gt;\(l\)&lt;/span&gt; 是标量；&lt;span class="math"&gt;\(\text{softmax}(\boldsymbol{a}) = \frac{\exp(\boldsymbol{a})}{\boldsymbol{1}^\text{T}\exp(\boldsymbol{a})}\)&lt;/span&gt;，其中 &lt;span class="math"&gt;\(\exp(\boldsymbol{a})\)&lt;/span&gt; 表示逐元素求指数，&lt;span class="math"&gt;\(\boldsymbol{1}\)&lt;/span&gt; 代表全1向量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解答&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;首先将 softmax 函数代入并写成：&lt;/p&gt;
&lt;div class="math"&gt;$$l = -\boldsymbol{y}^\text{T} \left(\ln (\exp({\bf W}\boldsymbol{x}))-\boldsymbol{1}\ln(\boldsymbol{1}^\text{T}\exp({\bf W}\boldsymbol{x}))\right) \\
= -\boldsymbol{y}^\text{T}{\bf W}\boldsymbol{x} + \ln(\boldsymbol{1}^\text{T}\exp({\bf W}\boldsymbol{x}))\\$$&lt;/div&gt;
&lt;p&gt;这里注意：注意逐元素 log 满足等式：&lt;/p&gt;
&lt;div class="math"&gt;$$\ln(\boldsymbol{u}/c) = \ln(\boldsymbol{u}) - \boldsymbol{1}\ln(c)$$&lt;/div&gt;
&lt;p&gt;以及：&lt;/p&gt;
&lt;div class="math"&gt;$$\boldsymbol{y}^\text{T} \boldsymbol{1} = 1$$&lt;/div&gt;
&lt;p&gt;求微分：&lt;/p&gt;
&lt;div class="math"&gt;$$dl =-\boldsymbol{y}^\text{T}d{\bf W}\boldsymbol{x}+\frac{\boldsymbol{1}^\text{T}\left(\exp({\bf {\bf W}}\boldsymbol{x})\odot(d{\bf W}\boldsymbol{x})\right)}{\boldsymbol{1}^\text{T}\exp({\bf W}\boldsymbol{x})}$$&lt;/div&gt;
&lt;p&gt;根据：&lt;/p&gt;
&lt;div class="math"&gt;$$\boldsymbol{1}^\text{T} (\boldsymbol{u}\odot \boldsymbol{v}) = \boldsymbol{u}^\text{T} \boldsymbol{v}$$&lt;/div&gt;
&lt;p&gt;得：&lt;/p&gt;
&lt;div class="math"&gt;$$\boldsymbol{1}^\text{T}\left(\exp({\bf W}\boldsymbol{x})\odot(d{\bf W}\boldsymbol{x})\right) = \exp({\bf W}\boldsymbol{x})^\text{T}d{\bf W}\boldsymbol{x}$$&lt;/div&gt;
&lt;p&gt;求迹化简为：&lt;/p&gt;
&lt;div class="math"&gt;$$dl = \text{tr}\left(-\boldsymbol{y}^\text{T}d{\bf W}\boldsymbol{x}+\frac{\exp({\bf W}\boldsymbol{x})^\text{T}d{\bf W}\boldsymbol{x}}{\boldsymbol{1}^\text{T}\exp({\bf W}\boldsymbol{x})}\right) =\text{tr}(\boldsymbol{x}(\text{softmax}({\bf W}\boldsymbol{x})-\boldsymbol{y})^\text{T}d{\bf W})$$&lt;/div&gt;
&lt;p&gt;得到：&lt;/p&gt;
&lt;div class="math"&gt;$$\frac{\partial l}{\partial {\bf W}}= (\text{softmax}({\bf W}\boldsymbol{x})-\boldsymbol{y})\boldsymbol{x}^\text{T}$$&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;例题5&lt;/strong&gt;：二层神经网络。&lt;span class="math"&gt;\(l = -\boldsymbol{y}^\text{T}\log\text{softmax}({\bf W_2}\sigma({\bf W_1}\boldsymbol{x}))\)&lt;/span&gt;，求 &lt;span class="math"&gt;\(\frac{\partial l}{\partial {\bf W_1}}\)&lt;/span&gt; 和 &lt;span class="math"&gt;\(\frac{\partial l}{\partial \bf{W_2}}\)&lt;/span&gt;。其中 &lt;span class="math"&gt;\(\boldsymbol{y}\)&lt;/span&gt; 是除一个元素为1外其它元素为0的的 &lt;span class="math"&gt;\(m\times 1\)&lt;/span&gt; 列向量，&lt;span class="math"&gt;\({\bf W_2}\)&lt;/span&gt; 是 &lt;span class="math"&gt;\(m\times p\)&lt;/span&gt; 矩阵，&lt;span class="math"&gt;\({\bf W_1}\)&lt;/span&gt; 是 &lt;span class="math"&gt;\(p\times n\)&lt;/span&gt; 矩阵，&lt;span class="math"&gt;\(\boldsymbol{x}\)&lt;/span&gt; 是 &lt;span class="math"&gt;\(n\times 1\)&lt;/span&gt; 列向量，&lt;span class="math"&gt;\(l\)&lt;/span&gt; 是标量；&lt;span class="math"&gt;\(\text{softmax}(\boldsymbol{a}) = \frac{\exp(\boldsymbol{a})}{\boldsymbol{1}^\text{T}\exp(\boldsymbol{a})}\)&lt;/span&gt; 同例5，&lt;span class="math"&gt;\(\sigma(\cdot)\)&lt;/span&gt; 是逐元素 sigmoid 函数 &lt;span class="math"&gt;\(\sigma(a) = \frac{1}{1+\exp(-a)}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解答&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;定义：&lt;/p&gt;
&lt;div class="math"&gt;$$\boldsymbol{a}_1={\bf W_1}\boldsymbol{x}，\boldsymbol{h}_1 = \sigma(\boldsymbol{a}_1)，\boldsymbol{a}_2 = {\bf W_2} \boldsymbol{h}_1$$&lt;/div&gt;
&lt;p&gt;则：&lt;/p&gt;
&lt;div class="math"&gt;$$l =-\boldsymbol{y}^\text{T}\log\text{softmax}(\boldsymbol{a}_2)$$&lt;/div&gt;
&lt;p&gt;在例5中已求出：&lt;/p&gt;
&lt;div class="math"&gt;$$\frac{\partial l}{\partial \boldsymbol{a}_2} = \text{softmax}(\boldsymbol{a}_2)-\boldsymbol{y}$$&lt;/div&gt;
&lt;p&gt;使用复合法则，注意此处 &lt;span class="math"&gt;\(\boldsymbol{h}_1, {\bf W_2}\)&lt;/span&gt; 都是变量：&lt;/p&gt;
&lt;div class="math"&gt;$$dl = \text{tr}\left(\frac{\partial l}{\partial \boldsymbol{a}_2}^\text{T}d\boldsymbol{a}_2\right) = \text{tr}\left(\frac{\partial l}{\partial \boldsymbol{a}_2}^\text{T}dW_2 \boldsymbol{h}_1\right) + \text{tr}\left(\frac{\partial l}{\partial \boldsymbol{a}_2}^\text{T}W_2 d\boldsymbol{h}_1\right)$$&lt;/div&gt;
&lt;p&gt;使用矩阵乘法交换的迹技巧从第一项得到：&lt;/p&gt;
&lt;div class="math"&gt;$$\frac{\partial l}{\partial W_2}= \frac{\partial l}{\partial\boldsymbol{a}_2}\boldsymbol{h}_1^\text{T}$$&lt;/div&gt;
&lt;p&gt;从第二项得到：&lt;/p&gt;
&lt;div class="math"&gt;$$\frac{\partial l}{\partial \boldsymbol{h}_1}= W_2^\text{T}\frac{\partial l}{\partial\boldsymbol{a}_2}$$&lt;/div&gt;
&lt;p&gt;接下来求 &lt;span class="math"&gt;\(\frac{\partial l}{\partial \boldsymbol{a}_1}\)&lt;/span&gt;，继续使用复合法则，并利用矩阵乘法和逐元素乘法交换的迹技巧：&lt;/p&gt;
&lt;div class="math"&gt;$$\text{tr}\left(\frac{\partial l}{\partial\boldsymbol{h}_1}^\text{T}d\boldsymbol{h}_1\right) = \text{tr}\left(\frac{\partial l}{\partial\boldsymbol{h}_1}^\text{T}(\sigma'(\boldsymbol{a}_1)\odot d\boldsymbol{a}_1)\right) = \text{tr}\left(\left(\frac{\partial l}{\partial\boldsymbol{h}_1}\odot \sigma'(\boldsymbol{a}_1)\right)^\text{T}d\boldsymbol{a}_1\right)$$&lt;/div&gt;
&lt;p&gt;得到：&lt;/p&gt;
&lt;div class="math"&gt;$$\frac{\partial l}{\partial \boldsymbol{a}_1}= \frac{\partial l}{\partial\boldsymbol{h}_1}\odot\sigma'(\boldsymbol{a}_1)$$&lt;/div&gt;
&lt;p&gt;为求 &lt;span class="math"&gt;\(\frac{\partial l}{\partial {\bf W_1}}\)&lt;/span&gt;，再用一次复合法则
：&lt;/p&gt;
&lt;div class="math"&gt;$$\text{tr}\left(\frac{\partial l}{\partial\boldsymbol{a}_1}^\text{T}d\boldsymbol{a}_1\right) = \text{tr}\left(\frac{\partial l}{\partial\boldsymbol{a}_1}^\text{T}d{\bf W_1}\boldsymbol{x}\right) = \text{tr}\left(\boldsymbol{x}\frac{\partial l}{\partial\boldsymbol{a}_1}^\text{T}d{\bf W_1}\right)$$&lt;/div&gt;
&lt;p&gt;得到：&lt;/p&gt;
&lt;div class="math"&gt;$$\frac{\partial l}{\partial {\bf W_1}}= \frac{\partial l}{\partial\boldsymbol{a}_1}\boldsymbol{x}^\text{T}$$&lt;/div&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="矩阵"></category><category term="数学"></category></entry></feed>