<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>You Know Nothing - 基础知识</title><link href="https://xutree.github.io/" rel="alternate"></link><link href="https://xutree.github.io/feeds/ji-chu-zhi-shi.atom.xml" rel="self"></link><id>https://xutree.github.io/</id><updated>2018-10-23T20:42:45+08:00</updated><entry><title>矩阵求导</title><link href="https://xutree.github.io/pages/2018/10/23/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC/" rel="alternate"></link><published>2018-10-23T20:42:45+08:00</published><updated>2018-10-23T20:42:45+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-23:/pages/2018/10/23/矩阵求导/</id><summary type="html">&lt;p&gt;矩阵求导，本质是多元函数求导，仅仅是把函数的⾃变量以及求导的结果排列成了矩阵的形式，⽅便表达与计算。类似地，复合函数的求导法则本质上也是多元函数求导的链式法则，只是将结果整理成了矩阵的形式。从原理上讲，可以对矩阵的每个分量逐元素地求导，得到最终结果；但是这样做太繁琐，极其容易出错，因此推导并记住⼀些常⽤的结论在实践中是⾮常必要的。&lt;/p&gt;
&lt;p&gt;不同的矩阵求导方法采取不同的导数排列方法，以便于所求导数可以方便后续计算。这里采取求导结果与原矩阵/向量同型的排布方式。&lt;/p&gt;
&lt;h2&gt;1. 向量对向量求导&lt;/h2&gt;
&lt;p&gt;&lt;span class="math"&gt;\({\boldsymbol y}=
    \pmatrix{
    y_1\\
    y_2\\
    \vdots\\
    y_m
},
{\boldsymbol x}=
    \pmatrix{
    x_1\\
    x_2\\
    \vdots\\
    x_n
}\Longrightarrow
\frac{\partial {\boldsymbol y}}{\partial {\boldsymbol x}}=
\pmatrix{
    \frac{\partial  y_1}{\partial …&lt;/span&gt;&lt;/p&gt;&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><content type="html">&lt;p&gt;矩阵求导，本质是多元函数求导，仅仅是把函数的⾃变量以及求导的结果排列成了矩阵的形式，⽅便表达与计算。类似地，复合函数的求导法则本质上也是多元函数求导的链式法则，只是将结果整理成了矩阵的形式。从原理上讲，可以对矩阵的每个分量逐元素地求导，得到最终结果；但是这样做太繁琐，极其容易出错，因此推导并记住⼀些常⽤的结论在实践中是⾮常必要的。&lt;/p&gt;
&lt;p&gt;不同的矩阵求导方法采取不同的导数排列方法，以便于所求导数可以方便后续计算。这里采取求导结果与原矩阵/向量同型的排布方式。&lt;/p&gt;
&lt;h2&gt;1. 向量对向量求导&lt;/h2&gt;
&lt;p&gt;&lt;span class="math"&gt;\({\boldsymbol y}=
    \pmatrix{
    y_1\\
    y_2\\
    \vdots\\
    y_m
},
{\boldsymbol x}=
    \pmatrix{
    x_1\\
    x_2\\
    \vdots\\
    x_n
}\Longrightarrow
\frac{\partial {\boldsymbol y}}{\partial {\boldsymbol x}}=
\pmatrix{
    \frac{\partial  y_1}{\partial x_1} &amp;amp; \frac{\partial  y_1}{\partial x_2} &amp;amp; \dots &amp;amp; \frac{\partial  y_1}{\partial x_n}\\
    \frac{\partial  y_2}{\partial x_1} &amp;amp; \frac{\partial  y_2}{\partial x_2} &amp;amp; \dots &amp;amp; \frac{\partial  y_2}{\partial x_n}\\
    \vdots &amp;amp; \vdots &amp;amp; \ddots &amp;amp; \vdots\\
    \frac{\partial  y_m}{\partial x_1} &amp;amp; \frac{\partial  y_m}{\partial x_2} &amp;amp; \dots &amp;amp; \frac{\partial  y_m}{\partial x_n}
}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;求导结果为 &lt;span class="math"&gt;\(m\times n\)&lt;/span&gt; 矩阵，即雅可比矩阵。&lt;/p&gt;
&lt;h2&gt;2. 实值函数对矩阵求导&lt;/h2&gt;
&lt;p&gt;&lt;span class="math"&gt;\({\bf X}=
\pmatrix{
    x_{11} &amp;amp; x_{12} &amp;amp; \dots &amp;amp; x_{1n} \\
    x_{21} &amp;amp; x_{22} &amp;amp; \dots &amp;amp; x_{2n} \\
    \vdots &amp;amp; \vdots &amp;amp; \ddots &amp;amp; \vdots \\
    x_{m1} &amp;amp; x_{m2} &amp;amp; \dots &amp;amp; x_{mn} \\
}\Longrightarrow
\frac{\partial f}{\partial {\bf x}}=
\pmatrix{
    \frac{\partial f}{\partial  x_{11}} &amp;amp; \frac{\partial f}{\partial  x_{12}} &amp;amp; \dots &amp;amp; \frac{\partial f}{\partial  x_{1n}}\\
    \frac{\partial f}{\partial  x_{21}} &amp;amp; \frac{\partial f}{\partial  x_{22}} &amp;amp; \dots &amp;amp; \frac{\partial f}{\partial  x_{2n}}\\
    \vdots &amp;amp; \vdots &amp;amp; \ddots &amp;amp; \vdots\\
    \frac{\partial f}{\partial  x_{m1}} &amp;amp; \frac{\partial f}{\partial  x_{m2}} &amp;amp; \dots &amp;amp; \frac{\partial f}{\partial  x_{mn}}\\
}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;求导结果与 &lt;span class="math"&gt;\({\bf X}\)&lt;/span&gt; 形状一致。&lt;/p&gt;
&lt;p&gt;从这个定义，我们可以得到：

&lt;span class="math"&gt;\(\nabla_{{\bf x}}f\)&lt;/span&gt; 和 &lt;span class="math"&gt;\(\nabla_{{\bf x^T}}f\)&lt;/span&gt; 互为转置。&lt;/p&gt;
&lt;h3&gt;2.1 全微分公式&lt;/h3&gt;
&lt;p&gt;
对于实值函数对矩阵求导，我们可以写出：&lt;/p&gt;
&lt;p&gt;&lt;span class="math"&gt;\(df=\sum_{i=1}^m\sum_{j=1}^n\frac{\partial f}{\partial x_{ij}}dx_{ij}=\text{tr}\left(\left(\frac{\partial f}{\partial x}\right)^\text{T}dx\right)\)&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;2.2 微分法则&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;加减：&lt;span class="math"&gt;\(d({\bf X}\pm{\bf Y})=d{\bf X}\pm d{\bf Y}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;乘法：&lt;span class="math"&gt;\(d({\bf XY})=(d{\bf X}){\bf Y}+{\bf X}(d{\bf Y})\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;转置：&lt;span class="math"&gt;\(d({\bf X}^\text{T})=(d{\bf X})^\text{T}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;迹：&lt;span class="math"&gt;\(d\text{tr}({\bf X})=\text{tr}(d{\bf X})\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;逆：&lt;span class="math"&gt;\(d{\bf X}^{-1}=-{\bf X}^{-1}d{\bf X}{\bf X}^{-1}\)&lt;/span&gt;，利用 &lt;span class="math"&gt;\({\bf X}{\bf X}^{-1}=\mathbb{I}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;行列式：&lt;span class="math"&gt;\(d|{\bf X}|=\text{tr}({\bf X}^*d{\bf X})\)&lt;/span&gt;，其中 &lt;span class="math"&gt;\({\bf X}^*\)&lt;/span&gt; 表示 &lt;span class="math"&gt;\({\bf X}\)&lt;/span&gt; 的伴随矩阵，在 &lt;span class="math"&gt;\({\bf X}\)&lt;/span&gt; 可逆时又可以写做：&lt;span class="math"&gt;\(d|{\bf X}|=|{\bf X}|\text{tr}({\bf X}^{-1}d{\bf X})\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;逐元素乘：&lt;span class="math"&gt;\(d({\bf X}\odot{\bf Y})=d{\bf X}\odot{\bf Y}+{\bf X}\odot d{\bf Y}\)&lt;/span&gt;，&lt;span class="math"&gt;\(\odot\)&lt;/span&gt; 表示尺寸相同的矩阵逐元素相乘&lt;/li&gt;
&lt;li&gt;逐元素函数：&lt;span class="math"&gt;\(dw({\bf X})=w'({\bf X})\odot d{\bf X}\)&lt;/span&gt;，&lt;span class="math"&gt;\(w({\bf X})\)&lt;/span&gt; 是逐元素标量运算，&lt;span class="math"&gt;\(w'({\bf X})\)&lt;/span&gt;是逐元素求导&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;2.3 其他公式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;span class="math"&gt;\(\text{tr}(a)=a\)&lt;/span&gt;，&lt;span class="math"&gt;\(a\)&lt;/span&gt; 为标量&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(\text{tr}({\bf A}^\text{T})=\text{tr}({\bf A})\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(\text{tr}({\bf A}+{\bf B})=\text{tr}({\bf A})+\text{tr}({\bf B})\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(\text{tr}({\bf AB})=\text{tr}({\bf BA})\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class="math"&gt;\(\text{tr}\left({\bf A}^{\text{T}}({\bf B}\odot{\bf C})\right)=\text{tr}\left(({\bf A}\odot {\bf B})^{\text{T}}{\bf C}\right)\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;2.4 求导方法&lt;/h3&gt;
&lt;p&gt;若标量函数 &lt;span class="math"&gt;\(f\)&lt;/span&gt; 是矩阵&lt;span class="math"&gt;\({\bf X}\)&lt;/span&gt; 经加减乘法、行列式、逆、逐元素函数等运算构成，则使用相应的运算法则对 &lt;span class="math"&gt;\(f\)&lt;/span&gt; 求微分，再使用迹变换给 &lt;span class="math"&gt;\(df\)&lt;/span&gt; 套上迹并将其它项交换至 &lt;span class="math"&gt;\(d{\bf X}\)&lt;/span&gt; 左侧，即能得到导数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;例题1&lt;/strong&gt;：&lt;span class="math"&gt;\(f={\boldsymbol a}^{\text{T}}{\bf X}{\boldsymbol b}\)&lt;/span&gt;，求：&lt;span class="math"&gt;\(\frac{\partial f}{\partial {\bf X}}\)&lt;/span&gt;。其中 &lt;span class="math"&gt;\({\boldsymbol a}\)&lt;/span&gt; 是 &lt;span class="math"&gt;\(m\times 1\)&lt;/span&gt; 列向量，&lt;span class="math"&gt;\({\bf X}\)&lt;/span&gt; 是 &lt;span class="math"&gt;\(m\times n\)&lt;/span&gt; 矩阵，&lt;span class="math"&gt;\({\boldsymbol b}\)&lt;/span&gt; 是 &lt;span class="math"&gt;\(n\times 1\)&lt;/span&gt; 列向量，&lt;span class="math"&gt;\(f\)&lt;/span&gt; 是标量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解答&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;全微分：&lt;span class="math"&gt;\(df={\boldsymbol a}^{\text{T}}d{\bf X}{\boldsymbol b}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;两边取迹：&lt;span class="math"&gt;\(df=\text{tr}({\boldsymbol a}^{\text{T}}d{\bf X}{\boldsymbol b})=\text{tr}({\boldsymbol b}{\boldsymbol a}^{\text{T}}d{\bf X})\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;对照全微分公式：&lt;span class="math"&gt;\((\frac{\partial f}{\partial {\bf X}})^{\text{T}}={\boldsymbol b}{\boldsymbol a}^{\text{T}}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;得到：&lt;span class="math"&gt;\(\frac{\partial f}{\partial {\bf X}}=({\boldsymbol b}{\boldsymbol a}^{\text{T}})^{\text{T}}={\boldsymbol a}{\boldsymbol b}^{\text{T}}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;例题2&lt;/strong&gt;：&lt;span class="math"&gt;\(f={\boldsymbol a}^{\text{T}}\text{exp}({\bf X}{\boldsymbol b})\)&lt;/span&gt;，求：&lt;span class="math"&gt;\(\frac{\partial f}{\partial {\bf X}}\)&lt;/span&gt;。其中 &lt;span class="math"&gt;\(\boldsymbol{a}\)&lt;/span&gt; 是 &lt;span class="math"&gt;\(m\times 1\)&lt;/span&gt; 列向量，&lt;span class="math"&gt;\({\bf X}\)&lt;/span&gt; 是 &lt;span class="math"&gt;\(m\times n\)&lt;/span&gt; 矩阵，&lt;span class="math"&gt;\(\boldsymbol{b}\)&lt;/span&gt; 是 &lt;span class="math"&gt;\(n\times 1\)&lt;/span&gt; 列向量，&lt;span class="math"&gt;\(\text{exp}\)&lt;/span&gt; 表示逐元素求指数，&lt;span class="math"&gt;\(f\)&lt;/span&gt; 是标量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解答&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;全微分：&lt;span class="math"&gt;\(df=\boldsymbol{a}^{\text{T}}\left(\text{exp}({\bf X}{\boldsymbol b})\odot(d{\bf X}{\boldsymbol b})\right)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;两边取迹：&lt;span class="math"&gt;\(df = \text{tr}( \boldsymbol{a}^{\text{T}}(\exp({\bf X}\boldsymbol{b})\odot (d{\bf X}\boldsymbol{b}))) \\
=\text{tr}((\boldsymbol{a}\odot \exp({\bf X}\boldsymbol{b}))^{\text{T}}dX \boldsymbol{b}) \\
= \text{tr}(\boldsymbol{b}(\boldsymbol{a}\odot \exp({\bf X}\boldsymbol{b}))^Td{\bf X})\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;对照全微分公式得到：&lt;span class="math"&gt;\(\frac{\partial f}{\partial {\bf X}} = (\boldsymbol{b}(\boldsymbol{a}\odot \exp({\bf X}\boldsymbol{b}))^{\text{T}})^{\text{T}}= (\boldsymbol{a}\odot \exp({\bf X}\boldsymbol{b}))\boldsymbol{b}^{\text{T}}\)&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;矩阵对实值函数求导&lt;/h2&gt;
&lt;p&gt;&lt;span class="math"&gt;\({\bf Y}=
\pmatrix{
    y_{11} &amp;amp; y_{12} &amp;amp; \dots &amp;amp; y_{1n} \\
    y_{21} &amp;amp; y_{22} &amp;amp; \dots &amp;amp; y_{2n} \\
    \vdots &amp;amp; \vdots &amp;amp; \ddots &amp;amp; \vdots \\
    y_{m1} &amp;amp; y_{m2} &amp;amp; \dots &amp;amp; y_{mn} \\
}\Longrightarrow
\frac{\partial {\bf Y}}{\partial f}=
\pmatrix{
    \frac{\partial  y_{11}}{\partial f} &amp;amp; \frac{\partial  y_{12}}{\partial f} &amp;amp; \dots &amp;amp; \frac{\partial  y_{1n}}{\partial f}\\
    \frac{\partial  y_{21}}{\partial f} &amp;amp; \frac{\partial  y_{22}}{\partial f} &amp;amp; \dots &amp;amp; \frac{\partial  y_{2n}}{\partial f}\\
    \vdots &amp;amp; \vdots &amp;amp; \ddots &amp;amp; \vdots\\
    \frac{\partial  y_{m1}}{\partial f} &amp;amp; \frac{\partial  y_{m2}}{\partial f} &amp;amp; \dots &amp;amp; \frac{\partial  y_{mn}}{\partial f}\\
}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;求导结果与 &lt;span class="math"&gt;\({\bf Y}\)&lt;/span&gt; 形状一致。&lt;/p&gt;
&lt;h2&gt;未做定义&lt;/h2&gt;
&lt;p&gt;对于矩阵对矩阵求导、矩阵对向量求导、向量对矩阵求导，这里不做定义。&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="矩阵"></category><category term="数学"></category></entry></feed>