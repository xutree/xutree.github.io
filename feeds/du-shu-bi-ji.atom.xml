<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>You Know Nothing - 读书笔记</title><link href="https://xutree.github.io/" rel="alternate"></link><link href="https://xutree.github.io/feeds/du-shu-bi-ji.atom.xml" rel="self"></link><id>https://xutree.github.io/</id><updated>2018-10-12T22:06:13+08:00</updated><entry><title>数据结构——向量</title><link href="https://xutree.github.io/pages/2018/10/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%90%91%E9%87%8F/" rel="alternate"></link><published>2018-10-10T19:50:46+08:00</published><updated>2018-10-12T22:06:13+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-10:/pages/2018/10/10/数据结构向量/</id><summary type="html">&lt;p&gt;数据结构大致可分为：线性结构、半线性结构和非线性结构。线性结构中最基本的称为序列（sequence），根据其中数据项的逻辑次序与其物理存储地址的对应关系不同，又可分为向量（vector）和列表（list）。&lt;/p&gt;
&lt;h2&gt;从数组到向量&lt;/h2&gt;
&lt;p&gt;数组：集合 S 由 n 个元素组成，且各元素之间具有一个线性次序，则可以将它们存放于起始地址 A，物理位置连续的一段存储空间。记为：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;A[0,n) = { A[0], A[1], ..., A[n-1] }&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;将它们存放于起始地址 A，若每个元素占用 s 个单位的空间，则元素 A[i] 的物理地址为：&lt;code&gt;A + i * s&lt;/code&gt;，所以被称作线性数组。&lt;/p&gt;
&lt;p&gt;向量：&lt;code&gt;V[0,n) = { v[0 …&lt;/code&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;数据结构大致可分为：线性结构、半线性结构和非线性结构。线性结构中最基本的称为序列（sequence），根据其中数据项的逻辑次序与其物理存储地址的对应关系不同，又可分为向量（vector）和列表（list）。&lt;/p&gt;
&lt;h2&gt;从数组到向量&lt;/h2&gt;
&lt;p&gt;数组：集合 S 由 n 个元素组成，且各元素之间具有一个线性次序，则可以将它们存放于起始地址 A，物理位置连续的一段存储空间。记为：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;A[0,n) = { A[0], A[1], ..., A[n-1] }&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;将它们存放于起始地址 A，若每个元素占用 s 个单位的空间，则元素 A[i] 的物理地址为：&lt;code&gt;A + i * s&lt;/code&gt;，所以被称作线性数组。&lt;/p&gt;
&lt;p&gt;向量：&lt;code&gt;V[0,n) = { v[0], v[1], ..., v[n-1] }&lt;/code&gt;是线性数组的一种抽象和泛化，由具有线性次序的一组元素构成的集合，其中的元素由秩区分。各元素秩互异，且均为 [0, n) 内的整数。采用“寻秩访问”。经过抽象，不限定同一向量中元素都属于同一数据类型，故而不保证它们之间可以相互比较大小。&lt;/p&gt;
&lt;h2&gt;接口&lt;/h2&gt;
&lt;p&gt;作为一种抽象数据类型，向量对象应支持如下操作接口：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;操作接口&lt;/th&gt;
&lt;th align="left"&gt;功能&lt;/th&gt;
&lt;th align="left"&gt;适用对象&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;size()&lt;/td&gt;
&lt;td align="left"&gt;元素总数&lt;/td&gt;
&lt;td align="left"&gt;向量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;get(r)&lt;/td&gt;
&lt;td align="left"&gt;获取秩为 r 的元素&lt;/td&gt;
&lt;td align="left"&gt;向量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;put(r, e)&lt;/td&gt;
&lt;td align="left"&gt;用 e 代替秩为 r 的元素&lt;/td&gt;
&lt;td align="left"&gt;向量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;insert(r, e)&lt;/td&gt;
&lt;td align="left"&gt;e 作为秩为 r 的元素插入，原后继元素依次后移&lt;/td&gt;
&lt;td align="left"&gt;向量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;remove(r)&lt;/td&gt;
&lt;td align="left"&gt;删除秩为 r 的元素，返回该元素中原存放的对象&lt;/td&gt;
&lt;td align="left"&gt;向量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;disordered()&lt;/td&gt;
&lt;td align="left"&gt;判断所有元素是否已按非降序排列&lt;/td&gt;
&lt;td align="left"&gt;向量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;sort()&lt;/td&gt;
&lt;td align="left"&gt;非降序排序&lt;/td&gt;
&lt;td align="left"&gt;向量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;find(e)&lt;/td&gt;
&lt;td align="left"&gt;查找等于 e 且秩最大的元素&lt;/td&gt;
&lt;td align="left"&gt;向量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;search(e)&lt;/td&gt;
&lt;td align="left"&gt;查找目标元素 e，返回不大于 e 且秩最大的元素&lt;/td&gt;
&lt;td align="left"&gt;有序向量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;deduplicate()&lt;/td&gt;
&lt;td align="left"&gt;剔除重复元素&lt;/td&gt;
&lt;td align="left"&gt;向量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;uniquify()&lt;/td&gt;
&lt;td align="left"&gt;剔除重复元素&lt;/td&gt;
&lt;td align="left"&gt;有序向量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;traverse()&lt;/td&gt;
&lt;td align="left"&gt;遍历向量并统一处理所有元素，处理方法由函数对象指定&lt;/td&gt;
&lt;td align="left"&gt;向量&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;Vector 模板类&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;typedef int Rank;   //秩
#define DEFAULT_CAPACITY 3  //默认的初始容量（实际应用中可设置为更大）

template &amp;lt;typename T&amp;gt; class Vector {    //向量模板类
protected:
    Rank _size; int _capacity; T* _elem;    //规模、容量、数据区
    void copyFrom(T const* A, Rank lo, Rank hi);    //复制数组区间A[lo,hi)
    void expand();  //空间不足时扩容
    void shrink();  //装填因子过小时压缩
    bool bubble(Rank lo, Rank hi);  //扫描交换
    void bubbleSort()Rank lo, Rank hi); //气泡排序算法
    Rank max(Rank lo, Rank hi); //选取最大元素
    void selectionSort(Rank lo, Rank hi);   //选择排序算法
    void merge(Rank lo, Rank mi, Rank hi);   //归并算法
    void mergeSort(Rank lo, Rank hi);   //归并排序算法
    Rank partition(Rank lo, Rank hi);   //轴点构造算法
    void quickSort(Rank lo, Rank hi);   //快速排序算法
    void heapSort(Rank lo, Rank hi);    //堆排序
public:
//构造函数
     //容量为 c，规模为 s，所有元素初始化为 v，s&amp;lt;=c
    Vector(int c = DEFAULT_CAPACITY, int s = 0, T v = 0)
    { _elem = new T[_capacity = c]; for(_size = 0; _size &amp;lt; s; _elem[_size++] = v);  }
    Vector(T const* A, Rank n) { copyFrom(A, 0, n); }   //数组整体复制
    Vector(T const* A, Rank lo, Rank hi) { copyFrom(A, lo, hi); }   //区间
    Vector(Vector&amp;lt;T&amp;gt; const&amp;amp; V) { copyFrom(V._elem, 0, V._size); }   //向量整体复制
    Vector(Vector&amp;lt;T&amp;gt; const&amp;amp; V, Rank lo, Rank hi) { copyFrom(V._elem, lo, hi); } //区间
//析构函数
~Vector() { delete [] _elem; }  //释放内部空间
//只读访问接口
    Rank size() const { return _size; } //规模
    bool empty() const { return !_size; }   //判空
    int disordered() const; //判断向量是否已排序
    Rank find(T const&amp;amp; e) const { return find(e, 0, _size); }   //无序向量整体查找
    Rank find(T const&amp;amp; e, Rank lo, Rank hi) const;  //无序向量区间查找
    Rank search(T const&amp;amp; e) const   //有序向量整体查找
    { return (0 &amp;gt;= _size) ? -1 : search(e, 0, _size); }
    Rank search(T const&amp;amp; e, Rank lo, Rank hi) const   //有序向量区间查找
//可写访问接口
    T&amp;amp; operator[](Rank r) const;    //重载下标运算符，可以类似于数组形式引用各元素
    Vector&amp;lt;T&amp;gt; &amp;amp; operator=(Vector&amp;lt;T&amp;gt; const&amp;amp;);    //重载赋值运算符，以便直接克隆向量
    T remove(Rank r);   //删除秩为 r 的元素
    int remove(Rank lo, Rank hi);   //删除秩在区间 [lo,hi) 之内的元素
    Rank insert(Rank r, T const&amp;amp; e);    //插入元素
    Rank insert(T const&amp;amp; e) { return insert(_size, e); }    //默认作为尾元素插入
    void sort(Rank lo, Rank hi);    //对 [lo,hi) 排序
    void sort() { sort(0, _size); } //整体排序
    void unsort(Rank lo, Rank hi);    //对 [lo,hi) 置乱
    void unsort() { unsort(0, _size); } //整体置乱
    int deduplicate();  //无序去重
    int uniquify(); //有序去重
//遍历
    void traverse(void (*)(T&amp;amp;));    //遍历（使用函数指针，只读或局部性修改）
    template &amp;lt;typename VST&amp;gt; void traverse(VST&amp;amp;);    //遍历（使用函数对象，可全局性修改）
};//Vector
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;构造与析构&lt;/h2&gt;
&lt;p&gt;约定：向量中秩为 r 的元素，对应于内部数组中的 _elem[r]，其物理地址为：_elem + r&lt;/p&gt;
&lt;h3&gt;默认构造函数&lt;/h3&gt;
&lt;p&gt;整个默认构造过程顺序进行，没有任何迭代，故忽略用于分配数组空间的时间，需要常数时间。&lt;/p&gt;
&lt;h3&gt;基于复制的构造函数&lt;/h3&gt;
&lt;p&gt;在模板的实现中，我们将基于数组或者向量的复制操作（局部或整体的）都转交给如下的&lt;code&gt;copyFrom&lt;/code&gt;函数处理：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;template &amp;lt;typename T&amp;gt; void Vector&amp;lt;T&amp;gt;::copyFrom(T const* A, Rank lo, Rank hi) {
    _elem = new T[_capacity = 2 * (hi -lo) ]; _size = 0; //分配空间，规模清零
    while( lo &amp;lt;hi) //A[lo,hi) 元素逐一复制
        _elem[_size++] = A[lo++];   //
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;需要 &lt;em&gt;O&lt;/em&gt;(_size) 时间。&lt;/p&gt;
&lt;p&gt;需要强调的是，由于向量内部含有动态分配的空间，默认的“=”运算符不足以支持向量之间的直接赋值。故要重建“=”：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;template &amp;lt;typename T&amp;gt; Vector&amp;lt;T&amp;gt;&amp;amp; Vector&amp;lt;T&amp;gt;::operator=(Vector&amp;lt;T&amp;gt; const&amp;amp; V) {
    if( _elem ) delet [] _elem;
    copyFrom(V._elem, 0, V.size());
    return *this;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;析构&lt;/h3&gt;
&lt;p&gt;若不计系统用于空间回收的时间，整个析构过程只需常数时间。&lt;/p&gt;
&lt;h2&gt;动态空间管理&lt;/h2&gt;
&lt;h3&gt;扩容&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;template &amp;lt;typename T&amp;gt; void Vector&amp;lt;T&amp;gt;::expand() {
    if(_size &amp;lt; _capacity) return;   //尚未满员，不必扩容
    if(_capacity &amp;lt; DEFAULT_CAPACITY) _capacity = DEFAULT_CAPACITY;  //不低于最小容量
    T *oldElem = _elem; _elem = new T[_capacity &amp;lt;&amp;lt; 1]; //容量加倍
    for( int i = 0; i &amp;lt; _size; i++)
        _elem[i] = oldElem[i]; //复制原向量内容（T为基本类型，或以重载赋值运算符
    delete [] oldElem;  //释放原空间
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;分摊运行时间为 &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;
&lt;h3&gt;缩容&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;template &amp;lt;typename T&amp;gt; void Vector&amp;lt;T&amp;gt;::shrink() {
    if(_capacity &amp;lt; DEFAULT_CAPACITY &amp;lt;&amp;lt; 1) return;   //不至收缩到DEFAULT_CAPACITY
    if(_size &amp;lt;&amp;lt; 2 &amp;gt; _capacity) return;  //以25%为界
    T *oldElem = _elem; _elem = new T[_capacity &amp;gt;&amp;gt; 1]; //容量减半
    for( int i = 0; i &amp;lt; _size; i++)
        _elem[i] = oldElem[i]; //复制原向量内容（T为基本类型，或以重载赋值运算符
    delete [] oldElem;  //释放原空间
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;就单次扩容或缩容操作而言，所需时间的确会高达 &lt;em&gt;O&lt;/em&gt;(n)，因此在对单次操作的执行速度及其敏感的应用场合以上策略并不适用，其中缩容操作甚至可以完全不予考虑。&lt;/p&gt;
&lt;h2&gt;常规向量&lt;/h2&gt;
&lt;h3&gt;直接引用元素&lt;/h3&gt;
&lt;p&gt;与数组直接通过下标访问元素的形式相比，向量 ADT（abstract data type）所设置的&lt;code&gt;get()&lt;/code&gt;和&lt;code&gt;put()&lt;/code&gt;接口都显得不甚自然。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;template &amp;lt;typename T&amp;gt; T&amp;amp; Vector&amp;lt;T&amp;gt;::operator[](Rank r) const
{ return _elem[r]; }    //assert: 0 &amp;lt;= r &amp;lt; _size
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;置乱器&lt;/h3&gt;
&lt;p&gt;重载后&lt;code&gt;[]&lt;/code&gt;返回的是对数组元素的引用，这就意味着它既可以取代&lt;code&gt;get()&lt;/code&gt;操作（通常作为赋值表达式的右值），也可以取代&lt;code&gt;set()&lt;/code&gt;操作（通常作为左值）。采用这种形式，可以很清晰地实现如下的向量置乱器：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;template &amp;lt;typename T&amp;gt; void permute(Vector&amp;lt;T&amp;gt;&amp;amp; V) {
    for(int i = V.size(); i &amp;gt; 0; i--)
        swap(V[i-1], V[rand() % i]); //V[i-1] 与 V[0,i) 中某一随机元素交换
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;从理论上讲，上述算法可以枚举出同一向量所有可能的排列，而且能够保证生成各种排列的概率均等。&lt;/p&gt;
&lt;p&gt;为便于对各种向量算法的测试与比较，不妨将上述算法封装到向量 ADT 中，并对外提供向量的置乱接口操作：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;template &amp;lt;typename T&amp;gt; void Vector&amp;lt;T&amp;gt;::unsort(Rank lo, Rank hi) {
    T* V = _elem + lo;
    for(Rank i =hi -lo; i &amp;gt; 0; i--)
        swap(V[i-1], V[rand() % i]);
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上述两段代码的细微差异：上面的代码通过重载“[]”，利用秩间接访问&lt;strong&gt;向量&lt;/strong&gt;元素，下面的代码通过下标直接访问内部&lt;strong&gt;数组&lt;/strong&gt;的元素。&lt;/p&gt;
&lt;h3&gt;判等器和比较器&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;template &amp;lt;typename T&amp;gt; static bool lt(T* a, T* b) { return lt(*a, *b); } //less than
template &amp;lt;typename T&amp;gt; static bool lt(T&amp;amp; a, T&amp;amp; b) { return a &amp;lt; b; } //less than
template &amp;lt;typename T&amp;gt; static bool eq(T* a, T* b) { return eq(*a, *b); } //equal
template &amp;lt;typename T&amp;gt; static bool eq(T&amp;amp; a, T&amp;amp; b) { return a == b; } //equal
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在一些复杂的数据结构中，内部元素本身的类型可能就是指向其他对象的指针，从而外部更多关注的，往往是其所指向对象的大小如直接比较指针，则结果毫无意义，故上面的代码分别出了了指针和引用的情况。&lt;/p&gt;
&lt;h3&gt;无序查找&lt;/h3&gt;
&lt;h4&gt;判等器&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;Vector&lt;/code&gt;模板中的&lt;code&gt;find&lt;/code&gt;接口的语义为“查找与数据对象 e 相等的元素”。这暗示向量元素可以通过相互“比对”判断是否相等。这类仅支持比对，但未必支持比较的向量，称为无序向量（unsorted vector）。&lt;/p&gt;
&lt;h4&gt;顺序查找&lt;/h4&gt;
&lt;p&gt;由于&lt;code&gt;find&lt;/code&gt;函数查找相等的最大秩元素，故从后往前比对：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;template &amp;lt;typename T&amp;gt; Rank Vector&amp;lt;T&amp;gt;::find(T const&amp;amp; e, Rank lo, Rank hi) const {
    while( (lo &amp;lt; hi--) &amp;amp;&amp;amp; (e != _elem[hi]) ); //assert: 0 &amp;lt;= lo &amp;lt; hi &amp;lt;= _size
    return hi;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;最坏情况：&lt;em&gt;O&lt;/em&gt;(n)；最好情况：&lt;em&gt;O&lt;/em&gt;(1)。为输入敏感（input sensitive）算法。&lt;/p&gt;
&lt;h3&gt;插入&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//assert: 0 &amp;lt;= r &amp;lt;= size
template &amp;lt;typename T&amp;gt; Rank Vector&amp;lt;T&amp;gt;::insert(Rank r, T const&amp;amp; e) {
    expan(); //如有必要，扩容
    for(int i = _size; i &amp;gt; r; i--) _elem[i] = _elem[i-1];
    _elem[r] = e; _size++; //插入并更新容量
    return r;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意从后往前搬移数据，以防覆盖。复杂度：若插入位置等概论分布，则平均运行时间为&lt;em&gt;O&lt;/em&gt;(_size)=&lt;em&gt;O&lt;/em&gt;(n)。&lt;/p&gt;
&lt;h3&gt;删除&lt;/h3&gt;
&lt;p&gt;应将单元素删除视为区间删除的特例，并基于后者来实现前者。&lt;/p&gt;
&lt;h4&gt;区间删除&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//删除区间[lo, hi)
template &amp;lt;typename T&amp;gt; int Vector&amp;lt;T&amp;gt;::remove(Rank lo, Rank hi) {
    if(lo === hi) return 0;
    while(hi &amp;lt; _size)   _elem[lo++] = _elem[hi++];
    _size = lo;
    shrink();
    return hi - lo; //返回被删除元素个数
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;单元素删除&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;template &amp;lt;typename T&amp;gt; T Vector&amp;lt;T&amp;gt;::remove(Rank r) {
    T e = _elem[r];
    remove(r, r + 1);
    return e;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;被删除元素在向量中的位置越靠后（前）所需时间越短（长），最好为&lt;em&gt;O&lt;/em&gt;(1)，最坏为&lt;em&gt;O&lt;/em&gt;(n)。&lt;/p&gt;
&lt;h3&gt;唯一化&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;template &amp;lt;typename T&amp;gt; int Vector&amp;lt;T&amp;gt;::deduplicate() {
    int oldSize = _size;
    Rank i = 1;
    while(i &amp;lt; _size)
        (find(_elem[i], 0, i) &amp;lt; 0) ? i++ : remove(i);
    return oldSize - _size;
}
&lt;/pre&gt;&lt;/div&gt;</content><category term="数据结构"></category></entry><entry><title>C++ Primer 第八章 IO 库</title><link href="https://xutree.github.io/pages/2018/10/09/C++_Primer_Chapter_8/" rel="alternate"></link><published>2018-10-09T22:19:51+08:00</published><updated>2018-10-09T22:19:51+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-09:/pages/2018/10/09/C++_Primer_Chapter_8/</id><summary type="html">&lt;h2&gt;IO 类&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;iostream&lt;/code&gt;头文件：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;istream&lt;/code&gt;,&lt;code&gt;wistream&lt;/code&gt;,&lt;code&gt;ostream&lt;/code&gt;,&lt;code&gt;wostream&lt;/code&gt;,&lt;code&gt;iostream&lt;/code&gt;,&lt;code&gt;wiostream&lt;/code&gt;类型。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;fstream&lt;/code&gt;头文件：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ifstream&lt;/code&gt;,&lt;code&gt;wifstream&lt;/code&gt;,&lt;code&gt;ofstream&lt;/code&gt;,&lt;code&gt;wofstream&lt;/code&gt;,&lt;code&gt;fstream&lt;/code&gt;,&lt;code&gt;wfstream&lt;/code&gt;类型。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sstream&lt;/code&gt;头文件：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;istringstream&lt;/code&gt;,&lt;code&gt;wistringstream&lt;/code&gt;,&lt;code&gt;ostringstream&lt;/code&gt;,&lt;code&gt;wostringstream&lt;/code&gt;,&lt;code&gt;stringstream&lt;/code&gt;,&lt;code&gt;wstringstream&lt;/code&gt;类型。&lt;/p&gt;
&lt;p&gt;宽字符版本的类型和函数的名字以一个“w”开始。&lt;/p&gt;
&lt;p&gt;IO 对象无拷贝和赋值。进行 IO 操作的函数通常以引用方式传递和返回值。读写一个 IO 对象会改变其状态，因此传递和返回的引用不能是&lt;code&gt;const&lt;/code&gt;的。&lt;/p&gt;
&lt;h3&gt;条件状态&lt;/h3&gt;
&lt;p&gt;下表中 &lt;em&gt;strm&lt;/em&gt; 是一种 IO 类型：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;状态 …&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;/table&gt;</summary><content type="html">&lt;h2&gt;IO 类&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;iostream&lt;/code&gt;头文件：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;istream&lt;/code&gt;,&lt;code&gt;wistream&lt;/code&gt;,&lt;code&gt;ostream&lt;/code&gt;,&lt;code&gt;wostream&lt;/code&gt;,&lt;code&gt;iostream&lt;/code&gt;,&lt;code&gt;wiostream&lt;/code&gt;类型。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;fstream&lt;/code&gt;头文件：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ifstream&lt;/code&gt;,&lt;code&gt;wifstream&lt;/code&gt;,&lt;code&gt;ofstream&lt;/code&gt;,&lt;code&gt;wofstream&lt;/code&gt;,&lt;code&gt;fstream&lt;/code&gt;,&lt;code&gt;wfstream&lt;/code&gt;类型。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sstream&lt;/code&gt;头文件：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;istringstream&lt;/code&gt;,&lt;code&gt;wistringstream&lt;/code&gt;,&lt;code&gt;ostringstream&lt;/code&gt;,&lt;code&gt;wostringstream&lt;/code&gt;,&lt;code&gt;stringstream&lt;/code&gt;,&lt;code&gt;wstringstream&lt;/code&gt;类型。&lt;/p&gt;
&lt;p&gt;宽字符版本的类型和函数的名字以一个“w”开始。&lt;/p&gt;
&lt;p&gt;IO 对象无拷贝和赋值。进行 IO 操作的函数通常以引用方式传递和返回值。读写一个 IO 对象会改变其状态，因此传递和返回的引用不能是&lt;code&gt;const&lt;/code&gt;的。&lt;/p&gt;
&lt;h3&gt;条件状态&lt;/h3&gt;
&lt;p&gt;下表中 &lt;em&gt;strm&lt;/em&gt; 是一种 IO 类型：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;状态&lt;/th&gt;
&lt;th align="left"&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;em&gt;strm&lt;/em&gt;::iostate&lt;/td&gt;
&lt;td align="left"&gt;iostate 是一种机器相关的类型，提供了表达条件状态的完整功能&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;em&gt;strm&lt;/em&gt;::badbit&lt;/td&gt;
&lt;td align="left"&gt;流已崩溃&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;em&gt;strm&lt;/em&gt;::failbit&lt;/td&gt;
&lt;td align="left"&gt;IO 操作失败了&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;em&gt;strm&lt;/em&gt;::eofbit&lt;/td&gt;
&lt;td align="left"&gt;流到达了文件结束&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;em&gt;strm&lt;/em&gt;::goodbit&lt;/td&gt;
&lt;td align="left"&gt;流未处于错误状态，此值保证为0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;s.eof()&lt;/td&gt;
&lt;td align="left"&gt;若流 s 的 eofbit 置位，返回 true&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;s.fail()&lt;/td&gt;
&lt;td align="left"&gt;若流 s 的 failbit 或 badbit 置位，返回 true&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;s.bad()&lt;/td&gt;
&lt;td align="left"&gt;若流 s 的 badbit 置位，返回 true&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;s.good()&lt;/td&gt;
&lt;td align="left"&gt;若流 s 处于有效状态，返回 true&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;s.clear()&lt;/td&gt;
&lt;td align="left"&gt;将流 s 所以状态位复位，将流的状态设为有效，返回 void&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;s.clear(flags)&lt;/td&gt;
&lt;td align="left"&gt;根据 flags 复位，flags 类型为 &lt;em&gt;strm&lt;/em&gt;::iostate，返回 void&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;s.setstate(flags)&lt;/td&gt;
&lt;td align="left"&gt;根据 flags 置位，flags 类型为 &lt;em&gt;strm&lt;/em&gt;::iostate，返回 void&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;s.rdstate()&lt;/td&gt;
&lt;td align="left"&gt;返回流 s 的当前条件状态，返回值类型为 &lt;em&gt;strm&lt;/em&gt;::iostate&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;badbit&lt;/code&gt;表示系统级错误，如不可恢复的读写错误，一旦被置位，流就无法再使用了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;failbit&lt;/code&gt;表示可恢复的错误，例如期望读取数值却读到一个字符等错误。这种问题通常是可以修正的，流还可以继续使用。&lt;/p&gt;
&lt;p&gt;如果到达文件结尾，&lt;code&gt;eofbit&lt;/code&gt;和&lt;code&gt;failbit&lt;/code&gt;都会被置位。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;goodbit&lt;/code&gt;值为0，表示流未发生错误。&lt;/p&gt;
&lt;p&gt;如果&lt;code&gt;badbit&lt;/code&gt;、&lt;code&gt;failbit&lt;/code&gt;和&lt;code&gt;eofbit&lt;/code&gt;任一个被置位，则检测流状态的条件会失败。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;good()&lt;/code&gt;函数在所有错误位均未置位的情况下返回&lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;我们将流当做条件使用的代码等价于&lt;code&gt;!fail()&lt;/code&gt;。&lt;/p&gt;
&lt;h3&gt;管理条件状态&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;// 记住 cin 的当前状态
auto old_state = cin.rdstate(); // 记住 cin 的当前状态
cin.clean();  // 使 cin 有效
process_input(cin); // 使用 cin
cin.setstate(old_state);  // 将 cin 置为原有状态
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;// 复位 failbit 和 badbit，保持其他标志位布标
cin.clear(cin.rdstate() &amp;amp; ~cin.failbit &amp;amp; ~cin.badbit);
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;管理输出缓冲&lt;/h3&gt;
&lt;p&gt;每个输出流都管理一个缓冲区，用来保存程序读写的数据。&lt;/p&gt;
&lt;p&gt;导致缓冲刷新（即，数据真正写到输出设备或文件）的原因有很多：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;程序正常结束，作为&lt;code&gt;main&lt;/code&gt;函数的&lt;code&gt;return&lt;/code&gt;操作的一部分，缓冲刷新被执行&lt;/li&gt;
&lt;li&gt;缓冲区满&lt;/li&gt;
&lt;li&gt;使用操纵符&lt;code&gt;endl&lt;/code&gt;（插入换行）、&lt;code&gt;ends&lt;/code&gt;（插入空字符）、&lt;code&gt;flush&lt;/code&gt;（什么都不插入）显式刷新&lt;/li&gt;
&lt;li&gt;在每个输出操作之后，可以用操纵符&lt;code&gt;unitbuf&lt;/code&gt;设置流的内部状态，来情况缓冲区。默认情况下，对&lt;code&gt;cerr&lt;/code&gt;是设置&lt;code&gt;unitbuf&lt;/code&gt;的，因此&lt;code&gt;cerr&lt;/code&gt;的内容都是立即刷新的&lt;/li&gt;
&lt;li&gt;一个输出流可以关联到另一个流。当读写被关联的流时，关联到的流的缓冲区会被刷新。默认情况下，&lt;code&gt;cin&lt;/code&gt;和&lt;code&gt;cerr&lt;/code&gt;都关联到&lt;code&gt;cout&lt;/code&gt;。因此读&lt;code&gt;cin&lt;/code&gt;或者写&lt;code&gt;cerr&lt;/code&gt;都会导致&lt;code&gt;cout&lt;/code&gt;的缓冲区被刷新&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;unitbuf 操纵符&lt;/h3&gt;
&lt;p&gt;如果想在每次输出操作后都刷新缓冲区，可以使用&lt;code&gt;unitbuf&lt;/code&gt;操纵符。它告诉流在接下来的每次写操作之后都执行一次&lt;code&gt;flush&lt;/code&gt;刷新。&lt;code&gt;nounitbuf&lt;/code&gt;操纵符则重置流，使其恢复使用正常的系统管理的缓冲区刷新机制：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;cout &amp;lt;&amp;lt; unitbuf;    // 所有输出操作后都会立即刷新缓冲区
// 任何输出都会立即刷新，无缓冲
cout &amp;lt;&amp;lt; nounitbuf;    // 回到正常的缓冲方式
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;关联输入和输出流&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;tie()&lt;/code&gt;有两个重载的版本：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不带参数的版本返回指向输出流的指针。如果本对象当前关联到一个输出流，则返回的就是指向这个流的指针，如果对象未关联到流，则返回空指针&lt;/li&gt;
&lt;li&gt;第二个版本接受一个指向&lt;code&gt;ostream&lt;/code&gt;的指针，将自己关联到此&lt;code&gt;ostream&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每个流同时最多关联到一个流，但多个流可以同时关联到同一个&lt;code&gt;ostream&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;文件输入输出&lt;/h2&gt;
&lt;h3&gt;fstream 特有的操作&lt;/h3&gt;
&lt;p&gt;下表中的 &lt;em&gt;fstream&lt;/em&gt; 是头文件 fstream 中定义的一个类型：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;操作&lt;/th&gt;
&lt;th align="left"&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;em&gt;fstream&lt;/em&gt; fstrm;&lt;/td&gt;
&lt;td align="left"&gt;创建一个未绑定的文件流&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;em&gt;fstream&lt;/em&gt; fstrm(s);&lt;/td&gt;
&lt;td align="left"&gt;创建一个 &lt;em&gt;fstream&lt;/em&gt;，并打开名为 s 的文件。s 可以是 string 类型或者指向 C 风格字符串的指针。这些构造函数都是&lt;code&gt;explicit&lt;/code&gt;的。默认的文件模式 mode 依赖于 &lt;em&gt;fstream&lt;/em&gt; 的类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;em&gt;fstream&lt;/em&gt; fstrm(s, mode);&lt;/td&gt;
&lt;td align="left"&gt;按 mode 打开文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;fstrm.open(s)&lt;/td&gt;
&lt;td align="left"&gt;打开名为 s 的文件并与 fstrm 绑定。s 可以是 string 类型或者指向 C 风格字符串的指针。默认的文件模式 mode 依赖于 &lt;em&gt;fstream&lt;/em&gt; 的类型。返回&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;fstrm.close()&lt;/td&gt;
&lt;td align="left"&gt;关闭与 fstrm 绑定的文件。返回&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;fstrm.is_open()&lt;/td&gt;
&lt;td align="left"&gt;返回一个布尔值，指出与 fstrm 关联的文件是否打开成功且尚未关闭&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;如果调用&lt;code&gt;open()&lt;/code&gt;失败，&lt;code&gt;failbit&lt;/code&gt;会被置位，条件会为假：&lt;code&gt;if(open(file))&lt;/code&gt;可用于判定。&lt;/p&gt;
&lt;p&gt;对一个已经打开的文件流调用&lt;code&gt;open()&lt;/code&gt;会失败，并且&lt;code&gt;failbit&lt;/code&gt;会被置位。为了将文件流关联到另一个文件，必须先关闭已经关联的文件。&lt;/p&gt;
&lt;p&gt;当一个&lt;code&gt;fstream&lt;/code&gt;对象被销毁时，&lt;code&gt;close&lt;/code&gt;会自动被调用。&lt;/p&gt;
&lt;h3&gt;文件模式&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;文件模式&lt;/th&gt;
&lt;th align="left"&gt;意义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;in&lt;/td&gt;
&lt;td align="left"&gt;只读&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;out&lt;/td&gt;
&lt;td align="left"&gt;只写（会清空已有数据）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;app&lt;/td&gt;
&lt;td align="left"&gt;每次写操作前均定位到文件末尾&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;ate&lt;/td&gt;
&lt;td align="left"&gt;打开文件后立即定位到文件末尾&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;trunc&lt;/td&gt;
&lt;td align="left"&gt;截断文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;binary&lt;/td&gt;
&lt;td align="left"&gt;以二进制方式进行 IO&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;ifstream&lt;/code&gt;默认&lt;code&gt;in&lt;/code&gt;模式；&lt;code&gt;ofstream&lt;/code&gt;默认&lt;code&gt;out&lt;/code&gt;模式；&lt;code&gt;fstream&lt;/code&gt;默认&lt;code&gt;in&lt;/code&gt;和&lt;code&gt;out&lt;/code&gt;模式打开。&lt;/p&gt;
&lt;h2&gt;string 流&lt;/h2&gt;
&lt;h3&gt;fstream 特有的操作&lt;/h3&gt;
&lt;p&gt;下表中的 &lt;em&gt;sstream&lt;/em&gt; 是头文件 sstream 中定义的一个类型：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;操作&lt;/th&gt;
&lt;th align="left"&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;em&gt;sstream&lt;/em&gt; strm;&lt;/td&gt;
&lt;td align="left"&gt;创建一个未绑定的 stringstream 对象&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;em&gt;sstream&lt;/em&gt; strm(s);&lt;/td&gt;
&lt;td align="left"&gt;strm 是一个 sstream 对象，保存 string s 的一个拷贝。此构造函数时&lt;code&gt;explicit&lt;/code&gt;的&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;strm.str()&lt;/td&gt;
&lt;td align="left"&gt;返回 strm 所保存的 string 的拷贝&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;strm.str(s)&lt;/td&gt;
&lt;td align="left"&gt;将 string s 拷贝到 strm 中，返回 void&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</content><category term="C++"></category></entry><entry><title>C++ Primer 第七章 类</title><link href="https://xutree.github.io/pages/2018/10/09/C++_Primer_Chapter_7/" rel="alternate"></link><published>2018-10-09T20:38:15+08:00</published><updated>2018-10-09T20:38:15+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-09:/pages/2018/10/09/C++_Primer_Chapter_7/</id><summary type="html">&lt;p&gt;类的基本思想是数据抽象和封装。&lt;/p&gt;
&lt;p&gt;数据抽象是一种依赖于接口和实现分离的编程（以及设计）技术。类的接口包括用户可以执行的操作，类的实现包括类的数据成员，负责接口实现的函数体以及定义类所需的各种私有函数。&lt;/p&gt;
&lt;p&gt;封装实现了类的接口和实现的分离。封装后的类隐藏了它的实现细节，类的用户只能使用接口而无法访问实现部分。&lt;/p&gt;
&lt;h2&gt;类的定义&lt;/h2&gt;
&lt;p&gt;定义在类内部的函数时隐式&lt;code&gt;inline&lt;/code&gt;的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;this&lt;/code&gt;是一个常量指针。&lt;/p&gt;
&lt;h3&gt;const 成员函数&lt;/h3&gt;
&lt;p&gt;通过在紧随参数列表之后添加&lt;code&gt;const&lt;/code&gt;，可以定义&lt;code&gt;const&lt;/code&gt;成员函数。&lt;code&gt;const&lt;/code&gt;的作用是修改隐式&lt;code&gt;this&lt;/code&gt;指针的类型。&lt;/p&gt;
&lt;p&gt;默认情况下，&lt;code&gt;this&lt;/code&gt;指针的类型是指向类类型非常量版本的常量指针（顶层常量）。这意味着我们不能把&lt;code&gt;this&lt;/code&gt;绑定到一个常量对象上。&lt;/p&gt;
&lt;p&gt;常量对象，以及常量对象的引用或者指针都只能调用常量成员函数。&lt;/p&gt;
&lt;h3&gt;类作用域和成员函数&lt;/h3&gt;
&lt;p&gt;编译器分两步处理类：首先编译成员的声明，然后才轮到成员函数体（如果有的话）。因此，成员函数体可以随意使用类中的其他成员而无须在意这些成员出现的顺序。&lt;/p&gt;
&lt;p&gt;编译器处理完类中的全部声明后才会处理成员函数的定义。&lt;/p&gt;
&lt;p&gt;这种两阶段的处理方式只适用于成员函数中使用的名字。声明中使用的名字，包括返回类型或者参数列表中使用的名字，都必须在使用前确保可见。如果某个成员的声明使用了类中尚未出现的名字，则编译器将会在定义该类的作用域中继续查找 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;类的基本思想是数据抽象和封装。&lt;/p&gt;
&lt;p&gt;数据抽象是一种依赖于接口和实现分离的编程（以及设计）技术。类的接口包括用户可以执行的操作，类的实现包括类的数据成员，负责接口实现的函数体以及定义类所需的各种私有函数。&lt;/p&gt;
&lt;p&gt;封装实现了类的接口和实现的分离。封装后的类隐藏了它的实现细节，类的用户只能使用接口而无法访问实现部分。&lt;/p&gt;
&lt;h2&gt;类的定义&lt;/h2&gt;
&lt;p&gt;定义在类内部的函数时隐式&lt;code&gt;inline&lt;/code&gt;的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;this&lt;/code&gt;是一个常量指针。&lt;/p&gt;
&lt;h3&gt;const 成员函数&lt;/h3&gt;
&lt;p&gt;通过在紧随参数列表之后添加&lt;code&gt;const&lt;/code&gt;，可以定义&lt;code&gt;const&lt;/code&gt;成员函数。&lt;code&gt;const&lt;/code&gt;的作用是修改隐式&lt;code&gt;this&lt;/code&gt;指针的类型。&lt;/p&gt;
&lt;p&gt;默认情况下，&lt;code&gt;this&lt;/code&gt;指针的类型是指向类类型非常量版本的常量指针（顶层常量）。这意味着我们不能把&lt;code&gt;this&lt;/code&gt;绑定到一个常量对象上。&lt;/p&gt;
&lt;p&gt;常量对象，以及常量对象的引用或者指针都只能调用常量成员函数。&lt;/p&gt;
&lt;h3&gt;类作用域和成员函数&lt;/h3&gt;
&lt;p&gt;编译器分两步处理类：首先编译成员的声明，然后才轮到成员函数体（如果有的话）。因此，成员函数体可以随意使用类中的其他成员而无须在意这些成员出现的顺序。&lt;/p&gt;
&lt;p&gt;编译器处理完类中的全部声明后才会处理成员函数的定义。&lt;/p&gt;
&lt;p&gt;这种两阶段的处理方式只适用于成员函数中使用的名字。声明中使用的名字，包括返回类型或者参数列表中使用的名字，都必须在使用前确保可见。如果某个成员的声明使用了类中尚未出现的名字，则编译器将会在定义该类的作用域中继续查找。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;typedef&lt;/span&gt; &lt;span class="kr"&gt;double&lt;/span&gt; &lt;span class="nx"&gt;Money&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;string&lt;/span&gt; &lt;span class="nx"&gt;bal&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;Account&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="kr"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="nx"&gt;Money&lt;/span&gt; &lt;span class="nx"&gt;balance() {&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;bal&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kr"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="nx"&gt;Money&lt;/span&gt; &lt;span class="nx"&gt;bal&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="c1"&gt;// ...&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当编译器看到 balance 函数的声明语句时，它将在 Account 类的范围内寻找对 Money 的声明。编译器只考虑 Account 中在使用 Money 前出现的声明，因为没找到匹配的成员，所以编译器会接着到 Account 的外层作用域中查找。在上面的例子中，编译器会找到 Money 的&lt;code&gt;typedef&lt;/code&gt;语句，该类型被用作 balance 函数的返回类型及数据成员 bal 的类型。另一方面，balance 函数体在整个类可见后才被处理。因此，该函数的&lt;code&gt;return&lt;/code&gt;语句返回名为 bal 的成员，而非外层作用域的&lt;code&gt;string&lt;/code&gt;对象。&lt;/p&gt;
&lt;h3&gt;构造函数&lt;/h3&gt;
&lt;p&gt;构造函数不能被声明成&lt;code&gt;const&lt;/code&gt;的。&lt;/p&gt;
&lt;p&gt;当我们创建类的一个&lt;code&gt;const&lt;/code&gt;对象时，直到构造函数完成初始化过程，对象才能真正取得其“常量”属性。因此，构造函数在&lt;code&gt;const&lt;/code&gt;对象的构造过程中可以向其写值。&lt;/p&gt;
&lt;p&gt;如果我们的类没有显式定义构造函数，编译器会生成合成的默认构造函数。对于大多数类来说，合成的默认构造函数按照如下规则初始化类的数据成员：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果存在类内的初始值，用它来初始化成员&lt;/li&gt;
&lt;li&gt;否则，执行默认初始化&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 C++ 11中，如果我们需要默认的行为，那么可以通过在参数列表后面写上 &lt;strong&gt;= default&lt;/strong&gt; 来要求编译器生成构造函数。如果 &lt;strong&gt;= default&lt;/strong&gt; 出现在类的内部，则默认构造函数是内联的；如果它出现在外部，则该成员默认情况下不是内联的。&lt;/p&gt;
&lt;h4&gt;构造函数初始值列表&lt;/h4&gt;
&lt;p&gt;构造函数初始值列表：&lt;code&gt;Sales_data(const std::string &amp;amp;s) : bookNo(s) { }&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果成员是&lt;code&gt;const&lt;/code&gt;或者引用的话，必须将其初始化。类似的，当成员属于某种类类型且该类类型没有定义默认构造函数时，也必须将这个成员初始化。&lt;/p&gt;
&lt;p&gt;随着构造函数体一开始执行，初始化就完成了。我们初始化&lt;code&gt;const&lt;/code&gt;或者引用类型的唯一机会就是通过构造函数初始化。&lt;/p&gt;
&lt;p&gt;构造函数初始值列表只说明用于初始化成员的值。成员的初始化顺序与它们在类定义中出现顺序一致。&lt;/p&gt;
&lt;h4&gt;委托构造函数&lt;/h4&gt;
&lt;p&gt;一个委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程，或者说它把它自己的一些（或者全部）职责委托给了其他构造函数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;Sales_data&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="kr"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="c1"&gt;// 非委托构造函数&lt;/span&gt;
    &lt;span class="nx"&gt;Sales_data&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt; &lt;span class="nx"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;unsigned&lt;/span&gt; &lt;span class="nx"&gt;cnt&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kr"&gt;double&lt;/span&gt; &lt;span class="nx"&gt;price&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt;
        &lt;span class="nx"&gt;bookNo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;s&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="nx"&gt;units_sold&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;cnt&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="nx"&gt;revenue&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;cnt&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;price&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="c1"&gt;// 其余构造函数都委托给另外一个构造函数&lt;/span&gt;
    &lt;span class="nx"&gt;Sales_data&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;Sales_data&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="nx"&gt;Sales_data&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt; &lt;span class="nx"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;Sales_data&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="nx"&gt;Sales_data&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;istream&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;is&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;Sales_data() {&lt;/span&gt; &lt;span class="nx"&gt;read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;is&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="c1"&gt;//其他成员&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;受委托的构造函数先执行。&lt;/p&gt;
&lt;h2&gt;访问控制与封装&lt;/h2&gt;
&lt;p&gt;定义在 &lt;strong&gt;public&lt;/strong&gt; 说明符之后的成员在整个程序内可被访问，&lt;strong&gt;public&lt;/strong&gt; 成员定义类的接口。&lt;/p&gt;
&lt;p&gt;定义在 &lt;strong&gt;private&lt;/strong&gt; 说明符之后的成员可以被类的成员函数访问，但是不能被使用该类的代码访问。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;class&lt;/code&gt;和&lt;code&gt;struct&lt;/code&gt;定义类唯一的区别就是默认的访问权限。&lt;/p&gt;
&lt;h3&gt;友元&lt;/h3&gt;
&lt;p&gt;通过友元，类可以允许其他类或者函数访问它的&lt;strong&gt;非公有成员&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果类想把一个函数作为它的友元，只需要增加一条以&lt;code&gt;friend&lt;/code&gt;关键字开始的函数声明即可。友元声明只能出现在类定义的内部，但是在类内出现的具体位置不限。友元不是类的成员也不受它所在区域访问控制级别的约束。&lt;/p&gt;
&lt;p&gt;友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明。如果我们希望类的用户能够调用某个友元函数，那么我们必须在友元声明之外再专门对函数进行一次声明。&lt;/p&gt;
&lt;p&gt;友元关系不存在传递性。&lt;/p&gt;
&lt;p&gt;如果一个类指定了友元类，则友元类的成员函数可以访问此类&lt;strong&gt;包括非公有成员在内的所有成员&lt;/strong&gt;。&lt;/p&gt;
&lt;h2&gt;类的其他特性&lt;/h2&gt;
&lt;h3&gt;定义类型成员&lt;/h3&gt;
&lt;p&gt;类可以自定义某种类型在类中的别名。要注意，用来定义类型的成员必须先定义后使用。&lt;/p&gt;
&lt;h3&gt;可变数据成员&lt;/h3&gt;
&lt;p&gt;有时我们希望能够修改类的某个数据成员，即使是在一个&lt;code&gt;const&lt;/code&gt;成员函数内。通过关键字&lt;code&gt;mutable&lt;/code&gt;可以达到这种效果。一个可变数据成员永远不会是&lt;code&gt;const&lt;/code&gt;，即使它是&lt;code&gt;const&lt;/code&gt;对象的成员。&lt;/p&gt;
&lt;h3&gt;返回 *this 的成员函数&lt;/h3&gt;
&lt;p&gt;一个&lt;code&gt;const&lt;/code&gt;成员函数如果以引用的方式返回*this，那么它的返回类型将是常量引用。&lt;/p&gt;
&lt;p&gt;基于&lt;code&gt;const&lt;/code&gt;的重载：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;Screen&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="kr"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="c1"&gt;// 根据对象是否是 const 重载 display 函数&lt;/span&gt;
    &lt;span class="nx"&gt;Screen&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;display&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;ostream&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;os&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;   &lt;span class="nx"&gt;do_display&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;os&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;Screen&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;display&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;ostream&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;os&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;const&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;   &lt;span class="nx"&gt;do_display&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;os&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kr"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="c1"&gt;// 该函数负责显示 Screen 的内容&lt;/span&gt;
    &lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="nx"&gt;do_display&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;ostream&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;os&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;   &lt;span class="nx"&gt;os&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="nx"&gt;contents&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;类类型&lt;/h3&gt;
&lt;p&gt;声明方法：&lt;code&gt;Sales_data item1;&lt;/code&gt;或&lt;code&gt;class Sales_data item1;&lt;/code&gt;后一种从 C 语言继承而来。&lt;/p&gt;
&lt;p&gt;类的声明：前向声明，在类声明之后定义之前，类是一个不完全类型。&lt;/p&gt;
&lt;p&gt;不完全类型只能在非常有限的情景下使用：定义指向这种类型的引用或指针，也可以声明（但是不能定义）以不完全类型作为参数或者返回类型的函数。&lt;/p&gt;
&lt;p&gt;直到类被定义之后数据成员才可以被声明成这种类类型。然而，当一个类的名字出现后，它被认为是声明过了（但尚未定义），因此允许包含指向它自身类型的引用或者指针（有没有想到链表结构）。&lt;/p&gt;
&lt;h4&gt;隐式的类类型转换&lt;/h4&gt;
&lt;p&gt;如果构造函数只接受一个实参，则它实际上定义了转换为此类类型的隐式转换机制，有时我们把这种构造函数称为转换构造函数。&lt;/p&gt;
&lt;p&gt;只允许一步类类型转换。类类型转换不是总有效。&lt;/p&gt;
&lt;h4&gt;抑制构造函数定义的隐式转换&lt;/h4&gt;
&lt;p&gt;可以通过将构造函数声明为&lt;code&gt;explicit&lt;/code&gt;加以阻止。&lt;/p&gt;
&lt;p&gt;关键字&lt;code&gt;explicit&lt;/code&gt;只对一个实参的构造函数有效。需要多个实参的构造函数不能用于执行隐式转换，所以无须将这些构造函数指定为&lt;code&gt;explicit&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;只能在类内声明构造函数时使用&lt;code&gt;explicit&lt;/code&gt;关键字，在类外部定义时不应重复。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;explicit&lt;/code&gt;构造函数只能用于直接初始化。&lt;/p&gt;
&lt;p&gt;尽管编译器不会将&lt;code&gt;explicit&lt;/code&gt;的构造函数用于隐式转换过程，但是我们可以使用这样的构造函数显式地强制类型转换：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;item.combine(static_cast&amp;lt;Sales_data&amp;gt;(cin));
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;聚合类&lt;/h3&gt;
&lt;p&gt;当一个类满足如下条件时，我们说它是聚合的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有成员都是&lt;code&gt;public&lt;/code&gt;的&lt;/li&gt;
&lt;li&gt;没有定义任何构造函数&lt;/li&gt;
&lt;li&gt;没有类内初始值&lt;/li&gt;
&lt;li&gt;没有基类，也没有虚函数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;struct Data {
    int ival;
    string s;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以使用初始化列表初始化，初始值的顺序必须与声明的顺序一致。如果初始值列表中的元素个数少于类的成员数量，则靠后的成员被值初始化。&lt;/p&gt;
&lt;h3&gt;字面值常量类&lt;/h3&gt;
&lt;p&gt;字面值类型的类可能含有&lt;code&gt;constexpr&lt;/code&gt;函数成员，它们是隐式&lt;code&gt;const&lt;/code&gt;成员函数。&lt;/p&gt;
&lt;p&gt;数据成员都是字面值类型的聚合类是字面值常量类。&lt;/p&gt;
&lt;p&gt;如果一个类不是聚合类，符合以下要求也是一个字面值常量类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据成员都必须是字面值类型&lt;/li&gt;
&lt;li&gt;类必须至少有一个&lt;code&gt;constexpr&lt;/code&gt;构造函数&lt;/li&gt;
&lt;li&gt;如果一个数据成员含有类内初始值，则内置类型成员的初始值必须是一条常量表达式；如果成员属于某种类类型，则初始值必须使用成员自己的&lt;code&gt;constexpr&lt;/code&gt;构造函数&lt;/li&gt;
&lt;li&gt;类必须使用析构函数的默认定义，该成员负责销毁类的定义&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;尽管构造函数不能是&lt;code&gt;const&lt;/code&gt;的，但是字面值常量类的构造函数可以使&lt;code&gt;constexpr&lt;/code&gt;函数。事实上，一个字面值常量类都必须至少提供一个&lt;code&gt;constexpr&lt;/code&gt;构造函数。通过前置关键字&lt;code&gt;constexpr&lt;/code&gt;就可以声明一个&lt;code&gt;constexpr&lt;/code&gt;构造函数。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;constexpr&lt;/code&gt;构造函数可以声明成&lt;code&gt;=default&lt;/code&gt;或者删除函数的形式，否则，&lt;code&gt;constexpr&lt;/code&gt;构造函数就必须既符合构造函数的要求（意味着不能包含返回语句），又符合&lt;code&gt;constexpr&lt;/code&gt;函数的要求（意味着它唯一可执行语句就是返回语句），综合这两点，&lt;code&gt;constexpr&lt;/code&gt;构造函数体一般来说应该是空的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;constexpr&lt;/code&gt;构造函数必须初始化所有数据成员，初始值或者使用&lt;code&gt;constexpr&lt;/code&gt;构造函数，或者是一条常量表达式。&lt;/p&gt;
&lt;h2&gt;类的静态成员&lt;/h2&gt;
&lt;p&gt;类的静态成员存在于任何对象之外，对象中不包含任何与静态数据成员有关的数据。类似的，静态成员函数也不与任何对象绑定在一起，它们不包含&lt;code&gt;this&lt;/code&gt;指针。作为结果，静态成员函数不能声明成&lt;code&gt;const&lt;/code&gt;的，而且我们也不能在静态函数体内使用&lt;code&gt;this&lt;/code&gt;指针。&lt;/p&gt;
&lt;p&gt;成员函数不用通过作用域运算符就能直接使用静态成员。&lt;/p&gt;
&lt;p&gt;当在类的外部定义静态成员时，不能重复&lt;code&gt;static&lt;/code&gt;关键字，该关键字只出现在类内部的声明语句。&lt;/p&gt;
&lt;p&gt;必须在类的外部定义和初始化每个静态成员（一个例外，如果静态成员是字面值类型的&lt;code&gt;constexpr&lt;/code&gt;可以在类内给它提供一个整数类型的常量表达式初始值），一个静态成员只能被初始化一次。&lt;/p&gt;
&lt;p&gt;类似于全局变量，静态数据成员定义在任何函数之外，一直存在于程序的整个生命周期中。&lt;/p&gt;
&lt;p&gt;静态数据成员可以是不完全类型，非静态数据成员只能声明成它所属类的指针或引用。&lt;/p&gt;
&lt;p&gt;静态数据成员可以作为默认实参，非静态数据成员不行，因为它的值本身属于对象的一部分，这么做的结果是无法真正提供一个对象以便从中获得成员的值（类似于循环定义），将引发错误。&lt;/p&gt;</content><category term="C++"></category></entry><entry><title>C++ Primer 第六章 函数</title><link href="https://xutree.github.io/pages/2018/10/09/C++_Primer_Chapter_6/" rel="alternate"></link><published>2018-10-09T15:55:08+08:00</published><updated>2018-10-09T15:55:08+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-09:/pages/2018/10/09/C++_Primer_Chapter_6/</id><summary type="html">&lt;p&gt;函数是一个命名了的代码块。&lt;/p&gt;
&lt;h2&gt;函数基础&lt;/h2&gt;
&lt;p&gt;为了与 C 语言兼容，可以使用关键字&lt;code&gt;void&lt;/code&gt;表示函数没有形参。&lt;/p&gt;
&lt;p&gt;函数的返回值不能是数组或者函数类型，但可以返回指向数组和函数的指针。&lt;/p&gt;
&lt;p&gt;自动对象：只存在于块执行期间的对象。当块的执行结束后，块中创建的自动对象的值就变成未定义的了。&lt;/p&gt;
&lt;p&gt;局部静态对象：在程序执行路径第一次经过对象定义语句时初始化，并且直到程序终止才销毁。如果没有显示初始化，则执行值初始化，内置类型的局部静态变量初始化为0。&lt;/p&gt;
&lt;h2&gt;参数传递&lt;/h2&gt;
&lt;p&gt;值传递和引用传递。&lt;/p&gt;
&lt;p&gt;当某种类型不支持拷贝操作时，函数只能通过引用形参访问该类型的对象。如 IO 类型。&lt;/p&gt;
&lt;h3&gt;const 形参和实参&lt;/h3&gt;
&lt;p&gt;如果函数无须改变引用形参的值，最好将其声明为常量引用。&lt;/p&gt;
&lt;p&gt;此外，使用引用而非常量引用也会极大地限制函数所能接受的实参类型。例如，我们不能把&lt;code&gt;const&lt;/code&gt;对象、字面值或者需要类型转换的对象传递给普通的引用形参，这种绝不像看起来那么简单，它可能造成出人意料的后果。考虑如下函数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nd"&gt;size_type&lt;/span&gt; &lt;span class="nt"&gt;find_char&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;string&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nt"&gt;s&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;char&lt;/span&gt; &lt;span class="nt"&gt;c&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nd"&gt;size_type …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;函数是一个命名了的代码块。&lt;/p&gt;
&lt;h2&gt;函数基础&lt;/h2&gt;
&lt;p&gt;为了与 C 语言兼容，可以使用关键字&lt;code&gt;void&lt;/code&gt;表示函数没有形参。&lt;/p&gt;
&lt;p&gt;函数的返回值不能是数组或者函数类型，但可以返回指向数组和函数的指针。&lt;/p&gt;
&lt;p&gt;自动对象：只存在于块执行期间的对象。当块的执行结束后，块中创建的自动对象的值就变成未定义的了。&lt;/p&gt;
&lt;p&gt;局部静态对象：在程序执行路径第一次经过对象定义语句时初始化，并且直到程序终止才销毁。如果没有显示初始化，则执行值初始化，内置类型的局部静态变量初始化为0。&lt;/p&gt;
&lt;h2&gt;参数传递&lt;/h2&gt;
&lt;p&gt;值传递和引用传递。&lt;/p&gt;
&lt;p&gt;当某种类型不支持拷贝操作时，函数只能通过引用形参访问该类型的对象。如 IO 类型。&lt;/p&gt;
&lt;h3&gt;const 形参和实参&lt;/h3&gt;
&lt;p&gt;如果函数无须改变引用形参的值，最好将其声明为常量引用。&lt;/p&gt;
&lt;p&gt;此外，使用引用而非常量引用也会极大地限制函数所能接受的实参类型。例如，我们不能把&lt;code&gt;const&lt;/code&gt;对象、字面值或者需要类型转换的对象传递给普通的引用形参，这种绝不像看起来那么简单，它可能造成出人意料的后果。考虑如下函数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nd"&gt;size_type&lt;/span&gt; &lt;span class="nt"&gt;find_char&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;string&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nt"&gt;s&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;char&lt;/span&gt; &lt;span class="nt"&gt;c&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nd"&gt;size_type&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nt"&gt;occurs&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;则只能将 find_char 函数用于&lt;code&gt;string&lt;/code&gt;对象。类似下面的调用将在编译时发生错误：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;find_char(&amp;quot;Hello World&amp;quot;, &amp;#39;o&amp;#39;, ctr);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;还有一个更难察觉的问题。假如其它函数（正确的）将它们的形参定义成常量引用，那么上述的 find_char 函数无法在此类函数中正常使用。例如&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;bool&lt;/span&gt; &lt;span class="nt"&gt;is_sentence&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;const&lt;/span&gt; &lt;span class="nt"&gt;string&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nt"&gt;s&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;size_type&lt;/span&gt; &lt;span class="n"&gt;ctr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="err"&gt;return&lt;/span&gt; &lt;span class="err"&gt;find_char(s,&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;.&amp;#39;,&lt;/span&gt; &lt;span class="err"&gt;ctr)&lt;/span&gt; &lt;span class="err"&gt;==&lt;/span&gt; &lt;span class="err"&gt;s.size()&lt;/span&gt; &lt;span class="err"&gt;-&lt;/span&gt; &lt;span class="err"&gt;1&lt;/span&gt; &lt;span class="err"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="err"&gt;ctr&lt;/span&gt; &lt;span class="err"&gt;==&lt;/span&gt; &lt;span class="err"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;正确的修改思路是改正 find_char 函数的形参。如果实在不能修改 find_char，就在 is_sentence 内部定义一个&lt;code&gt;string&lt;/code&gt;类型的变量，令其为 s 的副本，然后把这个对象传递给 find_char。&lt;/p&gt;
&lt;p&gt;用实参初始化形参时，会忽略顶层&lt;code&gt;const&lt;/code&gt;。也就是说，当形参是顶层&lt;code&gt;const&lt;/code&gt;时，传给它常量对象或者非常量对象都是可以的。&lt;/p&gt;
&lt;p&gt;可以使用一个非常量初始化一个底层&lt;code&gt;const&lt;/code&gt;对象，但反过来不行。&lt;/p&gt;
&lt;h3&gt;数组形参&lt;/h3&gt;
&lt;p&gt;数组的两个性质：不允许拷贝数组；使用数组时会将其转换成指针。&lt;/p&gt;
&lt;p&gt;当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针。&lt;/p&gt;
&lt;p&gt;尽管不能以值传递的方式传递数组，但是我们可以把形参写成类似数组的形式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;void print(const int*);
void print(const int[]);
void print(const int[10]);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;尽管表现形式不同，但是上面的三个函数是等价的：每个函数的唯一形参都是&lt;code&gt;const int*&lt;/code&gt;类型的。如果我们传给 print 函数的是一个数组，则实参自动的转换成指向数组首元素的指针，数组的大小对函数的调用没有影响。&lt;/p&gt;
&lt;p&gt;因为数组是以指针的形式传递给函数的，所以一开始函数并不知道数组的确切尺寸，调用者应该为此提供一些额外的信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用标记指定数组长度：让数组本身包含一个结束标记，例如 C 风格字符串&lt;/li&gt;
&lt;li&gt;使用标准库规范，&lt;code&gt;begin()&lt;/code&gt;和&lt;code&gt;end()&lt;/code&gt;函数&lt;/li&gt;
&lt;li&gt;显示传递一个表示数组大小的形参&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当函数不需要对数组元素执行写操作的时候，数组形参应该是指向&lt;code&gt;const&lt;/code&gt;的指针，注意下面的函数只能作用于大小为10的数组&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;void print(int (&amp;amp;arr)[10])
{
        for (auto elem : arr)
                cout &amp;lt;&amp;lt; elem &amp;lt;&amp;lt; endl;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;main：处理命令行选项&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int main(int argc, char *argv[]) { ... }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;第二个形参 argv 是一个数组，它的元素是指向 C 风格字符串的指针；第一个形参 argc 表示数组中字符串的数量。因为第二个形参是数组，所以 main 函数也可以定义成：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int main(int argc, char **argv) { ... }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当实参传给 main 函数之后，argv 的第一个元素指向程序的名字或者一个空字符串，接下来的元素依次传递命令行提供的实参，最后一个指针之后的元素值保证为0。&lt;/p&gt;
&lt;h3&gt;含有可变形参的函数&lt;/h3&gt;
&lt;p&gt;为了编写能够处理不同数量实参的函数，C++11 新标准提供了两种主要的方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果所有实参类型相同，可以传递一个名为&lt;code&gt;initializer_list&lt;/code&gt;的标准库类型&lt;/li&gt;
&lt;li&gt;如果实参的类型不同，可以编写可变参数模板&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++ 还有一种特殊的形参类型（即省略号），可以用它传递可变数量的实参，不过需要注意的是，这种功能一般只用于与 C 函数交互的接口程序&lt;/p&gt;
&lt;h4&gt;initializer_list 形参&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;initializer_list&lt;/code&gt;类型定义在同名的头文件中。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;initializer_list&lt;/code&gt;是一种类型模板，提供的操作如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;initializer_list &amp;lt;T&amp;gt; lst;&lt;/code&gt;默认初始化；T 类型元素的空列表。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;initializer_list &amp;lt;T&amp;gt; lst{a,b,c...};&lt;/code&gt;lst 的元素数量和初始值一样多；lst 的元素是对应初始值的副本；列表中的元素是 const。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;lst2(lst);&lt;/code&gt;拷贝或赋值一个&lt;code&gt;initializer_list&lt;/code&gt;对象不会拷贝列表中的元素；拷贝后，原始列表和副本共享元素。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;lst2 = lst;&lt;/code&gt;等价于&lt;code&gt;lst2(lst)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;lst.size();&lt;/code&gt;列表中的元素数量。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;lst.begin();&lt;/code&gt;返回指向 lst 中首元素的指针。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;lst.end();&lt;/code&gt;返回指向 lst 中尾元素下一位置的指针。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;initializer_list&lt;/code&gt;和&lt;code&gt;vector&lt;/code&gt;一样，也是类型模板，定义&lt;code&gt;initializer_list&lt;/code&gt;对象时，必须说明列表中所含对象的类型。和&lt;code&gt;vector&lt;/code&gt;不一样的是，&lt;code&gt;initializer_list&lt;/code&gt;对象中的元素永远是常量值。&lt;/p&gt;
&lt;p&gt;如果想向&lt;code&gt;initializer_list&lt;/code&gt;形参中传递一个值的序列，则必须把序列放在一对花括号内：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//expected和actual是string对象
if (expected != actual)
        error_msg({&amp;quot;functionX&amp;quot;, expected, actual});
else
        error_msg({&amp;quot;functionX&amp;quot;, &amp;quot;okay&amp;quot;});
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;省略符形参&lt;/h4&gt;
&lt;p&gt;省略符形参是为了便于 C++ 程序访问某些特殊的 C 代码而设置的，这些代码使用了名为 varargs 的 C 标准库功能。通常，省略符形参不应用于其他目的。你的 C 编译器文档会描述如何使用 varargs。&lt;/p&gt;
&lt;p&gt;省略符形参只能出现在形参列表的最后一个位置，无外乎两种形式，在第一种形式中，形参声明后面的逗号是可选的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;void foo(parm_list,...);
void foo(...);
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;返回类型和 return 语句&lt;/h2&gt;
&lt;p&gt;返回&lt;code&gt;void&lt;/code&gt;的函数不要求非得有&lt;code&gt;return&lt;/code&gt;语句，以为这类函数的最后一句会隐式的执行&lt;code&gt;return&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;返回的值用于初始化调用点的一个临时量，该临时量就是函数调用的结果。&lt;/p&gt;
&lt;p&gt;不要返回局部对象的引用或指针。&lt;/p&gt;
&lt;p&gt;调用一个返回引用的函数得到左值，其他返回类型得到右值。&lt;/p&gt;
&lt;p&gt;C++ 11新标准规定，函数可以返回花括号包围的值的列表，类似于其他返回结果，此处的列表也用来对表示函数返回的临时量进行初始化。如果列表为空，临时量执行值初始化。如果函数返回的是内置类型，则花括号包围的列表最多包含一个值，且该值所占空间不应该大于目标类型的空间。如果返回的是类类型，由类本身定义初始值如何使用。&lt;/p&gt;
&lt;p&gt;如果控制语句到达了 main 函数的结尾处而且没有&lt;code&gt;return&lt;/code&gt;语句，编译器会隐式的插入一条返回0的&lt;code&gt;return&lt;/code&gt;语句。&lt;/p&gt;
&lt;p&gt;cstdlib 头文件定义了两个预处理变量表示成功与失败：&lt;code&gt;EXIT_SUCCESS&lt;/code&gt;，&lt;code&gt;EXIT_FAILURE&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;int (*func(int i))[10];&lt;/code&gt;func 是一个函数指针，指向：接受一个&lt;code&gt;int&lt;/code&gt;参数，返回值是包含10个&lt;code&gt;int&lt;/code&gt;数组的地址的函数。也可以利用尾置返回类型（C++ 11）写为：&lt;code&gt;auto func(int i) -&amp;gt; int(*)[10];&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;还有一种情况，如果我们知道函数返回的指针将指向哪个数组，就可以使用&lt;code&gt;decltype&lt;/code&gt;关键字声明返回类型。例如，下面的函数返回一个指针，该指针根据参数i的不同指向两个已知数组中的某一个：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int odd[] = {1, 3, 5, 7, 9};
int even[] = {0, 2, 4, 6, 8};
//返回一个指针，该指针指向含有5个整数的数组
decltype(odd) *arrPtr(int i)
{
        return (i % 2) ? &amp;amp;odd : &amp;amp;even;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;arrPtr 使用关键字&lt;code&gt;decltype&lt;/code&gt;表示它的返回类型是个指针，并且该指针所指的对象与 odd 的类型一致。因为 odd 是数组，所以 arrPtr 返回一个指向含有5个整数的数组的指针。有一个地方需要注意，&lt;code&gt;decltype&lt;/code&gt;并不负责把数组类型转换成对应的指针，所以&lt;code&gt;decltype&lt;/code&gt;的结果是个数组，要想表示 arrPtr 返回指针还必须在函数声明时加一个 * 符号。&lt;/p&gt;
&lt;h2&gt;函数重载&lt;/h2&gt;
&lt;h3&gt;顶层 const&lt;/h3&gt;
&lt;p&gt;顶层&lt;code&gt;const&lt;/code&gt;不影响传入函数的对象。一个用于顶层&lt;code&gt;const&lt;/code&gt;的形参无法和一个没有顶层&lt;code&gt;const&lt;/code&gt;的形参区分开，无法重载：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Record lookup(Phone);
Record lookup(const Phone);
//
Record lookup(Phone*);
Record lookup(Phone* const);
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;底层 const&lt;/h3&gt;
&lt;p&gt;底层&lt;code&gt;const&lt;/code&gt;可以实现重载。当我们传递一个非常量对象或者指向非常量对象的指针时，编译器会优先选用非常量的版本：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Record lookup(Account&amp;amp;);
Record lookup(const Account&amp;amp;);
//
Record lookup(Account*);
Record lookup(const Account*);
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;const_cast和重载&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//函数1
const string &amp;amp;shorterString(const string &amp;amp;s1, const strinf &amp;amp;s2)
{
        return s1.size() &amp;lt;= s2.size() ? s1 : s2;
}
//函数2
string &amp;amp;shorterString(string &amp;amp;s1, string &amp;amp;s2)
{
        auto &amp;amp;r = shorterString(const_cast&amp;lt;const string &amp;amp;&amp;gt;(s1),
                                const_cast&amp;lt;const string&amp;amp;&amp;gt;(s2));
        return const_cast&amp;lt;string&amp;amp;&amp;gt;(r);
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;函数1的参数和返回类型都是&lt;code&gt;const string&lt;/code&gt;的引用。我们当然可以对两个非常量的&lt;code&gt;string&lt;/code&gt;实参调用这个函数，但返回的结果仍然是&lt;code&gt;const string&lt;/code&gt;的引用。&lt;/p&gt;
&lt;h3&gt;作用域与重载&lt;/h3&gt;
&lt;p&gt;编译器首先在当前作用域寻找函数，一旦找到，就会忽略掉外层作用域中的同名实体，剩下的工作就是检查函数调用是否有效了。&lt;/p&gt;
&lt;p&gt;在C++语言中，名字查找发生在类型检查之前。&lt;/p&gt;
&lt;h2&gt;特殊用于语言特性&lt;/h2&gt;
&lt;h3&gt;默认实参&lt;/h3&gt;
&lt;p&gt;一旦一个形参被赋予了默认值，它后面的所有形参都必须有默认值。&lt;/p&gt;
&lt;p&gt;在给定的作用域中，一个形参只能被赋予一次默认实参。&lt;/p&gt;
&lt;p&gt;局部变量不能作为默认实参。&lt;/p&gt;
&lt;p&gt;用作函数实参的名字在函数声明所在的作用域内解析，而这些名字的求值过程发生在函数调用时：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sz wd = 80;
char def = &amp;#39;&amp;#39;;
sz ht();
string screen(sz = ht(), sz = wd, char = def);

void f()
{
    def = &amp;#39;*&amp;#39;;  //改变默认实参的值
    sz wd = 100;    //隐藏了外层定义的wd，但是没有改变默认值
    window = screen();  //调用 screen(ht(), 80, &amp;#39;*&amp;#39;)
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;内联函数&lt;/h3&gt;
&lt;p&gt;以空间换时间。在函数返回类型前面加上关键字&lt;code&gt;inline&lt;/code&gt;。内联说明只是向编译器发出一个请求，编译器可以选择忽略这个请求。&lt;/p&gt;
&lt;h3&gt;constexpr 函数&lt;/h3&gt;
&lt;p&gt;能用于常量表达式的函数。函数的返回类型及所有的形参类型都得是字面值类型。函数体中必须有且只有一条&lt;code&gt;return&lt;/code&gt;语句。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;constexpr int new_sz() { return 42; }
constexpr int foo = new_sz();
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;编译器在程序编译时验证 new_sz 函数的返回类型。执行初始化任务时，编译器把对&lt;code&gt;constexpr&lt;/code&gt;函数的调用替换成其结果值。为了能在编译过程中随时展开，&lt;code&gt;constexpr&lt;/code&gt;函数被隐式指定为内联函数。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;constexpr&lt;/code&gt;函数体内也可以包含其他语句，只要这些语句在运行时不执行任何操作就行，例如，空语句、类型别名及&lt;code&gt;using&lt;/code&gt;声明。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;constexpr&lt;/code&gt;函数不一定返回常量表达式，当把这类函数用在需要常量表达式的上下文中时，会出错。&lt;/p&gt;
&lt;p&gt;把内联函数和&lt;code&gt;constexpr&lt;/code&gt;函数放在头文件内。&lt;/p&gt;
&lt;p&gt;和其它函数不一样，内联函数和&lt;code&gt;constexpr&lt;/code&gt;函数可以在程序中多次定义，但是多个定义必须完全一致。&lt;/p&gt;
&lt;h3&gt;调试帮助&lt;/h3&gt;
&lt;h4&gt;assert 预处理宏&lt;/h4&gt;
&lt;p&gt;所谓预处理宏其实是一个预处理变量，它的行为有点类似于内联函数。&lt;code&gt;assert&lt;/code&gt;宏使用一个表达式作为它的条件：&lt;code&gt;assert(expr);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;首先对 expr 求值，如果表达式为假，&lt;code&gt;assert&lt;/code&gt;输出信息并终止程序的执行。如果表达式为真，&lt;code&gt;assert&lt;/code&gt;什么也不做。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;assert&lt;/code&gt;定义在cassert头文件中，&lt;code&gt;assert&lt;/code&gt;宏常用于检查“不能发生”的条件。&lt;/p&gt;
&lt;h4&gt;NDEBUG 预处理变量&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;assert&lt;/code&gt;的行为依赖于&lt;code&gt;NDEBUG&lt;/code&gt;预处理变量的状态。如果定义了&lt;code&gt;NDEBUG&lt;/code&gt;，&lt;code&gt;assert&lt;/code&gt;什么都不做，默认情况下没有定义&lt;code&gt;NDEBUG&lt;/code&gt;，&lt;code&gt;assert&lt;/code&gt;将执行运行时检查。我们可以使用一个&lt;code&gt;#define&lt;/code&gt;语句定义&lt;code&gt;NDEBUG&lt;/code&gt;，从而关闭调试状态。同时，很多编译器都提供了一个命令行选项使我们可以定义预处理变量：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ CC -D NDEBUG main.C &lt;span class="c1"&gt;#use /D with the Mocrosoft compiler.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;除了使用&lt;code&gt;assert&lt;/code&gt;外，也可以使用&lt;code&gt;NDEBUG&lt;/code&gt;编写自己的条件调试代码。如果&lt;code&gt;NDEBUG&lt;/code&gt;未定义，将执行&lt;code&gt;#ifndef&lt;/code&gt;和&lt;code&gt;#endif&lt;/code&gt;之间的代码；如果定义了&lt;code&gt;NDEBUG&lt;/code&gt;，这些代码将被忽略掉。&lt;/p&gt;
&lt;p&gt;编译器为每个函数都定义了&lt;code&gt;__func__&lt;/code&gt;，它是一个&lt;code&gt;const char&lt;/code&gt;局部静态数组，用于存放函数的名字，除了 C++ 编译器定义的&lt;code&gt;__func__&lt;/code&gt;之外，预处理器还定义了另外4个对于程序调试很有用的名字：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;__FILE__&lt;/code&gt; 存放文件名的字符串字面值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__LINE__&lt;/code&gt; 存放当前行号的整型字面值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__TIME__&lt;/code&gt; 存放文件编译时间的字符串字面值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__DATE__&lt;/code&gt; 存放文件编译日期的字符串字面值&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;函数匹配&lt;/h2&gt;
&lt;p&gt;候选函数：函数匹配的第一步是选定本次调用对应的重载函数集。&lt;/p&gt;
&lt;p&gt;可行函数：形参数量与本次提供的实参数量相等（默认形参可以少于）；每个实参的类型与对应的形参相同，或者可以转换成形参的类型。&lt;/p&gt;
&lt;p&gt;寻找最佳匹配（如果有的话）：该函数每个实参的匹配都不劣于其他可行函数需要的匹配；至少有一个实参的匹配优于其他可行函数提供的匹配。&lt;/p&gt;
&lt;p&gt;如果没找到可行函数：编译器报告无匹配函数的错误；如果最佳匹配不唯一，编译器报告二义性错误。&lt;/p&gt;
&lt;h2&gt;函数指针&lt;/h2&gt;
&lt;p&gt;要声明一个函数指针，只需要用指针替换函数名：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;bool (*pf)(const string &amp;amp;, const string &amp;amp;); //未初始化，pf 两端括号必不可少
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当把函数名作为一个值使用时，该函数自动转换为指针，也就是说取地址符是可选的。同样，我们可以直接用函数指针调用函数，解引用符也是可选的。&lt;/p&gt;
&lt;p&gt;不同类型的函数指针之前不存在转换规则。&lt;/p&gt;
&lt;p&gt;函数指针没有指向任何一个函数：将函数指针赋为0或者 &lt;code&gt;nullptr&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;和数组类似，虽然不能定义函数类型的形参，但是可以定义指向函数的指针。此时，形参看起来是函数，实际上被当成指针使用：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//形参是函数类型，会自动转化为指向函数的指针
void test(bool pf(const string &amp;amp;, const string &amp;amp;));
//等价的定义
void test(bool (*pf)(const string &amp;amp;, const string &amp;amp;));
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果函数返回指向函数的指针，那么必须显示的将返回类型指定为指针。&lt;/p&gt;</content><category term="C++"></category></entry><entry><title>C++ Primer 第五章 语句</title><link href="https://xutree.github.io/pages/2018/10/09/C++_Primer_Chapter_5/" rel="alternate"></link><published>2018-10-09T12:06:33+08:00</published><updated>2018-10-09T12:06:33+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-09:/pages/2018/10/09/C++_Primer_Chapter_5/</id><summary type="html">&lt;h2&gt;空语句&lt;/h2&gt;
&lt;p&gt;使用空语句时应该加上注释，从而令读这段代码的知道该语句是有意省略的。&lt;/p&gt;
&lt;h2&gt;悬垂 else&lt;/h2&gt;
&lt;p&gt;C++ 规定&lt;code&gt;else&lt;/code&gt;与离它最近的尚未匹配的&lt;code&gt;if&lt;/code&gt;匹配。&lt;/p&gt;
&lt;h2&gt;switch 语句&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;switch&lt;/code&gt;语句中的&lt;code&gt;case&lt;/code&gt;标签必须是&lt;strong&gt;整型常量表达式&lt;/strong&gt;或者&lt;strong&gt;可以转换成整型常量表达式的类型&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果某个&lt;code&gt;case&lt;/code&gt;标签匹配成功，将从该标签处开始往后顺序执行所有&lt;code&gt;case&lt;/code&gt;分支，除非程序显示的中断了这一过程，否则直到&lt;code&gt;switch&lt;/code&gt;结尾处才停下来。在大多说情况下，在下一个&lt;code&gt;case&lt;/code&gt;标签之前应该有一条&lt;code&gt;break&lt;/code&gt;语句用于中断。&lt;/p&gt;
&lt;p&gt;标签不应该孤零零的出现，它后面必须跟上一条语句或者另一个&lt;code&gt;case&lt;/code&gt;标签。如果&lt;code&gt;switch&lt;/code&gt;结构以一个空的&lt;code&gt;default&lt;/code&gt;标签作为结束，则该&lt;code&gt;default&lt;/code&gt;标签后面必须跟上一条空语句或一个空块。&lt;/p&gt;
&lt;p&gt;不允许跨过变量的初始化语句直接跳转到该变量作用域内的另一个位置。&lt;/p&gt;
&lt;h2&gt;范围 …&lt;/h2&gt;</summary><content type="html">&lt;h2&gt;空语句&lt;/h2&gt;
&lt;p&gt;使用空语句时应该加上注释，从而令读这段代码的知道该语句是有意省略的。&lt;/p&gt;
&lt;h2&gt;悬垂 else&lt;/h2&gt;
&lt;p&gt;C++ 规定&lt;code&gt;else&lt;/code&gt;与离它最近的尚未匹配的&lt;code&gt;if&lt;/code&gt;匹配。&lt;/p&gt;
&lt;h2&gt;switch 语句&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;switch&lt;/code&gt;语句中的&lt;code&gt;case&lt;/code&gt;标签必须是&lt;strong&gt;整型常量表达式&lt;/strong&gt;或者&lt;strong&gt;可以转换成整型常量表达式的类型&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果某个&lt;code&gt;case&lt;/code&gt;标签匹配成功，将从该标签处开始往后顺序执行所有&lt;code&gt;case&lt;/code&gt;分支，除非程序显示的中断了这一过程，否则直到&lt;code&gt;switch&lt;/code&gt;结尾处才停下来。在大多说情况下，在下一个&lt;code&gt;case&lt;/code&gt;标签之前应该有一条&lt;code&gt;break&lt;/code&gt;语句用于中断。&lt;/p&gt;
&lt;p&gt;标签不应该孤零零的出现，它后面必须跟上一条语句或者另一个&lt;code&gt;case&lt;/code&gt;标签。如果&lt;code&gt;switch&lt;/code&gt;结构以一个空的&lt;code&gt;default&lt;/code&gt;标签作为结束，则该&lt;code&gt;default&lt;/code&gt;标签后面必须跟上一条空语句或一个空块。&lt;/p&gt;
&lt;p&gt;不允许跨过变量的初始化语句直接跳转到该变量作用域内的另一个位置。&lt;/p&gt;
&lt;h2&gt;范围 for&lt;/h2&gt;
&lt;p&gt;在范围&lt;code&gt;for&lt;/code&gt;语句中，预存了&lt;code&gt;end()&lt;/code&gt;的值，一旦程序中添加（删除）元素，&lt;code&gt;end&lt;/code&gt;函数的值就可能变得无效，所以不能通过范围&lt;code&gt;for&lt;/code&gt;语句增加或删除容器的元素。&lt;/p&gt;
&lt;h2&gt;do while 语句&lt;/h2&gt;
&lt;p&gt;应该在括号包围起来的条件后面用一个分号表示语句结束。&lt;/p&gt;
&lt;h2&gt;跳转语句&lt;/h2&gt;
&lt;h3&gt;break 语句&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;break&lt;/code&gt;语句负责终止离它最近的&lt;code&gt;while&lt;/code&gt;、&lt;code&gt;do while&lt;/code&gt;、&lt;code&gt;for&lt;/code&gt;或&lt;code&gt;switch&lt;/code&gt;语句，并从这些语句之后的第一条语句开始继续执行。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;break&lt;/code&gt;语句只能出现在迭代语句或者&lt;code&gt;switch&lt;/code&gt;语句内部（包括嵌套在此类循环里的语句或块的内部）。&lt;code&gt;break&lt;/code&gt;语句的作用范围仅限于最近的循环或者&lt;code&gt;switch&lt;/code&gt;。&lt;/p&gt;
&lt;h3&gt;continue 语句&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;continu&lt;/code&gt;e语句终止最近的循环中的当前迭代并立即开始下一次迭代。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;continue&lt;/code&gt;语句只能出现在&lt;code&gt;for&lt;/code&gt;、&lt;code&gt;while&lt;/code&gt;和&lt;code&gt;do while&lt;/code&gt;的循环的内部，或者嵌套在此类循环里的语句或块的内部。&lt;/p&gt;
&lt;p&gt;和&lt;code&gt;break&lt;/code&gt;语句类似的是，出现在嵌套循环中的&lt;code&gt;continue&lt;/code&gt;语句也仅作用于离它最近的循环。&lt;/p&gt;
&lt;p&gt;和&lt;code&gt;break&lt;/code&gt;语句不同的是，只有当&lt;code&gt;switch&lt;/code&gt;语句嵌套在迭代语句内部时，才能在&lt;code&gt;switch&lt;/code&gt;里使用&lt;code&gt;continue&lt;/code&gt;。&lt;/p&gt;
&lt;h3&gt;goto 语句&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;goto&lt;/code&gt;语句的作用是从&lt;code&gt;goto&lt;/code&gt;语句无条件跳转到同一函数内的另一条语句。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;goto&lt;/code&gt;语句和控制权转向的那条带标签的语句必须位于同一函数之内。&lt;/p&gt;
&lt;h2&gt;异常处理&lt;/h2&gt;
&lt;h3&gt;throw 表达式&lt;/h3&gt;
&lt;p&gt;异常检测部分使用&lt;code&gt;throw&lt;/code&gt;表达式来表示它遇到了无法处理的问题。我们说&lt;code&gt;throw&lt;/code&gt;引发了异常，例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;throw runtime_error(&amp;quot;Data must refer to same ISBN&amp;quot;);
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;try 语句块&lt;/h3&gt;
&lt;p&gt;异常处理部分使用&lt;code&gt;try&lt;/code&gt;语句处理异常。&lt;code&gt;try&lt;/code&gt;语句块以关键字&lt;code&gt;try&lt;/code&gt;开始，并以一个或多个&lt;code&gt;catch&lt;/code&gt;字句结束。&lt;code&gt;try&lt;/code&gt;语句块中代码抛出的异常通常会被某个catch字句处理，这些字句称为异常处理代码。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;try{
    program-statements
} catch (exception-declaration) {
    handler-statements
} catch (exception-declaration) {
    handler-statements
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;跟在&lt;code&gt;try&lt;/code&gt;块之后的是一个或多个&lt;code&gt;catch&lt;/code&gt;子句。&lt;code&gt;catch&lt;/code&gt;子句包括三个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关键字&lt;code&gt;catch&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;括号内一个（可能未命名的）对象的声明（称作异常声明）&lt;/li&gt;
&lt;li&gt;一个块&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;try&lt;/code&gt;语句块中 program-statements 组成程序的正常逻辑，像其他任何块一样，可以有包含声明在内的任意 C++ 语句。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;try&lt;/code&gt;语句块内声明的变量在块外部无法访问，特别是在&lt;code&gt;catch子&lt;/code&gt;句内也无法访问。&lt;/p&gt;
&lt;p&gt;函数在寻找代码处理的过程中退出，如果最终没能找到任何匹配的&lt;code&gt;catch&lt;/code&gt;子句，程序转到名为&lt;code&gt;terminate&lt;/code&gt;的标准库函数。该函数的行为与系统有关，一般情况下，执行该函数将导致程序非正常退出。&lt;/p&gt;
&lt;h3&gt;标准异常&lt;/h3&gt;
&lt;p&gt;C++ 标准库定义了一组类，用于报告标准库函数遇到的问题，这些异常类也可以在用户别写的程序中使用，它们分别定义在4个头文件中：&lt;/p&gt;
&lt;h4&gt;exception 头文件&lt;/h4&gt;
&lt;p&gt;定义了最通用的异常类&lt;code&gt;exception&lt;/code&gt;。它只报告异常的发生，不提供任何异常信息&lt;/p&gt;
&lt;h4&gt;stdexcept 头文件定义了几种常见的异常类&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;异常类&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;exception&lt;/td&gt;
&lt;td&gt;最常见的问题&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;runtime_error&lt;/td&gt;
&lt;td&gt;只有在运行时才能检测出的问题&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;range_error&lt;/td&gt;
&lt;td&gt;运行时错误：生成的结果超出了有意义的值域范围&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;overflow_error&lt;/td&gt;
&lt;td&gt;运行时错误：计算上溢&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;underflow_error&lt;/td&gt;
&lt;td&gt;运行时错误：计算下溢&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;logic_error&lt;/td&gt;
&lt;td&gt;程序逻辑错误&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;domain_error&lt;/td&gt;
&lt;td&gt;逻辑错误：参数对应的结果值不存在&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;invalid_argument&lt;/td&gt;
&lt;td&gt;逻辑错误：无效参数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;length_error&lt;/td&gt;
&lt;td&gt;逻辑错误：试图创建一个超出该类型最大长度的对象&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;out_of_range&lt;/td&gt;
&lt;td&gt;逻辑错误：使用一个超出有效范围的值&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4&gt;new 头文件&lt;/h4&gt;
&lt;p&gt;定义了&lt;code&gt;bad_alloc&lt;/code&gt;异常类型&lt;/p&gt;
&lt;h4&gt;type_info 头文件&lt;/h4&gt;
&lt;p&gt;定义了&lt;code&gt;bad_cast&lt;/code&gt;异常类型&lt;/p&gt;
&lt;p&gt;标准异常库只定义了几种运算，包括创建和拷贝异常类型的对象，以及为异常类型的对象赋值。我们只能以默认初始化的方式初始化&lt;code&gt;exception&lt;/code&gt;、&lt;code&gt;bad_alloc&lt;/code&gt;和&lt;code&gt;bad_cas&lt;/code&gt;t对象，不允许为这些对象提供初始值。&lt;/p&gt;
&lt;p&gt;其他异常类型的行为则刚好相反。应该使用&lt;code&gt;string&lt;/code&gt;对象或者 C 风格字符串初始化这些类型的对象，但是不允许使用默认初始化的方式。当创建此类对象时，必须提供初始值，该初始值含有错误相关的信息。&lt;/p&gt;
&lt;p&gt;异常类型只定义了一个名为&lt;code&gt;what&lt;/code&gt;的成员函数，该函数没有任何参数，返回值是一个指向 C 风格字符串的&lt;code&gt;const char *&lt;/code&gt;。该字符串的目的是提供关于异常的一些文本信息。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;what&lt;/code&gt;函数返回的 C 风格字符串的内容与异常对象的类型有关。如果异常类型只有一个字符串初始值，则&lt;code&gt;what&lt;/code&gt;返回该字符串。对于其他无初始值的异常类型来说，&lt;code&gt;what&lt;/code&gt;返回的内容由编译器决定。&lt;/p&gt;</content><category term="C++"></category></entry><entry><title>C++ Primer 第四章 表达式</title><link href="https://xutree.github.io/pages/2018/10/07/C++_Primer_Chapter_4/" rel="alternate"></link><published>2018-10-07T10:44:38+08:00</published><updated>2018-10-07T11:08:56+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-07:/pages/2018/10/07/C++_Primer_Chapter_4/</id><summary type="html">&lt;p&gt;重载运算符时，其包括运算对象的类型和返回值的类型，都是由该运算符定义的；但是运算对象的个数、运算符的优先级和结合律都是无法改变的。&lt;/p&gt;
&lt;h2&gt;左值和右值&lt;/h2&gt;
&lt;p&gt;当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。&lt;/p&gt;
&lt;p&gt;一个重要的原则：在需要右值的地方可以用左值来代替，但是不能把右值当成左值（也就是位置）使用。当一个左值被当成右值使用时，实际使用的是它的内容（值）。&lt;/p&gt;
&lt;p&gt;要用到左值的运算符：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;赋值运算符需要一个左值作为其左侧运算对象，得到的结果也仍然是一个左值&lt;/li&gt;
&lt;li&gt;取地址符作用于一个左值运算对象，返回一个指向该运算对象的指针，这个指针是一个右值&lt;/li&gt;
&lt;li&gt;内置解引用运算符、下标运算符、迭代器解引用运算符、&lt;code&gt;string&lt;/code&gt;和&lt;code&gt;vector&lt;/code&gt;的下标运算符的求值结果都是左值&lt;/li&gt;
&lt;li&gt;内置类型和迭代器的递增递减运算符作用于左值运算对象&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;求值顺序&lt;/h2&gt;
&lt;p&gt;优先级规定了运算对象的组合方式，但是没有说明运算对象按照什么顺序求值。对于那些没有指定执行顺序的运算符来说，如果表达式指向并修改了同一个对象，将会引发错误并产生未定义的行为。&lt;/p&gt;
&lt;p&gt;例如，下面的输出表达式是未定义的，我们无法推测编译器是先求 ++i 还是先输出：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int i = 0;
cout &amp;lt;&amp;lt; i …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;重载运算符时，其包括运算对象的类型和返回值的类型，都是由该运算符定义的；但是运算对象的个数、运算符的优先级和结合律都是无法改变的。&lt;/p&gt;
&lt;h2&gt;左值和右值&lt;/h2&gt;
&lt;p&gt;当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。&lt;/p&gt;
&lt;p&gt;一个重要的原则：在需要右值的地方可以用左值来代替，但是不能把右值当成左值（也就是位置）使用。当一个左值被当成右值使用时，实际使用的是它的内容（值）。&lt;/p&gt;
&lt;p&gt;要用到左值的运算符：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;赋值运算符需要一个左值作为其左侧运算对象，得到的结果也仍然是一个左值&lt;/li&gt;
&lt;li&gt;取地址符作用于一个左值运算对象，返回一个指向该运算对象的指针，这个指针是一个右值&lt;/li&gt;
&lt;li&gt;内置解引用运算符、下标运算符、迭代器解引用运算符、&lt;code&gt;string&lt;/code&gt;和&lt;code&gt;vector&lt;/code&gt;的下标运算符的求值结果都是左值&lt;/li&gt;
&lt;li&gt;内置类型和迭代器的递增递减运算符作用于左值运算对象&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;求值顺序&lt;/h2&gt;
&lt;p&gt;优先级规定了运算对象的组合方式，但是没有说明运算对象按照什么顺序求值。对于那些没有指定执行顺序的运算符来说，如果表达式指向并修改了同一个对象，将会引发错误并产生未定义的行为。&lt;/p&gt;
&lt;p&gt;例如，下面的输出表达式是未定义的，我们无法推测编译器是先求 ++i 还是先输出：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int i = 0;
cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; ++i &amp;lt;&amp;lt; endl;    //未定义的
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;有4种运算符明确规定了运算对象的求值顺序。&amp;amp;&amp;amp;、||、?:、和逗号（，）运算符。&lt;/p&gt;
&lt;p&gt;对于f()+g()*h()+j()的表达式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优先级规定，g() 的返回值和 h() 的返回值相乘&lt;/li&gt;
&lt;li&gt;结合律规定，f() 的返回值先与 g() 和 h() 的乘积相加，所得结果再与 j() 的返回值相加&lt;/li&gt;
&lt;li&gt;对于这些函数的调用顺序没有明确规定&lt;/li&gt;
&lt;li&gt;如果 f、g、h 和 j 是无关函数，它们既不会改变同一对象的状态也不执行 IO 任务，那么函数的调用顺序不受限制。反之，如果其中某几个函数影响同一对象，则它是一条错误的表达式，将产生未定义的行为&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;算术运算符&lt;/h2&gt;
&lt;p&gt;+(正号)、-(负号)、*(乘)、/(除),%(求余)，+(加)、-(减)&lt;/p&gt;
&lt;p&gt;算术运算符的运算对象和求值结果都是右值。&lt;/p&gt;
&lt;p&gt;一元正号负号运算符对运算对象作用后，返回一个（提升后的）副本：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int i = 1024;
int k = -i;
bool b = true;
bool b2 = -b;   //b2 是 true
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;对大多数运算符来说，布尔类型的运算对象将被提升为&lt;code&gt;int&lt;/code&gt;类型。如上，b 参与运算时被提升成整数值1，对它求负-1，转换为布尔值将其作为 b2 的初始值。&lt;/p&gt;
&lt;p&gt;在除法运算中，如果两个运算对象的符号相同则商为正，否则商为负。C++ 语言的早期版本允许结果为负值的商向上或向下取整，C++11 新标准则规定商一律向0取整（即直接切除小数部分）。&lt;/p&gt;
&lt;h2&gt;逻辑和关系运算符&lt;/h2&gt;
&lt;p&gt;运算对象和求值结果都是右值；短路求值；进行比较运算符时，除非比较的对象是布尔类型，否则不要使用布尔字面值&lt;code&gt;true&lt;/code&gt;和&lt;code&gt;false&lt;/code&gt;作为运算对象&lt;/p&gt;
&lt;h2&gt;赋值运算符&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;赋值运算符的左侧运算对象必须是一个可修改的左值&lt;/li&gt;
&lt;li&gt;赋值运算的结果是它的左侧运算对象，并且是一个左值，结果的类型就是左侧运算对象的类型&lt;/li&gt;
&lt;li&gt;如果赋值运算符的左右两个运算对象类型不同，则右侧运算对象将转换成左侧运算对象的类型&lt;/li&gt;
&lt;li&gt;赋值运算满足右结合律：ival = jval = 0；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;++ 和 -- 运算符&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;前置版本将对象本身作为左值返回，后置版本则将对象原始值的副本作为右值返回&lt;/li&gt;
&lt;li&gt;建议：除非必须，否则不用递增递减算符的后置版本&lt;/li&gt;
&lt;li&gt;后置递增运算符的优先级高于解引用运算符，因此 *pbeg++ 等价于 *(pbeg++)，pbeg++ 把 pbeg 的值加1，然后返回 pbeg 的初始值的副本作为其求值结果&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;成员访问运算符&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;由于解引用运算符的优先级低于逗号运算符，因此要对解引用运算符加括号&lt;/li&gt;
&lt;li&gt;箭头运算符作用于一个指针类型的运算对象，结果是一个左值&lt;/li&gt;
&lt;li&gt;点运算符分成两种情况：如果成员所属的对象是左值，那么结果就是左值；反之，如果成员所属的对象是右值，那么结果是右值&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;条件运算符&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;当条件运算符的两个表达式都是左值或者能转换成同一种左值类型时，运算的结果是左值；否则运算的结果是右值&lt;/li&gt;
&lt;li&gt;条件运算符满足右结合律&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;位运算符&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;位运算符作用于整数类型的运算对象&lt;/li&gt;
&lt;li&gt;关于符号位如何处理没有明确的规定，所以强烈建议仅将位运算符作用于处理无符号类型&lt;/li&gt;
&lt;li&gt;移位运算符&lt;ul&gt;
&lt;li&gt;首先令左侧运算对象的内容按照右侧运算对象的要求移动指定位数，然后将经过移动的（可能还进行了提升）左侧运算对象的拷贝作为求值结果。其中，右侧的运算对象一定不能为负，而且值必须严格小于结果的位数，否则就会产生未定义的行为。移出边界之外的位就被舍弃掉了&lt;/li&gt;
&lt;li&gt;移位运算符满足左结合律&lt;/li&gt;
&lt;li&gt;移位运算符的优先级比算术运算符低，比关系运算符、赋值运算符和条件运算符高&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;sizeof运算符&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;sizeof&lt;/code&gt;运算符返回一条表达式或一个类型名字所占的字节数。&lt;code&gt;sizeof&lt;/code&gt;运算符满足右结合律，其所得的值是一个&lt;code&gt;size_t&lt;/code&gt;类型的常量表达式&lt;/p&gt;
&lt;p&gt;两种形式&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sizeof (type)
sizeof expr
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;sizeof&lt;/code&gt;并不直接计算其运算对象的值。&lt;/p&gt;
&lt;p&gt;对于&lt;code&gt;sizeof *p&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因为&lt;code&gt;sizeof&lt;/code&gt;满足右结合律并且与 * 的运算符的优先级一样，所以表达式按照从右到左的顺序结合，等价于：&lt;code&gt;sizeof (*p)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;其次，因为&lt;code&gt;sizeof&lt;/code&gt;不实际求运算对象的值，所以即使 p 是一个无效（即未初始化）的指针也不会有什么影响&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;sizeof&lt;/code&gt;的运算对象中解引用一个无效的指针仍然是一种安全的行为，因为指针实际上并没有被真正使用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sizeof&lt;/code&gt;运算符的结果部分地依赖于其作用的类型：&lt;ul&gt;
&lt;li&gt;对&lt;code&gt;char&lt;/code&gt;或者类型为&lt;code&gt;char&lt;/code&gt;的表达式执行&lt;code&gt;sizeof&lt;/code&gt;运算，结果得1&lt;/li&gt;
&lt;li&gt;对引用类型执行&lt;code&gt;sizeof&lt;/code&gt;运算得到被引用对象所占空间的大小&lt;/li&gt;
&lt;li&gt;对指针执行&lt;code&gt;sizeof&lt;/code&gt;运算得到指针本身所占空间的大小&lt;/li&gt;
&lt;li&gt;对解引用指针执行&lt;code&gt;sizeof&lt;/code&gt;运算得到指针指向的对象所占空间的大小，指针不需有效&lt;/li&gt;
&lt;li&gt;对数值执行&lt;code&gt;sizeof&lt;/code&gt;运算符得到整个数组所占空间的大小。&lt;code&gt;sizeof&lt;/code&gt;运算不会把数组转换成指针来处理&lt;/li&gt;
&lt;li&gt;对&lt;code&gt;string&lt;/code&gt;对象或者&lt;code&gt;vector&lt;/code&gt;对象执行&lt;code&gt;sizeof&lt;/code&gt;运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。即只取决于里面存放的数据类型，与元素的个数无关，是个编译器相关的值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;逗号运算符&lt;/h2&gt;
&lt;p&gt;首先对左侧的表达式求值，然后将求值结果丢弃掉。逗号表达式真正的结果是右侧表达式的值。如果右侧运算对象是左值，那么最终的求值结果也是左值。&lt;/p&gt;
&lt;h2&gt;类型转换&lt;/h2&gt;
&lt;h3&gt;何时发生隐式类型转换&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;在大多数表达式中，比&lt;code&gt;int&lt;/code&gt;类型小的整数值首先提升为较大的整数类型&lt;/li&gt;
&lt;li&gt;在条件中，非布尔值转换成布尔类型&lt;/li&gt;
&lt;li&gt;初始化过程中，初始值转换成变量的类型；在赋值语句中，右侧运算对象装换成左侧运算对象的类型&lt;/li&gt;
&lt;li&gt;如果算术运算或关系运算的运算对象有多种类型，需要转换成同一种类型&lt;/li&gt;
&lt;li&gt;函数调用时也会发生类型转换&lt;/li&gt;
&lt;li&gt;数组转换成指针（当数组被用作&lt;code&gt;decltype&lt;/code&gt;关键字的参数，或者作为取地址符、&lt;code&gt;sizeof&lt;/code&gt;即&lt;code&gt;typeid&lt;/code&gt;等运算符的运算对象时，上述转换不会发生，如果用一个引用来初始化数组，上述转换也不会发生）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;指针的转换&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;常量整数值0或者字面值&lt;code&gt;nullptr&lt;/code&gt;能转换成任意指针类型&lt;/li&gt;
&lt;li&gt;指向任意非常量的指针能转换成&lt;code&gt;void *&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;指向任意对象的指针能转换成&lt;code&gt;const void *&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;转换成常量：允许将指向非常量类型的指针转换成指向相应的常量类型的指针，对于引用也是这样。相反的转换并不存在，因为它试图删掉底层&lt;code&gt;const&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;类类型定义的转换&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;类类型能定义由编译器自动执行的转换，不过编译器每次只能执行一种类类型的转换，如果同时提出多个转换请求，这些请求将被拒绝&lt;/li&gt;
&lt;li&gt;之前遇到过的类类型转换&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;string s, t = &amp;quot;a value&amp;quot;;    //字符串字面值转换成 string 类型
wile( cin &amp;gt;&amp;gt; s)     //while 的条件部分把 cin 转换成布尔值
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;显示转换&lt;/h3&gt;
&lt;p&gt;虽然有时不得不使用强制类型转换，但这种方法本质上是非常危险的。&lt;/p&gt;
&lt;h3&gt;命名的强制类型转换&lt;/h3&gt;
&lt;p&gt;一个命名的强制类型转换具有如下格式：&lt;code&gt;cast-name&amp;lt;type&amp;gt;(expression);&lt;/code&gt;type 是转换的目标类型。如果 type 是引用类型，则结果是左值；expression 是要转换的值；cast-name 是&lt;code&gt;static_cast&lt;/code&gt;、&lt;code&gt;dynamic_cast&lt;/code&gt;、&lt;code&gt;const_cast&lt;/code&gt;和&lt;code&gt;reinterpret_cast&lt;/code&gt;中的一种。&lt;code&gt;dynamic_cast&lt;/code&gt;支持运行时类型识别。&lt;/p&gt;
&lt;h3&gt;static_cast&lt;/h3&gt;
&lt;p&gt;任何具有明确定义的类型转换，只要不包含底层&lt;code&gt;const&lt;/code&gt;，都可以使用&lt;code&gt;static_cast&lt;/code&gt;。当需要把一个较大的算术类型赋给较小的类型时，&lt;code&gt;static_cast&lt;/code&gt;非常有用。此时，强制类型转换告诉程序的读者和编译器：我们知道并且不在乎潜在的精度损失。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;static_cast&lt;/code&gt;对于编译器无法自动执行的类型转换也非常有用。例如，我们可以使用它找回&lt;code&gt;void *&lt;/code&gt;指针中的值:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;void *p = &amp;amp;d;
double *dp = static_cast&amp;lt;double *&amp;gt;(p);
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;const_cast&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;const_cast&lt;/code&gt;只能改变运算对象的底层&lt;code&gt;const&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;const char *pc;
char *p = const_cast&amp;lt;char*&amp;gt;(pc);//正确，但通过p写值是未定义的行为
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;只有&lt;code&gt;const_cast&lt;/code&gt;能改变表达式的常量属性。&lt;/p&gt;
&lt;h3&gt;reinterpret_cast&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;einterpret_cast&lt;/code&gt;通常为运算对象的位模式提供较低层次上的重新解释。&lt;/p&gt;
&lt;p&gt;假如有以下转换：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int *ip;
char *pc = reinterpret_cast&amp;lt;char*&amp;gt;(ip);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们必须牢记 pc 所指的真实对象是一个 int 而非字符，如果把 pc 当成普通的字符指针使用就可能在运行时发生错误。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;string str(pc);     //可能导致异常的运行时行为
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;reinterpret_cast&lt;/code&gt;本质上依赖于机器。要想安全地使用&lt;code&gt;reinterpret_cast&lt;/code&gt;必须对涉及的类型和编译器实现转换的过程都非常了解。&lt;/p&gt;
&lt;p&gt;强制类型转换干扰了正常的类型检查，因此强烈建议避免使用强制类型转换。&lt;/p&gt;
&lt;h3&gt;旧式的强制类型转换&lt;/h3&gt;
&lt;p&gt;在早期版本的 C++ 语言中，显示地进行强制类型转换包含两种形式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;type (expr);    //函数形式的强制类型转换
(type) expr;    //C 语言风格的强制类型转换
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;根据所设计的类型不同，旧式的强制类型转换分别具有与&lt;code&gt;const_cast&lt;/code&gt;，&lt;code&gt;static_cast&lt;/code&gt;或&lt;code&gt;reinterpret_cast&lt;/code&gt;相似的行为。当我们在某处执行旧式的强制类型转换时，如果换成&lt;code&gt;const_cast&lt;/code&gt;和&lt;code&gt;static_cast&lt;/code&gt;也合法，则其行为与相应的命名转换一致。如果替换后不合法，则旧式强制类型转换执行与&lt;code&gt;reinterpret_cast&lt;/code&gt;类似的功能。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;char *pc = (char*) ip;  //ip是指向整数的指针
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上述代码的效果与&lt;code&gt;reinterpret_cast&lt;/code&gt;一样。&lt;/p&gt;</content><category term="C++"></category></entry><entry><title>C++ Primer 第三章 字符串、向量和数组</title><link href="https://xutree.github.io/pages/2018/10/06/C++_Primer_Chapter_3/" rel="alternate"></link><published>2018-10-06T22:31:16+08:00</published><updated>2018-10-07T10:48:54+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-06:/pages/2018/10/06/C++_Primer_Chapter_3/</id><summary type="html">&lt;p&gt;&lt;code&gt;string&lt;/code&gt;表示可变长的字符数组。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vector&lt;/code&gt;存放的是某种给定类型对象的可变长序列。&lt;/p&gt;
&lt;p&gt;数组和其他内置类型一样，实现与硬件密切相关，在灵活性上稍显不足。&lt;/p&gt;
&lt;p&gt;命名空间&lt;code&gt;using&lt;/code&gt;声明：&lt;code&gt;using namespace::name;&lt;/code&gt;例如：&lt;code&gt;using std::cin;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;头文件不应包含&lt;code&gt;using&lt;/code&gt;声明，防止名字冲突。&lt;/p&gt;
&lt;h2&gt;标准库类型 string&lt;/h2&gt;
&lt;h3&gt;头文件和声明&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="n"&gt;using&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kr"&gt;string&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;定义和初始化&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;string s1;  //默认初始化，空字符串
string s2 = s1; //s2是s1的副本，等价于 s2(s1)
string s3 = &amp;quot;hiya&amp;quot;; //s3是字符串字面值的副本，等价于s3(&amp;quot;hiya&amp;quot;)
string s4(10 …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;&lt;code&gt;string&lt;/code&gt;表示可变长的字符数组。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vector&lt;/code&gt;存放的是某种给定类型对象的可变长序列。&lt;/p&gt;
&lt;p&gt;数组和其他内置类型一样，实现与硬件密切相关，在灵活性上稍显不足。&lt;/p&gt;
&lt;p&gt;命名空间&lt;code&gt;using&lt;/code&gt;声明：&lt;code&gt;using namespace::name;&lt;/code&gt;例如：&lt;code&gt;using std::cin;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;头文件不应包含&lt;code&gt;using&lt;/code&gt;声明，防止名字冲突。&lt;/p&gt;
&lt;h2&gt;标准库类型 string&lt;/h2&gt;
&lt;h3&gt;头文件和声明&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="n"&gt;using&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kr"&gt;string&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;定义和初始化&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;string s1;  //默认初始化，空字符串
string s2 = s1; //s2是s1的副本，等价于 s2(s1)
string s3 = &amp;quot;hiya&amp;quot;; //s3是字符串字面值的副本，等价于s3(&amp;quot;hiya&amp;quot;)
string s4(10, &amp;#39;c&amp;#39;); //s4的内容是cccccccccc
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;string 对象上的操作&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;操作&lt;/th&gt;
&lt;th&gt;意义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;os &amp;lt;&amp;lt; s&lt;/td&gt;
&lt;td&gt;将 s 写到输出流 os 中，返回 os&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;is &amp;gt;&amp;gt; s&lt;/td&gt;
&lt;td&gt;从 is 中读取字符串赋给 s，字符串以空白分隔，返回 is&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;getline(is, s)&lt;/td&gt;
&lt;td&gt;从 is 中读取一行赋给 s，返回 is&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s.empty()&lt;/td&gt;
&lt;td&gt;s 为空返回 true，否则返回 false&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s.size()&lt;/td&gt;
&lt;td&gt;返回 s 中字符的个数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s[n]&lt;/td&gt;
&lt;td&gt;返回 s 中第 n 个字符的引用，位置 n 从0记起&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s1 + s2&lt;/td&gt;
&lt;td&gt;返回连接后的结果&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s1 = s2&lt;/td&gt;
&lt;td&gt;用 s2 的副本代替 s1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s1 == s2&lt;/td&gt;
&lt;td&gt;如果 s1 和 s2 中所含的字符完全一样，则他们相等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s1 != s2&lt;/td&gt;
&lt;td&gt;string 对象的相等性判断对大小写敏感&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;lt;, &amp;lt;=, &amp;gt;, &amp;gt;=&lt;/td&gt;
&lt;td&gt;利用字符在字典里的顺序进行比较，大小写敏感&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;读取未知数量的 string 对象&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int main()
{
    string word;
    while (cin &amp;gt;&amp;gt; word)
        cout &amp;lt;&amp;lt; word &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;直到遇到结束标记或者非法输入才会停止&lt;/p&gt;
&lt;h3&gt;使用 getline 读取一整行&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int main()
{
    string line;
    while (getline(cin,line))
        cout &amp;lt;&amp;lt; line &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;getline&lt;/code&gt;函数的参数是一个输入流和一个&lt;code&gt;string&lt;/code&gt;对象，&lt;code&gt;getline&lt;/code&gt;从给定的输入流中读入内容，直到遇到换行符为止（注意换行符也被读进来了），然后把所读的内容存入&lt;code&gt;string&lt;/code&gt;对象中（注意不存换行符）。如果输入一开始就是换行符，那么所得的结果是个空&lt;code&gt;string&lt;/code&gt;。&lt;/p&gt;
&lt;h3&gt;string::size_type 类型&lt;/h3&gt;
&lt;p&gt;是一个无符号类型的值。如果一个表达式中已经有&lt;code&gt;size&lt;/code&gt;函数就不要再使用&lt;code&gt;int&lt;/code&gt;了，这样可以避免混用&lt;code&gt;int&lt;/code&gt;和&lt;code&gt;unsigned&lt;/code&gt;可能带来的问题。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;string&lt;/code&gt;对象可以和字符字符串字面值相加，只要保证 + 号两侧的运算对象至少有一个&lt;code&gt;string&lt;/code&gt;对象即可。&lt;/p&gt;
&lt;p&gt;由于某些历史原因，也为了和 C 兼容，所以 C++ 中的字符串字面值并不是标准库&lt;code&gt;string&lt;/code&gt;类型。&lt;/p&gt;
&lt;h3&gt;处理 string 对象里的字符&lt;/h3&gt;
&lt;p&gt;包含在&lt;code&gt;cctype&lt;/code&gt;头文件中：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;意义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;isalunm(c)&lt;/td&gt;
&lt;td&gt;当 c 是字母或数字时为真&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;isalpha(c)&lt;/td&gt;
&lt;td&gt;当 c 是字母时为真&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;iscntrl(c)&lt;/td&gt;
&lt;td&gt;当 c 是控制字符时为真&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;isdigit(c)&lt;/td&gt;
&lt;td&gt;当 c 是数字时为真&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;isgraph(c)&lt;/td&gt;
&lt;td&gt;当 c 不是空格但可打印时为真&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;islower(c)&lt;/td&gt;
&lt;td&gt;当 c 是小写字母时为真&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;isprint(c)&lt;/td&gt;
&lt;td&gt;当 c 是可打印字符时为真（即 c 是空格或 c 具有可视形式）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ispunct(c)&lt;/td&gt;
&lt;td&gt;当 c 是标点符号时为真（即 c 不是控制字符、数字、字母、可打印空白中的一种）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;isspace(c)&lt;/td&gt;
&lt;td&gt;当 c 是空白时为真（即 c 是空格、横向制表符、纵向制表符、回车符、换行符、进纸符中的一种）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;isupper(c)&lt;/td&gt;
&lt;td&gt;当 c 是大写字母时为真&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;isxdigit(c)&lt;/td&gt;
&lt;td&gt;当 c 是十六进制数字时为真&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;tolower(c)&lt;/td&gt;
&lt;td&gt;输出 c 的小写&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;toupper(c)&lt;/td&gt;
&lt;td&gt;输出 c 的大写&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;C++ 标准库除了定义 C++ 语言特有的功能外，也兼容了 C 语言的标准库。C 语言的头文件形如 name.h，C++ 则将这些文件命名为 cname。因此&lt;code&gt;cctype&lt;/code&gt;头文件和&lt;code&gt;ctype.h&lt;/code&gt; 头文件的内容是一样的，只不过从命名规范上来讲更符合 C++ 语言的要求。特别地，在名为 cname 的头文件中定义的名字从属于命名空间&lt;code&gt;std&lt;/code&gt;。&lt;/p&gt;
&lt;h3&gt;范围 for&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;for (declaration: expression)
        statement
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;expression 是一个对象，用于表示一个序列；declaration 负责定义一个变量，该变量将被用于访问序列中的基础元素，每次迭代，declaration 部分的变量会被初始化为 expression 部分的下一个元素值。&lt;/p&gt;
&lt;p&gt;使用范围for输出&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;string str(&amp;quot;some string&amp;quot;);
        for (auto c : str)
cout &amp;lt;&amp;lt; c &amp;lt;&amp;lt; endl;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;使用范围for修改&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;string s(&amp;quot;Hello World!&amp;quot;);
for (auto &amp;amp;c : s)
        c = toupper(c);
cout &amp;lt;&amp;lt; s &amp;lt;&amp;lt; endl;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;下标运算符 [ ]&lt;/h3&gt;
&lt;p&gt;[ ]接收的输入参数是&lt;code&gt;string:size_type&lt;/code&gt;类型的值，这个参数表示要访问的字符的位置，返回值是该位置上字符的引用。&lt;code&gt;string&lt;/code&gt;对象的下标必须大于等于0而小于&lt;code&gt;s.size()&lt;/code&gt;。&lt;/p&gt;
&lt;h2&gt;标准库类型 vector&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;vector&lt;/code&gt;表示对象的集合，其中所有对象的类型都相同，也常被称作容器，是一种类模板&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;vector&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="n"&gt;using&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;编译器根据模板创建类或函数的过程称为实例化，对于类模板，我们通过提供一些额外信息来指定模板到底实例化成什么样的类：在模板名字后面跟一对尖括号，在括号内放上信息&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;vector&amp;lt;int&amp;gt; ivec;
vector&amp;lt;Sales_item&amp;gt; Sales_vec;
vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; file;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在早期版本的 C++ 标准中如果&lt;code&gt;vector&lt;/code&gt;的元素还是&lt;code&gt;vector&lt;/code&gt;（或者其他模板类型），则其定义的形式与现在的 C++11 新标准略有不同。过去，必须在外层&lt;code&gt;vector&lt;/code&gt;对象的右尖括号和其元素类型之间添加一个空格，如应写成&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;初始化&lt;/h3&gt;
&lt;p&gt;默认初始化。&lt;/p&gt;
&lt;p&gt;列表初始化。&lt;/p&gt;
&lt;p&gt;值初始化：通常情况下，可以只提供vector对象容纳的元素数量而略去初始值。此时库会创建一个值初始化的元素初值，并把它赋给容器中的所有元素。这个初值由vector对象中元素的类型决定。内置类型：0；类类型：由类默认初始化。&lt;/p&gt;
&lt;h3&gt;添加元素&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;push_back&lt;/code&gt;：负责把一个值当成&lt;code&gt;vector&lt;/code&gt;对象的尾元素压到&lt;code&gt;vector&lt;/code&gt;对象的尾端&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;vector&amp;lt;int&amp;gt; v2;
for (int i = 0; i != 100; ++i)
        v2.push_back(i);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果循环内部包含有向&lt;code&gt;vector&lt;/code&gt;对象添加元素的语句，则不能使用范围&lt;code&gt;for&lt;/code&gt;循环。&lt;/p&gt;
&lt;h3&gt;其他vector操作&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;v.empty()&lt;/td&gt;
&lt;td&gt;如果 v 不含有任何元素，返回真；否则返回假&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;v.size()&lt;/td&gt;
&lt;td&gt;返回 v 中元素的个数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;v.push_back(t)&lt;/td&gt;
&lt;td&gt;向 v 的尾端添加一个值为 t 的元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;v[n]&lt;/td&gt;
&lt;td&gt;返回 v 中第 n 个位置上元素的引用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;v1 = v2&lt;/td&gt;
&lt;td&gt;用 v2 中的元素拷贝替换 v1 中的元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td a，b，c...&gt;v1 = &lt;/td&gt;
&lt;td&gt;用列表中元素的拷贝替换 v1 中的元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;v1 == v2&lt;/td&gt;
&lt;td&gt;v1 和 v2 相等当且仅当它们的元素数量相同且对应位置的元素值都相同&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;v1 != v2&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;lt;,&amp;lt;=,&amp;gt;,&amp;gt;=&lt;/td&gt;
&lt;td&gt;以字典顺序进行比较&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;vector 的 size_type&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;vector&amp;lt;int&amp;gt;::size_type      //正确
vector::size_type           //错误
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;和&lt;code&gt;string&lt;/code&gt;一样，&lt;code&gt;vector&lt;/code&gt;对象的下标也是从0开始计算，&lt;code&gt;vector&lt;/code&gt;对象（以及&lt;code&gt;string&lt;/code&gt;对象）的下标运算符可用于访问已存在的元素，而不能用于添加元素。&lt;/p&gt;
&lt;h2&gt;迭代器&lt;/h2&gt;
&lt;p&gt;所有标准库容器都可以使用迭代器，但只有少数的几种才同时支持下标运算符。&lt;/p&gt;
&lt;p&gt;严格来讲，&lt;code&gt;string&lt;/code&gt;不属于容器类型，但是&lt;code&gt;string&lt;/code&gt;支持很多与容器类型相似的操作。&lt;code&gt;vector&lt;/code&gt;支持下标运算符，这点和&lt;code&gt;string&lt;/code&gt;一样。&lt;/p&gt;
&lt;p&gt;和指针不一样，获取迭代器不是使用取地址符，有迭代器的类型同时拥有返回迭代器的成员。&lt;code&gt;begin&lt;/code&gt;和&lt;code&gt;end&lt;/code&gt;：&lt;code&gt;auto b = v.begin(), e = v.end();&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;end&lt;/code&gt;成员负责返回指向容器“尾元素的下一位置”的迭代器。常被称作尾后迭代器或尾迭代器。&lt;/p&gt;
&lt;p&gt;如果容器为空，则&lt;code&gt;begin&lt;/code&gt;和&lt;code&gt;end&lt;/code&gt;返回的是同一个迭代器，都是尾后迭代器。&lt;/p&gt;
&lt;h3&gt;标准容器迭代器的运算符&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;符号&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;*iter&lt;/td&gt;
&lt;td&gt;返回迭代器 iter 所指元素的引用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;iter-&amp;gt;mem&lt;/td&gt;
&lt;td&gt;解引用 iter 并获取该元素的名为 mem 的成员，等价于(*iter).mem&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;++iter&lt;/td&gt;
&lt;td&gt;令 iter 指向容器中的下一个元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;--iter&lt;/td&gt;
&lt;td&gt;令 iter 指向容器中的上一个元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;iter1 == iter2&lt;/td&gt;
&lt;td&gt;判断两个迭代器是否相等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;iter1 != iter2&lt;/td&gt;
&lt;td&gt;如果指向同一元素或者他们是同一容器的尾后迭代器&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;因为&lt;code&gt;end&lt;/code&gt;返回的迭代器并不实际指向某个元素，所以不能对其进行递增或解引用操作。C++ 程序员习惯性地使用&lt;code&gt;!=&lt;/code&gt;，其原因和他们更愿意使用迭代器而非下标的原因一样：这种编程风格在标准库提供的所有容器上都有效，因为所有标准库容器都定义了&lt;code&gt;==&lt;/code&gt;和&lt;code&gt;!=&lt;/code&gt;。&lt;/p&gt;
&lt;h3&gt;迭代器类型&lt;/h3&gt;
&lt;p&gt;拥有迭代器的标准库类型使用&lt;code&gt;iterator&lt;/code&gt;和&lt;code&gt;const_iterator&lt;/code&gt;来表示迭代器的类型&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nd"&gt;iterator&lt;/span&gt; &lt;span class="nt"&gt;it&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;   &lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="nt"&gt;it&lt;/span&gt; &lt;span class="nt"&gt;能读写&lt;/span&gt; &lt;span class="nt"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nt"&gt;的元素&lt;/span&gt;
&lt;span class="nt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nd"&gt;iterator&lt;/span&gt; &lt;span class="nt"&gt;it2&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;       &lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="nt"&gt;it2&lt;/span&gt; &lt;span class="nt"&gt;能读写&lt;/span&gt; &lt;span class="nt"&gt;string&lt;/span&gt; &lt;span class="nt"&gt;对象中的元素&lt;/span&gt;
&lt;span class="nt"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="nt"&gt;const_iterator&lt;/span&gt; &lt;span class="nt"&gt;it3&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;  &lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="nt"&gt;it3&lt;/span&gt; &lt;span class="nt"&gt;只能读元素&lt;/span&gt;&lt;span class="err"&gt;，&lt;/span&gt;&lt;span class="nt"&gt;不能写元素&lt;/span&gt;
&lt;span class="nt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nd"&gt;const_iterator&lt;/span&gt; &lt;span class="nt"&gt;it4&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;     &lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="nt"&gt;it4&lt;/span&gt; &lt;span class="nt"&gt;只能读字符&lt;/span&gt;&lt;span class="err"&gt;，&lt;/span&gt;&lt;span class="nt"&gt;不能写字符&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;begin&lt;/code&gt;和&lt;code&gt;end&lt;/code&gt;返回的具体类型由对象是否是常量决定，如果对象是常量，&lt;code&gt;begin&lt;/code&gt;和&lt;code&gt;end&lt;/code&gt;返回&lt;code&gt;const_iterator&lt;/code&gt;；如果对象不是常量，返回&lt;code&gt;iterator&lt;/code&gt;。如果对象只需读操作而无需写操作的话最好使用常量类型迭代器。为了专门得到&lt;code&gt;const_iterator&lt;/code&gt;，C++11 标准引入两个新函数：&lt;code&gt;cbegin&lt;/code&gt;和&lt;code&gt;cend&lt;/code&gt;。任何一种可能改变容器容量的操作，都会是迭代器失效。&lt;/p&gt;
&lt;h3&gt;迭代器运算&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;string&lt;/code&gt;和&lt;code&gt;vector&lt;/code&gt;的迭代器提供了更多额外的运算符：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;iter + n&lt;/code&gt;：迭代器加上一个整数值仍得到一个迭代器，迭代器指示的新位置与原来相比向前移动了若干个元素。结果迭代器或者指示容器内的一个元素，或者指示容器尾元素的下一位置。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;iter - n&lt;/code&gt;：迭代器减去一个整数值仍得一个迭代器，迭代器指示的新位置与原来相比向后移动了若干位置。结果迭代器或者指示容器内的一个元素，或者指示容器尾元素的下一位置。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;iter1 - iter2&lt;/code&gt;：两个迭代器相减的结果是它们之间的距离，也就是说，将运算符右侧的迭代器向前移动差值个元素后将得到左侧的迭代器。参与运算的两个迭代器必须指向的是同一容器中的元素或者尾元素的下一位置。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;gt;, &amp;gt;=, &amp;lt;, &amp;lt;=&lt;/code&gt;：迭代器的关系运算符，如果迭代器指向的容器位置在另一个迭代器所指位置之前，则说前者小于后者。&lt;/p&gt;
&lt;h2&gt;数组&lt;/h2&gt;
&lt;p&gt;因为数组的大小固定，因此在对某些特殊的应用来说程序的运行时性能较好，但是相应的也损失了一些灵活性。&lt;/p&gt;
&lt;p&gt;数组的维度必须是一个常量表达式。&lt;/p&gt;
&lt;p&gt;默认情况下数组的元素被默认初始化。&lt;/p&gt;
&lt;p&gt;和内置类型的变量一样，如果在函数内部定义了某种内置类型的数组，那么默认初始化会令数组含有未定义的值。&lt;/p&gt;
&lt;p&gt;定义数组的时候必须指定数组的类型，不允许用auto关键字由初始值的列表推断类型。&lt;/p&gt;
&lt;p&gt;字符数组可以利用字符串字面值初始化，此时注意字符串字面值末尾的空字符，也会被拷贝到字符数组中。&lt;/p&gt;
&lt;p&gt;不允许拷贝和赋值。一些编译器支持数组的赋值，这就是所谓的编译器扩展，但一般来说，最好避免使用非标准特性，因为可能在其他编译器上无法正常工作。&lt;/p&gt;
&lt;p&gt;理解复杂的数组声明：由内向外阅读&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int *ptrs[10];   //ptrs 是含有10个整型指针的数组
int (*Parray)[10] = &amp;amp;arr;   //Parray 是指针，指向一个含有10个整数的数组
int (&amp;amp;arrRef)[10] = arr;    //arrRef 是引用，引用一个含有10个整数的数组
int *(&amp;amp;arry)[10] = ptrs;    //arry 是引用，引用一个含有10个整型指针的数组
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;访问数组元素&lt;/h3&gt;
&lt;p&gt;数组的索引从0开始。&lt;/p&gt;
&lt;p&gt;在使用数组下标的时候，通常将其定义为&lt;code&gt;size_t&lt;/code&gt;类型。&lt;code&gt;size_t&lt;/code&gt;是一种机器相关的无符号类型，它被设计的足够大以便能表示内存中任意对象的大小。&lt;/p&gt;
&lt;p&gt;在 cstddef 头文件中定义了&lt;code&gt;size_t&lt;/code&gt;类型，这个文件是 C 标准库 stddef.h 头文件的 C++ 版本。&lt;/p&gt;
&lt;p&gt;使用数组的时候编译器一般会把它转换成指针。&lt;/p&gt;
&lt;p&gt;通常情况下，使用取地址符来获取指向某个对象的指针，取地址符可以用于任何对象。数组的元素也是对象，对数组使用下标运算符得到该数组指定位置的元素，对数组元素应用取地址符就能得到指向该元素的指针。&lt;/p&gt;
&lt;p&gt;数组还有一个特性：在很多时候用到数组名字的地方，编译器都会自动地将其替换为一个指向数组首元素的指针&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;string *p2 = nums;  //等价于 p2 = &amp;amp;nums[0]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;所以如果使用数组作为一个auto变量的初始值时，推断的类型是指针而非数组&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int ia[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9,};
auto ia2(ia);       // ia2 是一个整型指针，指向 ia 的第一个元素
ia2 = 42;       //错误，ia2 是一个指针，不能用 int 赋值
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当使用&lt;code&gt;decltype&lt;/code&gt;关键字时上述转换不会发生，&lt;code&gt;decltype(ia)&lt;/code&gt;返回的类型是由10个整数构成的数组&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;decltype(ia) ia3 = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
ia3 = p;        //错误，不能用整型指针给数组赋值
ia3[4] = i;     //正确：把 i 的值赋给 ia3 的一个元素
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;为了让指针的使用更简单、更安全，C++11 新标准引入两个名为&lt;code&gt;begin&lt;/code&gt;和&lt;code&gt;end&lt;/code&gt;的函数，不过数组毕竟不是类类型，因此这两个函数不是成员函数。正确的使用形式是将数组作为它们的参数&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int ia[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};
int *beg = begin(ia);
int *last = end(ia);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;begin&lt;/code&gt;函数返回指向 ia 首元素的指针，&lt;code&gt;end&lt;/code&gt;函数返回指向 ia 尾元素下一位置的指针，这两个函数定义在 iterator 头文件中&lt;/p&gt;
&lt;p&gt;两个指针相减结果的类型是一种名为&lt;code&gt;ptrdiff_t&lt;/code&gt;的类型，和&lt;code&gt;size_t&lt;/code&gt;一样，它也是定义在 cstddef 头文件中的机器相关的类型。因为差值可能是负值，所以它是一种带符号类型。&lt;/p&gt;
&lt;p&gt;内置的下标运算符所用的索引值不是无符号类型，这一点和&lt;code&gt;vector&lt;/code&gt;和&lt;code&gt;string&lt;/code&gt;不一样&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int *p = &amp;amp;ia[2];
int k = p[-2];      //k 是 ia[0] 那个元素
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;C 风格字符串&lt;/h3&gt;
&lt;p&gt;按此习惯书写的字符串存放在字符数组中并以空字符结束。&lt;/p&gt;
&lt;p&gt;C 语言标准库提供了一组函数用于操作 C 风格字符串，它们定义在 cstring 头文件中，cstring 是 C 语言头文件 string.h 的 C++ 版本。&lt;/p&gt;
&lt;h3&gt;与旧代码的接口&lt;/h3&gt;
&lt;p&gt;任何出现字符串字面值的地方都可以用空字符结尾的字符数组来代替。不能用string对象直接初始化指向字符的指针，为了完成该功能，string专门提供了一个名为c_str的成员函数&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;char *str = s;      //错误，不能用 string 对象初始化 char*
const char *str = s.c_str();    //正确
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们无法保证 c_str 函数返回的数组一直有效，事实上，如果后续的操作改变了 s 的值就可能让之前返回的数组失去效用&lt;/p&gt;
&lt;p&gt;使用数组初始化&lt;code&gt;vector&lt;/code&gt;对象&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int int_arr[] = {0, 1, 2, 3, 4, 5};
vector&amp;lt;int&amp;gt; ivec(begin(int_arr),end(int_arr));
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;现代的 C++ 程序员应当尽量使用&lt;code&gt;vector&lt;/code&gt;和迭代器，避免使用内置的数组和指针，应该尽量使用&lt;code&gt;string&lt;/code&gt;，避免使用 C 风格的基于数组的字符串。&lt;/p&gt;
&lt;p&gt;多维数组：要使用范围 for 语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型。&lt;/p&gt;
&lt;p&gt;缓冲区溢出：主要原因是试图通过一个越界的索引访问容器内容。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;difference_type&lt;/code&gt;：由&lt;code&gt;string&lt;/code&gt;和&lt;code&gt;vector&lt;/code&gt;定义的一种带符号整数类型，表示两个迭代器之间的距离。&lt;/p&gt;</content><category term="C++"></category></entry><entry><title>C++ Primer 第二章 变量和基本类型</title><link href="https://xutree.github.io/pages/2018/10/06/C++_Primer_Chapter_2/" rel="alternate"></link><published>2018-10-06T22:02:54+08:00</published><updated>2018-10-07T10:48:38+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-06:/pages/2018/10/06/C++_Primer_Chapter_2/</id><summary type="html">&lt;h2&gt;类型&lt;/h2&gt;
&lt;p&gt;下表列出了 C++ 标准规定的数据类型尺寸的最小值，同时允许编译器赋予这些类型更大的尺寸&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;th&gt;最小尺寸&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;bool&lt;/td&gt;
&lt;td&gt;布尔类型&lt;/td&gt;
&lt;td&gt;未定义&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;char&lt;/td&gt;
&lt;td&gt;字符&lt;/td&gt;
&lt;td&gt;8位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;wchar_t&lt;/td&gt;
&lt;td&gt;宽字符&lt;/td&gt;
&lt;td&gt;16位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;char16_t&lt;/td&gt;
&lt;td&gt;Unicode 字符&lt;/td&gt;
&lt;td&gt;16位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;char32_t&lt;/td&gt;
&lt;td&gt;Unicode 字符&lt;/td&gt;
&lt;td&gt;32位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;short&lt;/td&gt;
&lt;td&gt;短整型&lt;/td&gt;
&lt;td&gt;16位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;整型&lt;/td&gt;
&lt;td&gt;16位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;long&lt;/td&gt;
&lt;td&gt;长整型&lt;/td&gt;
&lt;td&gt;32位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;long long&lt;/td&gt;
&lt;td&gt;长整型&lt;/td&gt;
&lt;td&gt;64位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;float&lt;/td&gt;
&lt;td&gt;单精度浮点数&lt;/td&gt;
&lt;td&gt;6位有效数字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;double&lt;/td&gt;
&lt;td&gt;双精度浮点数&lt;/td&gt;
&lt;td&gt;10位有效数字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;long double&lt;/td&gt;
&lt;td&gt;扩展精度浮点数&lt;/td&gt;
&lt;td&gt;10位有效数字&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;一个&lt;code&gt;char …&lt;/code&gt;&lt;/p&gt;</summary><content type="html">&lt;h2&gt;类型&lt;/h2&gt;
&lt;p&gt;下表列出了 C++ 标准规定的数据类型尺寸的最小值，同时允许编译器赋予这些类型更大的尺寸&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;th&gt;最小尺寸&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;bool&lt;/td&gt;
&lt;td&gt;布尔类型&lt;/td&gt;
&lt;td&gt;未定义&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;char&lt;/td&gt;
&lt;td&gt;字符&lt;/td&gt;
&lt;td&gt;8位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;wchar_t&lt;/td&gt;
&lt;td&gt;宽字符&lt;/td&gt;
&lt;td&gt;16位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;char16_t&lt;/td&gt;
&lt;td&gt;Unicode 字符&lt;/td&gt;
&lt;td&gt;16位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;char32_t&lt;/td&gt;
&lt;td&gt;Unicode 字符&lt;/td&gt;
&lt;td&gt;32位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;short&lt;/td&gt;
&lt;td&gt;短整型&lt;/td&gt;
&lt;td&gt;16位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;整型&lt;/td&gt;
&lt;td&gt;16位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;long&lt;/td&gt;
&lt;td&gt;长整型&lt;/td&gt;
&lt;td&gt;32位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;long long&lt;/td&gt;
&lt;td&gt;长整型&lt;/td&gt;
&lt;td&gt;64位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;float&lt;/td&gt;
&lt;td&gt;单精度浮点数&lt;/td&gt;
&lt;td&gt;6位有效数字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;double&lt;/td&gt;
&lt;td&gt;双精度浮点数&lt;/td&gt;
&lt;td&gt;10位有效数字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;long double&lt;/td&gt;
&lt;td&gt;扩展精度浮点数&lt;/td&gt;
&lt;td&gt;10位有效数字&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;一个&lt;code&gt;char&lt;/code&gt;的空间应确保可以存放机器基本字符集中任意字符对应的数字值。也就是说，一个&lt;code&gt;char&lt;/code&gt;的大小和一个机器字节一样。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;wchar_t&lt;/code&gt;类型用于确保可以存放机器最大扩展字符集中的任意一个字符。&lt;/p&gt;
&lt;p&gt;C++ 语言规定，一个&lt;code&gt;int&lt;/code&gt;至少和一个&lt;code&gt;short&lt;/code&gt;一样大，一个&lt;code&gt;long&lt;/code&gt;至少和一个&lt;code&gt;int&lt;/code&gt;一样大，一个&lt;code&gt;long long&lt;/code&gt;至少和一个&lt;code&gt;long&lt;/code&gt;一样大。&lt;/p&gt;
&lt;p&gt;可寻址的最小内存块成称为“字节（byte）”，存储的基本单元称为“字（word）”，它通常有几个字节组成。&lt;/p&gt;
&lt;p&gt;在 C++ 语言中，一个字节至少能容纳机器基本字符串中的字符。大多数机器的字节由8比特构成，字则由32或64比特构成，也就是4字节或8字节。&lt;/p&gt;
&lt;p&gt;C++ 标准指定了一个浮点数有效位数的最小值，然而大多数编译器都实现了更高的精度。通常，&lt;code&gt;float&lt;/code&gt;以1个字（32比特）来表示，&lt;code&gt;double&lt;/code&gt;以2个字（64位）来表示，&lt;code&gt;long double&lt;/code&gt;以3或4个字（96或128比特）来表示。一般来说，&lt;code&gt;float&lt;/code&gt;和&lt;code&gt;double&lt;/code&gt;分别有7和16个有效位；类型&lt;code&gt;long double&lt;/code&gt;则常常被用于有特殊浮点要求的硬件，它的具体实现不同，精度也各不相同。&lt;/p&gt;
&lt;p&gt;类型&lt;code&gt;int&lt;/code&gt;、&lt;code&gt;short&lt;/code&gt;、&lt;code&gt;long&lt;/code&gt;和&lt;code&gt;long long&lt;/code&gt;都是带符号的，通过在这些类型名前添加&lt;code&gt;unsigned&lt;/code&gt;就可以得到无符号类型。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;char&lt;/code&gt;、&lt;code&gt;signed char&lt;/code&gt;和&lt;code&gt;unsigned char&lt;/code&gt;，&lt;code&gt;char&lt;/code&gt;是否等于&lt;code&gt;signed char&lt;/code&gt;由编译器决定。&lt;/p&gt;
&lt;p&gt;C++ 标准并没有规定带符号类型应如何表示，但是约定了在表示范围内正值和负值的量应该平衡。因此，8比特的&lt;code&gt;signed char&lt;/code&gt;理论上可以表示-127至127区间内的值，大多数现代计算机将实际的表示范围定为-128至127。&lt;/p&gt;
&lt;h2&gt;如何选择类型&lt;/h2&gt;
&lt;p&gt;明知数值不可能为负数，选用无符号类型。&lt;/p&gt;
&lt;p&gt;如果数值超过了&lt;code&gt;int&lt;/code&gt;的表示范围，选用&lt;code&gt;long long&lt;/code&gt;，因为&lt;code&gt;long&lt;/code&gt;一般和&lt;code&gt;int&lt;/code&gt;有一样的尺寸。&lt;/p&gt;
&lt;p&gt;算术表达式中不要使用&lt;code&gt;bool&lt;/code&gt;或&lt;code&gt;char&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;执行浮点数运算选用&lt;code&gt;double&lt;/code&gt;。因为&lt;code&gt;float&lt;/code&gt;通常精度不够而且计算代价相差无几。&lt;code&gt;long double&lt;/code&gt;提供的精度一般情况下是没有必要的而且计算代价大。&lt;/p&gt;
&lt;h2&gt;类型转换&lt;/h2&gt;
&lt;p&gt;非布尔 -&amp;gt; 布尔：0 -&amp;gt; &lt;code&gt;false&lt;/code&gt;，其他 -&amp;gt; &lt;code&gt;ture&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;布尔 -&amp;gt; 非布尔：&lt;code&gt;false&lt;/code&gt;-&amp;gt; 0，&lt;code&gt;ture&lt;/code&gt; -&amp;gt; 1。&lt;/p&gt;
&lt;p&gt;浮点 -&amp;gt; 整型：仅保留小数点前。&lt;/p&gt;
&lt;p&gt;整型 -&amp;gt; 浮点：小数部分记为0，如果该整数所占的空间超过浮点类型的容量，精度可能损失。&lt;/p&gt;
&lt;p&gt;当我们赋给无符号类型一个超过它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。&lt;/p&gt;
&lt;p&gt;当我们赋给带符号类型一个超出它表示范围的值时，结果是未定义的。此时，程序可能继续工作、可能崩溃，也可能生成垃圾数据。&lt;/p&gt;
&lt;p&gt;当一个算术表达式中既有无符号数又有&lt;code&gt;int&lt;/code&gt;值时，那个&lt;code&gt;int&lt;/code&gt;会转换成无符号数。把&lt;code&gt;int&lt;/code&gt;转换成无符号数的过程和把&lt;code&gt;int&lt;/code&gt;赋值给无符号变量一样。&lt;/p&gt;
&lt;p&gt;当从一个无符号数中减去一个值时，我们必须确保结果不是负值，否则实际结果会是取模后的值。&lt;/p&gt;
&lt;h2&gt;字面值常量&lt;/h2&gt;
&lt;p&gt;整型和浮点型字面值。&lt;/p&gt;
&lt;p&gt;字符和字符串字面值：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;‘a’ 和“a”，字符串字面值最后补’\0’&lt;/li&gt;
&lt;li&gt;如果两个字符串字面值位置紧邻且仅由空格、缩进和换行分隔，则它们是一个整体&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;布尔字面值：&lt;code&gt;true&lt;/code&gt;、&lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;指针字面值：&lt;code&gt;nullptr&lt;/code&gt;。&lt;/p&gt;
&lt;h2&gt;指定字面值的类型&lt;/h2&gt;
&lt;p&gt;字符和字符串字面值&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;前缀&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;u&lt;/td&gt;
&lt;td&gt;char16_t&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;U&lt;/td&gt;
&lt;td&gt;char32_t&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;L&lt;/td&gt;
&lt;td&gt;wchar_t&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;u8&lt;/td&gt;
&lt;td&gt;char&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;整型字面值&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;后缀&lt;/th&gt;
&lt;th&gt;最小匹配类型&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;u 或 U&lt;/td&gt;
&lt;td&gt;unsigned&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;l 或 L&lt;/td&gt;
&lt;td&gt;long&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ll 或 LL&lt;/td&gt;
&lt;td&gt;long long&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;浮点型字面值&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;后缀&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;f 或 F&lt;/td&gt;
&lt;td&gt;float&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;l 或 L&lt;/td&gt;
&lt;td&gt;long double&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;列表初始化&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;int units_sold{0}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;列表初始化的重要特点：如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将报错。&lt;/p&gt;
&lt;h2&gt;默认初始化&lt;/h2&gt;
&lt;p&gt;内置类型变量&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定义于任何函数之外，初始化为0&lt;/li&gt;
&lt;li&gt;定义于函数体内的局部静态变量，初始化为0&lt;/li&gt;
&lt;li&gt;定义于函数体内的非局部静态变量，不被初始化，试图拷贝或以其他方式访问此类值将引发错误&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每个类各自决定其初始化对象的方式。&lt;/p&gt;
&lt;h2&gt;分离式编译&lt;/h2&gt;
&lt;p&gt;将程序分割为若干个文件，每个文件可被独立编译&lt;/p&gt;
&lt;h2&gt;声明&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;extern int i;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;extern&lt;/code&gt;语句如果包含初始值就不再是声明，而变成定义了：&lt;code&gt;extern int i = 0;&lt;/code&gt;在函数体内部，试图初始化一个由&lt;code&gt;extern&lt;/code&gt;关键字标记的变量将引发错误。&lt;/p&gt;
&lt;p&gt;静态类型语言：在编译阶段执行类型检查&lt;/p&gt;
&lt;h2&gt;C++ 标识符&lt;/h2&gt;
&lt;p&gt;字母、数字、下划线，必须以字母或下划线开头，长度无限制，大小写敏感。&lt;/p&gt;
&lt;p&gt;C++ 为标准库保留了一些名字&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自定义标识符中不能连续出现两个下划线&lt;/li&gt;
&lt;li&gt;不能以下划线紧接大写字母开头&lt;/li&gt;
&lt;li&gt;定义在函数体外的函数不能以下划线开头&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;作用域操作符 ::&lt;/h2&gt;
&lt;p&gt;若左侧为空，则指代全局作用域&lt;/p&gt;
&lt;h2&gt;复合类型&lt;/h2&gt;
&lt;h3&gt;引用&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;int &amp;amp;b = a;&lt;/code&gt;b指向a。&lt;/p&gt;
&lt;p&gt;引用必须初始化。&lt;/p&gt;
&lt;p&gt;引用本身不是一个对象，不能定义引用的引用。&lt;/p&gt;
&lt;p&gt;引用必须绑定到对象上，不能绑定到字面值或者某个表达式的计算结果上。&lt;/p&gt;
&lt;p&gt;除了两种例外，所有引用的类型都要和它所绑定的对象严格匹配：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可&lt;/li&gt;
&lt;li&gt;允许将基类的引用绑定到派生类上&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;指针&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;int *b = &amp;amp;a;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;指针是一个对象。&lt;/p&gt;
&lt;p&gt;在块作用域内定义的指针如果未初始化，将拥有一个不确定的值。&lt;/p&gt;
&lt;p&gt;除了两种例外，所有指针的类型都要和它所指向的对象严格匹配：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;允许一个指向常量的指针指向一个非常量对象&lt;/li&gt;
&lt;li&gt;允许将基类的指针绑定到派生类上&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;试图拷贝或以其他方式访问无效指针的值将引起错误，编译器不负责检查此类错误。&lt;/p&gt;
&lt;p&gt;任何非零的指针对应的条件值都是true。&lt;/p&gt;
&lt;p&gt;合法指针可以比较大小：== 或 !=。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;void *&lt;/code&gt;是一个特殊的指针类型，可用于存放任意对象的地址，只支持有限的操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;拿它和别的指针比较&lt;/li&gt;
&lt;li&gt;作为函数的输入或输出&lt;/li&gt;
&lt;li&gt;赋给另外一个&lt;code&gt;void *&lt;/code&gt;指针&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;理解复合类型的声明&lt;/h2&gt;
&lt;p&gt;变量的定义包括一个基本数据类型和一组声明符。&lt;/p&gt;
&lt;p&gt;一条定义语句可能定义出不同类型的变量：&lt;code&gt;int i = 1024, *p = &amp;amp;i, &amp;amp;r =i;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;面对一条比较复杂的指针或者引用的声明语句时，从右往左阅读有助于弄清楚它的真实含义，例如：&lt;code&gt;int \*&amp;amp;r;&lt;/code&gt;首先 r 是一个引用，其次 r 是一个指针的引用，再次 r 是一个指向整型指针的引用。&lt;/p&gt;
&lt;h2&gt;const 限定符&lt;/h2&gt;
&lt;p&gt;因为&lt;code&gt;const&lt;/code&gt;对象一旦创建就无法改变其值，所以必须初始化。&lt;/p&gt;
&lt;p&gt;当用一个对象去初始化另外一个对象，它们是不是&lt;code&gt;const&lt;/code&gt;都无关紧要，常量的特性仅仅在执行改变其值的操作时才会发挥作用。&lt;/p&gt;
&lt;p&gt;默认情况下，&lt;code&gt;const&lt;/code&gt;对象仅在文件内有效。&lt;/p&gt;
&lt;p&gt;如果想在多个文件之间共享&lt;code&gt;const&lt;/code&gt;对象，必须在变量的定义之前添加&lt;code&gt;extern&lt;/code&gt;关键字。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;const&lt;/code&gt;的引用，常量引用的初始化：初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。尤其，允许为一个常量引用绑定非常量的对象、字面值甚至是一个表达式。实际上是通过绑定到一个临时量对象上实现的。&lt;/p&gt;
&lt;p&gt;对&lt;code&gt;const&lt;/code&gt;的引用可能引用一个并非&lt;code&gt;const&lt;/code&gt;的对象，常量引用仅对引用可参与的操作做了限制，对于引用的对象本身是不是常量未做限制。&lt;/p&gt;
&lt;h2&gt;指针和 const&lt;/h2&gt;
&lt;h3&gt;指向常量的指针&lt;/h3&gt;
&lt;p&gt;允许一个指向常量的指针指向一个非常量对象。&lt;/p&gt;
&lt;p&gt;仅对指向常量的指针可参与的操作做了限制，对于指向的对象本身是不是常量未做限制。&lt;/p&gt;
&lt;h3&gt;const 指针&lt;/h3&gt;
&lt;p&gt;指针是对象，可以把指针本身定为常量。&lt;/p&gt;
&lt;p&gt;常量指针必须初始化，一经初始化就不能再改变。&lt;/p&gt;
&lt;p&gt;把*放在&lt;code&gt;const&lt;/code&gt;关键字之前说明指针是一个常量。&lt;/p&gt;
&lt;h3&gt;顶层和底层 const&lt;/h3&gt;
&lt;p&gt;顶层&lt;code&gt;const&lt;/code&gt;：指针本身是个常量。&lt;/p&gt;
&lt;p&gt;底层&lt;code&gt;const&lt;/code&gt;：指针所值的对象是一个常量。&lt;/p&gt;
&lt;p&gt;更一般的，顶层&lt;code&gt;const&lt;/code&gt;可以表示任意的对象是常量，这一点对任意数据类型都适用。底层&lt;code&gt;const&lt;/code&gt;则与指针和引用等复合类型的基本类型部分有关。&lt;/p&gt;
&lt;p&gt;执行对象的拷贝操作时，顶层&lt;code&gt;const&lt;/code&gt;不受影响；拷入和拷出的对象必须具有相同的底层&lt;code&gt;const&lt;/code&gt;资格，或者两个对象的数据类型必须能够转换。一般来说，非常量可以转换成常量，反之不行。&lt;/p&gt;
&lt;h3&gt;constexpr 和常量表达式&lt;/h3&gt;
&lt;p&gt;常量表达式：值不会改变并且在编译过程就能得到计算结果的表达式。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;constexpr&lt;/code&gt;变量：由编译器来验证变量的值是否是一个常量表达式，声明为&lt;code&gt;constexpr&lt;/code&gt;的变量一定是一个常量，并且必须用常量表达式初始化。&lt;/p&gt;
&lt;p&gt;字面值类型：算术类型、引用、指针、字面值常量类、枚举。&lt;/p&gt;
&lt;p&gt;声明&lt;code&gt;constexpr&lt;/code&gt;用到的类型为字面值类型。&lt;/p&gt;
&lt;p&gt;一个&lt;code&gt;constexpr&lt;/code&gt;指针的初始值必须是&lt;code&gt;nullptr&lt;/code&gt;或者0，或者是存储于某个固定地址中的对象：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函数体内定义的变量一般并非存放在固定地址中，&lt;code&gt;constexpr&lt;/code&gt;指针不能指向这样的变量（局部静态对象除外）&lt;/li&gt;
&lt;li&gt;定义于所有函数体之外的对象地址固定不变，能用来初始化&lt;code&gt;constexpr&lt;/code&gt;指针&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在&lt;code&gt;constexpr&lt;/code&gt;声明中如果定义了一个指针，限定符&lt;code&gt;constexpr&lt;/code&gt;仅对指针有效，与指针所指的对象无关。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;constexpr&lt;/code&gt;把它所定义的对象置为顶层&lt;code&gt;const&lt;/code&gt;。&lt;/p&gt;
&lt;h2&gt;处理类型&lt;/h2&gt;
&lt;h3&gt;类型别名&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;typedef double wages;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;using SI = Sales_item;&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;auto 类型说明符&lt;/h3&gt;
&lt;p&gt;让编译器自己去分析表达式所属的类型。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;auto&lt;/code&gt;也能在一条语句中声明多个变量。因为一条声明语句只能有一个基本数据类型，所以该语句中所有变量的基本数据类型都必须一样。&lt;/p&gt;
&lt;p&gt;当引用被用作初始化&lt;code&gt;auto&lt;/code&gt;变量时，编译器以引用所引用对象的类型作为&lt;code&gt;auto&lt;/code&gt;的类型。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;auto&lt;/code&gt;一般会忽略顶层&lt;code&gt;const&lt;/code&gt;，同时底层&lt;code&gt;const&lt;/code&gt;会保留下来。&lt;/p&gt;
&lt;p&gt;如果希望推断出的&lt;code&gt;auto&lt;/code&gt;类型是一个顶层&lt;code&gt;const&lt;/code&gt;，需要明确指出。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;auto&lt;/code&gt;引用&lt;code&gt;auto &amp;amp;b = a;&lt;/code&gt;初始值 a 的顶层&lt;code&gt;const&lt;/code&gt;会保留。&lt;/p&gt;
&lt;h3&gt;decltype 类型指示符&lt;/h3&gt;
&lt;p&gt;选择并返回操作数的数据类型，编译器分析表达式得到它的类型，却不实际计算表达式的值，编译器并不实际调用f。&lt;/p&gt;
&lt;p&gt;如果&lt;code&gt;decltype&lt;/code&gt;使用的表达式是一个变量，则&lt;code&gt;decltype&lt;/code&gt;返回该变量的类型（包括顶层&lt;code&gt;const&lt;/code&gt;和引用在内），需要指出的是，引用从来都作为其所指对象的同义词出现，只有在&lt;code&gt;decltype&lt;/code&gt;处是一个例外。&lt;/p&gt;
&lt;p&gt;如果&lt;code&gt;decltype&lt;/code&gt;使用的表达式不是一个变量，则&lt;code&gt;decltype&lt;/code&gt;返回该表达式的结果对应的类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因为 r 是一个引用，&lt;code&gt;decltype(r)&lt;/code&gt;的结果是引用类型，如果想让结果类型是 r 所指的类型，可以把 r 作为表达式的一部分，显然这个表达式的结果是一个具体的值而非一个引用&lt;/li&gt;
&lt;li&gt;如果表达式的内容是解引用操作，则&lt;code&gt;decltype&lt;/code&gt;将得到引用类型&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果&lt;code&gt;decltype&lt;/code&gt;使用的表达式是一个变量：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不加括号，得到该变量的类型&lt;/li&gt;
&lt;li&gt;加括号，得到引用类型&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;自定义数据结构：结构体和类&lt;/h2&gt;
&lt;p&gt;记得定义末尾的分号。可以类内初始化。&lt;/p&gt;
&lt;h2&gt;头文件保护符&lt;/h2&gt;
&lt;p&gt;头文件保护符依赖于预处理变量。&lt;/p&gt;
&lt;p&gt;预处理变量由两个状态：已定义和未定义。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;#define&lt;/code&gt;指令把一个名字设定为预处理变量。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;#ifdef&lt;/code&gt;当且仅当变量已定义时为真。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;#ifndef&lt;/code&gt;当且仅当变量未定义时为真。&lt;/p&gt;
&lt;p&gt;一旦检查结果为真，则执行后续操作直到遇到&lt;code&gt;#endif&lt;/code&gt;指令为止&lt;/p&gt;</content><category term="C++"></category></entry><entry><title>C++ Primer 第一章 开始</title><link href="https://xutree.github.io/pages/2018/10/05/C++_Primer_Chapter_1/" rel="alternate"></link><published>2018-10-05T23:11:35+08:00</published><updated>2018-10-07T10:48:26+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-05:/pages/2018/10/05/C++_Primer_Chapter_1/</id><summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;code&gt;g++ -std=c++14  -Wall -o test test.cpp&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iostream&lt;/code&gt; &lt;code&gt;cin&lt;/code&gt; &lt;code&gt;cout&lt;/code&gt; &lt;code&gt;cerr&lt;/code&gt; &lt;code&gt;clog&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;运算符返回其左侧的运算对象&lt;/li&gt;
&lt;li&gt;写入&lt;code&gt;endl&lt;/code&gt;的效果是结束当前行，并将与设备关联的缓冲区中的内容刷到设备中。缓冲刷新操作可以保证到目前为止程序所产生的所有输出都真正写入到输出流中，而不是仅停留在内存中等待写入流&lt;/li&gt;
&lt;li&gt;小心程序崩溃，输出可能还留在缓冲区的情况，利用&lt;code&gt;endl&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;标准库定义的所有名字都在命名空间&lt;code&gt;std&lt;/code&gt;中&lt;/li&gt;
&lt;li&gt;当我们使用一个&lt;code&gt;istream&lt;/code&gt;对象作为条件时，其效果是检测流的状态。流有效，即流未遇到错误，那么检测成功。当遇到文件结束符（end of file），或遇到一个无效输入时，&lt;code&gt;istream&lt;/code&gt;对象的状态会变为无效。无效的&lt;code&gt;istream&lt;/code&gt;对象会使条件为假&lt;/li&gt;
&lt;li&gt;文件结束符：Windows 先Ctrl + Z，后Enter …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;ul&gt;
&lt;li&gt;&lt;code&gt;g++ -std=c++14  -Wall -o test test.cpp&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iostream&lt;/code&gt; &lt;code&gt;cin&lt;/code&gt; &lt;code&gt;cout&lt;/code&gt; &lt;code&gt;cerr&lt;/code&gt; &lt;code&gt;clog&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;运算符返回其左侧的运算对象&lt;/li&gt;
&lt;li&gt;写入&lt;code&gt;endl&lt;/code&gt;的效果是结束当前行，并将与设备关联的缓冲区中的内容刷到设备中。缓冲刷新操作可以保证到目前为止程序所产生的所有输出都真正写入到输出流中，而不是仅停留在内存中等待写入流&lt;/li&gt;
&lt;li&gt;小心程序崩溃，输出可能还留在缓冲区的情况，利用&lt;code&gt;endl&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;标准库定义的所有名字都在命名空间&lt;code&gt;std&lt;/code&gt;中&lt;/li&gt;
&lt;li&gt;当我们使用一个&lt;code&gt;istream&lt;/code&gt;对象作为条件时，其效果是检测流的状态。流有效，即流未遇到错误，那么检测成功。当遇到文件结束符（end of file），或遇到一个无效输入时，&lt;code&gt;istream&lt;/code&gt;对象的状态会变为无效。无效的&lt;code&gt;istream&lt;/code&gt;对象会使条件为假&lt;/li&gt;
&lt;li&gt;文件结束符：Windows 先Ctrl + Z，后Enter 或 Return；UNIX：Ctrl +D&lt;/li&gt;
&lt;li&gt;标准库文件通常不带后缀。编译器一般不关心头文件名的形式，但有的IDE对此有特定要求&lt;/li&gt;
&lt;li&gt;头文件包含：标准库头文件 &amp;lt;&amp;gt;     非标准库头文件 ""&lt;/li&gt;
&lt;li&gt;文件重定向：从文件读入\&amp;lt;infile，输出到文件&gt;outfile&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cerr&lt;/code&gt;(无缓冲标准错误) 没有缓冲，发送给它的内容立即被输出&lt;/li&gt;
&lt;li&gt;&lt;code&gt;clog&lt;/code&gt;(缓冲标准错误)  有缓冲，缓冲区满时输出&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cout&lt;/code&gt;标准输出&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cout&lt;/code&gt;是在终端显示器输出，&lt;code&gt;cout&lt;/code&gt;流在内存中对应开辟了一个缓冲区，用来存放流中的数据，当向&lt;code&gt;cout&lt;/code&gt;流插入一个&lt;code&gt;endl&lt;/code&gt;，不论缓冲区是否满了，都立即输出流中所有数据，然后插入一个换行符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cerr&lt;/code&gt;流对象是标准错误流，指定为和显示器关联，和&lt;code&gt;cout&lt;/code&gt;作用差不多，有点不同就是&lt;code&gt;cout&lt;/code&gt;通常是传到显示器输出，但可以被重定向输出到文件，而&lt;code&gt;cerr&lt;/code&gt;流中的信息只能在显示器输出&lt;/li&gt;
&lt;li&gt;&lt;code&gt;clog&lt;/code&gt;流也是标准错误流，作用和&lt;code&gt;cerr&lt;/code&gt;一样，区别在于&lt;code&gt;cerr&lt;/code&gt;不经过缓冲区，直接向显示器输出信息，而&lt;code&gt;clog&lt;/code&gt;中的信息存放在缓冲区，缓冲区满或者遇到&lt;code&gt;endl&lt;/code&gt;时才输出&lt;/li&gt;
&lt;li&gt;对于为什么有&lt;code&gt;cerr&lt;/code&gt;和&lt;code&gt;clog&lt;/code&gt;？比如，你的程序遇到调用栈用完了的威胁（无限，没有出口的递归。你说，你到什么地方借内存，存放你的错误信息？所以有了&lt;code&gt;cerr&lt;/code&gt;。其目的，就是在你最需要它的紧急情况下，还能得到输出功能的支持&lt;/li&gt;
&lt;li&gt;缓冲区的目的，就是减少刷屏的次数——比如，你的程序输出圣经中的一篇文章。不带缓冲的话，就会每写一个字母，就输出一个字母，然后刷屏。有了缓冲，你将看到若干句子“同时”就出现在了屏幕上（由内存翻新到显存，然后刷新屏幕）&lt;/li&gt;
&lt;/ul&gt;</content><category term="C++"></category></entry></feed>