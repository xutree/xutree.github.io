<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>You Know Nothing - 读书笔记</title><link href="https://xutree.github.io/" rel="alternate"></link><link href="https://xutree.github.io/feeds/du-shu-bi-ji.atom.xml" rel="self"></link><id>https://xutree.github.io/</id><updated>2018-10-07T08:46:31+08:00</updated><entry><title>【读书笔记】C++ Primer 第三章</title><link href="https://xutree.github.io/pages/2018/10/06/C++_Primer_Chapter_3/" rel="alternate"></link><published>2018-10-06T22:31:16+08:00</published><updated>2018-10-07T08:38:15+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-06:/pages/2018/10/06/C++_Primer_Chapter_3/</id><summary type="html">&lt;p&gt;&lt;code&gt;string&lt;/code&gt; 表示可变长的字符数组。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vector&lt;/code&gt; 存放的是某种给定类型对象的可变长序列。&lt;/p&gt;
&lt;p&gt; 数组和其他内置类型一样，实现与硬件密切相关，在灵活性上稍显不足。&lt;/p&gt;
&lt;p&gt; 命名空间 &lt;code&gt;using&lt;/code&gt; 声明：&lt;code&gt;using namespace::name;&lt;/code&gt; 例如：&lt;code&gt;using std::cin;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt; 头文件不应包含 &lt;code&gt;using&lt;/code&gt; 声明，防止名字冲突。&lt;/p&gt;
&lt;h2&gt; 标准库类型 string&lt;/h2&gt;
&lt;h3&gt; 头文件和声明 &lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="n"&gt;using&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kr"&gt;string&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt; 定义和初始化 &lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;string s1;  // 默认初始化，空字符串
string s2 = s1; //s2 是 s1 的副本，等价于 s2(s1)
string s3 = &amp;quot;hiya&amp;quot;; //s3 是字符串字面值的副本，等价于 …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;&lt;code&gt;string&lt;/code&gt; 表示可变长的字符数组。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vector&lt;/code&gt; 存放的是某种给定类型对象的可变长序列。&lt;/p&gt;
&lt;p&gt; 数组和其他内置类型一样，实现与硬件密切相关，在灵活性上稍显不足。&lt;/p&gt;
&lt;p&gt; 命名空间 &lt;code&gt;using&lt;/code&gt; 声明：&lt;code&gt;using namespace::name;&lt;/code&gt; 例如：&lt;code&gt;using std::cin;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt; 头文件不应包含 &lt;code&gt;using&lt;/code&gt; 声明，防止名字冲突。&lt;/p&gt;
&lt;h2&gt; 标准库类型 string&lt;/h2&gt;
&lt;h3&gt; 头文件和声明 &lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="n"&gt;using&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kr"&gt;string&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt; 定义和初始化 &lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;string s1;  // 默认初始化，空字符串
string s2 = s1; //s2 是 s1 的副本，等价于 s2(s1)
string s3 = &amp;quot;hiya&amp;quot;; //s3 是字符串字面值的副本，等价于 s3(&amp;quot;hiya&amp;quot;)
string s4(10, &amp;#39;c&amp;#39;); //s4 的内容是 cccccccccc
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;string 对象上的操作 &lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt; 操作 &lt;/th&gt;
&lt;th&gt; 意义 &lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;os &amp;lt;&amp;lt; s&lt;/td&gt;
&lt;td&gt; 将 s 写到输出流 os 中，返回 os&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;is &amp;gt;&amp;gt; s&lt;/td&gt;
&lt;td&gt; 从 is 中读取字符串赋给 s，字符串以空白分隔，返回 is&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;getline(is, s)&lt;/td&gt;
&lt;td&gt; 从 is 中读取一行赋给 s，返回 is&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s.empty()&lt;/td&gt;
&lt;td&gt;s 为空返回 true，否则返回 false&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s.size()&lt;/td&gt;
&lt;td&gt; 返回 s 中字符的个数 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s[n]&lt;/td&gt;
&lt;td&gt; 返回 s 中第 n 个字符的引用，位置 n 从 0 记起 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s1 + s2&lt;/td&gt;
&lt;td&gt; 返回连接后的结果 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s1 = s2&lt;/td&gt;
&lt;td&gt; 用 s2 的副本代替 s1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s1 == s2&lt;/td&gt;
&lt;td&gt; 如果 s1 和 s2 中所含的字符完全一样，则他们相等 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s1 != s2&lt;/td&gt;
&lt;td&gt;string 对象的相等性判断对大小写敏感 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;lt;, &amp;lt;=, &amp;gt;, &amp;gt;=&lt;/td&gt;
&lt;td&gt; 利用字符在字典里的顺序进行比较，大小写敏感 &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt; 读取未知数量的 string 对象 &lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int main()
{
    string word;
    while (cin &amp;gt;&amp;gt; word)
        cout &amp;lt;&amp;lt; word &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; 直到遇到结束标记或者非法输入才会停止 &lt;/p&gt;
&lt;h3&gt; 使用 getline 读取一整行 &lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int main()
{
    string line;
    while (getline(cin,line))
        cout &amp;lt;&amp;lt; line &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;getline&lt;/code&gt; 函数的参数是一个输入流和一个 &lt;code&gt;string&lt;/code&gt; 对象，&lt;code&gt;getline&lt;/code&gt; 从给定的输入流中读入内容，直到遇到换行符为止（注意换行符也被读进来了），然后把所读的内容存入 &lt;code&gt;string&lt;/code&gt; 对象中（注意不存换行符）。如果输入一开始就是换行符，那么所得的结果是个空 &lt;code&gt;string&lt;/code&gt;。&lt;/p&gt;
&lt;h3&gt;string::size_type 类型 &lt;/h3&gt;
&lt;p&gt; 是一个无符号类型的值。如果一个表达式中已经有 &lt;code&gt;size&lt;/code&gt; 函数就不要再使用 &lt;code&gt;int&lt;/code&gt; 了，这样可以避免混用 &lt;code&gt;int&lt;/code&gt; 和 &lt;code&gt;unsigned&lt;/code&gt; 可能带来的问题。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;string&lt;/code&gt; 对象可以和字符字符串字面值相加，只要保证 + 号两侧的运算对象至少有一个 &lt;code&gt;string&lt;/code&gt; 对象即可。&lt;/p&gt;
&lt;p&gt; 由于某些历史原因，也为了和 C 兼容，所以 C++ 中的字符串字面值并不是标准库 &lt;code&gt;string&lt;/code&gt; 类型。&lt;/p&gt;
&lt;h3&gt; 处理 string 对象里的字符 &lt;/h3&gt;
&lt;p&gt; 包含在 &lt;code&gt;cctype&lt;/code&gt; 头文件中：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt; 函数 &lt;/th&gt;
&lt;th&gt; 意义 &lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;isalunm(c)&lt;/td&gt;
&lt;td&gt; 当 c 是字母或数字时为真 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;isalpha(c)&lt;/td&gt;
&lt;td&gt; 当 c 是字母时为真 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;iscntrl(c)&lt;/td&gt;
&lt;td&gt; 当 c 是控制字符时为真 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;isdigit(c)&lt;/td&gt;
&lt;td&gt; 当 c 是数字时为真 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;isgraph(c)&lt;/td&gt;
&lt;td&gt; 当 c 不是空格但可打印时为真 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;islower(c)&lt;/td&gt;
&lt;td&gt; 当 c 是小写字母时为真 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;isprint(c)&lt;/td&gt;
&lt;td&gt; 当 c 是可打印字符时为真（即 c 是空格或 c 具有可视形式）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ispunct(c)&lt;/td&gt;
&lt;td&gt; 当 c 是标点符号时为真（即 c 不是控制字符、数字、字母、可打印空白中的一种）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;isspace(c)&lt;/td&gt;
&lt;td&gt; 当 c 是空白时为真（即 c 是空格、横向制表符、纵向制表符、回车符、换行符、进纸符中的一种）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;isupper(c)&lt;/td&gt;
&lt;td&gt; 当 c 是大写字母时为真 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;isxdigit(c)&lt;/td&gt;
&lt;td&gt; 当 c 是十六进制数字时为真 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;tolower(c)&lt;/td&gt;
&lt;td&gt; 输出 c 的小写 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;toupper(c)&lt;/td&gt;
&lt;td&gt; 输出 c 的大写 &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;C++ 标准库除了定义 C++ 语言特有的功能外，也兼容了 C 语言的标准库。C 语言的头文件形如 name.h，C++ 则将这些文件命名为 cname。因此 &lt;code&gt;cctype&lt;/code&gt; 头文件和 &lt;code&gt;ctype.h&lt;/code&gt; 头文件的内容是一样的，只不过从命名规范上来讲更符合 C++ 语言的要求。特别地，在名为 cname 的头文件中定义的名字从属于命名空间 &lt;code&gt;std&lt;/code&gt;。&lt;/p&gt;
&lt;h3&gt; 范围 for&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;for (declaration: expression)
        statement
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;expression 是一个对象，用于表示一个序列；declaration 负责定义一个变量，该变量将被用于访问序列中的基础元素，每次迭代，declaration 部分的变量会被初始化为 expression 部分的下一个元素值。&lt;/p&gt;
&lt;p&gt; 使用范围 for 输出 &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;string str(&amp;quot;some string&amp;quot;);
        for (auto c : str)
cout &amp;lt;&amp;lt; c &amp;lt;&amp;lt; endl;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; 使用范围 for 修改 &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;string s(&amp;quot;Hello World!&amp;quot;);
for (auto &amp;amp;c : s)
        c = toupper(c);
cout &amp;lt;&amp;lt; s &amp;lt;&amp;lt; endl;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt; 下标运算符 [ ]&lt;/h3&gt;
&lt;p&gt;[ ] 接收的输入参数是 &lt;code&gt;string:size_type&lt;/code&gt; 类型的值，这个参数表示要访问的字符的位置，返回值是该位置上字符的引用。&lt;code&gt;string&lt;/code&gt; 对象的下标必须大于等于 0 而小于 &lt;code&gt;s.size()&lt;/code&gt;。&lt;/p&gt;
&lt;h2&gt; 标准库类型 vector&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;vector&lt;/code&gt; 表示对象的集合，其中所有对象的类型都相同，也常被称作容器，是一种类模板 &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;vector&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="n"&gt;using&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; 编译器根据模板创建类或函数的过程称为实例化，对于类模板，我们通过提供一些额外信息来指定模板到底实例化成什么样的类：在模板名字后面跟一对尖括号，在括号内放上信息 &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;vector&amp;lt;int&amp;gt; ivec;
vector&amp;lt;Sales_item&amp;gt; Sales_vec;
vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; file;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; 在早期版本的 C++ 标准中如果 &lt;code&gt;vector&lt;/code&gt; 的元素还是 &lt;code&gt;vector&lt;/code&gt;（或者其他模板类型），则其定义的形式与现在的 C++11 新标准略有不同。过去，必须在外层 &lt;code&gt;vector&lt;/code&gt; 对象的右尖括号和其元素类型之间添加一个空格，如应写成 &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt; 初始化 &lt;/h3&gt;
&lt;p&gt; 默认初始化。&lt;/p&gt;
&lt;p&gt; 列表初始化。&lt;/p&gt;
&lt;p&gt; 值初始化：通常情况下，可以只提供 vector 对象容纳的元素数量而略去初始值。此时库会创建一个值初始化的元素初值，并把它赋给容器中的所有元素。这个初值由 vector 对象中元素的类型决定。内置类型：0；类类型：由类默认初始化。&lt;/p&gt;
&lt;h3&gt; 添加元素 &lt;/h3&gt;
&lt;p&gt;&lt;code&gt;push_back&lt;/code&gt;：负责把一个值当成 &lt;code&gt;vector&lt;/code&gt; 对象的尾元素压到 &lt;code&gt;vector&lt;/code&gt; 对象的尾端 &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;vector&amp;lt;int&amp;gt; v2;
for (int i = 0; i != 100; ++i)
        v2.push_back(i);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; 如果循环内部包含有向 &lt;code&gt;vector&lt;/code&gt; 对象添加元素的语句，则不能使用范围 &lt;code&gt;for&lt;/code&gt; 循环。&lt;/p&gt;
&lt;h3&gt; 其他 vector 操作 &lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt; 函数 &lt;/th&gt;
&lt;th&gt; 含义 &lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;v.empty()&lt;/td&gt;
&lt;td&gt; 如果 v 不含有任何元素，返回真；否则返回假 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;v.size()&lt;/td&gt;
&lt;td&gt; 返回 v 中元素的个数 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;v.push_back(t)&lt;/td&gt;
&lt;td&gt; 向 v 的尾端添加一个值为 t 的元素 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;v[n]&lt;/td&gt;
&lt;td&gt; 返回 v 中第 n 个位置上元素的引用 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;v1 = v2&lt;/td&gt;
&lt;td&gt; 用 v2 中的元素拷贝替换 v1 中的元素 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td a，b，c...&gt;v1 = &lt;/td&gt;
&lt;td&gt; 用列表中元素的拷贝替换 v1 中的元素 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;v1 == v2&lt;/td&gt;
&lt;td&gt;v1 和 v2 相等当且仅当它们的元素数量相同且对应位置的元素值都相同 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;v1 != v2&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;lt;,&amp;lt;=,&amp;gt;,&amp;gt;=&lt;/td&gt;
&lt;td&gt; 以字典顺序进行比较 &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;vector 的 size_type&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;vector&amp;lt;int&amp;gt;::size_type      // 正确
vector::size_type           // 错误
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; 和 &lt;code&gt;string&lt;/code&gt; 一样，&lt;code&gt;vector&lt;/code&gt; 对象的下标也是从 0 开始计算，&lt;code&gt;vector&lt;/code&gt; 对象（以及 &lt;code&gt;string&lt;/code&gt; 对象）的下标运算符可用于访问已存在的元素，而不能用于添加元素。&lt;/p&gt;
&lt;h2&gt; 迭代器 &lt;/h2&gt;
&lt;p&gt; 所有标准库容器都可以使用迭代器，但只有少数的几种才同时支持下标运算符。&lt;/p&gt;
&lt;p&gt; 严格来讲，&lt;code&gt;string&lt;/code&gt; 不属于容器类型，但是 &lt;code&gt;string&lt;/code&gt; 支持很多与容器类型相似的操作。&lt;code&gt;vector&lt;/code&gt; 支持下标运算符，这点和 &lt;code&gt;string&lt;/code&gt; 一样。&lt;/p&gt;
&lt;p&gt; 和指针不一样，获取迭代器不是使用取地址符，有迭代器的类型同时拥有返回迭代器的成员。&lt;code&gt;begin&lt;/code&gt; 和 &lt;code&gt;end&lt;/code&gt;：&lt;code&gt;auto b = v.begin(), e = v.end();&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;end&lt;/code&gt; 成员负责返回指向容器 “ 尾元素的下一位置 ” 的迭代器。常被称作尾后迭代器或尾迭代器。&lt;/p&gt;
&lt;p&gt; 如果容器为空，则 &lt;code&gt;begin&lt;/code&gt; 和 &lt;code&gt;end&lt;/code&gt; 返回的是同一个迭代器，都是尾后迭代器。&lt;/p&gt;
&lt;h3&gt; 标准容器迭代器的运算符 &lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt; 符号 &lt;/th&gt;
&lt;th&gt; 含义 &lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;*iter&lt;/td&gt;
&lt;td&gt; 返回迭代器 iter 所指元素的引用 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;iter-&amp;gt;mem&lt;/td&gt;
&lt;td&gt; 解引用 iter 并获取该元素的名为 mem 的成员，等价于 (*iter).mem&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;++iter&lt;/td&gt;
&lt;td&gt; 令 iter 指向容器中的下一个元素 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;--iter&lt;/td&gt;
&lt;td&gt; 令 iter 指向容器中的上一个元素 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;iter1 == iter2&lt;/td&gt;
&lt;td&gt; 判断两个迭代器是否相等 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;iter1 != iter2&lt;/td&gt;
&lt;td&gt; 如果指向同一元素或者他们是同一容器的尾后迭代器 &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt; 因为 &lt;code&gt;end&lt;/code&gt; 返回的迭代器并不实际指向某个元素，所以不能对其进行递增或解引用操作。C++ 程序员习惯性地使用 &lt;code&gt;!=&lt;/code&gt;，其原因和他们更愿意使用迭代器而非下标的原因一样：这种编程风格在标准库提供的所有容器上都有效，因为所有标准库容器都定义了 &lt;code&gt;==&lt;/code&gt; 和 &lt;code&gt;!=&lt;/code&gt;。&lt;/p&gt;
&lt;h3&gt; 迭代器类型 &lt;/h3&gt;
&lt;p&gt; 拥有迭代器的标准库类型使用 &lt;code&gt;iterator&lt;/code&gt; 和 &lt;code&gt;const_iterator&lt;/code&gt; 来表示迭代器的类型 &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nd"&gt;iterator&lt;/span&gt; &lt;span class="nt"&gt;it&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;   &lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="nt"&gt;it&lt;/span&gt; &lt;span class="nt"&gt; 能读写 &lt;/span&gt; &lt;span class="nt"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nt"&gt; 的元素 &lt;/span&gt;
&lt;span class="nt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nd"&gt;iterator&lt;/span&gt; &lt;span class="nt"&gt;it2&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;       &lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="nt"&gt;it2&lt;/span&gt; &lt;span class="nt"&gt; 能读写 &lt;/span&gt; &lt;span class="nt"&gt;string&lt;/span&gt; &lt;span class="nt"&gt; 对象中的元素 &lt;/span&gt;
&lt;span class="nt"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="nt"&gt;const_iterator&lt;/span&gt; &lt;span class="nt"&gt;it3&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;  &lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="nt"&gt;it3&lt;/span&gt; &lt;span class="nt"&gt; 只能读元素 &lt;/span&gt;&lt;span class="err"&gt;，&lt;/span&gt;&lt;span class="nt"&gt; 不能写元素 &lt;/span&gt;
&lt;span class="nt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nd"&gt;const_iterator&lt;/span&gt; &lt;span class="nt"&gt;it4&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;     &lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="nt"&gt;it4&lt;/span&gt; &lt;span class="nt"&gt; 只能读字符 &lt;/span&gt;&lt;span class="err"&gt;，&lt;/span&gt;&lt;span class="nt"&gt; 不能写字符 &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;begin&lt;/code&gt; 和 &lt;code&gt;end&lt;/code&gt; 返回的具体类型由对象是否是常量决定，如果对象是常量，&lt;code&gt;begin&lt;/code&gt; 和 &lt;code&gt;end&lt;/code&gt; 返回 &lt;code&gt;const_iterator&lt;/code&gt;；如果对象不是常量，返回 &lt;code&gt;iterator&lt;/code&gt;。如果对象只需读操作而无需写操作的话最好使用常量类型迭代器。为了专门得到 &lt;code&gt;const_iterator&lt;/code&gt;，C++11 标准引入两个新函数：&lt;code&gt;cbegin&lt;/code&gt; 和 &lt;code&gt;cend&lt;/code&gt;。任何一种可能改变容器容量的操作，都会是迭代器失效。&lt;/p&gt;
&lt;h3&gt; 迭代器运算 &lt;/h3&gt;
&lt;p&gt;&lt;code&gt;string&lt;/code&gt; 和 &lt;code&gt;vector&lt;/code&gt; 的迭代器提供了更多额外的运算符：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;iter + n&lt;/code&gt;：迭代器加上一个整数值仍得到一个迭代器，迭代器指示的新位置与原来相比向前移动了若干个元素。结果迭代器或者指示容器内的一个元素，或者指示容器尾元素的下一位置。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;iter - n&lt;/code&gt;：迭代器减去一个整数值仍得一个迭代器，迭代器指示的新位置与原来相比向后移动了若干位置。结果迭代器或者指示容器内的一个元素，或者指示容器尾元素的下一位置。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;iter1 - iter2&lt;/code&gt;：两个迭代器相减的结果是它们之间的距离，也就是说，将运算符右侧的迭代器向前移动差值个元素后将得到左侧的迭代器。参与运算的两个迭代器必须指向的是同一容器中的元素或者尾元素的下一位置。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;gt;, &amp;gt;=, &amp;lt;, &amp;lt;=&lt;/code&gt;：迭代器的关系运算符，如果迭代器指向的容器位置在另一个迭代器所指位置之前，则说前者小于后者。&lt;/p&gt;
&lt;h2&gt; 数组 &lt;/h2&gt;
&lt;p&gt; 因为数组的大小固定，因此在对某些特殊的应用来说程序的运行时性能较好，但是相应的也损失了一些灵活性。&lt;/p&gt;
&lt;p&gt; 数组的维度必须是一个常量表达式。&lt;/p&gt;
&lt;p&gt; 默认情况下数组的元素被默认初始化。&lt;/p&gt;
&lt;p&gt; 和内置类型的变量一样，如果在函数内部定义了某种内置类型的数组，那么默认初始化会令数组含有未定义的值。&lt;/p&gt;
&lt;p&gt; 定义数组的时候必须指定数组的类型，不允许用 auto 关键字由初始值的列表推断类型。&lt;/p&gt;
&lt;p&gt; 字符数组可以利用字符串字面值初始化，此时注意字符串字面值末尾的空字符，也会被拷贝到字符数组中。&lt;/p&gt;
&lt;p&gt; 不允许拷贝和赋值。一些编译器支持数组的赋值，这就是所谓的编译器扩展，但一般来说，最好避免使用非标准特性，因为可能在其他编译器上无法正常工作。&lt;/p&gt;
&lt;p&gt; 理解复杂的数组声明：由内向外阅读 &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int *ptrs[10];   //ptrs 是含有 10 个整型指针的数组
int (*Parray)[10] = &amp;amp;arr;   //Parray 是指针，指向一个含有 10 个整数的数组
int (&amp;amp;arrRef)[10] = arr;    //arrRef 是引用，引用一个含有 10 个整数的数组
int *(&amp;amp;arry)[10] = ptrs;    //arry 是引用，引用一个含有 10 个整型指针的数组
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt; 访问数组元素 &lt;/h3&gt;
&lt;p&gt; 数组的索引从 0 开始。&lt;/p&gt;
&lt;p&gt; 在使用数组下标的时候，通常将其定义为 &lt;code&gt;size_t&lt;/code&gt; 类型。&lt;code&gt;size_t&lt;/code&gt; 是一种机器相关的无符号类型，它被设计的足够大以便能表示内存中任意对象的大小。&lt;/p&gt;
&lt;p&gt; 在 cstddef 头文件中定义了 &lt;code&gt;size_t&lt;/code&gt; 类型，这个文件是 C 标准库 stddef.h 头文件的 C++ 版本。&lt;/p&gt;
&lt;p&gt; 使用数组的时候编译器一般会把它转换成指针。&lt;/p&gt;
&lt;p&gt; 通常情况下，使用取地址符来获取指向某个对象的指针，取地址符可以用于任何对象。数组的元素也是对象，对数组使用下标运算符得到该数组指定位置的元素，对数组元素应用取地址符就能得到指向该元素的指针。&lt;/p&gt;
&lt;p&gt; 数组还有一个特性：在很多时候用到数组名字的地方，编译器都会自动地将其替换为一个指向数组首元素的指针 &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;string *p2 = nums;  // 等价于 p2 = &amp;amp;nums[0]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; 所以如果使用数组作为一个 auto 变量的初始值时，推断的类型是指针而非数组 &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int ia[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9,};
auto ia2(ia);       // ia2 是一个整型指针，指向 ia 的第一个元素
ia2 = 42;       // 错误，ia2 是一个指针，不能用 int 赋值
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; 当使用 &lt;code&gt;decltype&lt;/code&gt; 关键字时上述转换不会发生，&lt;code&gt;decltype(ia)&lt;/code&gt; 返回的类型是由 10 个整数构成的数组 &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;decltype(ia) ia3 = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
ia3 = p;        // 错误，不能用整型指针给数组赋值
ia3[4] = i;     // 正确：把 i 的值赋给 ia3 的一个元素
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; 为了让指针的使用更简单、更安全，C++11 新标准引入两个名为 &lt;code&gt;begin&lt;/code&gt; 和 &lt;code&gt;end&lt;/code&gt; 的函数，不过数组毕竟不是类类型，因此这两个函数不是成员函数。正确的使用形式是将数组作为它们的参数 &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int ia[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};
int *beg = begin(ia);
int *last = end(ia);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;begin&lt;/code&gt; 函数返回指向 ia 首元素的指针，&lt;code&gt;end&lt;/code&gt; 函数返回指向 ia 尾元素下一位置的指针，这两个函数定义在 iterator 头文件中 &lt;/p&gt;
&lt;p&gt; 两个指针相减结果的类型是一种名为 &lt;code&gt;ptrdiff_t&lt;/code&gt; 的类型，和 &lt;code&gt;size_t&lt;/code&gt; 一样，它也是定义在 cstddef 头文件中的机器相关的类型。因为差值可能是负值，所以它是一种带符号类型。&lt;/p&gt;
&lt;p&gt; 内置的下标运算符所用的索引值不是无符号类型，这一点和 &lt;code&gt;vector&lt;/code&gt; 和 &lt;code&gt;string&lt;/code&gt; 不一样 &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int *p = &amp;amp;ia[2];
int k = p[-2];      //k 是 ia[0] 那个元素
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;C 风格字符串 &lt;/h3&gt;
&lt;p&gt; 按此习惯书写的字符串存放在字符数组中并以空字符结束。&lt;/p&gt;
&lt;p&gt;C 语言标准库提供了一组函数用于操作 C 风格字符串，它们定义在 cstring 头文件中，cstring 是 C 语言头文件 string.h 的 C++ 版本。&lt;/p&gt;
&lt;h3&gt; 与旧代码的接口 &lt;/h3&gt;
&lt;p&gt; 任何出现字符串字面值的地方都可以用空字符结尾的字符数组来代替。不能用 string 对象直接初始化指向字符的指针，为了完成该功能，string 专门提供了一个名为 c_str 的成员函数 &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;char *str = s;      // 错误，不能用 string 对象初始化 char*
const char *str = s.c_str();    // 正确
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; 我们无法保证 c_str 函数返回的数组一直有效，事实上，如果后续的操作改变了 s 的值就可能让之前返回的数组失去效用 &lt;/p&gt;
&lt;p&gt; 使用数组初始化 &lt;code&gt;vector&lt;/code&gt; 对象 &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int int_arr[] = {0, 1, 2, 3, 4, 5};
vector&amp;lt;int&amp;gt; ivec(begin(int_arr),end(int_arr));
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; 现代的 C++ 程序员应当尽量使用 &lt;code&gt;vector&lt;/code&gt; 和迭代器，避免使用内置的数组和指针，应该尽量使用 &lt;code&gt;string&lt;/code&gt;，避免使用 C 风格的基于数组的字符串。&lt;/p&gt;
&lt;p&gt; 多维数组：要使用范围 for 语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型。&lt;/p&gt;
&lt;p&gt; 缓冲区溢出：主要原因是试图通过一个越界的索引访问容器内容。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;difference_type&lt;/code&gt;：由 &lt;code&gt;string&lt;/code&gt; 和 &lt;code&gt;vector&lt;/code&gt; 定义的一种带符号整数类型，表示两个迭代器之间的距离。&lt;/p&gt;</content><category term="C++"></category></entry><entry><title>【读书笔记】C++ Primer 第二章</title><link href="https://xutree.github.io/pages/2018/10/06/C++_Primer_Chapter_2/" rel="alternate"></link><published>2018-10-06T22:02:54+08:00</published><updated>2018-10-07T08:46:15+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-06:/pages/2018/10/06/C++_Primer_Chapter_2/</id><summary type="html">&lt;h2&gt; 类型 &lt;/h2&gt;
&lt;p&gt; 下表列出了 C++ 标准规定的数据类型尺寸的最小值，同时允许编译器赋予这些类型更大的尺寸 &lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt; 类型 &lt;/th&gt;
&lt;th&gt; 含义 &lt;/th&gt;
&lt;th&gt; 最小尺寸 &lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;bool&lt;/td&gt;
&lt;td&gt; 布尔类型 &lt;/td&gt;
&lt;td&gt; 未定义 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;char&lt;/td&gt;
&lt;td&gt; 字符 &lt;/td&gt;
&lt;td&gt;8 位 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;wchar_t&lt;/td&gt;
&lt;td&gt; 宽字符 &lt;/td&gt;
&lt;td&gt;16 位 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;char16_t&lt;/td&gt;
&lt;td&gt;Unicode 字符 &lt;/td&gt;
&lt;td&gt;16 位 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;char32_t&lt;/td&gt;
&lt;td&gt;Unicode 字符 &lt;/td&gt;
&lt;td&gt;32 位 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;short&lt;/td&gt;
&lt;td&gt; 短整型 &lt;/td&gt;
&lt;td&gt;16 位 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt; 整型 &lt;/td&gt;
&lt;td&gt;16 位 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;long&lt;/td&gt;
&lt;td&gt; 长整型 &lt;/td&gt;
&lt;td&gt;32 位 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;long long&lt;/td&gt;
&lt;td&gt; 长整型 &lt;/td&gt;
&lt;td&gt;64 位 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;float&lt;/td&gt;
&lt;td&gt; 单精度浮点数 &lt;/td&gt;
&lt;td&gt;6 位有效数字 …&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</summary><content type="html">&lt;h2&gt; 类型 &lt;/h2&gt;
&lt;p&gt; 下表列出了 C++ 标准规定的数据类型尺寸的最小值，同时允许编译器赋予这些类型更大的尺寸 &lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt; 类型 &lt;/th&gt;
&lt;th&gt; 含义 &lt;/th&gt;
&lt;th&gt; 最小尺寸 &lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;bool&lt;/td&gt;
&lt;td&gt; 布尔类型 &lt;/td&gt;
&lt;td&gt; 未定义 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;char&lt;/td&gt;
&lt;td&gt; 字符 &lt;/td&gt;
&lt;td&gt;8 位 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;wchar_t&lt;/td&gt;
&lt;td&gt; 宽字符 &lt;/td&gt;
&lt;td&gt;16 位 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;char16_t&lt;/td&gt;
&lt;td&gt;Unicode 字符 &lt;/td&gt;
&lt;td&gt;16 位 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;char32_t&lt;/td&gt;
&lt;td&gt;Unicode 字符 &lt;/td&gt;
&lt;td&gt;32 位 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;short&lt;/td&gt;
&lt;td&gt; 短整型 &lt;/td&gt;
&lt;td&gt;16 位 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt; 整型 &lt;/td&gt;
&lt;td&gt;16 位 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;long&lt;/td&gt;
&lt;td&gt; 长整型 &lt;/td&gt;
&lt;td&gt;32 位 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;long long&lt;/td&gt;
&lt;td&gt; 长整型 &lt;/td&gt;
&lt;td&gt;64 位 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;float&lt;/td&gt;
&lt;td&gt; 单精度浮点数 &lt;/td&gt;
&lt;td&gt;6 位有效数字 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;double&lt;/td&gt;
&lt;td&gt; 双精度浮点数 &lt;/td&gt;
&lt;td&gt;10 位有效数字 &lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;long double&lt;/td&gt;
&lt;td&gt; 扩展精度浮点数 &lt;/td&gt;
&lt;td&gt;10 位有效数字 &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt; 一个 &lt;code&gt;char&lt;/code&gt; 的空间应确保可以存放机器基本字符集中任意字符对应的数字值。也就是说，一个 &lt;code&gt;char&lt;/code&gt; 的大小和一个机器字节一样。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;wchar_t&lt;/code&gt; 类型用于确保可以存放机器最大扩展字符集中的任意一个字符。&lt;/p&gt;
&lt;p&gt;C++ 语言规定，一个 &lt;code&gt;int&lt;/code&gt; 至少和一个 &lt;code&gt;short&lt;/code&gt; 一样大，一个 &lt;code&gt;long&lt;/code&gt; 至少和一个 &lt;code&gt;int&lt;/code&gt; 一样大，一个 &lt;code&gt;long long&lt;/code&gt; 至少和一个 &lt;code&gt;long&lt;/code&gt; 一样大。&lt;/p&gt;
&lt;p&gt; 可寻址的最小内存块成称为 “ 字节（byte）”，存储的基本单元称为 “ 字（word）”，它通常有几个字节组成。&lt;/p&gt;
&lt;p&gt; 在 C++ 语言中，一个字节至少能容纳机器基本字符串中的字符。大多数机器的字节由 8 比特构成，字则由 32 或 64 比特构成，也就是 4 字节或 8 字节。&lt;/p&gt;
&lt;p&gt;C++ 标准指定了一个浮点数有效位数的最小值，然而大多数编译器都实现了更高的精度。通常，&lt;code&gt;float&lt;/code&gt; 以 1 个字（32 比特）来表示，&lt;code&gt;double&lt;/code&gt; 以 2 个字（64 位）来表示，&lt;code&gt;long double&lt;/code&gt; 以 3 或 4 个字（96 或 128 比特）来表示。一般来说，&lt;code&gt;float&lt;/code&gt; 和 &lt;code&gt;double&lt;/code&gt; 分别有 7 和 16 个有效位；类型 &lt;code&gt;long double&lt;/code&gt; 则常常被用于有特殊浮点要求的硬件，它的具体实现不同，精度也各不相同。&lt;/p&gt;
&lt;p&gt; 类型 &lt;code&gt;int&lt;/code&gt;、&lt;code&gt;short&lt;/code&gt;、&lt;code&gt;long&lt;/code&gt; 和 &lt;code&gt;long long&lt;/code&gt; 都是带符号的，通过在这些类型名前添加 &lt;code&gt;unsigned&lt;/code&gt; 就可以得到无符号类型。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;char&lt;/code&gt;、&lt;code&gt;signed char&lt;/code&gt; 和 &lt;code&gt;unsigned char&lt;/code&gt;，&lt;code&gt;char&lt;/code&gt; 是否等于 &lt;code&gt;signed char&lt;/code&gt; 由编译器决定。&lt;/p&gt;
&lt;p&gt;C++ 标准并没有规定带符号类型应如何表示，但是约定了在表示范围内正值和负值的量应该平衡。因此，8 比特的 &lt;code&gt;signed char&lt;/code&gt; 理论上可以表示 -127 至 127 区间内的值，大多数现代计算机将实际的表示范围定为 -128 至 127。&lt;/p&gt;
&lt;h2&gt; 如何选择类型 &lt;/h2&gt;
&lt;p&gt; 明知数值不可能为负数，选用无符号类型。&lt;/p&gt;
&lt;p&gt; 如果数值超过了 &lt;code&gt;int&lt;/code&gt; 的表示范围，选用 &lt;code&gt;long long&lt;/code&gt;，因为 &lt;code&gt;long&lt;/code&gt; 一般和 &lt;code&gt;int&lt;/code&gt; 有一样的尺寸。&lt;/p&gt;
&lt;p&gt; 算术表达式中不要使用 &lt;code&gt;bool&lt;/code&gt; 或 &lt;code&gt;char&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt; 执行浮点数运算选用 &lt;code&gt;double&lt;/code&gt;。因为 &lt;code&gt;float&lt;/code&gt; 通常精度不够而且计算代价相差无几。&lt;code&gt;long double&lt;/code&gt; 提供的精度一般情况下是没有必要的而且计算代价大。&lt;/p&gt;
&lt;h2&gt; 类型转换 &lt;/h2&gt;
&lt;p&gt; 非布尔 -&amp;gt; 布尔：0 -&amp;gt; &lt;code&gt;false&lt;/code&gt;，其他 -&amp;gt; &lt;code&gt;ture&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt; 布尔 -&amp;gt; 非布尔：&lt;code&gt;false&lt;/code&gt;-&amp;gt; 0，&lt;code&gt;ture&lt;/code&gt; -&amp;gt; 1。&lt;/p&gt;
&lt;p&gt; 浮点 -&amp;gt; 整型：仅保留小数点前。&lt;/p&gt;
&lt;p&gt; 整型 -&amp;gt; 浮点：小数部分记为 0，如果该整数所占的空间超过浮点类型的容量，精度可能损失。&lt;/p&gt;
&lt;p&gt; 当我们赋给无符号类型一个超过它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。&lt;/p&gt;
&lt;p&gt; 当我们赋给带符号类型一个超出它表示范围的值时，结果是未定义的。此时，程序可能继续工作、可能崩溃，也可能生成垃圾数据。&lt;/p&gt;
&lt;p&gt; 当一个算术表达式中既有无符号数又有 &lt;code&gt;int&lt;/code&gt; 值时，那个 &lt;code&gt;int&lt;/code&gt; 会转换成无符号数。把 &lt;code&gt;int&lt;/code&gt; 转换成无符号数的过程和把 &lt;code&gt;int&lt;/code&gt; 赋值给无符号变量一样。&lt;/p&gt;
&lt;p&gt; 当从一个无符号数中减去一个值时，我们必须确保结果不是负值，否则实际结果会是取模后的值。&lt;/p&gt;
&lt;h2&gt; 字面值常量 &lt;/h2&gt;
&lt;p&gt; 整型和浮点型字面值。&lt;/p&gt;
&lt;p&gt; 字符和字符串字面值：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;‘a’ 和 “a”，字符串字面值最后补 ’\0’&lt;/li&gt;
&lt;li&gt; 如果两个字符串字面值位置紧邻且仅由空格、缩进和换行分隔，则它们是一个整体 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; 布尔字面值：&lt;code&gt;true&lt;/code&gt;、&lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt; 指针字面值：&lt;code&gt;nullptr&lt;/code&gt;。&lt;/p&gt;
&lt;h2&gt; 指定字面值的类型 &lt;/h2&gt;
&lt;p&gt; 字符和字符串字面值 &lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt; 前缀 &lt;/th&gt;
&lt;th&gt; 类型 &lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;u&lt;/td&gt;
&lt;td&gt;char16_t&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;U&lt;/td&gt;
&lt;td&gt;char32_t&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;L&lt;/td&gt;
&lt;td&gt;wchar_t&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;u8&lt;/td&gt;
&lt;td&gt;char&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt; 整型字面值 &lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt; 后缀 &lt;/th&gt;
&lt;th&gt; 最小匹配类型 &lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;u 或 U&lt;/td&gt;
&lt;td&gt;unsigned&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;l 或 L&lt;/td&gt;
&lt;td&gt;long&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ll 或 LL&lt;/td&gt;
&lt;td&gt;long long&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt; 浮点型字面值 &lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt; 后缀 &lt;/th&gt;
&lt;th&gt; 类型 &lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;f 或 F&lt;/td&gt;
&lt;td&gt;float&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;l 或 L&lt;/td&gt;
&lt;td&gt;long double&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt; 列表初始化 &lt;/h2&gt;
&lt;p&gt;&lt;code&gt;int units_sold{0}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt; 列表初始化的重要特点：如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将报错。&lt;/p&gt;
&lt;h2&gt; 默认初始化 &lt;/h2&gt;
&lt;p&gt; 内置类型变量 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt; 定义于任何函数之外，初始化为 0&lt;/li&gt;
&lt;li&gt; 定义于函数体内的局部静态变量，初始化为 0&lt;/li&gt;
&lt;li&gt; 定义于函数体内的非局部静态变量，不被初始化，试图拷贝或以其他方式访问此类值将引发错误 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; 每个类各自决定其初始化对象的方式。&lt;/p&gt;
&lt;h2&gt; 分离式编译 &lt;/h2&gt;
&lt;p&gt; 将程序分割为若干个文件，每个文件可被独立编译 &lt;/p&gt;
&lt;h2&gt; 声明 &lt;/h2&gt;
&lt;p&gt;&lt;code&gt;extern int i;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;extern&lt;/code&gt; 语句如果包含初始值就不再是声明，而变成定义了：&lt;code&gt;extern int i = 0;&lt;/code&gt; 在函数体内部，试图初始化一个由 &lt;code&gt;extern&lt;/code&gt; 关键字标记的变量将引发错误。&lt;/p&gt;
&lt;p&gt; 静态类型语言：在编译阶段执行类型检查 &lt;/p&gt;
&lt;h2&gt;C++ 标识符 &lt;/h2&gt;
&lt;p&gt; 字母、数字、下划线，必须以字母或下划线开头，长度无限制，大小写敏感。&lt;/p&gt;
&lt;p&gt;C++ 为标准库保留了一些名字 &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt; 自定义标识符中不能连续出现两个下划线 &lt;/li&gt;
&lt;li&gt; 不能以下划线紧接大写字母开头 &lt;/li&gt;
&lt;li&gt; 定义在函数体外的函数不能以下划线开头 &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt; 作用域操作符 ::&lt;/h2&gt;
&lt;p&gt; 若左侧为空，则指代全局作用域 &lt;/p&gt;
&lt;h2&gt; 复合类型 &lt;/h2&gt;
&lt;h3&gt; 引用 &lt;/h3&gt;
&lt;p&gt;&lt;code&gt;int &amp;amp;b = a;&lt;/code&gt;b 指向 a。&lt;/p&gt;
&lt;p&gt; 引用必须初始化。&lt;/p&gt;
&lt;p&gt; 引用本身不是一个对象，不能定义引用的引用。&lt;/p&gt;
&lt;p&gt; 引用必须绑定到对象上，不能绑定到字面值或者某个表达式的计算结果上。&lt;/p&gt;
&lt;p&gt; 除了两种例外，所有引用的类型都要和它所绑定的对象严格匹配：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt; 初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可 &lt;/li&gt;
&lt;li&gt; 允许将基类的引用绑定到派生类上 &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt; 指针 &lt;/h3&gt;
&lt;p&gt;&lt;code&gt;int *b = &amp;amp;a;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt; 指针是一个对象。&lt;/p&gt;
&lt;p&gt; 在块作用域内定义的指针如果未初始化，将拥有一个不确定的值。&lt;/p&gt;
&lt;p&gt; 除了两种例外，所有指针的类型都要和它所指向的对象严格匹配：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt; 允许一个指向常量的指针指向一个非常量对象 &lt;/li&gt;
&lt;li&gt; 允许将基类的指针绑定到派生类上 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; 试图拷贝或以其他方式访问无效指针的值将引起错误，编译器不负责检查此类错误。&lt;/p&gt;
&lt;p&gt; 任何非零的指针对应的条件值都是 true。&lt;/p&gt;
&lt;p&gt; 合法指针可以比较大小：== 或 !=。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;void *&lt;/code&gt; 是一个特殊的指针类型，可用于存放任意对象的地址，只支持有限的操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt; 拿它和别的指针比较 &lt;/li&gt;
&lt;li&gt; 作为函数的输入或输出 &lt;/li&gt;
&lt;li&gt; 赋给另外一个 &lt;code&gt;void *&lt;/code&gt; 指针 &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt; 理解复合类型的声明 &lt;/h2&gt;
&lt;p&gt; 变量的定义包括一个基本数据类型和一组声明符。&lt;/p&gt;
&lt;p&gt; 一条定义语句可能定义出不同类型的变量：&lt;code&gt;int i = 1024, *p = &amp;amp;i, &amp;amp;r =i;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt; 面对一条比较复杂的指针或者引用的声明语句时，从右往左阅读有助于弄清楚它的真实含义，例如：&lt;code&gt;int \*&amp;amp;r;&lt;/code&gt; 首先 r 是一个引用，其次 r 是一个指针的引用，再次 r 是一个指向整型指针的引用。&lt;/p&gt;
&lt;h2&gt;const 限定符 &lt;/h2&gt;
&lt;p&gt; 因为 &lt;code&gt;const&lt;/code&gt; 对象一旦创建就无法改变其值，所以必须初始化。&lt;/p&gt;
&lt;p&gt; 当用一个对象去初始化另外一个对象，它们是不是 &lt;code&gt;const&lt;/code&gt; 都无关紧要，常量的特性仅仅在执行改变其值的操作时才会发挥作用。&lt;/p&gt;
&lt;p&gt; 默认情况下，&lt;code&gt;const&lt;/code&gt; 对象仅在文件内有效。&lt;/p&gt;
&lt;p&gt; 如果想在多个文件之间共享 &lt;code&gt;const&lt;/code&gt; 对象，必须在变量的定义之前添加 &lt;code&gt;extern&lt;/code&gt; 关键字。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;const&lt;/code&gt; 的引用，常量引用的初始化：初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。尤其，允许为一个常量引用绑定非常量的对象、字面值甚至是一个表达式。实际上是通过绑定到一个临时量对象上实现的。&lt;/p&gt;
&lt;p&gt; 对 &lt;code&gt;const&lt;/code&gt; 的引用可能引用一个并非 &lt;code&gt;const&lt;/code&gt; 的对象，常量引用仅对引用可参与的操作做了限制，对于引用的对象本身是不是常量未做限制。&lt;/p&gt;
&lt;h2&gt; 指针和 const&lt;/h2&gt;
&lt;h3&gt; 指向常量的指针 &lt;/h3&gt;
&lt;p&gt; 允许一个指向常量的指针指向一个非常量对象。&lt;/p&gt;
&lt;p&gt; 仅对指向常量的指针可参与的操作做了限制，对于指向的对象本身是不是常量未做限制。&lt;/p&gt;
&lt;h3&gt;const 指针 &lt;/h3&gt;
&lt;p&gt; 指针是对象，可以把指针本身定为常量。&lt;/p&gt;
&lt;p&gt; 常量指针必须初始化，一经初始化就不能再改变。&lt;/p&gt;
&lt;p&gt; 把 * 放在 &lt;code&gt;const&lt;/code&gt; 关键字之前说明指针是一个常量。&lt;/p&gt;
&lt;h3&gt; 顶层和底层 const&lt;/h3&gt;
&lt;p&gt; 顶层 &lt;code&gt;const&lt;/code&gt;：指针本身是个常量。&lt;/p&gt;
&lt;p&gt; 底层 &lt;code&gt;const&lt;/code&gt;：指针所值的对象是一个常量。&lt;/p&gt;
&lt;p&gt; 更一般的，顶层 &lt;code&gt;const&lt;/code&gt; 可以表示任意的对象是常量，这一点对任意数据类型都适用。底层 &lt;code&gt;const&lt;/code&gt; 则与指针和引用等复合类型的基本类型部分有关。&lt;/p&gt;
&lt;p&gt; 执行对象的拷贝操作时，顶层 &lt;code&gt;const&lt;/code&gt; 不受影响；拷入和拷出的对象必须具有相同的底层 &lt;code&gt;const&lt;/code&gt; 资格，或者两个对象的数据类型必须能够转换。一般来说，非常量可以转换成常量，反之不行。&lt;/p&gt;
&lt;h3&gt;constexpr 和常量表达式 &lt;/h3&gt;
&lt;p&gt; 常量表达式：值不会改变并且在编译过程就能得到计算结果的表达式。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;constexpr&lt;/code&gt; 变量：由编译器来验证变量的值是否是一个常量表达式，声明为 &lt;code&gt;constexpr&lt;/code&gt; 的变量一定是一个常量，并且必须用常量表达式初始化。&lt;/p&gt;
&lt;p&gt; 字面值类型：算术类型、引用、指针、字面值常量类、枚举。&lt;/p&gt;
&lt;p&gt; 声明 &lt;code&gt;constexpr&lt;/code&gt; 用到的类型为字面值类型。&lt;/p&gt;
&lt;p&gt; 一个 &lt;code&gt;constexpr&lt;/code&gt; 指针的初始值必须是 &lt;code&gt;nullptr&lt;/code&gt; 或者 0，或者是存储于某个固定地址中的对象：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt; 函数体内定义的变量一般并非存放在固定地址中，&lt;code&gt;constexpr&lt;/code&gt; 指针不能指向这样的变量（局部静态对象除外）&lt;/li&gt;
&lt;li&gt; 定义于所有函数体之外的对象地址固定不变，能用来初始化 &lt;code&gt;constexpr&lt;/code&gt; 指针 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; 在 &lt;code&gt;constexpr&lt;/code&gt; 声明中如果定义了一个指针，限定符 &lt;code&gt;constexpr&lt;/code&gt; 仅对指针有效，与指针所指的对象无关。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;constexpr&lt;/code&gt; 把它所定义的对象置为顶层 &lt;code&gt;const&lt;/code&gt;。&lt;/p&gt;
&lt;h2&gt; 处理类型 &lt;/h2&gt;
&lt;h3&gt; 类型别名 &lt;/h3&gt;
&lt;p&gt;&lt;code&gt;typedef double wages;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;using SI = Sales_item;&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;auto 类型说明符 &lt;/h3&gt;
&lt;p&gt; 让编译器自己去分析表达式所属的类型。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;auto&lt;/code&gt; 也能在一条语句中声明多个变量。因为一条声明语句只能有一个基本数据类型，所以该语句中所有变量的基本数据类型都必须一样。&lt;/p&gt;
&lt;p&gt; 当引用被用作初始化 &lt;code&gt;auto&lt;/code&gt; 变量时，编译器以引用所引用对象的类型作为 &lt;code&gt;auto&lt;/code&gt; 的类型。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;auto&lt;/code&gt; 一般会忽略顶层 &lt;code&gt;const&lt;/code&gt;，同时底层 &lt;code&gt;const&lt;/code&gt; 会保留下来。&lt;/p&gt;
&lt;p&gt; 如果希望推断出的 &lt;code&gt;auto&lt;/code&gt; 类型是一个顶层 &lt;code&gt;const&lt;/code&gt;，需要明确指出。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;auto&lt;/code&gt; 引用 &lt;code&gt;auto &amp;amp;b = a;&lt;/code&gt; 初始值 a 的顶层 &lt;code&gt;const&lt;/code&gt; 会保留。&lt;/p&gt;
&lt;h3&gt;decltype 类型指示符 &lt;/h3&gt;
&lt;p&gt; 选择并返回操作数的数据类型，编译器分析表达式得到它的类型，却不实际计算表达式的值，编译器并不实际调用 f。&lt;/p&gt;
&lt;p&gt; 如果 &lt;code&gt;decltype&lt;/code&gt; 使用的表达式是一个变量，则 &lt;code&gt;decltype&lt;/code&gt; 返回该变量的类型（包括顶层 &lt;code&gt;const&lt;/code&gt; 和引用在内），需要指出的是，引用从来都作为其所指对象的同义词出现，只有在 &lt;code&gt;decltype&lt;/code&gt; 处是一个例外。&lt;/p&gt;
&lt;p&gt; 如果 &lt;code&gt;decltype&lt;/code&gt; 使用的表达式不是一个变量，则 &lt;code&gt;decltype&lt;/code&gt; 返回该表达式的结果对应的类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt; 因为 r 是一个引用，&lt;code&gt;decltype(r)&lt;/code&gt; 的结果是引用类型，如果想让结果类型是 r 所指的类型，可以把 r 作为表达式的一部分，显然这个表达式的结果是一个具体的值而非一个引用 &lt;/li&gt;
&lt;li&gt; 如果表达式的内容是解引用操作，则 &lt;code&gt;decltype&lt;/code&gt; 将得到引用类型 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt; 如果 &lt;code&gt;decltype&lt;/code&gt; 使用的表达式是一个变量：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt; 不加括号，得到该变量的类型 &lt;/li&gt;
&lt;li&gt; 加括号，得到引用类型 &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt; 自定义数据结构：结构体和类 &lt;/h2&gt;
&lt;p&gt; 记得定义末尾的分号。可以类内初始化。&lt;/p&gt;
&lt;h2&gt; 头文件保护符 &lt;/h2&gt;
&lt;p&gt; 头文件保护符依赖于预处理变量。&lt;/p&gt;
&lt;p&gt; 预处理变量由两个状态：已定义和未定义。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;#define&lt;/code&gt; 指令把一个名字设定为预处理变量。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;#ifdef&lt;/code&gt; 当且仅当变量已定义时为真。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;#ifndef&lt;/code&gt; 当且仅当变量未定义时为真。&lt;/p&gt;
&lt;p&gt; 一旦检查结果为真，则执行后续操作直到遇到 &lt;code&gt;#endif&lt;/code&gt; 指令为止 &lt;/p&gt;</content><category term="C++"></category></entry><entry><title>【读书笔记】C++ Primer 第一章</title><link href="https://xutree.github.io/pages/2018/10/05/C++_Primer_Chapter_1/" rel="alternate"></link><published>2018-10-05T23:11:35+08:00</published><updated>2018-10-07T08:46:31+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-05:/pages/2018/10/05/C++_Primer_Chapter_1/</id><summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;code&gt;g++ -std=c++14  -Wall -o test test.cpp&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iostream&lt;/code&gt; &lt;code&gt;cin&lt;/code&gt; &lt;code&gt;cout&lt;/code&gt; &lt;code&gt;cerr&lt;/code&gt; &lt;code&gt;clog&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 运算符返回其左侧的运算对象 &lt;/li&gt;
&lt;li&gt; 写入 &lt;code&gt;endl&lt;/code&gt; 的效果是结束当前行，并将与设备关联的缓冲区中的内容刷到设备中。缓冲刷新操作可以保证到目前为止程序所产生的所有输出都真正写入到输出流中，而不是仅停留在内存中等待写入流 &lt;/li&gt;
&lt;li&gt; 小心程序崩溃，输出可能还留在缓冲区的情况，利用 &lt;code&gt;endl&lt;/code&gt;&lt;/li&gt;
&lt;li&gt; 标准库定义的所有名字都在命名空间 &lt;code&gt;std&lt;/code&gt; 中 &lt;/li&gt;
&lt;li&gt; 当我们使用一个 &lt;code&gt;istream&lt;/code&gt; 对象作为条件时，其效果是检测流的状态。流有效，即流未遇到错误，那么检测成功。当遇到文件结束符（end of file），或遇到一个无效输入时，&lt;code&gt;istream&lt;/code&gt; 对象的状态会变为无效。无效的 &lt;code&gt;istream&lt;/code&gt; 对象会使条件为假 &lt;/li&gt;
&lt;li&gt; 文件结束符：Windows 先 Ctrl + Z …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;ul&gt;
&lt;li&gt;&lt;code&gt;g++ -std=c++14  -Wall -o test test.cpp&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iostream&lt;/code&gt; &lt;code&gt;cin&lt;/code&gt; &lt;code&gt;cout&lt;/code&gt; &lt;code&gt;cerr&lt;/code&gt; &lt;code&gt;clog&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 运算符返回其左侧的运算对象 &lt;/li&gt;
&lt;li&gt; 写入 &lt;code&gt;endl&lt;/code&gt; 的效果是结束当前行，并将与设备关联的缓冲区中的内容刷到设备中。缓冲刷新操作可以保证到目前为止程序所产生的所有输出都真正写入到输出流中，而不是仅停留在内存中等待写入流 &lt;/li&gt;
&lt;li&gt; 小心程序崩溃，输出可能还留在缓冲区的情况，利用 &lt;code&gt;endl&lt;/code&gt;&lt;/li&gt;
&lt;li&gt; 标准库定义的所有名字都在命名空间 &lt;code&gt;std&lt;/code&gt; 中 &lt;/li&gt;
&lt;li&gt; 当我们使用一个 &lt;code&gt;istream&lt;/code&gt; 对象作为条件时，其效果是检测流的状态。流有效，即流未遇到错误，那么检测成功。当遇到文件结束符（end of file），或遇到一个无效输入时，&lt;code&gt;istream&lt;/code&gt; 对象的状态会变为无效。无效的 &lt;code&gt;istream&lt;/code&gt; 对象会使条件为假 &lt;/li&gt;
&lt;li&gt; 文件结束符：Windows 先 Ctrl + Z，后 Enter 或 Return；UNIX：Ctrl +D&lt;/li&gt;
&lt;li&gt; 标准库文件通常不带后缀。编译器一般不关心头文件名的形式，但有的 IDE 对此有特定要求 &lt;/li&gt;
&lt;li&gt; 头文件包含：标准库头文件 &amp;lt;&amp;gt;     非标准库头文件 ""&lt;/li&gt;
&lt;li&gt; 文件重定向：从文件读入 \&amp;lt;infile，输出到文件 &gt;outfile&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cerr&lt;/code&gt;( 无缓冲标准错误 ) 没有缓冲，发送给它的内容立即被输出 &lt;/li&gt;
&lt;li&gt;&lt;code&gt;clog&lt;/code&gt;( 缓冲标准错误 )  有缓冲，缓冲区满时输出 &lt;/li&gt;
&lt;li&gt;&lt;code&gt;cout&lt;/code&gt; 标准输出 &lt;/li&gt;
&lt;li&gt;&lt;code&gt;cout&lt;/code&gt; 是在终端显示器输出，&lt;code&gt;cout&lt;/code&gt; 流在内存中对应开辟了一个缓冲区，用来存放流中的数据，当向 &lt;code&gt;cout&lt;/code&gt; 流插入一个 &lt;code&gt;endl&lt;/code&gt;，不论缓冲区是否满了，都立即输出流中所有数据，然后插入一个换行符 &lt;/li&gt;
&lt;li&gt;&lt;code&gt;cerr&lt;/code&gt; 流对象是标准错误流，指定为和显示器关联，和 &lt;code&gt;cout&lt;/code&gt; 作用差不多，有点不同就是 &lt;code&gt;cout&lt;/code&gt; 通常是传到显示器输出，但可以被重定向输出到文件，而 &lt;code&gt;cerr&lt;/code&gt; 流中的信息只能在显示器输出 &lt;/li&gt;
&lt;li&gt;&lt;code&gt;clog&lt;/code&gt; 流也是标准错误流，作用和 &lt;code&gt;cerr&lt;/code&gt; 一样，区别在于 &lt;code&gt;cerr&lt;/code&gt; 不经过缓冲区，直接向显示器输出信息，而 &lt;code&gt;clog&lt;/code&gt; 中的信息存放在缓冲区，缓冲区满或者遇到 &lt;code&gt;endl&lt;/code&gt; 时才输出 &lt;/li&gt;
&lt;li&gt; 对于为什么有 &lt;code&gt;cerr&lt;/code&gt; 和 &lt;code&gt;clog&lt;/code&gt;？比如，你的程序遇到调用栈用完了的威胁（无限，没有出口的递归。你说，你到什么地方借内存，存放你的错误信息？所以有了 &lt;code&gt;cerr&lt;/code&gt;。其目的，就是在你最需要它的紧急情况下，还能得到输出功能的支持 &lt;/li&gt;
&lt;li&gt; 缓冲区的目的，就是减少刷屏的次数 —— 比如，你的程序输出圣经中的一篇文章。不带缓冲的话，就会每写一个字母，就输出一个字母，然后刷屏。有了缓冲，你将看到若干句子 “ 同时 ” 就出现在了屏幕上（由内存翻新到显存，然后刷新屏幕）&lt;/li&gt;
&lt;/ul&gt;</content><category term="C++"></category></entry></feed>