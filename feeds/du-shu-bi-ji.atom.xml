<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>You Know Nothing - 读书笔记</title><link href="https://xutree.github.io/" rel="alternate"></link><link href="https://xutree.github.io/feeds/du-shu-bi-ji.atom.xml" rel="self"></link><id>https://xutree.github.io/</id><updated>2018-11-11T17:55:33+08:00</updated><entry><title>统计学习方法 第七章 支持向量机</title><link href="https://xutree.github.io/pages/2018/11/11/7/" rel="alternate"></link><published>2018-11-11T13:47:48+08:00</published><updated>2018-11-11T17:55:33+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-11-11:/pages/2018/11/11/7/</id><summary type="html">&lt;p&gt;支持向量机（support vector machines，SVM）是一种二分类模型。它的基本模型是定义在特征空间上的间隔最大的线性分类器，间隔最大使它有别于感知机；支持向量机还包括核技巧，这使它成为实质上的非线性分类器。&lt;/p&gt;
&lt;p&gt;支持向量机的学习策略就是间隔最大化，可形式化为一个求解凸二次规划（convex quadratic programming）的问题，也等价于正则化的合页损失函数的最小化问题。支持向量机的学习算法是求解凸二次规划的最优化算法。&lt;/p&gt;
&lt;p&gt;支持向量机学习方法包含构建由间至繁的模型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线性可分支持向量机（linear support vector machine in linearly separable case）：数据线性可分，通过硬间隔最大化（hard margin maximization），学习一个线性分类器&lt;/li&gt;
&lt;li&gt;线性支持向量机（linear support vector machine）：数据近似线性可分，通过软间隔最大化（soft margin maximization），学习一个线性分类器，又称软间隔支持向量机&lt;/li&gt;
&lt;li&gt;非线性支持向量机（non-linear support …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;支持向量机（support vector machines，SVM）是一种二分类模型。它的基本模型是定义在特征空间上的间隔最大的线性分类器，间隔最大使它有别于感知机；支持向量机还包括核技巧，这使它成为实质上的非线性分类器。&lt;/p&gt;
&lt;p&gt;支持向量机的学习策略就是间隔最大化，可形式化为一个求解凸二次规划（convex quadratic programming）的问题，也等价于正则化的合页损失函数的最小化问题。支持向量机的学习算法是求解凸二次规划的最优化算法。&lt;/p&gt;
&lt;p&gt;支持向量机学习方法包含构建由间至繁的模型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线性可分支持向量机（linear support vector machine in linearly separable case）：数据线性可分，通过硬间隔最大化（hard margin maximization），学习一个线性分类器&lt;/li&gt;
&lt;li&gt;线性支持向量机（linear support vector machine）：数据近似线性可分，通过软间隔最大化（soft margin maximization），学习一个线性分类器，又称软间隔支持向量机&lt;/li&gt;
&lt;li&gt;非线性支持向量机（non-linear support vector machine）：数据线性不可分，通过核技巧（kernel trick）及软间隔最大化，学习一个非线性分类器&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;7.1 线性可分支持向量机与硬间隔最大化&lt;/h2&gt;
&lt;h3&gt;7.1.1 线性可分支持向量机&lt;/h3&gt;
&lt;p&gt;一般的，当训练数据集线性可分时，存在无穷多个分离超平面可将两类数据正确分开。感知机利用分类误差最小的策略，求得分离超平面，不过这是的解有无穷多个。线性可分支持向量机利用间隔最大化求解最优分离超平面，这时，解是唯一的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;
定义 7.1（线性可分支持向量机）给定线性可分训练数据集，通过间隔最大化或等价的求解相应的凸二次规划问题学习得到的分离超平面为
&lt;div class="math"&gt;$$w^\star\cdot x+b^\star=0$$&lt;/div&gt;
以及相应的分类决策函数
&lt;div class="math"&gt;$$f(x)=\text{sign}(w^\star\cdot x+b^\star)$$&lt;/div&gt;
称为线性可分支持向量机。
&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;7.1.2 函数间隔和几何间隔&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;
定义 7.2（函数间隔）对于给定的训练数据集 &lt;span class="math"&gt;\(T\)&lt;/span&gt; 和超平面 &lt;span class="math"&gt;\((w,b)\)&lt;/span&gt;，定义超平面 &lt;span class="math"&gt;\((w,b)\)&lt;/span&gt; 关于样本点 &lt;span class="math"&gt;\((x_i,y_i)\)&lt;/span&gt; 的函数间隔为
&lt;div class="math"&gt;$$\hat{\gamma}_i=y_i(w\cdot x_i+b)$$&lt;/div&gt;
定义超平面 &lt;span class="math"&gt;\((w,b)\)&lt;/span&gt; 关于训练数据集 &lt;span class="math"&gt;\(T\)&lt;/span&gt; 的函数间隔为
&lt;div class="math"&gt;$$\hat{\gamma}=\min_{i=1,2,\cdots,N}\hat{\gamma}_i$$&lt;/div&gt;
&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;函数间隔（functional margin）可以表示分类预测的正确性和确信度，但是具有不确定因子，我们需要对分离超平面的法向量 &lt;span class="math"&gt;\(w\)&lt;/span&gt; 加以约束，使得间隔是确定的。这时函数间隔就成了几何间隔（geometric margin）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;
定义 7.2（几何间隔）对于给定的训练数据集 &lt;span class="math"&gt;\(T\)&lt;/span&gt; 和超平面 &lt;span class="math"&gt;\((w,b)\)&lt;/span&gt;，定义超平面 &lt;span class="math"&gt;\((w,b)\)&lt;/span&gt; 关于样本点 &lt;span class="math"&gt;\((x_i,y_i)\)&lt;/span&gt; 的几何间隔为
&lt;div class="math"&gt;$$\gamma_i=y_i\left(\frac{w}{\|w\|}\cdot x_i+\frac{b}{\|w\|}\right)$$&lt;/div&gt;
定义超平面 &lt;span class="math"&gt;\((w,b)\)&lt;/span&gt; 关于训练数据集 &lt;span class="math"&gt;\(T\)&lt;/span&gt; 的几何间隔为
&lt;div class="math"&gt;$$\gamma=\min_{i=1,2,\cdots,N}\gamma_i$$&lt;/div&gt;
&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;易知：
&lt;/p&gt;
&lt;div class="math"&gt;$$\gamma_i=\frac{\hat{\gamma}_i}{\|w\|} \\
\gamma=\frac{\hat{\gamma}}{\|w\|}$$&lt;/div&gt;
&lt;p&gt;
如果超平面参数 &lt;span class="math"&gt;\(w\)&lt;/span&gt; 和 &lt;span class="math"&gt;\(b\)&lt;/span&gt; 成比例变化（超平面没有改变），函数间隔也按此比例变化，几何间隔不变。&lt;/p&gt;
&lt;h3&gt;7.1.3 间隔最大化&lt;/h3&gt;
&lt;p&gt;间隔最大化的直观解释：对训练数据集找到几何间隔最大的超平面意味着以充分大的确定度对训练数据进行分类。这样的超平面对未知的新实例有很好的分类预测能力。&lt;/p&gt;
&lt;h4&gt;最大间隔分离超平面&lt;/h4&gt;
&lt;p&gt;求解几何间隔最大的分离超平面问题即求解下面的约束最优化问题：
&lt;/p&gt;
&lt;div class="math"&gt;$$\max_{w,b}\ \gamma \\
\text{s.t.}\ \ \ \ y_i\left(\frac{w}{\|w\|}\cdot x_i+\frac{b}{\|w\|}\right)\geq\gamma,\ i=1,2,\cdots,N$$&lt;/div&gt;
&lt;p&gt;
可改写为：
&lt;/p&gt;
&lt;div class="math"&gt;$$\max_{w,b}\ \frac{\hat{\gamma}}{\|w\|} \\
\text{s.t.}\ \ \ \ y_i\left(w\cdot x_i+b\right)\geq\hat{\gamma},\ i=1,2,\cdots,N$$&lt;/div&gt;
&lt;p&gt;
对于上式来说，假设将分离超平面 &lt;span class="math"&gt;\((w,b)\)&lt;/span&gt; 按比例改变为 &lt;span class="math"&gt;\((\lambda w,\lambda b)\)&lt;/span&gt;，这时函数间隔变为 &lt;span class="math"&gt;\(\lambda \hat{\gamma}\)&lt;/span&gt;，所以对目标函数和约束条件都没有影响。那么，如果我们做如下变换：
&lt;/p&gt;
&lt;div class="math"&gt;$$(w,b)\to(\frac{1}{\hat{\gamma}}w,\frac{1}{\hat{\gamma}}b)$$&lt;/div&gt;
&lt;p&gt;
则函数间隔变为 1，故上述问题可改写为：
&lt;/p&gt;
&lt;div class="math"&gt;$$\max_{w,b}\ \frac{1}{\|w\|} \\
\text{s.t.}\ \ \ \ y_i\left(w\cdot x_i+b\right)\geq 1,\ i=1,2,\cdots,N$$&lt;/div&gt;
&lt;p&gt;
注意到最大化 &lt;span class="math"&gt;\(\frac{1}{\|w\|}\)&lt;/span&gt; 和最小化 &lt;span class="math"&gt;\(\frac{1}{2}\|w\|^2\)&lt;/span&gt; 是等价的，于是问题变为：
&lt;/p&gt;
&lt;div class="math"&gt;$$\min_{w,b}\ \frac{1}{2}\|w\|^2 \\
\text{s.t.}\ \ \ \ y_i\left(w\cdot x_i+b\right)-1\geq0,\ i=1,2,\cdots,N$$&lt;/div&gt;
&lt;p&gt;
这是一个凸二次规划问题。&lt;/p&gt;
&lt;p&gt;凸优化问题是指约束最优化问题
&lt;/p&gt;
&lt;div class="math"&gt;$$\min_w\ f(w) \\
\text{s.t.}\ \ \ \ \begin{eqnarray}
g_i(x) &amp;amp;\leq0&amp;amp;,\ i=1,2\cdots,k \\
h_i(w) &amp;amp;=&amp;amp; 0,\ i=1,2,\cdots,l
\end{eqnarray}
$$&lt;/div&gt;
&lt;p&gt;
其中，目标函数 &lt;span class="math"&gt;\(f(w)\)&lt;/span&gt; 和约束函数 &lt;span class="math"&gt;\(g_i(w)\)&lt;/span&gt; 都是 &lt;span class="math"&gt;\(\mathbb{R}^n\)&lt;/span&gt; 上的连续可微凸函数，约束函数 &lt;span class="math"&gt;\(h_i(w)\)&lt;/span&gt; 是 &lt;span class="math"&gt;\(\mathbb{R}^n\)&lt;/span&gt; 上的仿射函数（即满足 &lt;span class="math"&gt;\(h_i(w)=a\cdot w+b\)&lt;/span&gt; 的形式）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;
算法 7.1（线性可分支持向量机学习算法——最大间隔法）&lt;br&gt;
输入：线性可分训练数据集 &lt;span class="math"&gt;\(T=\{(x_1,y_1),(x_2,y_2),\cdots,(x_N,y_N)\}\)&lt;/span&gt;，其中 &lt;span class="math"&gt;\(x_i\in{\cal X}=\mathbb{R}^n\)&lt;/span&gt;，&lt;span class="math"&gt;\(y_i\in{\cal Y}=\{+1,-1\}\)&lt;/span&gt;，&lt;span class="math"&gt;\(i=1,2,\cdots,N\)&lt;/span&gt;&lt;br&gt;
输出：最大间隔分离超平面和分类决策函数&lt;br&gt;
(1) 构造并求解约束最优化问题
&lt;div class="math"&gt;$$\min_{w,b}\ \frac{1}{2}\|w\|^2 \\
\text{s.t.}\ \ \ \ y_i\left(w\cdot x_i+b\right)-1\geq0,\ i=1,2,\cdots,N$$&lt;/div&gt;
求得最优解 &lt;span class="math"&gt;\(w^\star\)&lt;/span&gt;，&lt;span class="math"&gt;\(b^\star\)&lt;/span&gt;&lt;br&gt;
(2) 由此得到分离超平面
&lt;div class="math"&gt;$$w^\star\cdot x+b^\star=0$$&lt;/div&gt;
分类决策函数
&lt;div class="math"&gt;$$f(x)=\text{sign}(w^\star\cdot x+b^\star)$$&lt;/div&gt;
&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上面的算法就是最大间隔法（maximum margin method）。&lt;/p&gt;
&lt;h4&gt;最大间隔分离超平面的存在唯一性&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;
定理 7.1（最大间隔分离超平面的存在唯一性）若训练数据集线性可分，则可将训练数据集中的样本点完全正确分开的最大间隔分离超平面存在且唯一。
&lt;/strong&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="统计学习"></category><category term="机器学习"></category></entry><entry><title>统计学习方法 第六章 逻辑回归与最大熵模型</title><link href="https://xutree.github.io/pages/2018/11/09/6/" rel="alternate"></link><published>2018-11-09T16:17:17+08:00</published><updated>2018-11-11T13:21:32+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-11-09:/pages/2018/11/09/6/</id><summary type="html">&lt;p&gt;逻辑回归（logistic regression）是统计学习中的经典分类方法。最大熵是概率模型学习的一个准则，将其推广到分类问题得到最大熵模型（maximum entropy model）。&lt;/p&gt;
&lt;p&gt;逻辑回归模型和最大熵模型都属于对数线性模型。&lt;/p&gt;
&lt;h2&gt;6.1 逻辑回归模型&lt;/h2&gt;
&lt;h3&gt;6.1.1 逻辑分布&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;
定义 6.1（逻辑分布）设 &lt;span class="math"&gt;\(X\)&lt;/span&gt; 是连续随机变量，&lt;span class="math"&gt;\(X\)&lt;/span&gt; 服从逻辑分布是指 &lt;span class="math"&gt;\(X\)&lt;/span&gt; 具有下列分布函数和密度函数：
&lt;div class="math"&gt;$$\begin{eqnarray}
F(x) &amp;amp;=&amp;amp; P(X\leq x)=\frac{1}{1+\text{e}^{-(x-\mu)/\gamma}} \\
f(x) &amp;amp;=&amp;amp; F'(x)=\frac …&lt;/div&gt;&lt;/strong&gt;&lt;/p&gt;&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><content type="html">&lt;p&gt;逻辑回归（logistic regression）是统计学习中的经典分类方法。最大熵是概率模型学习的一个准则，将其推广到分类问题得到最大熵模型（maximum entropy model）。&lt;/p&gt;
&lt;p&gt;逻辑回归模型和最大熵模型都属于对数线性模型。&lt;/p&gt;
&lt;h2&gt;6.1 逻辑回归模型&lt;/h2&gt;
&lt;h3&gt;6.1.1 逻辑分布&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;
定义 6.1（逻辑分布）设 &lt;span class="math"&gt;\(X\)&lt;/span&gt; 是连续随机变量，&lt;span class="math"&gt;\(X\)&lt;/span&gt; 服从逻辑分布是指 &lt;span class="math"&gt;\(X\)&lt;/span&gt; 具有下列分布函数和密度函数：
&lt;div class="math"&gt;$$\begin{eqnarray}
F(x) &amp;amp;=&amp;amp; P(X\leq x)=\frac{1}{1+\text{e}^{-(x-\mu)/\gamma}} \\
f(x) &amp;amp;=&amp;amp; F'(x)=\frac{\text{e}^{-(x-\mu)/\gamma}}{\gamma(1+\text{e}^{-(x-\mu)/\gamma})^2}
\end{eqnarray}$$&lt;/div&gt;
式中，&lt;span class="math"&gt;\(\mu\)&lt;/span&gt; 为位置参数，&lt;span class="math"&gt;\(\gamma&amp;gt;0\)&lt;/span&gt; 为形状参数。
&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下图中绘制了对于不用 &lt;span class="math"&gt;\(\gamma\)&lt;/span&gt; 逻辑分布函数和概率密度函数。分布函数是一条 S 形曲线（sigmoid curve）。该曲线以点 &lt;span class="math"&gt;\(\left(\mu,\frac{1}{2}\right)\)&lt;/span&gt; 为中心对称，即满足
&lt;/p&gt;
&lt;div class="math"&gt;$$F(-x+\mu)+F(x+\mu)=1$$&lt;/div&gt;
&lt;p&gt;&lt;img alt="逻辑分布" src="https://xutree.github.io/images/statistical_learning_6.1.png"&gt;&lt;/p&gt;
&lt;p&gt;曲线在中心附近增长速度较快，在两端增长速度较慢。&lt;/p&gt;
&lt;h3&gt;6.1.2 二项逻辑回归模型&lt;/h3&gt;
&lt;p&gt;二项逻辑回归模型（binomial logistic regression model）是一种分类模型，由条件概率 &lt;span class="math"&gt;\(P(Y|X)\)&lt;/span&gt; 表示，形式为参数化的逻辑分布。这里，随机变量 &lt;span class="math"&gt;\(X\)&lt;/span&gt; 取值为实数，随机变量 &lt;span class="math"&gt;\(Y\)&lt;/span&gt; 取值为 1 或 0，我们通过监督学习的方法来估计模型参数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;
定义 6.2 （逻辑回归模型）二项逻辑回归模型是如下的条件概率分布：
&lt;div class="math"&gt;$$\begin{eqnarray}
P(Y=1|x) &amp;amp;=&amp;amp; \frac{\exp(w\cdot x+b)}{1+\exp(w\cdot x+b)} \\
P(Y=0|x) &amp;amp;=&amp;amp; \frac{1}{1+\exp(w\cdot x+b)}
\end{eqnarray}$$&lt;/div&gt;
这里，&lt;span class="math"&gt;\(x\in\mathbb{R}^n\)&lt;/span&gt; 是输入，&lt;span class="math"&gt;\(Y\in\{0,1\}\)&lt;/span&gt; 是输出，&lt;span class="math"&gt;\(w\in\mathbb{R}^n\)&lt;/span&gt; 和 &lt;span class="math"&gt;\(b\in\mathbb{R}\)&lt;/span&gt; 是参数（分别称为权重向量和偏置），&lt;span class="math"&gt;\(w\cdot x\)&lt;/span&gt; 是内积。
&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于给定的输入实例 &lt;span class="math"&gt;\(x\)&lt;/span&gt;，按照定义 6.2 可以求得 &lt;span class="math"&gt;\(P(Y=1|x)\)&lt;/span&gt; 和 &lt;span class="math"&gt;\(P(Y=0|x)\)&lt;/span&gt;。逻辑回归比较两个概率值的大小，将实例 &lt;span class="math"&gt;\(x\)&lt;/span&gt; 分到概率值较大的那一类。&lt;/p&gt;
&lt;p&gt;有时为了方便，将权重向量和输入向量加以扩充，即
&lt;/p&gt;
&lt;div class="math"&gt;$$w=\left(w^{(1)},w^{(2)},\cdots,w^{(n)},1\right)^\text{T}\\
x=\left(x^{(1)},x^{(2)},\cdots,x^{(n)},1\right)^\text{T}$$&lt;/div&gt;
&lt;p&gt;
这时，逻辑回归模型如下：
&lt;/p&gt;
&lt;div class="math"&gt;$$\begin{eqnarray}
P(Y=1|x) &amp;amp;=&amp;amp; \frac{\exp(w\cdot x)}{1+\exp(w\cdot x)} \\
P(Y=0|x) &amp;amp;=&amp;amp; \frac{1}{1+\exp(w\cdot x)}
\end{eqnarray}$$&lt;/div&gt;
&lt;p&gt;一个事件的几率（odds）是指该事件发生的概率与该事件不发生的概率的比值，该事件的对数几率（log odds）或 logit 函数是
&lt;/p&gt;
&lt;div class="math"&gt;$$\text{logit}(p)=\log\frac{p}{1-p}$$&lt;/div&gt;
&lt;p&gt;对逻辑回归而言，由扩充后的回归模型得
&lt;/p&gt;
&lt;div class="math"&gt;$$\text{logit}\left(P(Y=1|x)\right)=\log\frac{P(Y=1|x)}{1-P(Y=1|x)}=w\cdot x$$&lt;/div&gt;
&lt;p&gt;
也就是说，输出 &lt;span class="math"&gt;\(Y=1\)&lt;/span&gt; 的对数几率是输入 &lt;span class="math"&gt;\(x\)&lt;/span&gt; 的线性函数，或者说，输出 &lt;span class="math"&gt;\(Y=1\)&lt;/span&gt; 的对数几率是由输入 &lt;span class="math"&gt;\(x\)&lt;/span&gt; 的线性函数表示的模型，即逻辑回归模型。&lt;/p&gt;
&lt;p&gt;换一个角度看，考虑对输入 &lt;span class="math"&gt;\(x\)&lt;/span&gt; 进行分类的线性函数 &lt;span class="math"&gt;\(w\cdot x\)&lt;/span&gt;（扩充后的），其值域为实数域。通过逻辑回归模型定义式可以将线性函数 &lt;span class="math"&gt;\(w\cdot x\)&lt;/span&gt; 转换为概率
&lt;/p&gt;
&lt;div class="math"&gt;$$P(Y=1|x)=\frac{\exp(w\cdot x)}{1+\exp(w\cdot x)}$$&lt;/div&gt;
&lt;p&gt;
上面的分布实际上是逻辑分布。这是，线性函数的值越接近 &lt;span class="math"&gt;\(+\infty\)&lt;/span&gt;，概率值就越接近 1；线性函数的值越接近 &lt;span class="math"&gt;\(-\infty\)&lt;/span&gt;，概率在就越接近 0。这样的模型就是逻辑回归模型。&lt;/p&gt;
&lt;h3&gt;6.1.3 模型参数估计&lt;/h3&gt;
&lt;p&gt;逻辑回归模型学习时，对于给定的训练数据集
&lt;/p&gt;
&lt;div class="math"&gt;$$T=\{(x_1,y_1),(x_2,y_2),\cdots,(x_N,y_N)\}$$&lt;/div&gt;
&lt;p&gt;
其中 &lt;span class="math"&gt;\(x_i\in\mathbb{R}^n\)&lt;/span&gt;，&lt;span class="math"&gt;\(y_i\in\{0,1\}\)&lt;/span&gt;，可以应用极大似然估计法估计模型参数，从而得到逻辑回归模型。&lt;/p&gt;
&lt;p&gt;设
&lt;/p&gt;
&lt;div class="math"&gt;$$P(Y=1|x) = \pi(x) \\
P(Y=0|x) = 1-\pi(x)$$&lt;/div&gt;
&lt;p&gt;
似然函数为
&lt;/p&gt;
&lt;div class="math"&gt;$$\prod_{i=1}^N\left[\pi(x_i)\right]^{y_i}\left[1-\pi(x_i)\right]^{1-y_i}$$&lt;/div&gt;
&lt;p&gt;
对数似然函数为
&lt;/p&gt;
&lt;div class="math"&gt;$$\begin{eqnarray}
L(w) &amp;amp;=&amp;amp; \sum_{i=1}^N\left[y_i\log\pi(x_i)+(1-y_i)\log(1-\pi(x_i))\right] \\
&amp;amp;=&amp;amp; \sum_{i=1}^N\left[y_i\log\frac{\pi(x_i)}{1-\pi(x_i)}+\log(1-\pi(x_i))\right] \\
&amp;amp;=&amp;amp; \sum_{i=1}^N[y_i(w\cdot x_i)-\log(1+\exp(w\cdot x_i))]
\end{eqnarray}$$&lt;/div&gt;
&lt;p&gt;
对 &lt;span class="math"&gt;\(L(w)\)&lt;/span&gt; 求极大值，得到 &lt;span class="math"&gt;\(w\)&lt;/span&gt; 的估计值。&lt;/p&gt;
&lt;p&gt;这样，问题就变成以对数似然函数为目标函数的最优化问题。逻辑回归学习中通常采用的方法是梯度下降法和拟牛顿法。&lt;/p&gt;
&lt;p&gt;假设 &lt;span class="math"&gt;\(w\)&lt;/span&gt; 的极大似然估计值是 &lt;span class="math"&gt;\(\hat{w}\)&lt;/span&gt;，那么学到的逻辑回归模型为
&lt;/p&gt;
&lt;div class="math"&gt;$$P(Y=1|x)=\frac{\exp(\hat{w}\cdot x)}{1+\exp(\hat{w}\cdot x)} \\
P(Y=0|x)=\frac{1}{1+\exp(\hat{w}\cdot x)}$$&lt;/div&gt;
&lt;h3&gt;6.1.4 多项逻辑回归&lt;/h3&gt;
&lt;p&gt;可以将二项回归模型推广到多项逻辑回归模型（multi-nominal logistic regression model），用于多类分类。&lt;/p&gt;
&lt;p&gt;假设离散型随机变量 &lt;span class="math"&gt;\(Y\)&lt;/span&gt; 的取值集合是 &lt;span class="math"&gt;\(\{1,2,\cdots,K\}\)&lt;/span&gt;，那么多项逻辑回归模型是
&lt;/p&gt;
&lt;div class="math"&gt;$$P(Y=k|x)=\frac{\exp(w_k\cdot x)}{1+\sum_{k=1}^{K-1}\exp(w_k\cdot x)},k=1,2,\cdots,K-1 \\
P(Y=K|x)=\frac{1}{1+\sum_{k=1}^{K-1}\exp(w_k\cdot x)}$$&lt;/div&gt;
&lt;p&gt;
这里，&lt;span class="math"&gt;\(x\in\mathbb{R}^{n+1}\)&lt;/span&gt;，&lt;span class="math"&gt;\(w_k\in\mathbb{R}^{n+1}\)&lt;/span&gt;
二项逻辑回归的参数估计法也可以推广到多项逻辑回归。&lt;/p&gt;
&lt;h2&gt;6.2 最大熵模型&lt;/h2&gt;
&lt;p&gt;最大熵模型（maximum entropy model）由最大熵原理推导实现。&lt;/p&gt;
&lt;h3&gt;6.2.1 最大熵原理&lt;/h3&gt;
&lt;p&gt;最大熵原理是概率模型学习的一个准则。最大熵原理认为：学习概率模型时，在所有可能的概率模型（分布）中，熵最大的模型时最好的模型。&lt;/p&gt;
&lt;p&gt;通常用约束条件来确定概率模型的集合，所以，最大熵原理也可以表述为在满足约束条件的模型集合中选取熵最大的模型。&lt;/p&gt;
&lt;p&gt;假设离散随机变量 &lt;span class="math"&gt;\(X\)&lt;/span&gt; 的概率分布是 &lt;span class="math"&gt;\(P(X)\)&lt;/span&gt;，则其熵是
&lt;/p&gt;
&lt;div class="math"&gt;$$H(P)=-\sum_xP(x)\log P(x)$$&lt;/div&gt;
&lt;p&gt;
熵满足下列不等式
&lt;/p&gt;
&lt;div class="math"&gt;$$0\leq H(P)\leq\log |X|$$&lt;/div&gt;
&lt;p&gt;
式中，&lt;span class="math"&gt;\(|X|\)&lt;/span&gt; 是 &lt;span class="math"&gt;\(X\)&lt;/span&gt; 取值个数，当且仅当 &lt;span class="math"&gt;\(X\)&lt;/span&gt; 的分布是均匀分布时右边的等号成立。也就是说，当 &lt;span class="math"&gt;\(X\)&lt;/span&gt; 服从均匀分布时，熵最大。&lt;/p&gt;
&lt;h3&gt;6.2.2 最大熵模型的定义&lt;/h3&gt;
&lt;p&gt;最大熵原理是统计学习的一般原理，将它应用到分类得到最大熵模型。&lt;/p&gt;
&lt;p&gt;假设分类模型是一个条件概率分布 &lt;span class="math"&gt;\(P(Y|X)\)&lt;/span&gt;，给定一个训练数据集
&lt;/p&gt;
&lt;div class="math"&gt;$$T=\{(x_1,y_1),(x_2,y_2),\cdots,(x_N,y_N)\}$$&lt;/div&gt;
&lt;p&gt;
学习的目标是用最大熵原理选择最好的分类模型。&lt;/p&gt;
&lt;p&gt;首先考虑模型应该满足的条件。给定训练数据集，可以确定联合概率分布 &lt;span class="math"&gt;\(P(X,Y)\)&lt;/span&gt; 和边缘分布 &lt;span class="math"&gt;\(P(X)\)&lt;/span&gt; 的经验分布，分别用 &lt;span class="math"&gt;\(\tilde{P}(X,Y)\)&lt;/span&gt; 和 &lt;span class="math"&gt;\(\tilde{P}(X)\)&lt;/span&gt; 表示
&lt;/p&gt;
&lt;div class="math"&gt;$$\tilde{P}(X=x,Y=y)=\frac{v(X=x,Y=y)}{N} \\
\tilde{P}(X=x)=\frac{v(X=x)}{N}$$&lt;/div&gt;
&lt;p&gt;
其中，&lt;span class="math"&gt;\(v(\cdot)\)&lt;/span&gt; 表示频数，&lt;span class="math"&gt;\(N\)&lt;/span&gt; 是训练样本容量。&lt;/p&gt;
&lt;p&gt;用特征函数（feature function）&lt;span class="math"&gt;\(f(x,y)\)&lt;/span&gt; 描述输入 &lt;span class="math"&gt;\(x\)&lt;/span&gt; 和输出 &lt;span class="math"&gt;\(y\)&lt;/span&gt; 之间的某一个事实。其定义是
&lt;/p&gt;
&lt;div class="math"&gt;$$f(x,y)=\begin{cases}
1, &amp;amp; x\ 与\ y\ 满足某一事实 \\
0, &amp;amp; 否则
\end{cases}$$&lt;/div&gt;
&lt;p&gt;
它是一个二值函数（一般的，特征函数可以是任意的实值函数）。&lt;/p&gt;
&lt;p&gt;特征函数 &lt;span class="math"&gt;\(f(x,y)\)&lt;/span&gt; 关于经验分布 &lt;span class="math"&gt;\(\tilde{P}(X,Y)\)&lt;/span&gt; 的期望值，用 &lt;span class="math"&gt;\(\text{E}_{\tilde{P}}(f)\)&lt;/span&gt; 表示
&lt;/p&gt;
&lt;div class="math"&gt;$$\text{E}_{\tilde{P}}(f)=\sum_{x,y}\tilde{P}(x,y)f(x,y)$$&lt;/div&gt;
&lt;p&gt;特征函数 &lt;span class="math"&gt;\(f(x,y)\)&lt;/span&gt; 关于模型 &lt;span class="math"&gt;\(P(Y|X)\)&lt;/span&gt; 与经验分布 &lt;span class="math"&gt;\(\tilde{P}(X)\)&lt;/span&gt; 的期望值，用 &lt;span class="math"&gt;\(\text{E}_P(f)\)&lt;/span&gt; 表示
&lt;/p&gt;
&lt;div class="math"&gt;$$\text{E}_P(f)=\sum_{x,y}\tilde{P}(x)P(y|x)f(x,y)$$&lt;/div&gt;
&lt;p&gt;如果模型能够获取训练数据中的信息，那么就可以假设这两个期望值相等，即
&lt;/p&gt;
&lt;div class="math"&gt;$$\text{E}_P(f)=\text{E}_{\tilde{P}}(f)$$&lt;/div&gt;
&lt;p&gt;
即
&lt;/p&gt;
&lt;div class="math"&gt;$$\sum_{x,y}\tilde{P}(x)P(y|x)f(x,y)=\sum_{x,y}\tilde{P}(x,y)f(x,y)$$&lt;/div&gt;
&lt;p&gt;
我们将上式作为模型学习的约束条件。假如有 &lt;span class="math"&gt;\(n\)&lt;/span&gt; 个特征函数 &lt;span class="math"&gt;\(f_i(x,y)\)&lt;/span&gt;，&lt;span class="math"&gt;\(i=1,2,\cdots,n\)&lt;/span&gt;，那么就有 &lt;span class="math"&gt;\(n\)&lt;/span&gt; 个约束条件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;
定义 6.3（最大熵模型）假设满足所有约束条件的模型集合为
&lt;div class="math"&gt;$${\cal C}\equiv\left\{P\in{\cal P}|\text{E}_P(f_i)=\text{E}_{\tilde{P}}(f_i),i=1,2,\cdots,n\right\}$$&lt;/div&gt;
定义在条件概率分布 &lt;span class="math"&gt;\(P(Y|X)\)&lt;/span&gt; 上的条件熵为
&lt;div class="math"&gt;$$H(P)=-\sum_{x,y}\tilde{P}(x)P(y|x)\log P(y|x)$$&lt;/div&gt;
则模型集合 &lt;span class="math"&gt;\({\cal C}\)&lt;/span&gt; 中条件熵 &lt;span class="math"&gt;\(H(P)\)&lt;/span&gt; 最大的模型称为最大熵模型。式中的对数为自然对数。
&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;6.2.3 最大熵模型的学习&lt;/h3&gt;
&lt;p&gt;最大熵模型的学习过程就是求解最大熵模型的过程。最大熵模型的学习可以形式化为约束最优化问题。&lt;/p&gt;
&lt;p&gt;对于给定的训练数据集
&lt;/p&gt;
&lt;div class="math"&gt;$$T=\{(x_1,y_1),(x_2,y_2),\cdots,(x_N,y_N)\}$$&lt;/div&gt;
&lt;p&gt;
以及特征函数
&lt;/p&gt;
&lt;div class="math"&gt;$$f_i(x,y),\ i=1,2,\cdots,n$$&lt;/div&gt;
&lt;p&gt;
最大熵模型的学习等价于约束优化问题：
&lt;/p&gt;
&lt;div class="math"&gt;$$\max_{P\in{\cal C}}\ \ \ \ \ H(P)=-\sum_{x,y}\tilde{P}(x)P(y|x)\log P(y|x) \\
\text{s.t.}\ \ \ \ \ \text{E}_P(f_i)=\text{E}_{\tilde{P}}(f_i),\ i=1,2,\cdots,n \\
\sum_{y}P(y|x)=1$$&lt;/div&gt;
&lt;p&gt;按照最优化问题的习惯，将求最大值问题改写为等价的求最小值问题：
&lt;/p&gt;
&lt;div class="math"&gt;$$\min_{P\in{\cal C}}\ \ \ \ \ -H(P)=\sum_{x,y}\tilde{P}(x)P(y|x)\log P(y|x) \\
\text{s.t.}\ \ \ \ \ \text{E}_P(f_i)-\text{E}_{\tilde{P}}(f_i)=0,\ i=1,2,\cdots,n \\
\sum_{y}P(y|x)=1$$&lt;/div&gt;
&lt;p&gt;这里，将约束最优化问题的原始问题转换为无约束最优化的对偶问题，通过求解对偶问题求解原始问题。&lt;/p&gt;
&lt;p&gt;首先，引进拉格朗日乘子 &lt;span class="math"&gt;\(w_0,w_1,w_2,\cdots,w_n\)&lt;/span&gt;，定义拉格朗日函数
&lt;/p&gt;
&lt;div class="math"&gt;$$\begin{eqnarray}
L(P,w) &amp;amp;\equiv&amp;amp; -H(P)+w_0\left(1-\sum_yP(y|x)\right)+\sum_{i=1}^nw_i\left(\text{E}_P(f_i)-\text{E}_{\tilde{P}}(f_i)\right) \\
&amp;amp;=&amp;amp; \sum_{x,y}\tilde{P}(x)P(y|x)\log P(y|x)+w_0\left(1-\sum_yP(y|x)\right) \\
&amp;amp;+&amp;amp; \sum_{i=1}^nw_i\left(\sum_{x,y}\tilde{P}(x,y)f_i(x,y)-\sum_{x,y}\tilde{P}(x)P(y|x)f_i(x,y)\right)
\end{eqnarray}$$&lt;/div&gt;
&lt;p&gt;
最优化的原始问题是
&lt;/p&gt;
&lt;div class="math"&gt;$$\min_{P\in{\cal C}}\max_wL(P,w)$$&lt;/div&gt;
&lt;p&gt;
对偶问题是
&lt;/p&gt;
&lt;div class="math"&gt;$$\max_w\min_{P\in{\cal C}}L(P,w)$$&lt;/div&gt;
&lt;p&gt;
由于拉格朗日函数 &lt;span class="math"&gt;\(L(P,w)\)&lt;/span&gt; 是 &lt;span class="math"&gt;\(P\)&lt;/span&gt; 的凸函数，原始问题的解和对偶问题的解是等价的。&lt;/p&gt;
&lt;p&gt;首先，求解对偶问题内部的极小化问题，记作
&lt;/p&gt;
&lt;div class="math"&gt;$$\Psi(w)=\min_{P\in{\cal C}}L(P,w)=L(P_w,w)$$&lt;/div&gt;
&lt;p&gt;
&lt;span class="math"&gt;\(\Psi(w)\)&lt;/span&gt; 称为对偶函数，同时，将其解记作
&lt;/p&gt;
&lt;div class="math"&gt;$$P_w=\arg\min_{P\in{\cal C}}L(P,w)=P_w(y|x)$$&lt;/div&gt;
&lt;p&gt;
通过令偏导数等于 0
&lt;/p&gt;
&lt;div class="math"&gt;$$\begin{eqnarray}
\frac{\partial L(P,w)}{\partial P(y|x)} &amp;amp;=&amp;amp; \sum_{x,y}\tilde{P}(x)\left(\log P(y|x)+1\right)-\sum_yw_0-\sum_{x,y}\left(\tilde{P}(x)\sum_{i=1}^nw_if_i(x,y)\right) \\
&amp;amp;=&amp;amp; \sum_{x,y}\tilde{P}(x)\left(\log P(y|x)+1-w_0-\sum_{i=1}^nw_if_i(x,y)\right)
\end{eqnarray}$$&lt;/div&gt;
&lt;p&gt;
在 &lt;span class="math"&gt;\(\tilde{P}(x)&amp;gt;0\)&lt;/span&gt; 的情况下，解得
&lt;/p&gt;
&lt;div class="math"&gt;$$\begin{eqnarray}
P(y|x) &amp;amp;=&amp;amp; \exp\left(\sum_{i=1}^nw_if_i(x,y)+w_0-1\right) \\
&amp;amp;=&amp;amp; \frac{\exp\left(\sum_{i=1}^nw_if_i(x,y)\right)}{\exp(1-w_0)}
\end{eqnarray}$$&lt;/div&gt;
&lt;p&gt;
由于 &lt;span class="math"&gt;\(\sum_yP(y|x)=1\)&lt;/span&gt;，得
&lt;/p&gt;
&lt;div class="math"&gt;$$P_w(y|x)=\frac{1}{Z_w(x)}\exp\left(\sum_{i=1}^nw_if_i(x,y)\right)$$&lt;/div&gt;
&lt;p&gt;
其中
&lt;/p&gt;
&lt;div class="math"&gt;$$Z_w(x)=\sum_y\exp\left(\sum_{i=1}^nw_if_i(x,y)\right)$$&lt;/div&gt;
&lt;p&gt;
称为规范化因子；&lt;span class="math"&gt;\(f_i(x,y)\)&lt;/span&gt; 是特征函数，&lt;span class="math"&gt;\(w_i\)&lt;/span&gt; 是特征函数的权值。由以上两式表示的 &lt;span class="math"&gt;\(P_w(y|x)\)&lt;/span&gt; 就是最大熵模型，&lt;span class="math"&gt;\(w\)&lt;/span&gt; 是最大熵模型中的参数向量。&lt;/p&gt;
&lt;p&gt;之后，求解对偶问题外部的极大化问题
&lt;/p&gt;
&lt;div class="math"&gt;$$\max_w\Psi(w)$$&lt;/div&gt;
&lt;p&gt;
将其解记为 &lt;span class="math"&gt;\(w^\star\)&lt;/span&gt;，即
&lt;/p&gt;
&lt;div class="math"&gt;$$w^\star=\arg\max_w\Psi(w)$$&lt;/div&gt;
&lt;p&gt;
故最终的最大熵模型是
&lt;/p&gt;
&lt;div class="math"&gt;$$P^\star=P_{w^\star}=P_{w^\star}(y|x)$$&lt;/div&gt;
&lt;h3&gt;6.2.4 极大似然估计&lt;/h3&gt;
&lt;p&gt;从最大熵模型学习中可以看出，最大熵模型是由下面两个式子表示的条件概率分布：
&lt;/p&gt;
&lt;div class="math"&gt;$$P_w(y|x)=\frac{1}{Z_w(x)}\exp\left(\sum_{i=1}^nw_if_i(x,y)\right) \\
Z_w(x)=\sum_y\exp\left(\sum_{i=1}^nw_if_i(x,y)\right)$$&lt;/div&gt;
&lt;p&gt;
下面证明，对偶函数的极大化等价于最大熵模型的极大似然估计。&lt;/p&gt;
&lt;p&gt;最大似然函数的一般形式是样本集中各个样本的联合概率：
&lt;/p&gt;
&lt;div class="math"&gt;$$L(x_1,x_2,\cdots,x_N;\theta)=\prod_{i=1}^{N} p(x_i;\theta)$$&lt;/div&gt;
&lt;p&gt;
其中利用了数据是独立同分布产生的假设。&lt;span class="math"&gt;\(x_1,x_2,\cdots,x_N\)&lt;/span&gt; 是样本具体观测值。随机变量 &lt;span class="math"&gt;\(X\)&lt;/span&gt; 是离散的，所以它的取值范围是一个集合，假设样本集的大小为 &lt;span class="math"&gt;\(N\)&lt;/span&gt;，&lt;span class="math"&gt;\(X\)&lt;/span&gt; 的取值有 &lt;span class="math"&gt;\(K\)&lt;/span&gt; 个，分别是 &lt;span class="math"&gt;\(c_1,c_2,\cdots,c_K\)&lt;/span&gt;。用 &lt;span class="math"&gt;\(v(X=c_i)\)&lt;/span&gt;表示在观测值中样本 &lt;span class="math"&gt;\(c_i\)&lt;/span&gt; 出现的频数。则：
&lt;/p&gt;
&lt;div class="math"&gt;$$L(x_1,x_2,\cdots,x_N;\theta)=\prod_{i=1}^{k}p(v_i;\theta)^{v(X=c_i)}$$&lt;/div&gt;
&lt;p&gt;
对等式两边同时开 &lt;span class="math"&gt;\(N\)&lt;/span&gt; 次方，可得：
&lt;/p&gt;
&lt;div class="math"&gt;$$L(x_1,x_2,\cdots,x_N;\theta)^{\frac{1}{N}}=\prod_{i=1}^{k}p(v_i;\theta)^{\frac{v(X=c_i)}{N}}$$&lt;/div&gt;
&lt;p&gt;
因为经验概率 &lt;span class="math"&gt;\(\tilde{p}(x)=\frac{v(X=c_i)}{N}\)&lt;/span&gt;，所以：
&lt;/p&gt;
&lt;div class="math"&gt;$$L(x_1,x_2,\cdots,x_N;\theta)^{\frac{1}{N}}=\prod_{x}p(x;\theta)^{\tilde{p}(x)}$$&lt;/div&gt;
&lt;p&gt;
很明显对 &lt;span class="math"&gt;\(L(x_1,x_2,\cdots,x_N;\theta)\)&lt;/span&gt; 求最大值和对 &lt;span class="math"&gt;\(L(x_1,x_2,\cdots,x_N;\theta)^{\frac{1}{N}}\)&lt;/span&gt;求最大值的优化的结果是一样的。整理上式所以最终的最大似然函数可以表示为：
&lt;/p&gt;
&lt;div class="math"&gt;$$L(x;\theta)=\prod_{x} p(x;\theta)^{\tilde{p}(x)}$$&lt;/div&gt;
&lt;p&gt;已知训练数据的经验概率分布 &lt;span class="math"&gt;\(\tilde{P}(X,Y)\)&lt;/span&gt;，条件概率分布 &lt;span class="math"&gt;\(P(Y|X)\)&lt;/span&gt; 的对数似然函数表示为：
&lt;/p&gt;
&lt;div class="math"&gt;$$L_{\tilde{P}}(P_w)=\log\prod_{x,y}P(y|x)^{\tilde{P}(x,y)}=\sum_{x,y}\tilde{P}(x,y)\log P(y|x)$$&lt;/div&gt;
&lt;p&gt;
当条件概率分布 &lt;span class="math"&gt;\(P(y|x)\)&lt;/span&gt; 是最大熵模型时，对数似然函数为
&lt;/p&gt;
&lt;div class="math"&gt;$$\begin{eqnarray}
L_{\tilde{P}}(P_w) &amp;amp;=&amp;amp; \sum_{x,y}\tilde{P}(x,y)\log P(y|x) \\
&amp;amp;=&amp;amp; \sum_{x,y}\tilde{P}(x,y)\sum_{i=1}^nw_if_i(x,y)-\sum_{x,y}\tilde{P}(x,y)\log Z_w(x) \\
&amp;amp;=&amp;amp; \sum_{x,y}\tilde{P}(x,y)\sum_{i=1}^nw_if_i(x,y)-\sum_x\tilde{P}(x)\log Z_w(x)
\end{eqnarray}$$&lt;/div&gt;
&lt;p&gt;
再看对偶函数 &lt;span class="math"&gt;\(\Psi(w)\)&lt;/span&gt;:
&lt;/p&gt;
&lt;div class="math"&gt;$$\begin{eqnarray}
\Psi(w) &amp;amp;=&amp;amp; \sum_{x,y}\tilde{P}(x)P_w(y|x)\log P_w(y|x)+w_0\left(1-\sum_yP_w(y|x)\right) \\
&amp;amp;+&amp;amp; \sum_{i=1}^nw_i\left(\sum_{x,y}\tilde{P}(x,y)f_i(x,y)-\sum_{x,y}\tilde{P}(x)P_w(y|x)f_i(x,y)\right) \\
&amp;amp;=&amp;amp; \sum_{x,y}\tilde{P}(x,y)\sum_{i=1}^nw_if_i(x,y) \\
&amp;amp;+&amp;amp; \sum_{x,y}\tilde{P}(x)P_w(y|x)\left(\log P_w(y|x)-\sum_{i=1}^nw_if_i(x,y)\right) \\
&amp;amp;=&amp;amp; \sum_{x,y}\tilde{P}(x,y)\sum_{i=1}^nw_if_i(x,y)-\sum_{x,y}\tilde{P}(x)P_w(y|x)\log Z_w(x) \\
&amp;amp;=&amp;amp; \sum_{x,y}\tilde{P}(x,y)\sum_{i=1}^nw_if_i(x,y)-\sum_{x}\tilde{P}(x)\log Z_w(x)
\end{eqnarray}$$&lt;/div&gt;
&lt;p&gt;
其中利用了 &lt;span class="math"&gt;\(\sum_yP(y|x)=1\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;比较易得 &lt;span class="math"&gt;\(\Psi(w)=L_{\tilde{P}}(P_w)\)&lt;/span&gt;，于是证明了最大熵学习中的对偶函数极大化等价于最大熵模型的极大似然估计这一事实。这样，最大熵模型的学习问题就转换为具体求解对数似然函数极大化或对偶函数极大化的问题。&lt;/p&gt;
&lt;p&gt;可以将最大熵模型写成更一般的形式：
&lt;/p&gt;
&lt;div class="math"&gt;$$P_w(y|x)=\frac{1}{Z_w(x)}\exp\left(\sum_{i=1}^nw_if_i(x,y)\right) \\
Z_w(x)=\sum_y\exp\left(\sum_{i=1}^nw_if_i(x,y)\right)$$&lt;/div&gt;
&lt;p&gt;
这里，&lt;span class="math"&gt;\(x\in\mathbb{R}^n\)&lt;/span&gt; 为输入，&lt;span class="math"&gt;\(y\in\{1,2,\cdots,K\}\)&lt;/span&gt; 为输出，&lt;span class="math"&gt;\(w\in\mathbb{R}^n\)&lt;/span&gt; 为权值向量，&lt;span class="math"&gt;\(f_i(x,y)\)&lt;/span&gt;，&lt;span class="math"&gt;\(i=1,2,\cdots,n\)&lt;/span&gt; 为任意实值特征函数。&lt;/p&gt;
&lt;p&gt;最大熵模型与逻辑回归模型有着类似的形式，它们又称为对数线性模型（log linear model）。模型学习就是在给定的训练数据条件下对模型进行极大似然估计或正则化的极大似然估计。&lt;/p&gt;
&lt;h2&gt;6.3 模型学习的最优化算法&lt;/h2&gt;
&lt;h3&gt;6.3.1 改进的迭代尺度法&lt;/h3&gt;
&lt;p&gt;改进的迭代尺度法（improved iterative scaling，IIS）是一种最大熵模型学习的最优化算法。&lt;/p&gt;
&lt;p&gt;已知最大熵模型：
&lt;/p&gt;
&lt;div class="math"&gt;$$P_w(y|x)=\frac{1}{Z_w(x)}\exp\left(\sum_{i=1}^nw_if_i(x,y)\right) \\
Z_w(x)=\sum_y\exp\left(\sum_{i=1}^nw_if_i(x,y)\right)$$&lt;/div&gt;
&lt;p&gt;对数似然函数为：
&lt;/p&gt;
&lt;div class="math"&gt;$$L(w)=\sum_{x,y}\tilde{P}(x,y)\sum_{i=1}^nw_if_i(x,y)-\sum_x\tilde{P}(x)\log Z_w(x)
$$&lt;/div&gt;
&lt;p&gt;
目标是通过极大似然估计学习模型参数，即求对数似然函数的极大值 &lt;span class="math"&gt;\(w^\star\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;首先建立对数似然函数改变量的下界
&lt;/p&gt;
&lt;div class="math"&gt;$$\begin{eqnarray}
L(w+\delta)-L(w) &amp;amp;=&amp;amp; \sum_{x,y}\tilde{P}(x,y)\log P_{w+\delta}(y|x)-\sum_{x,y}\tilde{P}(x,y)\log P_{w}(y|x) \\
&amp;amp;=&amp;amp; \sum_{x,y}\tilde{P}(x,y)\sum_{i=1}^n\delta_if_i(x,y)-\sum_x\tilde{P}(x)\log \frac{Z_{w+\delta}(x)}{Z_w(x)}
\end{eqnarray}$$&lt;/div&gt;
&lt;p&gt;
利用不等式
&lt;/p&gt;
&lt;div class="math"&gt;$$-\log\alpha\geq1-\alpha,\alpha&amp;gt;0$$&lt;/div&gt;
&lt;p&gt;
得
&lt;/p&gt;
&lt;div class="math"&gt;$$\begin{eqnarray}
L(w+\delta)-L(w) &amp;amp;\geq&amp;amp; \sum_{x,y}\tilde{P}(x,y)\sum_{i=1}^n\delta_if_i(x,y)+1-\sum_x\tilde{P}(x)\frac{Z_{w+\delta}(x)}{Z_w(x)} \\
&amp;amp;=&amp;amp; \sum_{x,y}\tilde{P}(x,y)\sum_{i=1}^n\delta_if_i(x,y)+1 \\
&amp;amp;-&amp;amp; \sum_x\tilde{P}(x)\sum_yP_w(y|x)\exp\left(\sum_{i=1}^n\delta_if_i(x,y)\right)
\end{eqnarray}$$&lt;/div&gt;
&lt;p&gt;
将右端记为
&lt;/p&gt;
&lt;div class="math"&gt;$$A(\delta|w)=\sum_{x,y}\tilde{P}(x,y)\sum_{i=1}^n\delta_if_i(x,y)+1-\sum_x\tilde{P}(x)\sum_yP_w(y|x)\exp\left(\sum_{i=1}^n\delta_if_i(x,y)\right)$$&lt;/div&gt;
&lt;p&gt;
于是有
&lt;/p&gt;
&lt;div class="math"&gt;$$L(w+\delta)-L(w)\geq A(\delta|w)$$&lt;/div&gt;
&lt;p&gt;如果能找到适当的 &lt;span class="math"&gt;\(\delta\)&lt;/span&gt; 使下界 &lt;span class="math"&gt;\(A(\delta|w)\)&lt;/span&gt; 提高，那么对数似然函数也会提高，然而 &lt;span class="math"&gt;\(A(\delta|w)\)&lt;/span&gt; 中的 &lt;span class="math"&gt;\(\delta\)&lt;/span&gt; 是个向量，不易同时优化，IIS 试图一次只优化其中一个变量 &lt;span class="math"&gt;\(\delta_i\)&lt;/span&gt;，而固定其他变量 &lt;span class="math"&gt;\(\delta_j\)&lt;/span&gt;，&lt;span class="math"&gt;\(i\neq j\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;为达到这一目的，IIS 进一步降低下界 &lt;span class="math"&gt;\(A(\delta|w)\)&lt;/span&gt;。引入一个量
&lt;/p&gt;
&lt;div class="math"&gt;$$f^\sharp(x,y)=\sum_if_i(x,y)$$&lt;/div&gt;
&lt;p&gt;
因为 &lt;span class="math"&gt;\(f_i\)&lt;/span&gt; 是二值函数，故 &lt;span class="math"&gt;\(f^\sharp(x,y)\)&lt;/span&gt; 表示所有特征在 &lt;span class="math"&gt;\((x,y)\)&lt;/span&gt; 出现的次数，这样 &lt;span class="math"&gt;\(A(\delta|w)\)&lt;/span&gt; 可改写为
&lt;/p&gt;
&lt;div class="math"&gt;$$\begin{eqnarray}
A(\delta|w) &amp;amp;=&amp;amp; \sum_{x,y}\tilde{P}(x,y)\sum_{i=1}^n\delta_if_i(x,y)+1 \\
&amp;amp;-&amp;amp; \sum_x\tilde{P}(x)\sum_yP_w(y|x)\exp\left(f^\sharp(x,y)\sum_{i=1}^n\frac{\delta_if_i(x,y)}{f^\sharp(x,y)}\right)
\end{eqnarray}$$&lt;/div&gt;
&lt;p&gt;
利用指数函数的凸性以及对任意 &lt;span class="math"&gt;\(i\)&lt;/span&gt;，有
&lt;/p&gt;
&lt;div class="math"&gt;$$\frac{f_i(x,y)}{f^\sharp(x,y)}\geq0\ 且\ \sum_{i=1}^n\frac{f_i(x,y)}{f^\sharp(x,y)}=1$$&lt;/div&gt;
&lt;p&gt;
根据琴生不等式（Jensen's inequality），得到
&lt;/p&gt;
&lt;div class="math"&gt;$$\exp\left(\sum_{i=1}^n\frac{f_i(x,y)}{f^\sharp(x,y)}\delta_if^\sharp(x,y)\right)\leq\sum_{i=1}^n\frac{f_i(x,y)}{f^\sharp(x,y)}\exp\left(\delta_if^\sharp(x,y)\right)$$&lt;/div&gt;
&lt;p&gt;
于是得到对数似然函数改变量的一个新的（相对不紧的）下界
&lt;/p&gt;
&lt;div class="math"&gt;$$\begin{eqnarray}
B(\delta|w) &amp;amp;=&amp;amp; \sum_{x,y}\tilde{P}(x,y)\sum_{i=1}^n\delta_if_i(x,y)+1 \\
&amp;amp;-&amp;amp; \sum_x\tilde{P}(x)\sum_yP_w(y|x)\sum_{i=1}^n\left(\frac{f_i(x,y)}{f^\sharp(x,y)}\right)\exp\left(\delta_if^\sharp(x,y)\right)
\end{eqnarray}$$&lt;/div&gt;
&lt;p&gt;
求 &lt;span class="math"&gt;\(B(\delta|w)\)&lt;/span&gt; 对 &lt;span class="math"&gt;\(\delta_i\)&lt;/span&gt; 的偏导数
&lt;/p&gt;
&lt;div class="math"&gt;$$\begin{eqnarray}
\frac{\partial B(\delta|w)}{\partial \delta_i} &amp;amp;=&amp;amp; \sum_{x,y}\tilde{P}(x,y)f_i(x,y) \\ &amp;amp;-&amp;amp; \sum_x\tilde{P}(x)\sum_yP_w(y|x)f_i(x,y)\exp\left(\delta_if^\sharp(x,y)\right)
\end{eqnarray}$$&lt;/div&gt;
&lt;p&gt;
上式只含有 &lt;span class="math"&gt;\(\delta_i\)&lt;/span&gt;，令偏导数等于 0 得到
&lt;/p&gt;
&lt;div class="math"&gt;$$\sum_x\tilde{P}(x)\sum_yP_w(y|x)f_i(x,y)\exp\left(\delta_if^\sharp(x,y)\right)=\text{E}_{\tilde{P}}(f_i)$$&lt;/div&gt;
&lt;p&gt;
于是，依次对 &lt;span class="math"&gt;\(\delta_i\)&lt;/span&gt; 求解上述方程就可以求出 &lt;span class="math"&gt;\(\delta\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;
算法 6.1（改进的迭代尺度算法 IIS）&lt;br&gt;
输入：特征函数 &lt;span class="math"&gt;\(f_1,f_2,\cdots,f_n\)&lt;/span&gt;；经验分布函数 &lt;span class="math"&gt;\(\tilde{P}(X,Y)\)&lt;/span&gt;，模型 &lt;span class="math"&gt;\(P_w(y|x)\)&lt;/span&gt;&lt;br&gt;
输出：最优参数值 &lt;span class="math"&gt;\(w_i^\star\)&lt;/span&gt;；最优模型 &lt;span class="math"&gt;\(P_{w^\star}\)&lt;/span&gt;&lt;br&gt;
(1) 对所有 &lt;span class="math"&gt;\(i\in\{1,2,\cdots,n\}\)&lt;/span&gt;，取初值 &lt;span class="math"&gt;\(w_i=0\)&lt;/span&gt;&lt;br&gt;
(2) 对每一 &lt;span class="math"&gt;\(i\in\{1,2,\cdots,n\}\)&lt;/span&gt;：&lt;br&gt;
(2.a) 令 &lt;span class="math"&gt;\(\delta_i\)&lt;/span&gt; 是方程
&lt;div class="math"&gt;$$\sum_x\tilde{P}(x)\sum_yP_w(y|x)f_i(x,y)\exp\left(\delta_if^\sharp(x,y)\right)=\text{E}_{\tilde{P}}(f_i)$$&lt;/div&gt;
的解，这里
&lt;div class="math"&gt;$$f^\sharp(x,y)=\sum_{i=1}^nf_i(x,y)$$&lt;/div&gt;&lt;br&gt;
(2.b) 更新：&lt;span class="math"&gt;\(w_i\leftarrow w_i+\delta_i\)&lt;/span&gt;&lt;br&gt;
(3) 如果不是所有 &lt;span class="math"&gt;\(w_i\)&lt;/span&gt; 都收敛，重复步骤 (2)
&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这一算法关键步骤是 (2.a)，如果 &lt;span class="math"&gt;\(f^\sharp(x,y)\)&lt;/span&gt; 是常数，即对任意的 &lt;span class="math"&gt;\(x\)&lt;/span&gt;，&lt;span class="math"&gt;\(y\)&lt;/span&gt;，有 &lt;span class="math"&gt;\(f^\sharp(x,y)=M\)&lt;/span&gt;，那么 &lt;span class="math"&gt;\(\delta_i\)&lt;/span&gt; 可以显示的表示为
&lt;/p&gt;
&lt;div class="math"&gt;$$\delta_i=\frac{1}{M}\log\frac{\text{E}_\tilde{P}(f_i)}{\text{E}_P(f_i)}$$&lt;/div&gt;
&lt;p&gt;
如果 &lt;span class="math"&gt;\(f^\sharp(x,y)\)&lt;/span&gt; 不是常数，就必须数值计算求 &lt;span class="math"&gt;\(\delta_i\)&lt;/span&gt;，简单有效的方法是牛顿法，由于方程有单根，因此牛顿法恒收敛，且收敛速度很快。&lt;/p&gt;
&lt;h3&gt;6.3.2 拟牛顿法&lt;/h3&gt;
&lt;p&gt;最大熵模型学习还可以应用牛顿法或拟牛顿法。&lt;/p&gt;
&lt;p&gt;对于最大熵模型
&lt;/p&gt;
&lt;div class="math"&gt;$$P_w(y|x)=\frac{\exp\left(\sum_{i=1}^nw_if_i(x,y)\right)}{\sum_y\exp\left(\sum_{i=1}^nw_if_i(x,y)\right)}$$&lt;/div&gt;
&lt;p&gt;目标函数为：
&lt;/p&gt;
&lt;div class="math"&gt;$$\min_{w\in\mathbb{R}^n}\ \ f(w)=\sum_x\tilde{P}(x)\log\sum_y\exp\left(\sum_{i=1}^nw_if_i(x,y)\right)-\sum_{x,y}\tilde{P}(x,y)\sum_{i=1}^nw_if_i(x,y)
$$&lt;/div&gt;
&lt;p&gt;
梯度：
&lt;/p&gt;
&lt;div class="math"&gt;$$g(w)=\left(\frac{\partial f(w)}{\partial w_1},\frac{\partial f(w)}{\partial w_2},\cdots,\frac{\partial f(w)}{\partial w_n}\right)^\text{T}$$&lt;/div&gt;
&lt;p&gt;
其中
&lt;/p&gt;
&lt;div class="math"&gt;$$\frac{\partial f(w)}{\partial w_i}=\sum_{x,y}\tilde{P}(x)P_w(y|x)f_i(x,y)-\text{E}_{\tilde{P}}(f_i),i=1,2,\cdots,n$$&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;
算法 6.2（最大熵模型学习的 BFGS）算法&lt;br&gt;
输入：特征函数 &lt;span class="math"&gt;\(f_1,f_2,\cdots,f_n\)&lt;/span&gt;；经验分布 &lt;span class="math"&gt;\(\tilde{P}(x,y)\)&lt;/span&gt;，目标函数 &lt;span class="math"&gt;\(f(w)\)&lt;/span&gt;，梯度 &lt;span class="math"&gt;\(g(w)=\nabla f(w)\)&lt;/span&gt;，精度要求 &lt;span class="math"&gt;\(\epsilon\)&lt;/span&gt;&lt;br&gt;
输出：最优化参数值 &lt;span class="math"&gt;\(w^\star\)&lt;/span&gt;；最优模型 &lt;span class="math"&gt;\(P_{w^\star}(y|x)\)&lt;/span&gt;&lt;br&gt;
(1) 选定初始点 &lt;span class="math"&gt;\(w^{(0)}\)&lt;/span&gt;，取 &lt;span class="math"&gt;\({\bf B_0}\)&lt;/span&gt; 为正定对称矩阵，置 &lt;span class="math"&gt;\(k=0\)&lt;/span&gt;&lt;br&gt;
(2) 计算 &lt;span class="math"&gt;\(g_k=g(w^{(k)})\)&lt;/span&gt;，若 &lt;span class="math"&gt;\(\|g_k\|&amp;lt;\epsilon\)&lt;/span&gt;，则停止计算，得 &lt;span class="math"&gt;\(w^\star=w^{(k)}\)&lt;/span&gt;；否则，转到 (3)&lt;br&gt;
(3) 由 &lt;span class="math"&gt;\({\bf B_k}p_k=-g_k\)&lt;/span&gt; 求出 &lt;span class="math"&gt;\(p_k\)&lt;/span&gt;&lt;br&gt;
(4) 一维搜索：求 &lt;span class="math"&gt;\(\lambda_k\)&lt;/span&gt; 使得
&lt;div class="math"&gt;$$f(w^{(k)}+\lambda_kp_k)=\min_{\lambda\geq0}f(w^{(k)}+\lambda p_k)$$&lt;/div&gt;
(5) 置 &lt;span class="math"&gt;\(w^{(k+1)}=w^{(k)}+\lambda_k p_k\)&lt;/span&gt;&lt;br&gt;
(6) 计算 &lt;span class="math"&gt;\(g_{k+1}=g(w^{(k+1)})\)&lt;/span&gt;，若 &lt;span class="math"&gt;\(\|g_{k+1}\|&amp;lt;\epsilon\)&lt;/span&gt;，则停止计算，得 &lt;span class="math"&gt;\(w^\star=w^{(k+1)}\)&lt;/span&gt;；否则，按照下式求出 &lt;span class="math"&gt;\({\bf B_{k+1}}\)&lt;/span&gt;
&lt;div class="math"&gt;$${\bf B_{k+1}}={\bf B_k}+\frac{y_ky_k^\text{T}}{y_k^\text{T}\delta_k}-\frac{{\bf B_k}\delta_k\delta_k^\text{T}{\bf B_k}}{\delta_k^\text{T}{\bf B_k}\delta_k}$$&lt;/div&gt;
其中，
&lt;div class="math"&gt;$$y_k=g_{k+1}-g_k,\delta_k=w^{(k+1)}-w^{(k)}$$&lt;/div&gt;
(7) 置 &lt;span class="math"&gt;\(k=k+1\)&lt;/span&gt;，转到 (3)
&lt;/strong&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="统计学习"></category><category term="机器学习"></category></entry><entry><title>统计学习方法 第五章 决策树</title><link href="https://xutree.github.io/pages/2018/11/07/5/" rel="alternate"></link><published>2018-11-07T16:52:41+08:00</published><updated>2018-11-09T14:49:41+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-11-07:/pages/2018/11/07/5/</id><summary type="html">&lt;p&gt;决策树（decision tree）是一种基本的分类与回归方法。其主要优点是模型具有可读性，分类速度快。决策树学习通常包括三个步骤：特征选择、决策树的生成和决策树的修剪。&lt;/p&gt;
&lt;h2&gt;5.1 决策树模型与学习&lt;/h2&gt;
&lt;h3&gt;5.1.1 决策树模型&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;
定义 5.1 （决策树）分类决策树模型是一种描述对实例进行分类的树形结构。决策树由节点（node）和有向边（directed edge）组成。节点有两种类型：内部节点（internal node）和叶节点（leaf node）。内部节点表示一个特征或属性，叶节点表示一个类。
&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;5.1.2 决策树学习&lt;/h3&gt;
&lt;p&gt;假设给定训练数据集
&lt;/p&gt;
&lt;div class="math"&gt;$$T=\{(x_1,y_1),(x_2,y_2),\cdots,(x_N,y_N)\}$$&lt;/div&gt;
&lt;p&gt;
其中输入实例 …&lt;/p&gt;&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><content type="html">&lt;p&gt;决策树（decision tree）是一种基本的分类与回归方法。其主要优点是模型具有可读性，分类速度快。决策树学习通常包括三个步骤：特征选择、决策树的生成和决策树的修剪。&lt;/p&gt;
&lt;h2&gt;5.1 决策树模型与学习&lt;/h2&gt;
&lt;h3&gt;5.1.1 决策树模型&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;
定义 5.1 （决策树）分类决策树模型是一种描述对实例进行分类的树形结构。决策树由节点（node）和有向边（directed edge）组成。节点有两种类型：内部节点（internal node）和叶节点（leaf node）。内部节点表示一个特征或属性，叶节点表示一个类。
&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;5.1.2 决策树学习&lt;/h3&gt;
&lt;p&gt;假设给定训练数据集
&lt;/p&gt;
&lt;div class="math"&gt;$$T=\{(x_1,y_1),(x_2,y_2),\cdots,(x_N,y_N)\}$$&lt;/div&gt;
&lt;p&gt;
其中输入实例（向量）为
&lt;/p&gt;
&lt;div class="math"&gt;$$x_i=\left(x_i^{(1)},x_i^{(2)},\cdots,x_i^{(n)},\right)$$&lt;/div&gt;
&lt;p&gt;
&lt;span class="math"&gt;\(n\)&lt;/span&gt; 为特征个数。类标记为
&lt;/p&gt;
&lt;div class="math"&gt;$$y_i\in\{c_1,c_2,\cdots,c_K\}$$&lt;/div&gt;
&lt;p&gt;
其中 &lt;span class="math"&gt;\(i\in\{1,2,\cdots,N\}\)&lt;/span&gt;，&lt;span class="math"&gt;\(N\)&lt;/span&gt; 为样本容量。&lt;/p&gt;
&lt;p&gt;学习的目的是根据给定的训练数据集构建一个决策树模型，使它能够对实例进行正确的分类。&lt;/p&gt;
&lt;p&gt;决策树学习本质上是从训练数据集中归纳出一组分类规则。与训练集不相矛盾的决策树可能有多个也可能一个也没有，我们需要的是一个与训练集矛盾较小的决策树，同时具有很好的泛化能力。&lt;/p&gt;
&lt;p&gt;决策树学习的损失函数通常是正则化的极大似然函数。决策树学习的策略是以损失函数为目标函数的最小化。&lt;/p&gt;
&lt;p&gt;当损失函数确定以后，学习问题变成在损失函数意义下选择最有决策树的问题，因为从所有可能的决策树中选取最优决策树是 NP 完全问题，所以现实中决策树学习算法通常采用启发式方法，近似求解这一最优化问题。这样得到的决策树是次最优（sub-optimal）的。&lt;/p&gt;
&lt;h2&gt;5.2 特征选择&lt;/h2&gt;
&lt;h3&gt;5.2.1 特征选择的问题&lt;/h3&gt;
&lt;p&gt;特征选择在于选取对训练数据具有分类能力的特征。这样就可以提高决策树学习的效率。如果利用一个特征进行分类的结果与随机分类的结果没有很大差别，则称这个特征是没有分类能力的。通常特征选取的准则是信息增益或信息增益比。&lt;/p&gt;
&lt;h3&gt;5.2.2 信息增益&lt;/h3&gt;
&lt;p&gt;为了便于说明，首先给出熵与条件熵的定义。&lt;/p&gt;
&lt;p&gt;熵（entropy）是表示随机变量不确定性的度量。&lt;/p&gt;
&lt;p&gt;设 &lt;span class="math"&gt;\(X\)&lt;/span&gt; 是一个离散随机变量，其概率分布为
&lt;/p&gt;
&lt;div class="math"&gt;$$P(X=x_i)=p_i,i=1,2,\cdots,n$$&lt;/div&gt;
&lt;p&gt;
则，随机变量 &lt;span class="math"&gt;\(X\)&lt;/span&gt; 的熵定义为
&lt;/p&gt;
&lt;div class="math"&gt;$$H(X)=-\sum_{i=1}^np_i\log p_i$$&lt;/div&gt;
&lt;p&gt;
若 &lt;span class="math"&gt;\(p_i=0\)&lt;/span&gt;，定义 &lt;span class="math"&gt;\(0\log0=0\)&lt;/span&gt;。通常，上式中对数的底为 2 或自然对数 e，这是熵的单位分别为比特（bit）或纳特（nat）。&lt;/p&gt;
&lt;p&gt;设有随机变量 &lt;span class="math"&gt;\((X,Y)\)&lt;/span&gt;，其联合概率分布为
&lt;/p&gt;
&lt;div class="math"&gt;$$P(X=x_i,Y=y_j)=p_{ij},i=1,2,\cdots,n;j=1,2,\cdots,m$$&lt;/div&gt;
&lt;p&gt;
条件熵（conditional entropy） &lt;span class="math"&gt;\(H(Y|X)\)&lt;/span&gt; 表示在已知随机变量 &lt;span class="math"&gt;\(X\)&lt;/span&gt; 的条件下随机变量 &lt;span class="math"&gt;\(Y\)&lt;/span&gt; 的不确定性，定义为 &lt;span class="math"&gt;\(X\)&lt;/span&gt; 给定条件下 &lt;span class="math"&gt;\(Y\)&lt;/span&gt; 的条件概率分布的熵对 &lt;span class="math"&gt;\(X\)&lt;/span&gt; 的数学期望
&lt;/p&gt;
&lt;div class="math"&gt;$$H(Y|X)=\sum_{i=1}^np_iH(Y|X=x_i)$$&lt;/div&gt;
&lt;p&gt;
这里 &lt;span class="math"&gt;\(p_i=P(X=x_i),i=1,2,\cdots,n\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;当熵和条件熵中的概率由数据估计（特别是极大似然估计）得到时，所对应的熵和条件熵分别称为经验熵（empirical entropy）和经验条件熵（empirical conditional entropy）。&lt;/p&gt;
&lt;p&gt;信息增益（information gain）表示得知特征 &lt;span class="math"&gt;\(X\)&lt;/span&gt; 的信息而使类 &lt;span class="math"&gt;\(Y\)&lt;/span&gt; 的信息的不确定度减少的程度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;
定义 5.2 （信息增益）特征 &lt;span class="math"&gt;\(A\)&lt;/span&gt; 对训练数据集 &lt;span class="math"&gt;\(D\)&lt;/span&gt; 的信息增益 &lt;span class="math"&gt;\(g(D,A)\)&lt;/span&gt;，定义为集合 &lt;span class="math"&gt;\(D\)&lt;/span&gt; 的经验熵 &lt;span class="math"&gt;\(H(D)\)&lt;/span&gt; 与特征 &lt;span class="math"&gt;\(A\)&lt;/span&gt; 给定条件下 &lt;span class="math"&gt;\(D\)&lt;/span&gt; 的经验条件熵 &lt;span class="math"&gt;\(H(D|A）\)&lt;/span&gt;只差
&lt;div class="math"&gt;$$g(D,A)=H(D)-H(D|A)$$&lt;/div&gt;
&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一般的，熵与条件熵只差称为互信息（mutual information）。决策树学习中的信息增益等价于训练数据集中类和特征的互信息。&lt;/p&gt;
&lt;p&gt;根据信息增益准则的特征选择方法是：对训练数据集（或子集）&lt;span class="math"&gt;\(D\)&lt;/span&gt;，计算其每个特征的信息增益，选择信息增益最大的特征。&lt;/p&gt;
&lt;p&gt;设训练数据集为 &lt;span class="math"&gt;\(D\)&lt;/span&gt;，&lt;span class="math"&gt;\(|D|\)&lt;/span&gt; 表示其样本容量。设有 &lt;span class="math"&gt;\(K\)&lt;/span&gt; 个类 &lt;span class="math"&gt;\(C_k\)&lt;/span&gt;，&lt;span class="math"&gt;\(k=1,2\cdots,K\)&lt;/span&gt;，&lt;span class="math"&gt;\(|C_k|\)&lt;/span&gt; 为属于类 &lt;span class="math"&gt;\(C_k\)&lt;/span&gt; 的样本个数。设特征 &lt;span class="math"&gt;\(A\)&lt;/span&gt; 有 &lt;span class="math"&gt;\(n\)&lt;/span&gt; 个不同的取值 ，根据特征 &lt;span class="math"&gt;\(A\)&lt;/span&gt; 的取值将 &lt;span class="math"&gt;\(D\)&lt;/span&gt; 划分为 &lt;span class="math"&gt;\(n\)&lt;/span&gt; 个子集，&lt;span class="math"&gt;\(|D_i|\)&lt;/span&gt; 为 &lt;span class="math"&gt;\(D_i\)&lt;/span&gt; 的样本个数。记子集 &lt;span class="math"&gt;\(D_i\)&lt;/span&gt; 中属于类 &lt;span class="math"&gt;\(C_k\)&lt;/span&gt; 的样本的集合为 &lt;span class="math"&gt;\(D_{ik}\)&lt;/span&gt;，&lt;span class="math"&gt;\(|D_{ik}|\)&lt;/span&gt; 为 &lt;span class="math"&gt;\(D_{ik}\)&lt;/span&gt; 的样本个数，于是信息增益的算法如下&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;
算法 5.1 （信息增益的算法）&lt;br&gt;
输入：训练数据集 &lt;span class="math"&gt;\(D\)&lt;/span&gt; 和特征 &lt;span class="math"&gt;\(A\)&lt;/span&gt;&lt;br&gt;
输出：特征 &lt;span class="math"&gt;\(A\)&lt;/span&gt; 对训练数据集 &lt;span class="math"&gt;\(D\)&lt;/span&gt; 的信息增益 &lt;span class="math"&gt;\(g(D,A)\)&lt;/span&gt;&lt;br&gt;
(1) 计算数据集 &lt;span class="math"&gt;\(D\)&lt;/span&gt; 的经验熵 &lt;span class="math"&gt;\(H(D)\)&lt;/span&gt;&lt;br&gt;
&lt;div class="math"&gt;$$H(D)=-\sum_{k=1}^K\frac{|C_k|}{|D|}\log_2\frac{|C_k|}{|D|}$$&lt;/div&gt;
(2) 计算特征 &lt;span class="math"&gt;\(A\)&lt;/span&gt; 对数据集 &lt;span class="math"&gt;\(D\)&lt;/span&gt; 的经验条件熵 &lt;span class="math"&gt;\(H(D|A)\)&lt;/span&gt;&lt;br&gt;
&lt;div class="math"&gt;$$H(D|A)=\sum_{i=1}^n\frac{|D_i|}{|D|}H(D_i)=-\sum_{i=1}^n\frac{|D_i|}{|D|}\sum_{k=1}^K\frac{|D_{ik}|}{|D_i|}\log_2\frac{|D_{ik}|}{|D_i|}$$&lt;/div&gt;
(3) 计算信息增益
&lt;div class="math"&gt;$$g(D,A)=H(D)-H(D|A)$$&lt;/div&gt;
&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;5.2.3 信息增益比&lt;/h3&gt;
&lt;p&gt;以信息增益作为划分训练集的特征，存在偏向于选择取值较多的特征的问题。使用信息增益比（information gain ratio）可以对这一问题进行校正。这是特征选择的另一准则。&lt;/p&gt;
&lt;p&gt;首先说明下为何信息增益会偏向选择取值较多的特性：假设特征 &lt;span class="math"&gt;\(A\)&lt;/span&gt; 有 &lt;span class="math"&gt;\(N\)&lt;/span&gt; 个不同取值（意味着每一个样本的特征 &lt;span class="math"&gt;\(A\)&lt;/span&gt; 都有一个不同的值），则易知 &lt;span class="math"&gt;\(H(D|A)=0\)&lt;/span&gt;，故一定会选取这个特性，但是这个特性（例如仅仅是不同训练数据的标号）可能对分类无用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;
定义 5.3 （信息增益比）特征 &lt;span class="math"&gt;\(A\)&lt;/span&gt; 对训练数据集 &lt;span class="math"&gt;\(D\)&lt;/span&gt; 的信息增益比 &lt;span class="math"&gt;\(g_R(D,A)\)&lt;/span&gt; 定义为其信息增益 &lt;span class="math"&gt;\(g(D,A)\)&lt;/span&gt; 与训练数据集 &lt;span class="math"&gt;\(D\)&lt;/span&gt; 关于特征 &lt;span class="math"&gt;\(A\)&lt;/span&gt; 的值的熵 &lt;span class="math"&gt;\(H_A(D)\)&lt;/span&gt; 之比
&lt;div class="math"&gt;$$g_R(D,A)=\frac{g(D,A)}{H_A{(D)}}$$&lt;/div&gt;
其中
&lt;div class="math"&gt;$$H_A(D)=-\sum_{i=1}^n\frac{|D_i|}{|D|}\log_2\frac{|D_i|}{|D|}$$&lt;/div&gt;
&lt;span class="math"&gt;\(n\)&lt;/span&gt; 是特征 &lt;span class="math"&gt;\(A\)&lt;/span&gt; 取值的个数。
&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;5.3 决策树的生成&lt;/h2&gt;
&lt;h3&gt;5.3.1 ID3 算法&lt;/h3&gt;
&lt;p&gt;ID3 算法的核心是在决策树各个节点上应用信息增益准则选择特征，递归的构建决策树，直到所有特征的信息增益均很小或没有特征可以选择为止。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;
算法 5.2 （ID3 算法）&lt;br&gt;
输入：训练数据集 &lt;span class="math"&gt;\(D\)&lt;/span&gt;，特征集 &lt;span class="math"&gt;\(A\)&lt;/span&gt;，阈值 &lt;span class="math"&gt;\(\epsilon\)&lt;/span&gt;&lt;br&gt;
输出：决策树 &lt;span class="math"&gt;\(T\)&lt;/span&gt;&lt;br&gt;
(1) 若 &lt;span class="math"&gt;\(D\)&lt;/span&gt; 中所有实例属于同一类 &lt;span class="math"&gt;\(C_k\)&lt;/span&gt;，则 &lt;span class="math"&gt;\(T\)&lt;/span&gt; 为单节点树，并将类 &lt;span class="math"&gt;\(C_k\)&lt;/span&gt; 作为该节点的类标记，返回 &lt;span class="math"&gt;\(T\)&lt;/span&gt;&lt;br&gt;
(2) 若 &lt;span class="math"&gt;\(A=\varnothing\)&lt;/span&gt;，则 &lt;span class="math"&gt;\(T\)&lt;/span&gt; 为单节点树，并将 &lt;span class="math"&gt;\(D\)&lt;/span&gt; 中实例数最大的类 &lt;span class="math"&gt;\(C_k\)&lt;/span&gt; 作为该节点的类标记，返回 &lt;span class="math"&gt;\(T\)&lt;/span&gt;&lt;br&gt;
(3) 否则，按算法 5.1 计算 &lt;span class="math"&gt;\(A\)&lt;/span&gt; 中哥特征对 &lt;span class="math"&gt;\(D\)&lt;/span&gt; 的信息增益，选择信息增益最大的特征 &lt;span class="math"&gt;\(A_g\)&lt;/span&gt;&lt;br&gt;
(4) 如果 &lt;span class="math"&gt;\(A_g\)&lt;/span&gt; 的信息增益小于阈值 &lt;span class="math"&gt;\(\epsilon\)&lt;/span&gt;，则置 &lt;span class="math"&gt;\(T\)&lt;/span&gt; 为单节点树，并将 &lt;span class="math"&gt;\(D\)&lt;/span&gt; 中实例数最大的类 &lt;span class="math"&gt;\(C_k\)&lt;/span&gt; 作为该节点的类标记，返回 &lt;span class="math"&gt;\(T\)&lt;/span&gt;&lt;br&gt;
(5) 否则，对 &lt;span class="math"&gt;\(A_g\)&lt;/span&gt; 的每一个可能值 &lt;span class="math"&gt;\(a_i\)&lt;/span&gt;，依 &lt;span class="math"&gt;\(A_g=a_i\)&lt;/span&gt; 将 &lt;span class="math"&gt;\(D\)&lt;/span&gt; 分割为若干非空子集 &lt;span class="math"&gt;\(D_i\)&lt;/span&gt;，将 &lt;span class="math"&gt;\(D_i\)&lt;/span&gt; 中实例数最大的类作为标记，构建子节点，由节点及其子节点构成数 &lt;span class="math"&gt;\(T\)&lt;/span&gt;，返回 &lt;span class="math"&gt;\(T\)&lt;/span&gt;&lt;br&gt;
(6) 对第 &lt;span class="math"&gt;\(i\)&lt;/span&gt; 个子节点，以 &lt;span class="math"&gt;\(D_i\)&lt;/span&gt; 为训练集，以 &lt;span class="math"&gt;\(A-\{A_g\}\)&lt;/span&gt; 为特征集递归的调用步骤 (1)~(5)，得到子树 &lt;span class="math"&gt;\(T_i\)&lt;/span&gt;，返回 &lt;span class="math"&gt;\(T_i\)&lt;/span&gt;
&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ID3 算法只有树的生成。所以该算法生成的树容易产生过拟合。&lt;/p&gt;
&lt;h3&gt;5.3.2 C4.5 的生成算法&lt;/h3&gt;
&lt;p&gt;C4.5 算法与 ID3 算法相似，C4.5 算法对 ID3 算法进行了改进，用信息增益比选择特征。其他步骤相同。&lt;/p&gt;
&lt;h2&gt;5.4 决策树的剪枝&lt;/h2&gt;
&lt;p&gt;决策树生成算法递归的产生决策树，直到不能继续下去为止。这样产生的树往往对训练数据的分类很准确，但对未知的测试数据的分类却没有那么准确，即出现过拟合现象。&lt;/p&gt;
&lt;p&gt;过拟合产生的原因是学习时过多的考虑如何提高对训练数据的正确分类，从而构建出过于复杂的决策树。&lt;/p&gt;
&lt;p&gt;解决这个问题的办法是对已生成的决策树进行简化——剪枝（pruning）。也就是从生成的决策树上剪掉一些子树或者叶节点。&lt;/p&gt;
&lt;p&gt;决策树的剪枝往往通过极小化决策树整体的损失函数或代价函数来实现。&lt;/p&gt;
&lt;p&gt;设树 &lt;span class="math"&gt;\(T\)&lt;/span&gt; 的叶节点个数为 &lt;span class="math"&gt;\(|T|\)&lt;/span&gt;，&lt;span class="math"&gt;\(t\)&lt;/span&gt; 是树 &lt;span class="math"&gt;\(T\)&lt;/span&gt; 的叶节点，该叶节点有 &lt;span class="math"&gt;\(N_t\)&lt;/span&gt; 个样本点，其中 &lt;span class="math"&gt;\(k\)&lt;/span&gt; 类的样本点有 &lt;span class="math"&gt;\(N_{tk}\)&lt;/span&gt; 个，&lt;span class="math"&gt;\(k=1,2,\cdots,K\)&lt;/span&gt;，&lt;span class="math"&gt;\(H_t(T)\)&lt;/span&gt; 为叶节点 &lt;span class="math"&gt;\(t\)&lt;/span&gt; 上的经验熵， &lt;span class="math"&gt;\(\alpha\geq0\)&lt;/span&gt; 为参数，则决策树学习的损失函数可以定义为
&lt;/p&gt;
&lt;div class="math"&gt;$$C_{\alpha}(T)=\sum_{t=1}^{|T|}N_tH_t(T)+\alpha|T|$$&lt;/div&gt;
&lt;p&gt;
其中经验熵为
&lt;/p&gt;
&lt;div class="math"&gt;$$H_t(T)=-\sum_{k=1}^K\frac{N_{tk}}{N_t}\log\frac{N_{tk}}{N_t}$$&lt;/div&gt;
&lt;p&gt;
令
&lt;/p&gt;
&lt;div class="math"&gt;$$C(T)=\sum_{t=1}^{|T|}N_tH_t(T)=-\sum_{t=1}^{|T|}\sum_{k=1}^KN_{tk}\log\frac{N_{tk}}{N_t}$$&lt;/div&gt;
&lt;p&gt;
则
&lt;/p&gt;
&lt;div class="math"&gt;$$C_\alpha(T)=C(T)+\alpha|T|$$&lt;/div&gt;
&lt;p&gt;
上式中，&lt;span class="math"&gt;\(C(T)\)&lt;/span&gt; 表示模型对训练数据的预测误差，&lt;span class="math"&gt;\(|T|\)&lt;/span&gt; 表示模型复杂度，参数 &lt;span class="math"&gt;\(\alpha\geq0\)&lt;/span&gt; 控制两者之间的影响。&lt;/p&gt;
&lt;p&gt;剪枝，就是当 &lt;span class="math"&gt;\(\alpha\)&lt;/span&gt; 确定时，选择损失函数最小的模型。&lt;/p&gt;
&lt;p&gt;决策树生成学习局部的模型，而决策树剪枝学习整体的模型。&lt;/p&gt;
&lt;p&gt;上式中定义的损失函数的极小化等价于正则化的极大似然估计。所以，利用损失函数最小原则进行剪枝就是用正则化的最大似然估计进行模型选择。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;
算法 5.4 （树的剪枝算法）&lt;br&gt;
输入：生成算法产生的整个树 &lt;span class="math"&gt;\(T\)&lt;/span&gt;，参数 &lt;span class="math"&gt;\(\alpha\)&lt;/span&gt;&lt;br&gt;
输出：修剪后的子树 &lt;span class="math"&gt;\(T_\alpha\)&lt;/span&gt;&lt;br&gt;
(1) 计算每个节点的经验熵&lt;br&gt;
(2) 递归的从树的叶节点向上回缩：设一组叶节点回缩到其父节点之前与之后的整体树分别为 &lt;span class="math"&gt;\(T_B\)&lt;/span&gt; 和 &lt;span class="math"&gt;\(T_A\)&lt;/span&gt;，其对应的损失函数分别是 &lt;span class="math"&gt;\(C_\alpha(T_B)\)&lt;/span&gt; 和 &lt;span class="math"&gt;\(C_\alpha(T_A)\)&lt;/span&gt;，如果
&lt;div class="math"&gt;$$C_\alpha(T_A)\leq C_\alpha(T_B)$$&lt;/div&gt;
则进行剪枝，即将父节点变为新的叶节点&lt;br&gt;
(3) 返回 (2)，直至不能继续为止，得到损失函数最小的子树 &lt;span class="math"&gt;\(T_\alpha\)&lt;/span&gt;
&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为步骤 (2) 中只考虑两个树的损失函数的差，其计算可以在局部进行，所以可以用动态规划算法实现。&lt;/p&gt;
&lt;h2&gt;5.5 CRAT 算法&lt;/h2&gt;
&lt;p&gt;分类与回归树（classification and regression tree）模型是应用广泛的决策树学习方法，既可以用于分类也可以用于回归。&lt;/p&gt;
&lt;p&gt;CART 是在给定输入随机变量 &lt;span class="math"&gt;\(X\)&lt;/span&gt; 条件下输出随机变量 &lt;span class="math"&gt;\(Y\)&lt;/span&gt; 的条件概率分布的学习方法。CART 假设决策树是二叉树，内部节点特征的取值为“是”和“否”。左分的取值是“是”，右分支的取值是“否”。&lt;/p&gt;
&lt;p&gt;CRAT 算法由以下两步组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;决策树生成：基于训练数据集生成决策树，生成的决策树要尽量大&lt;/li&gt;
&lt;li&gt;决策树剪枝：用验证数据集对已生成的树进行剪枝并选择最优子树，这时用损失函数最小作为剪枝的标准&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;5.5.1 CART 生成&lt;/h3&gt;
&lt;p&gt;决策树的生成就是递归的构建二叉决策树的过程，对回归树用平方误差最小化准则，对分类树用基尼指数（Gini index）最小化准则，进行特征选择，生成二叉树。&lt;/p&gt;
&lt;h4&gt;回归树的生成&lt;/h4&gt;
&lt;p&gt;假设 &lt;span class="math"&gt;\(X\)&lt;/span&gt; 和 &lt;span class="math"&gt;\(Y\)&lt;/span&gt; 分别为输入和输出变量，并且 &lt;span class="math"&gt;\(Y\)&lt;/span&gt; 是连续变量，给定训练数据集
&lt;/p&gt;
&lt;div class="math"&gt;$$D=\{(x_1,y_1),(x_2,y_2),\cdots,(x_N,y_N)\}$$&lt;/div&gt;
&lt;p&gt;
一个回归树对应着输入空间（特征空间）的一个划分以及在划分的单元上的输出值。假设已经将输入空间划分为 &lt;span class="math"&gt;\(M\)&lt;/span&gt; 个单元 &lt;span class="math"&gt;\(R_1,R_2,\cdots,R_M\)&lt;/span&gt;，并且每个单元 &lt;span class="math"&gt;\(R_m\)&lt;/span&gt; 上有一个固定的输出值 &lt;span class="math"&gt;\(c_m\)&lt;/span&gt;，于是，回归树模型可表示为
&lt;/p&gt;
&lt;div class="math"&gt;$$f(x)=\sum_{m=1}^Mc_m\mathbb{I}(x\in R_m)$$&lt;/div&gt;
&lt;p&gt;
当输入空间的划分确定时，可以用平方误差
&lt;/p&gt;
&lt;div class="math"&gt;$$\sum_{x_i\in R_m}\left(y_i-f(x_i)\right)^2$$&lt;/div&gt;
&lt;p&gt;
来表示回归树对于训练数据集的预测误差，用平方误差最下的准则求解每个单元上的最优输出值。&lt;/p&gt;
&lt;p&gt;易知，单元 &lt;span class="math"&gt;\(R_m\)&lt;/span&gt; 上的 &lt;span class="math"&gt;\(c_m\)&lt;/span&gt; 的最优值 &lt;span class="math"&gt;\(\hat{c}_m\)&lt;/span&gt; 是 &lt;span class="math"&gt;\(R_m\)&lt;/span&gt; 上所有输入实例 &lt;span class="math"&gt;\(x_i\)&lt;/span&gt; 对于的输出 &lt;span class="math"&gt;\(y_i\)&lt;/span&gt; 的均值，即
&lt;/p&gt;
&lt;div class="math"&gt;$$\hat{c}_m=\text{ave}(y_i|x_i\in R_m)$$&lt;/div&gt;
&lt;p&gt;
问题是怎么对输入空间进行划分。&lt;/p&gt;
&lt;p&gt;这里采用启发式的方法，选择第 &lt;span class="math"&gt;\(j\)&lt;/span&gt; 个特征 &lt;span class="math"&gt;\(x^{(i)}\)&lt;/span&gt; 和它的取值 &lt;span class="math"&gt;\(s\)&lt;/span&gt;，作为切分变量（splitting variable）和切分点（splitting point），并定义两个区域
&lt;/p&gt;
&lt;div class="math"&gt;$$\begin{eqnarray}
R_1(j,s) &amp;amp;=&amp;amp; \{x|x^{(j)}\leq s\} \\
R_2(j,s) &amp;amp;=&amp;amp; \{x|x^{(j)}&amp;gt;s\}
\end{eqnarray}$$&lt;/div&gt;
&lt;p&gt;
然后对于固定的 &lt;span class="math"&gt;\(j\)&lt;/span&gt; 可以找到最优切分的 &lt;span class="math"&gt;\(s\)&lt;/span&gt;，具体的，求解
&lt;/p&gt;
&lt;div class="math"&gt;$$\min_{j,s}\left[\min_{c_1}\sum_{x_i\in R_1(j,s)}(y_i-c_1)^2+\min_{c_2}\sum_{x_i\in R_2(j,s)}(y_i-c_2)^2\right]$$&lt;/div&gt;
&lt;p&gt;
历遍所有输入变量，找到最优的切分变量 &lt;span class="math"&gt;\(j\)&lt;/span&gt;，构成一个对 &lt;span class="math"&gt;\((j,s)\)&lt;/span&gt;。依次将输入空间划分为两个区域。接着，对每个区域重复上述划分过程，直到满足停止条件为止。这种方法生成的回归树通常称为最小二乘回归树（least squares regression tree）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;
算法 5.5 （最小二乘回归树生成算法）&lt;br&gt;
输入：训练数据集 &lt;span class="math"&gt;\(D\)&lt;/span&gt;&lt;br&gt;
输出：回归树 &lt;span class="math"&gt;\(f(x)\)&lt;/span&gt;&lt;br&gt;
在训练数据集所在的输入空间中，递归的将每个区域划分为两个子区域并决定每个子区域的输出值，构建二叉决策树&lt;br&gt;
(1) 选择最优切分变量 &lt;span class="math"&gt;\(j\)&lt;/span&gt; 和切分点 &lt;span class="math"&gt;\(s\)&lt;/span&gt;，求解
&lt;div class="math"&gt;$$\min_{j,s}\left[\min_{c_1}\sum_{x_i\in R_1(j,s)}(y_i-c_1)^2+\min_{c_2}\sum_{x_i\in R_2(j,s)}(y_i-c_2)^2\right]$$&lt;/div&gt;
遍历 &lt;span class="math"&gt;\(j\)&lt;/span&gt;，对固定的切分变量 &lt;span class="math"&gt;\(j\)&lt;/span&gt; 扫描切分点 &lt;span class="math"&gt;\(s\)&lt;/span&gt;，选择使上式最小的对 &lt;span class="math"&gt;\((j,s)\)&lt;/span&gt;&lt;br&gt;
(2) 用选定的对 &lt;span class="math"&gt;\((j,s)\)&lt;/span&gt; 划分区域并决定相应的输出值
&lt;div class="math"&gt;$$\begin{eqnarray}
R_1(j,s) &amp;amp;=&amp;amp; \{x|x^{(j)}\leq s\} \\
R_2(j,s) &amp;amp;=&amp;amp; \{x|x^{(j)}&amp;gt;s\}
\end{eqnarray}\\
\hat{c}_m=\frac{1}{N_m}\sum_{x_i\in R_m(j,s)}y_i,x\in R_m,m=1,2$$&lt;/div&gt;
(3) 继续对两个子区域调用步骤 (1)，(2)，直到满足停止条件&lt;br&gt;
(4) 将输入空间划分为 &lt;span class="math"&gt;\(M\)&lt;/span&gt; 个区域 &lt;span class="math"&gt;\(R_1,R_2,\cdots,R_M\)&lt;/span&gt;，生成决策树
&lt;div class="math"&gt;$$f(x)=\sum_{m=1}^M\hat{c}_m\mathbb{I}(x\in R_m)$$&lt;/div&gt;
&lt;/strong&gt;&lt;/p&gt;
&lt;h4&gt;分类树的生成&lt;/h4&gt;
&lt;p&gt;分类树用基尼指数选择最优特征，同时决定该特征的最优二值切分点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;
定义 5.4 （基尼指数）分类问题中，假设有 &lt;span class="math"&gt;\(K\)&lt;/span&gt; 个类，样本点属于第 &lt;span class="math"&gt;\(k\)&lt;/span&gt; 类的概率为 &lt;span class="math"&gt;\(p_k\)&lt;/span&gt;，则概率分布的基尼指数定义为
&lt;div class="math"&gt;$$\text{Gini}(p)=\sum_{k=1}^Kp_k(1-p_k)=1-\sum_{k=1}^Kp_k^2$$&lt;/div&gt;
对于二分类问题，若样本点属于第一个类的概率是 &lt;span class="math"&gt;\(p\)&lt;/span&gt;，则概率分布的基尼指数为
&lt;div class="math"&gt;$$\text{Gini}(p)=2p(1-p)$$&lt;/div&gt;
&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于给定的样本集合 &lt;span class="math"&gt;\(D\)&lt;/span&gt;，其基尼指数为
&lt;/p&gt;
&lt;div class="math"&gt;$$\text{Gini}(D)=1-\sum_{k=1}^K\left(\frac{|C_k|}{|D|}\right)^2$$&lt;/div&gt;
&lt;p&gt;
这里，&lt;span class="math"&gt;\(C_k\)&lt;/span&gt; 是属于第 &lt;span class="math"&gt;\(k\)&lt;/span&gt; 类的样本子集，&lt;span class="math"&gt;\(K\)&lt;/span&gt; 是类的个数。&lt;/p&gt;
&lt;p&gt;如果样本集合 &lt;span class="math"&gt;\(D\)&lt;/span&gt; 根据特征 &lt;span class="math"&gt;\(A\)&lt;/span&gt; 是否取某一可能值 &lt;span class="math"&gt;\(a\)&lt;/span&gt; 被分割成 &lt;span class="math"&gt;\(D_1\)&lt;/span&gt; 和 &lt;span class="math"&gt;\(D_2\)&lt;/span&gt; 两部分，即
&lt;/p&gt;
&lt;div class="math"&gt;$$D_1=\{(x,y)\in D|A(x)=a\},D_2=D-D_1$$&lt;/div&gt;
&lt;p&gt;
则在特征 A 的条件下，集合 D 的基尼指数定义为
&lt;/p&gt;
&lt;div class="math"&gt;$$\text{Gini}(D,A)=\frac{|D_1|}{|D|}\text{Gini}(D_1)+\frac{|D_2|}{|D|}\text{Gini}(D_2)$$&lt;/div&gt;
&lt;p&gt;
基尼指数 &lt;span class="math"&gt;\(\text{Gini}(D)\)&lt;/span&gt; 表示集合 &lt;span class="math"&gt;\(D\)&lt;/span&gt; 的不确定性，基尼指数 &lt;span class="math"&gt;\(\text{Gini}(D,A)\)&lt;/span&gt; 表示经 &lt;span class="math"&gt;\(A=a\)&lt;/span&gt; 分割后集合 &lt;span class="math"&gt;\(D\)&lt;/span&gt; 的不确定性。基尼指数数值越大，样本集合的不确定性也就越大，这一点与熵类似。

&lt;strong&gt;
算法 5.6 （CART 生成算法）&lt;br&gt;
输入：训练数据集 &lt;span class="math"&gt;\(D\)&lt;/span&gt;，停止计算的条件&lt;br&gt;
输出：CART 决策树&lt;br&gt;
根据训练数据集，从根节点开始，递归的对每个节点进行以下操作，构建二叉决策树：&lt;br&gt;
(1) 设节点的训练数据集为 &lt;span class="math"&gt;\(D\)&lt;/span&gt;，计算现有特征对该数据集的基尼指数。此时，对每一个特征 &lt;span class="math"&gt;\(A\)&lt;/span&gt;，对其可能取的每个值 &lt;span class="math"&gt;\(a\)&lt;/span&gt;，根据样本点对 &lt;span class="math"&gt;\(A=a\)&lt;/span&gt; 的测试为“是”或“否”将 &lt;span class="math"&gt;\(D\)&lt;/span&gt; 分割为两部分，计算 &lt;span class="math"&gt;\(A=a\)&lt;/span&gt; 时的基尼指数&lt;br&gt;
(2) 在所有可能的特征 &lt;span class="math"&gt;\(A\)&lt;/span&gt; 以及它们所有可能的切分点 &lt;span class="math"&gt;\(a\)&lt;/span&gt; 中，选择基尼指数最小的特征及其对应的切分点作为最优特征和最优切分点。依最优特征和最优切分点，从现节点生成两个子节点，将训练数据集依特征分配到两个子节点去&lt;br&gt;
(3) 对两个子节点递归的调用 (1)、(2)，直至满足停止条件&lt;br&gt;
(4) 生成 CART 决策树
&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;算法停止的条件是节点中的样本个数少于预定阈值，或样本集的基尼指数小于预定阈值（样本基本属于同一类），或者没有更多特征。&lt;/p&gt;
&lt;h3&gt;5.5.2 CART 剪枝&lt;/h3&gt;
&lt;p&gt;CART 剪枝算法从“完全生长”的决策树的底端剪去一些子树，使决策树变小（模型变简单），从而能够对未知数据有更准确的预测。&lt;/p&gt;
&lt;p&gt;CART 剪枝算法由两步组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从生成算法产生的决策树 &lt;span class="math"&gt;\(T_0\)&lt;/span&gt; 底部开始不断剪枝，直到 &lt;span class="math"&gt;\(T_0\)&lt;/span&gt; 的根节点，行成一个子树序列
&lt;div class="math"&gt;$$\{T_0,T_1,\cdots,T_n\}$$&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;通过交叉验证法在独立的验证数据集上对子树序列进行测试，从中选择最优子树&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;剪枝，形成一个子树序列&lt;/h4&gt;
&lt;p&gt;在剪枝过程中，计算子树的损失函数：
&lt;/p&gt;
&lt;div class="math"&gt;$$C_\alpha(T)=C(T)+\alpha|T|$$&lt;/div&gt;
&lt;p&gt;
其中，&lt;span class="math"&gt;\(T\)&lt;/span&gt; 为任意子树，&lt;span class="math"&gt;\(C(T)\)&lt;/span&gt; 为对训练数据的预测误差（如基尼指数），&lt;span class="math"&gt;\(|T|\)&lt;/span&gt; 为子树的叶节点个数，&lt;span class="math"&gt;\(\alpha\geq0\)&lt;/span&gt; 为参数，&lt;span class="math"&gt;\(C_\alpha(T)\)&lt;/span&gt; 为参数是 &lt;span class="math"&gt;\(\alpha\)&lt;/span&gt; 时的子树 &lt;span class="math"&gt;\(T\)&lt;/span&gt; 的整体损失。参数 &lt;span class="math"&gt;\(\alpha\)&lt;/span&gt; 权衡训练数据的拟合程度与模型的复杂度。&lt;/p&gt;
&lt;p&gt;对固定的 &lt;span class="math"&gt;\(\alpha\)&lt;/span&gt;，一定存在使损失函数 &lt;span class="math"&gt;\(C_\alpha(T)\)&lt;/span&gt; 最小的子树，将其表示为 &lt;span class="math"&gt;\(T_\alpha\)&lt;/span&gt;。&lt;span class="math"&gt;\(T_\alpha\)&lt;/span&gt; 在损失函数 &lt;span class="math"&gt;\(C_\alpha(T)\)&lt;/span&gt; 最小的意义下是最优的。容易验证这样的最优子树是唯一的。当 &lt;span class="math"&gt;\(\alpha\)&lt;/span&gt; 大的时候，最优子树 &lt;span class="math"&gt;\(T_\alpha\)&lt;/span&gt; 偏小；当 &lt;span class="math"&gt;\(\alpha\)&lt;/span&gt; 小的时候，最优子树 &lt;span class="math"&gt;\(T_\alpha\)&lt;/span&gt; 偏大。极端情况下，如果 &lt;span class="math"&gt;\(\alpha=0\)&lt;/span&gt;，那么整体树是最优的。当 &lt;span class="math"&gt;\(\alpha\to+\infty\)&lt;/span&gt; 时，根节点组成的单节点树是最优的。&lt;/p&gt;
&lt;p&gt;Breiman 等人证明：可以用递归的方法对树进行剪枝.将 &lt;span class="math"&gt;\(\alpha\)&lt;/span&gt; 从小增大：
&lt;/p&gt;
&lt;div class="math"&gt;$$0=\alpha_0&amp;lt;\alpha_1&amp;lt;\cdots&amp;lt;\alpha_n&amp;lt;+\infty$$&lt;/div&gt;
&lt;p&gt;
产生一系列的区间：
&lt;/p&gt;
&lt;div class="math"&gt;$$[\alpha_i,\alpha_{i+1}),i=0,1,\cdots,n$$&lt;/div&gt;
&lt;p&gt;
剪枝得到的子树序列对应着区间 &lt;span class="math"&gt;\(\alpha\in[\alpha_i,\alpha_{i+1}),i=0,1,\cdots,n\)&lt;/span&gt; 的最优子树序列：
&lt;/p&gt;
&lt;div class="math"&gt;$$\{T_0,T_1,\cdots,T_n\}$$&lt;/div&gt;
&lt;p&gt;
序列中的子树是嵌套的。&lt;/p&gt;
&lt;p&gt;具体的，从整体树 &lt;span class="math"&gt;\(T_0\)&lt;/span&gt; 开始剪枝。对 &lt;span class="math"&gt;\(T_0\)&lt;/span&gt; 的任意内部节点 &lt;span class="math"&gt;\(t\)&lt;/span&gt;，以 &lt;span class="math"&gt;\(t\)&lt;/span&gt; 为单节点树的损失函数是
&lt;/p&gt;
&lt;div class="math"&gt;$$C_\alpha(t)=C(t)+\alpha$$&lt;/div&gt;
&lt;p&gt;
以 &lt;span class="math"&gt;\(t\)&lt;/span&gt; 为根节点的子树 &lt;span class="math"&gt;\(T_t\)&lt;/span&gt; 的损失函数是
&lt;/p&gt;
&lt;div class="math"&gt;$$C_\alpha(T_t)=C(T_t)+\alpha|T_t|$$&lt;/div&gt;
&lt;p&gt;
当 &lt;span class="math"&gt;\(\alpha=0\)&lt;/span&gt; 及 &lt;span class="math"&gt;\(\alpha\)&lt;/span&gt; 充分小时，有不等式
&lt;/p&gt;
&lt;div class="math"&gt;$$C_\alpha(T_t)&amp;lt;C_\alpha(t)$$&lt;/div&gt;
&lt;p&gt;
当 &lt;span class="math"&gt;\(\alpha\)&lt;/span&gt; 增大时，在某一 &lt;span class="math"&gt;\(\alpha\)&lt;/span&gt; 有
&lt;/p&gt;
&lt;div class="math"&gt;$$C_\alpha(T_t)=C_\alpha(t)$$&lt;/div&gt;
&lt;p&gt;
当 &lt;span class="math"&gt;\(\alpha\)&lt;/span&gt; 再增大时，有
&lt;/p&gt;
&lt;div class="math"&gt;$$C_\alpha(T_t)&amp;gt;C_\alpha(t)$$&lt;/div&gt;
&lt;p&gt;综上所述，只要
&lt;/p&gt;
&lt;div class="math"&gt;$$\alpha=\frac{C(t)-C(T_t)}{|T_t|-1}$$&lt;/div&gt;
&lt;p&gt;
则 &lt;span class="math"&gt;\(T_t\)&lt;/span&gt; 与 &lt;span class="math"&gt;\(t\)&lt;/span&gt; 有相同的损失函数值，而 &lt;span class="math"&gt;\(t\)&lt;/span&gt; 的节点少，对 &lt;span class="math"&gt;\(T_t\)&lt;/span&gt; 进行剪枝。&lt;/p&gt;
&lt;p&gt;所以，对 &lt;span class="math"&gt;\(T_0\)&lt;/span&gt; 中每一内部节点 &lt;span class="math"&gt;\(t\)&lt;/span&gt;，计算
&lt;/p&gt;
&lt;div class="math"&gt;$$g(t)=\frac{C(t)-C(T_t)}{|T_t|-1}$$&lt;/div&gt;
&lt;p&gt;
它表示剪枝后整体损失函数减少的程度。在 &lt;span class="math"&gt;\(T_0\)&lt;/span&gt; 中剪去 &lt;span class="math"&gt;\(g(t)\)&lt;/span&gt; 最小的 &lt;span class="math"&gt;\(T_t\)&lt;/span&gt;（这里我们是要得到一系列的 &lt;span class="math"&gt;\(\alpha\)&lt;/span&gt; 区间，所以是剪去最小的），将得到的子树作为 &lt;span class="math"&gt;\(T_1\)&lt;/span&gt;，同时将最小的 &lt;span class="math"&gt;\(g(t)\)&lt;/span&gt; 设为 &lt;span class="math"&gt;\(\alpha_1\)&lt;/span&gt;。&lt;span class="math"&gt;\(T_1\)&lt;/span&gt; 为区间 &lt;span class="math"&gt;\([\alpha_1,\alpha_2)\)&lt;/span&gt; 的最优子树。&lt;/p&gt;
&lt;p&gt;如此剪枝下去，直到得到根节点。在这一过程中，不断的增加 &lt;span class="math"&gt;\(\alpha\)&lt;/span&gt; 的值，产生新的区间。&lt;/p&gt;
&lt;h4&gt;在剪枝得到的子树序列中通过交叉验证选取最优子树 &lt;span class="math"&gt;\(T_\alpha\)&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;具体的，利用独立的验证数据集，测试子树序列中各棵子树的平方误差或基尼指数。平方误差或基尼指数小的决策树被认为是最优的决策树。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;
算法 5.7 （CART 剪枝算法）&lt;br&gt;
输入：CART 算法生成的决策树 &lt;span class="math"&gt;\(T_0\)&lt;/span&gt;&lt;br&gt;
输出：最优决策树 &lt;span class="math"&gt;\(T_\alpha\)&lt;/span&gt;&lt;br&gt;
(1) 设 &lt;span class="math"&gt;\(k=0,T=T_0\)&lt;/span&gt;&lt;br&gt;
(2) 设 &lt;span class="math"&gt;\(\alpha=+\infty\)&lt;/span&gt;
(3) 自下而上的对各个内部节点 &lt;span class="math"&gt;\(t\)&lt;/span&gt; 计算 &lt;span class="math"&gt;\(C(T_t)\)&lt;/span&gt;，&lt;span class="math"&gt;\(|T_t|\)&lt;/span&gt; 以及
&lt;div class="math"&gt;$$\begin{eqnarray}
g(t) &amp;amp;=&amp;amp; \frac{C(t)-C(T_t)}{|T_t|-1} \\
\alpha &amp;amp;=&amp;amp; \min(\alpha,g(t))
\end{eqnarray}$$&lt;/div&gt;
这里，&lt;span class="math"&gt;\(T_t\)&lt;/span&gt; 表示以 &lt;span class="math"&gt;\(t\)&lt;/span&gt; 为根节点的子树，&lt;span class="math"&gt;\(C(T_t)\)&lt;/span&gt; 是对训练数据的预测误差，&lt;span class="math"&gt;\(|T_t|\)&lt;/span&gt; 是 &lt;span class="math"&gt;\(T_t\)&lt;/span&gt; 的叶节点个数&lt;br&gt;
(4) 对 &lt;span class="math"&gt;\(g(t)=\alpha\)&lt;/span&gt; 的内部节点 &lt;span class="math"&gt;\(t\)&lt;/span&gt; 进行剪枝，并对叶节点 &lt;span class="math"&gt;\(t\)&lt;/span&gt; 以多数表决法决定其类，得到树 &lt;span class="math"&gt;\(T\)&lt;/span&gt;&lt;br&gt;
(5) 设 &lt;span class="math"&gt;\(k=k+1.\alpha_k=\alpha,T_k=T\)&lt;/span&gt;&lt;br&gt;
(6) 如果 &lt;span class="math"&gt;\(T_k\)&lt;/span&gt; 不是由根节点及两个叶节点构成的树，则返回到步骤 (3)；否则，令 &lt;span class="math"&gt;\(T_k=T_n\)&lt;/span&gt;&lt;br&gt;
(7) 采用交叉验证法在子树序列 &lt;span class="math"&gt;\(T_0,T_1,\cdots,T_n\)&lt;/span&gt; 中选择最优子树 &lt;span class="math"&gt;\(T_\alpha\)&lt;/span&gt;
&lt;/strong&gt;&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="统计学习"></category><category term="机器学习"></category></entry><entry><title>统计学习方法 第四章 朴素贝叶斯法</title><link href="https://xutree.github.io/pages/2018/11/07/4/" rel="alternate"></link><published>2018-11-07T16:42:01+08:00</published><updated>2018-11-07T16:42:01+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-11-07:/pages/2018/11/07/4/</id><summary type="html">&lt;p&gt;朴素贝叶斯（naive Bayes）法是基于贝叶斯定理与特征条件独立假设的分类方法。朴素贝叶斯法实现简单，学习和预测效率都很高，是一种常用的方法。&lt;/p&gt;
&lt;h2&gt;4.1 朴素贝叶斯法的学习与分类&lt;/h2&gt;
&lt;h3&gt;4.1.1 基本方法&lt;/h3&gt;
&lt;p&gt;设输入特征向量
&lt;/p&gt;
&lt;div class="math"&gt;$$x\in{\cal X}\subseteq\mathbb{R}^n$$&lt;/div&gt;
&lt;p&gt;
输出类标记
&lt;/p&gt;
&lt;div class="math"&gt;$$y\in{\cal Y}=\{c_1,c_2,\cdots,c_K\}$$&lt;/div&gt;
&lt;p&gt;
&lt;span class="math"&gt;\(X\)&lt;/span&gt; 是定义在输入空间 &lt;span class="math"&gt;\({\cal X}\)&lt;/span&gt; 上的随机变量，&lt;span class="math"&gt;\(Y\)&lt;/span&gt; 是定义在输出空间 &lt;span class="math"&gt;\({\cal Y}\)&lt;/span&gt; 上的随机变量，&lt;span class="math"&gt;\(P(X,Y)\)&lt;/span&gt; 是 &lt;span class="math"&gt;\(X\)&lt;/span&gt; 和 &lt;span class="math"&gt;\(Y\)&lt;/span&gt; 的联合概率分布 …&lt;/p&gt;&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><content type="html">&lt;p&gt;朴素贝叶斯（naive Bayes）法是基于贝叶斯定理与特征条件独立假设的分类方法。朴素贝叶斯法实现简单，学习和预测效率都很高，是一种常用的方法。&lt;/p&gt;
&lt;h2&gt;4.1 朴素贝叶斯法的学习与分类&lt;/h2&gt;
&lt;h3&gt;4.1.1 基本方法&lt;/h3&gt;
&lt;p&gt;设输入特征向量
&lt;/p&gt;
&lt;div class="math"&gt;$$x\in{\cal X}\subseteq\mathbb{R}^n$$&lt;/div&gt;
&lt;p&gt;
输出类标记
&lt;/p&gt;
&lt;div class="math"&gt;$$y\in{\cal Y}=\{c_1,c_2,\cdots,c_K\}$$&lt;/div&gt;
&lt;p&gt;
&lt;span class="math"&gt;\(X\)&lt;/span&gt; 是定义在输入空间 &lt;span class="math"&gt;\({\cal X}\)&lt;/span&gt; 上的随机变量，&lt;span class="math"&gt;\(Y\)&lt;/span&gt; 是定义在输出空间 &lt;span class="math"&gt;\({\cal Y}\)&lt;/span&gt; 上的随机变量，&lt;span class="math"&gt;\(P(X,Y)\)&lt;/span&gt; 是 &lt;span class="math"&gt;\(X\)&lt;/span&gt; 和 &lt;span class="math"&gt;\(Y\)&lt;/span&gt; 的联合概率分布。训练数据集
&lt;/p&gt;
&lt;div class="math"&gt;$$T=\{(x_1,y_1),(x_2,y_2),\cdots,(x_N,y_N)\}$$&lt;/div&gt;
&lt;p&gt;
由 &lt;span class="math"&gt;\(P(X,Y)\)&lt;/span&gt; 独立同分布产生。&lt;/p&gt;
&lt;p&gt;朴素贝叶斯法通过训练数据集学习联合概率分布 &lt;span class="math"&gt;\(P(X,Y)\)&lt;/span&gt;。具体地，学习以下先验概率分布及条件概率分布。先验概率分布
&lt;/p&gt;
&lt;div class="math"&gt;$$P(Y=c_k),k=1,2,\cdots,K$$&lt;/div&gt;
&lt;p&gt;
条件概率分布
&lt;/p&gt;
&lt;div class="math"&gt;$$P(X=x|Y=c_k)=P(X^{(1)}=x^{(1)},\cdots,X^{(n)}=x^{(n)}|Y=c_k),k=1,2,\cdots,K$$&lt;/div&gt;
&lt;p&gt;
于是学习到联合概率分布
&lt;/p&gt;
&lt;div class="math"&gt;$$P(X,Y)=P(X=x|Y=c_k)P(Y=c_k)$$&lt;/div&gt;
&lt;p&gt;条件概率分布 &lt;span class="math"&gt;\(P(X=x|Y=c_k)\)&lt;/span&gt; 由指数级数量的参数，其估计实际是不可行的。事实上，假设 &lt;span class="math"&gt;\(x^{(i)}\)&lt;/span&gt; 可取值有 &lt;span class="math"&gt;\(S_j\)&lt;/span&gt; 个，&lt;span class="math"&gt;\(Y\)&lt;/span&gt; 可取值有 &lt;span class="math"&gt;\(K\)&lt;/span&gt; 个，那么参数个数为 &lt;span class="math"&gt;\(K\prod_{j=1}^nS_j\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;朴素贝叶斯法对条件概率分布作了条件独立性的假设。这是一个较强的假设，朴素贝叶斯法也由此得名。具体的，条件独立性假设是
&lt;/p&gt;
&lt;div class="math"&gt;$$\begin{eqnarray}
P(X=x|Y=c_k) &amp;amp;=&amp;amp; P(X^{(1)}=x^{(1)},\cdots,X^{(n)}=x^{(n)})|Y=c_k)\\
&amp;amp;=&amp;amp; \prod_{j=1}^nP(X^{(j)}=x^{(j)}|Y=c_k)
\end{eqnarray}$$&lt;/div&gt;
&lt;p&gt;朴素贝叶斯法实际上学习到生成数据的机制，所以属于生成模型。条件独立假设等于是说分类的特征在类确定的条件下都是条件独立的。这一假设使朴素贝叶斯法变得简单，但有时会牺牲一定的分类准确率。&lt;/p&gt;
&lt;p&gt;利用朴素贝叶斯法对给定输入 &lt;span class="math"&gt;\(x\)&lt;/span&gt;分类是，将后验概率最大的类作为 &lt;span class="math"&gt;\(x\)&lt;/span&gt; 的类输出，后验概率根据贝叶斯定理计算
&lt;/p&gt;
&lt;div class="math"&gt;$$P(Y=c_k|X=x)=\frac{P(X=x|Y=c_k)P(Y=c_k)}{\sum_kP(X=x|Y=c_k)P(Y=c_k)}$$&lt;/div&gt;
&lt;p&gt;
利用条件独立假设
&lt;/p&gt;
&lt;div class="math"&gt;$$P(Y=c_k|X=x)=\frac{P(Y=c_k)\prod_jP(X^{(j)}=x^{(j)}|Y=c_k)}{\sum_kP(Y=c_k)\prod_jP(X^{(j)}=x^{(j)}|Y=c_k)}$$&lt;/div&gt;
&lt;p&gt;
这是朴素贝叶斯法的基本公式，于是朴素贝叶斯分类器可表示为
&lt;/p&gt;
&lt;div class="math"&gt;$$y=f(x)=\arg\max_{c_k}\frac{P(Y=c_k)\prod_jP(X^{(j)}=x^{(j)}|Y=c_k)}{\sum_kP(Y=c_k)\prod_jP(X^{(j)}=x^{(j)}|Y=c_k)}$$&lt;/div&gt;
&lt;p&gt;
注意到上式中分母对所有 &lt;span class="math"&gt;\(c_k\)&lt;/span&gt; 都为 &lt;span class="math"&gt;\(P(X=x)\)&lt;/span&gt;，所以
&lt;/p&gt;
&lt;div class="math"&gt;$$y=f(x)=\arg\max_{c_k}P(Y=c_k)\prod_jP(X^{(j)}=x^{(j)}|Y=c_k)$$&lt;/div&gt;
&lt;h3&gt;4.1.2 后验概率最大化的含义&lt;/h3&gt;
&lt;p&gt;朴素贝叶斯法将实例分类到后验概率最大的类中，这等价于期望风险最小化。假设 0-1 损失函数
&lt;/p&gt;
&lt;div class="math"&gt;$$L(Y,f(X))=\begin{cases}1,&amp;amp;Y\neq f(X)\\0,&amp;amp; Y=f(X)\end{cases}$$&lt;/div&gt;
&lt;p&gt;
式中 &lt;span class="math"&gt;\(f(X)\)&lt;/span&gt; 是分类决策函数。这时期望风险函数为
&lt;/p&gt;
&lt;div class="math"&gt;$$\begin{eqnarray}
R_\text{exp}(f) &amp;amp;=&amp;amp; \text{E}[L(Y,f(X))]=\int_{{\cal X}\times{\cal Y}}L(y,f(x))P(x,y)dxdy\\
&amp;amp;=&amp;amp; \int_{\cal X}\int_{\cal Y}L(y,f(x))P(y|x)P(x)dxdy\\
&amp;amp;=&amp;amp; \int_{\cal X} \left[\int_{\cal Y}L(y,f(x))P(y|x)dy\right] P(x)dx
\end{eqnarray}$$&lt;/div&gt;
&lt;p&gt;
期望是对联合概率分布 &lt;span class="math"&gt;\(P(X,Y)\)&lt;/span&gt; 取的。由此取条件期望
&lt;/p&gt;
&lt;div class="math"&gt;$$R_\text{exp}(f)=\text{E}_X\sum_{k=1}^K[L(c_k,f(X))]P(c_k|X)$$&lt;/div&gt;
&lt;p&gt;
为了使期望风险最小化，只需对 &lt;span class="math"&gt;\(X=x\)&lt;/span&gt; 逐个极小化，得
&lt;/p&gt;
&lt;div class="math"&gt;$$\begin{eqnarray}f(x) &amp;amp;=&amp;amp; \arg\min_{y\in{\cal Y}}\sum_{k=1}^KL(c_k,y)P(c_k|X=x)\\&amp;amp;=&amp;amp;\arg\min_{y\in\cal Y}\sum_{k=1}^KP(y\neq c_k|X=x)\\&amp;amp;=&amp;amp;\arg\min_{y\in{\cal Y}}(1-P(y=c_k|X=x))\\&amp;amp;=&amp;amp;\arg\max_{y\in\cal Y}P(y=c_k|X=x)\end{eqnarray}$$&lt;/div&gt;
&lt;p&gt;
这样一来，根据期望风险最小化准则就得到了后验概率最大化准则
&lt;/p&gt;
&lt;div class="math"&gt;$$f(x)=\arg\max_{c_k}P(c_k|X=x)$$&lt;/div&gt;
&lt;p&gt;
即朴素贝叶斯法采用的原理。&lt;/p&gt;
&lt;h2&gt;4.2 朴素贝叶斯法的参数估计&lt;/h2&gt;
&lt;h3&gt;4.2.1 极大似然估计&lt;/h3&gt;
&lt;p&gt;对于
&lt;/p&gt;
&lt;div class="math"&gt;$$y=f(x)=\arg\max_{c_k}P(Y=c_k)\prod_jP(X^{(j)}=x^{(j)}|Y=c_k)$$&lt;/div&gt;
&lt;p&gt;
朴素贝叶斯学习意味着估计 &lt;span class="math"&gt;\(P(Y=c_k)\)&lt;/span&gt; 和 &lt;span class="math"&gt;\(P(X^{(j)}=x^{(j)}|Y=c_k)\)&lt;/span&gt;。可以应用极大似然估计法估计相应的概率。&lt;/p&gt;
&lt;p&gt;先验概率 &lt;span class="math"&gt;\(P(Y=c_k)\)&lt;/span&gt; 的极大似然估计是
&lt;/p&gt;
&lt;div class="math"&gt;$$P(Y=c_k)=\frac{\sum_{i=1}^N\mathbb{I}(y_i=c_k)}{N},k=1,2,\cdots,K$$&lt;/div&gt;
&lt;p&gt;
设第 &lt;span class="math"&gt;\(j\)&lt;/span&gt; 个特征 &lt;span class="math"&gt;\(x^{(j)}\)&lt;/span&gt; 可能的取值集合为 &lt;span class="math"&gt;\(\{a_{j1},a_{j2},\cdots,a_{jS_j}\}\)&lt;/span&gt;，条件概率的极大似然估计是
&lt;/p&gt;
&lt;div class="math"&gt;$$P(X^{(j)}=a_{jl}|Y=c_k)=\frac{\sum_{i=1}^N\mathbb{I}(x_i^{(j)}=a_{jl},y_i=c_k)}{\sum_{i=1}^N\mathbb{I}(y_i=c_k)}\\
j=1,2,\cdots,n; l=1,2,\cdots,S_j; k=1,2,\cdots,K$$&lt;/div&gt;
&lt;h3&gt;4.2.2 学习与分类算法&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;
算法 4.1 朴素贝叶斯法（naive Bayes algorithm）&lt;br&gt;
输入：&lt;br&gt;
(a) 训练数据集
&lt;div class="math"&gt;$$T=\{(x_1,y_1),(x_2,y_2),\cdots,(x_N,y_N)\}$$&lt;/div&gt;
其中
&lt;div class="math"&gt;$$x_i=\left(x_i^{(1)},x_i^{(2)},\cdots,x_i^{(n)}\right)^\text{T}$$&lt;/div&gt;
&lt;span class="math"&gt;\(x_i^{(j)}\)&lt;/span&gt; 是第 &lt;span class="math"&gt;\(i\)&lt;/span&gt; 个样本的第 &lt;span class="math"&gt;\(j\)&lt;/span&gt; 个特征，且
&lt;div class="math"&gt;$$x_i^{(j)}\in\{a_{j1},a_{j2},\cdots,a_{jS_j}\}$$&lt;/div&gt;
&lt;div class="math"&gt;$$y_i\in\{c_1,c_2,\cdots,c_K\}$$&lt;/div&gt;
(b) 实例 &lt;span class="math"&gt;\(x\)&lt;/span&gt;&lt;br&gt;
输出：实例 &lt;span class="math"&gt;\(x\)&lt;/span&gt; 的分类&lt;br&gt;
(1) 计算先验概率及条件概率
&lt;div class="math"&gt;$$\begin{eqnarray}
P(Y=c_k) &amp;amp;=&amp;amp; \frac{\sum_{i=1}^N\mathbb{I}(y_i=c_k)}{N} \\
P(X^{(j)}=a_{jl}|Y=c_k) &amp;amp;=&amp;amp; \frac{\sum_{i=1}^N\mathbb{I}(x_i^{(j)}=a_{jl},y_i=c_k)}{\sum_{i=1}^N\mathbb{I}(y_i=c_k)}
\end{eqnarray}\\
j=1,2,\cdots,n; l=1,2,\cdots,S_j; k=1,2,\cdots,K$$&lt;/div&gt;
(2) 对于给定的实例 &lt;span class="math"&gt;\(x=\left(x^{(1)},x^{(2)},\cdots,x^{(n)}\right)^\text{T}\)&lt;/span&gt;，计算
&lt;div class="math"&gt;$$P(Y=c_k)\prod_{j=1}P(X^{(j)}=x^{(j)}|Y=c_k),k=1,2,\cdots,K$$&lt;/div&gt;
(3) 确定实例 &lt;span class="math"&gt;\(x\)&lt;/span&gt; 的类
&lt;div class="math"&gt;$$y=f(x)=\arg\max_{c_k}P(Y=c_k)\prod_jP(X^{(j)}=x^{(j)}|Y=c_k)$$&lt;/div&gt;
&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;4.2.3 贝叶斯估计&lt;/h3&gt;
&lt;p&gt;用极大似然估计可能会出现所要估计的概率值为 0 的情况。这时会影响到后验概率的计算结果，使分类产生偏差。解决这一问题的方法是采用贝叶斯估计。&lt;/p&gt;
&lt;p&gt;先验概率的贝叶斯估计是
&lt;/p&gt;
&lt;div class="math"&gt;$$P_\lambda(Y=c_k)=\frac{\sum_{i=1}^N\mathbb{I}(y_i=c_k)+\lambda}{N+K\lambda},k=1,2,\cdots,K$$&lt;/div&gt;
&lt;p&gt;条件概率的贝叶斯估计是
&lt;/p&gt;
&lt;div class="math"&gt;$$P_\lambda(X^{(j)}=a_{jl}|Y=c_k)=\frac{\sum_{i=1}^N\mathbb{I}(x_i^{(j)}=a_{jl},y_i=c_k)+\lambda}{\sum_{i=1}^N\mathbb{I}(y_i=c_k)+S_j\lambda}\\
j=1,2,\cdots,n; l=1,2,\cdots,S_j; k=1,2,\cdots,K$$&lt;/div&gt;
&lt;p&gt;
式中 &lt;span class="math"&gt;\(\lambda\geq0\)&lt;/span&gt;，等价于在随机变量各个取值的频数上赋予一个非负数。当 &lt;span class="math"&gt;\(\lambda=0\)&lt;/span&gt; 时，就是极大似然估计。常取 &lt;span class="math"&gt;\(\lambda=1\)&lt;/span&gt;，这是称为拉普拉斯平滑（Laplace smoothing）。&lt;/p&gt;
&lt;p&gt;显然
&lt;/p&gt;
&lt;div class="math"&gt;$$\begin{eqnarray}
P_\lambda(X^{(j)}=a_{jl}|Y=c_k) &amp;amp;\geq&amp;amp; 0 \\
\sum_{l=1}^{S_j}P_\lambda(X^{(j)}=a_{jl}|Y=c_k) &amp;amp;=&amp;amp; 1
\end{eqnarray}$$&lt;/div&gt;
&lt;p&gt;
表明这的确是一种概率分布。&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="统计学习"></category><category term="机器学习"></category></entry><entry><title>统计学习方法 第三章 k 近邻法</title><link href="https://xutree.github.io/pages/2018/11/04/3/" rel="alternate"></link><published>2018-11-04T23:11:36+08:00</published><updated>2018-11-05T18:32:21+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-11-04:/pages/2018/11/04/3/</id><summary type="html">&lt;p&gt;&lt;span class="math"&gt;\(k\)&lt;/span&gt; 近邻法（&lt;span class="math"&gt;\(k\)&lt;/span&gt;-nearest neighbor，&lt;span class="math"&gt;\(k\)&lt;/span&gt;-NN）是一种基本分类与回归方法。&lt;span class="math"&gt;\(k\)&lt;/span&gt; 近邻法的输入为实例的特征向量，输出为实例的类别，可以取多类。&lt;span class="math"&gt;\(k\)&lt;/span&gt; 近邻法假设给定一个训练集数据，其中的实例类别已定。分类时，对新的实例，根据其 &lt;span class="math"&gt;\(k\)&lt;/span&gt; 个最近邻的训练实例的类别，通过多数表决等方式进行预测。因此，&lt;span class="math"&gt;\(k\)&lt;/span&gt; 近邻法不具有显式的学习过程。&lt;/p&gt;
&lt;p&gt;&lt;span class="math"&gt;\(k\)&lt;/span&gt; 近邻法实际上利用训练数据集对特征向量空间进行划分，并作为其分类的模型。&lt;/p&gt;
&lt;p&gt;&lt;span class="math"&gt;\(k\)&lt;/span&gt; 值得选择、距离度量以及分类决策规则是 &lt;span class="math"&gt;\(k\)&lt;/span&gt; 近邻法的三个基本要素。&lt;/p&gt;
&lt;h2&gt;3.1 &lt;span class="math"&gt;\(k\)&lt;/span&gt; 近邻算法&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;算法 3.1 （&lt;span class="math"&gt;\(k\)&lt;/span&gt; 近邻法）&lt;br&gt;
输入：训练数据集
&lt;div class="math"&gt;$$T=\{(x_1,y_1),(x_2,y_2 …&lt;/div&gt;&lt;/strong&gt;&lt;/p&gt;&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><content type="html">&lt;p&gt;&lt;span class="math"&gt;\(k\)&lt;/span&gt; 近邻法（&lt;span class="math"&gt;\(k\)&lt;/span&gt;-nearest neighbor，&lt;span class="math"&gt;\(k\)&lt;/span&gt;-NN）是一种基本分类与回归方法。&lt;span class="math"&gt;\(k\)&lt;/span&gt; 近邻法的输入为实例的特征向量，输出为实例的类别，可以取多类。&lt;span class="math"&gt;\(k\)&lt;/span&gt; 近邻法假设给定一个训练集数据，其中的实例类别已定。分类时，对新的实例，根据其 &lt;span class="math"&gt;\(k\)&lt;/span&gt; 个最近邻的训练实例的类别，通过多数表决等方式进行预测。因此，&lt;span class="math"&gt;\(k\)&lt;/span&gt; 近邻法不具有显式的学习过程。&lt;/p&gt;
&lt;p&gt;&lt;span class="math"&gt;\(k\)&lt;/span&gt; 近邻法实际上利用训练数据集对特征向量空间进行划分，并作为其分类的模型。&lt;/p&gt;
&lt;p&gt;&lt;span class="math"&gt;\(k\)&lt;/span&gt; 值得选择、距离度量以及分类决策规则是 &lt;span class="math"&gt;\(k\)&lt;/span&gt; 近邻法的三个基本要素。&lt;/p&gt;
&lt;h2&gt;3.1 &lt;span class="math"&gt;\(k\)&lt;/span&gt; 近邻算法&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;算法 3.1 （&lt;span class="math"&gt;\(k\)&lt;/span&gt; 近邻法）&lt;br&gt;
输入：训练数据集
&lt;div class="math"&gt;$$T=\{(x_1,y_1),(x_2,y_2),\cdots,(x_N,y_N)\}$$&lt;/div&gt;
其中
&lt;div class="math"&gt;$$x_i\in{\cal X}\subseteq\mathbb{R}^n$$&lt;/div&gt;
为实例的特征空间，
&lt;div class="math"&gt;$$y_i\in{\cal Y}=\{c_1,c_2,\cdots,c_K\}$$&lt;/div&gt;
为实例的类别；
实例特征向量 &lt;span class="math"&gt;\(x\)&lt;/span&gt;&lt;br&gt;
输出：实例 &lt;span class="math"&gt;\(x\)&lt;/span&gt; 所属的类 &lt;span class="math"&gt;\(y\)&lt;/span&gt;&lt;br&gt;
(1) 根据给定的距离度量，在训练集 &lt;span class="math"&gt;\(T\)&lt;/span&gt; 中找出与 &lt;span class="math"&gt;\(x\)&lt;/span&gt; 最邻近的 &lt;span class="math"&gt;\(k\)&lt;/span&gt; 个点，涵盖这 &lt;span class="math"&gt;\(k\)&lt;/span&gt; 个点的 &lt;span class="math"&gt;\(x\)&lt;/span&gt; 的邻域记作 &lt;span class="math"&gt;\(N_k(x)\)&lt;/span&gt;&lt;br&gt;
(2) 在 &lt;span class="math"&gt;\(N_k(x)\)&lt;/span&gt;  中根据分类决策规则（如多数表决）决定 &lt;span class="math"&gt;\(x\)&lt;/span&gt; 的类别 &lt;span class="math"&gt;\(y\)&lt;/span&gt;
&lt;div class="math"&gt;$$y=\arg\max_{c_j}\sum_{x_i\in N_k(x)}\mathbb{I}(y_i=c_j),i=1,2,\cdots,N; j=1,2,\cdots,K$$&lt;/div&gt;
式中，&lt;span class="math"&gt;\(\mathbb{I}\)&lt;/span&gt; 为指示函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class="math"&gt;\(k\)&lt;/span&gt; 近邻法的特殊情况是 &lt;span class="math"&gt;\(k=1\)&lt;/span&gt; 的情形，称为最近邻算法。对于输入的实例点（特征向量）&lt;span class="math"&gt;\(x\)&lt;/span&gt;，最邻近法将数据集中与 &lt;span class="math"&gt;\(x\)&lt;/span&gt; 最邻近点的类作为 &lt;span class="math"&gt;\(x\)&lt;/span&gt; 的类。&lt;/p&gt;
&lt;h2&gt;3.2 &lt;span class="math"&gt;\(k\)&lt;/span&gt; 近邻模型&lt;/h2&gt;
&lt;p&gt;&lt;span class="math"&gt;\(k\)&lt;/span&gt; 近邻法使用的模型实际上对应于特征空间的划分。模型由三个基本要素——距离度量，&lt;span class="math"&gt;\(k\)&lt;/span&gt; 值得选取和分类决策规则决定。&lt;/p&gt;
&lt;h3&gt;3.2.1 距离度量&lt;/h3&gt;
&lt;p&gt;特征空间中两个实例点的距离是两个实例点相似程度的反应。&lt;span class="math"&gt;\(k\)&lt;/span&gt; 近邻模型的特征空间一般是 &lt;span class="math"&gt;\(n\)&lt;/span&gt; 维实数向量空间 &lt;span class="math"&gt;\(\mathbb{R}^n\)&lt;/span&gt;。使用的距离是欧氏距离，也可以使用其他距离，例如更一般的 &lt;span class="math"&gt;\(L_p\)&lt;/span&gt; 距离或 Minkowski 距离。&lt;/p&gt;
&lt;p&gt;设特征空间 &lt;span class="math"&gt;\({\cal X}\)&lt;/span&gt; 是 &lt;span class="math"&gt;\(n\)&lt;/span&gt; 维实数向量空间 &lt;span class="math"&gt;\(\mathbb{R}^n\)&lt;/span&gt;，&lt;span class="math"&gt;\(x_i,x_j\in{\cal X}\)&lt;/span&gt;，&lt;span class="math"&gt;\(x_i=\left(x_i^{(1)},x_i^{(2)},\cdots,x_i^{(n)}\right)^\text{T}\)&lt;/span&gt;，&lt;span class="math"&gt;\(x_j=\left(x_j^{(1)},x_j^{(2)},\cdots,x_j^{(n)}\right)^\text{T}\)&lt;/span&gt;，&lt;span class="math"&gt;\(x_i,x_j\)&lt;/span&gt; 的 &lt;span class="math"&gt;\(L_p\)&lt;/span&gt; 距离定义为
&lt;/p&gt;
&lt;div class="math"&gt;$$L_p(x_i,x_j)=\left(\sum_{l=1}^n\left|x_i^{(l)}-x_j^{(l)}\right|^p\right)^\frac{1}{p}$$&lt;/div&gt;
&lt;h3&gt;3.2.2 &lt;span class="math"&gt;\(k\)&lt;/span&gt; 值的选择&lt;/h3&gt;
&lt;p&gt;&lt;span class="math"&gt;\(k\)&lt;/span&gt; 值得选择会对 &lt;span class="math"&gt;\(k\)&lt;/span&gt; 近邻法的结果产生重大影响。&lt;/p&gt;
&lt;p&gt;如果选择较小的 &lt;span class="math"&gt;\(k\)&lt;/span&gt; 值，就相当于用较小的邻域中的训练实例进行预测。“学习”的近似误差（approximation error）会减小，只有与输入实例较近的（相似的）训练实例才会对预测结果起作用。但缺点是“学习”的估计误差（estimation error）会增大，预测结果会对近邻的实例点非常敏感。如果邻近的实例点恰巧是噪声点，预测就会出错。换句话说，&lt;span class="math"&gt;\(k\)&lt;/span&gt; 值得减小就意味着整体模型变的复杂，容易发生过拟合。&lt;/p&gt;
&lt;p&gt;如果 &lt;span class="math"&gt;\(k\)&lt;/span&gt; 值选择过大，就相当于用较大邻域中的训练实例进行预测。其优点是可以减小学习的估计误差，但缺点是学习的近似误差会增大。这时与输入实例较远的（不相似的）训练实例也会对预测起作用，使预测发生错误。&lt;span class="math"&gt;\(k\)&lt;/span&gt; 值的增大意味着整体的模型变得简单。&lt;/p&gt;
&lt;p&gt;如果 &lt;span class="math"&gt;\(k=N\)&lt;/span&gt;，那么无论输入的实例是什么，都将简单的预测它属于在训练实例中最多的类，这时，模型过于简单，是不可取的。&lt;/p&gt;
&lt;p&gt;在应用中，&lt;span class="math"&gt;\(k\)&lt;/span&gt; 值一般取一个比较小的数值，通常采用交叉验证法来选取最优的 &lt;span class="math"&gt;\(k\)&lt;/span&gt; 值。&lt;/p&gt;
&lt;h3&gt;3.2.3 分类决策规则&lt;/h3&gt;
&lt;p&gt;&lt;span class="math"&gt;\(k\)&lt;/span&gt; 近邻法中的分类决策规则往往是多数表决，即由输入实例的 &lt;span class="math"&gt;\(k\)&lt;/span&gt; 个邻近的训练实例中的多数类决定输入实例的类。&lt;/p&gt;
&lt;p&gt;多数表决规则（majority voting rule）有如下解释：如果分类的损失函数是 0-1 损失函数，分类函数为
&lt;/p&gt;
&lt;div class="math"&gt;$$f:\mathbb{R}^n\longrightarrow\{c_1,c_2,\cdots,c_K\}$$&lt;/div&gt;
&lt;p&gt;
那么误分类的概率是
&lt;/p&gt;
&lt;div class="math"&gt;$$P(Y\neq f(X))=1-P(Y=f(X))$$&lt;/div&gt;
&lt;p&gt;
对于给定的实例 &lt;span class="math"&gt;\(x\in{\cal X}\)&lt;/span&gt;，其最邻近的 &lt;span class="math"&gt;\(k\)&lt;/span&gt; 个训练实例点构成集合 &lt;span class="math"&gt;\(N_k(x)\)&lt;/span&gt;。如果涵盖 &lt;span class="math"&gt;\(N_k(x)\)&lt;/span&gt; 的区域类别是 &lt;span class="math"&gt;\(c_j\)&lt;/span&gt;，那么误分类率是
&lt;/p&gt;
&lt;div class="math"&gt;$$\frac{1}{k}\sum_{x_i\in N_k(x)}\mathbb{I}(y_i\neq c_j)=1-\frac{1}{k}\sum_{x_i\in N_k(x)}\mathbb{I}(y_i= c_j)$$&lt;/div&gt;
&lt;p&gt;
要使误分类率最小即经验风险最小，就要使 &lt;span class="math"&gt;\(\sum_{x_i\in N_k(x)}\mathbb{I}(y_i= c_j)\)&lt;/span&gt; 最大，所以多数表决规则等价于经验风险最小化。&lt;/p&gt;
&lt;h2&gt;3.3 &lt;span class="math"&gt;\(k\)&lt;/span&gt; 近邻法的实现：&lt;span class="math"&gt;\(kd\)&lt;/span&gt; 树&lt;/h2&gt;
&lt;p&gt;为了对训练数据进行快速 &lt;span class="math"&gt;\(k\)&lt;/span&gt; 近邻搜索，我可以采取 &lt;span class="math"&gt;\(kd\)&lt;/span&gt; 树方法（此 &lt;span class="math"&gt;\(k\)&lt;/span&gt; 是计算机科学中的叫法）。&lt;/p&gt;
&lt;p&gt;&lt;span class="math"&gt;\(kd\)&lt;/span&gt; 树是每个节点都为 &lt;span class="math"&gt;\(k\)&lt;/span&gt; 维点的二叉树。所有非叶子节点可以视作用一个超平面把空间分割成两个半空间。节点左边的子树代表在超平面左边的点，节点右边的子树代表在超平面右边的点。选择超平面的方法如下：每个节点都与k维中垂直于超平面的那一维有关。因此，如果选择按照x轴划分，所有 &lt;span class="math"&gt;\(x\)&lt;/span&gt; 值小于指定值的节点都会出现在左子树，所有 &lt;span class="math"&gt;\(x\)&lt;/span&gt; 值大于指定值的节点都会出现在右子树。这样，超平面可以用该x值来确定，其法线为 &lt;span class="math"&gt;\(x\)&lt;/span&gt; 轴的单位向量。&lt;/p&gt;
&lt;h3&gt;3.3.1 构造 &lt;span class="math"&gt;\(kd\)&lt;/span&gt; 树&lt;/h3&gt;
&lt;p&gt;有很多种方法可以选择轴垂直分割面（axis-aligned splitting planes），所以有很多种创建 &lt;span class="math"&gt;\(kd\)&lt;/span&gt; 树的方法。 最典型的方法如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;随着树的深度轮流选择轴当作分割面。（例如：在三维空间中根节点是 &lt;span class="math"&gt;\(x\)&lt;/span&gt; 轴垂直分割面，其子节点皆为 &lt;span class="math"&gt;\(y\)&lt;/span&gt; 轴垂直分割面，其孙节点皆为 &lt;span class="math"&gt;\(z\)&lt;/span&gt; 轴垂直分割面，其曾孙节点则皆为 &lt;span class="math"&gt;\(x\)&lt;/span&gt; 轴垂直分割面，依此类推）&lt;/li&gt;
&lt;li&gt;点由垂直分割面之轴座标的中位数区分并放入子树&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个方法产生一个平衡的 &lt;span class="math"&gt;\(kd\)&lt;/span&gt; 树。每个叶节点的高度都十分接近。然而，平衡的树不一定对每个应用都是最佳的。&lt;/p&gt;
&lt;h3&gt;3.3.2 搜索 &lt;span class="math"&gt;\(kd\)&lt;/span&gt; 树&lt;/h3&gt;
&lt;p&gt;最邻近搜索用来找出在树中与输入点最接近的点。&lt;/p&gt;
&lt;p&gt;&lt;span class="math"&gt;\(kd\)&lt;/span&gt; 树最邻近搜索的过程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从根节点开始，递归的往下移。往左还是往右的决定方法与插入元素的方法一样(如果输入点在分区面的左边则进入左子节点，在右边则进入右子节点)&lt;/li&gt;
&lt;li&gt;一旦移动到叶节点，将该节点当作"目前最佳点"&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;解开递归，并对每个经过的节点运行下列步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果目前所在点比目前最佳点更靠近输入点，则将其变为目前最佳点&lt;/li&gt;
&lt;li&gt;检查另一边子树有没有更近的点，如果有则从该节点往下找&lt;/li&gt;
&lt;li&gt;当根节点搜索完毕后完成最邻近搜索&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果实例点是随机分布的，&lt;span class="math"&gt;\(kd\)&lt;/span&gt; 树搜索的平均计算复杂度是 &lt;span class="math"&gt;\(O(\log N)\)&lt;/span&gt;，这里 &lt;span class="math"&gt;\(N\)&lt;/span&gt; 是训练实例数。&lt;span class="math"&gt;\(kd\)&lt;/span&gt; 树更适用于训练实例数远大于空间维度时的 &lt;span class="math"&gt;\(k\)&lt;/span&gt; 近邻搜索。当空间维度接近训练实例数时，它的效率会迅速下降，几乎接近线性扫描。&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="统计学习"></category><category term="机器学习"></category></entry><entry><title>统计学习方法 第二章 感知机</title><link href="https://xutree.github.io/pages/2018/11/04/2/" rel="alternate"></link><published>2018-11-04T21:04:02+08:00</published><updated>2018-11-07T15:34:59+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-11-04:/pages/2018/11/04/2/</id><summary type="html">&lt;p&gt;感知机（perceptron）是二分类的线性分类模型，其输入是实例的特征向量，输出为实例的类别，取 +1 和 -1 二值。感知机对应于输入空间（特征空间）中将实例划分为正负类别的分离超平面，属于判别模型。&lt;/p&gt;
&lt;h2&gt;2.1 感知机模型&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;定义 2.1（感知机）假设输入空间（特征空间）是 &lt;span class="math"&gt;\({\cal X}\subseteq\mathbb{R}^n\)&lt;/span&gt;，输出空间是 &lt;span class="math"&gt;\({\cal Y}=\{+1,-1\}\)&lt;/span&gt;。输入 &lt;span class="math"&gt;\(x\in{\cal X}\)&lt;/span&gt; 表示实例的特征向量，对应于输入空间（特征空间）的点；输出 &lt;span class="math"&gt;\(y\in{\cal Y}\)&lt;/span&gt; 表示实例的类别 …&lt;/strong&gt;&lt;/p&gt;&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><content type="html">&lt;p&gt;感知机（perceptron）是二分类的线性分类模型，其输入是实例的特征向量，输出为实例的类别，取 +1 和 -1 二值。感知机对应于输入空间（特征空间）中将实例划分为正负类别的分离超平面，属于判别模型。&lt;/p&gt;
&lt;h2&gt;2.1 感知机模型&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;定义 2.1（感知机）假设输入空间（特征空间）是 &lt;span class="math"&gt;\({\cal X}\subseteq\mathbb{R}^n\)&lt;/span&gt;，输出空间是 &lt;span class="math"&gt;\({\cal Y}=\{+1,-1\}\)&lt;/span&gt;。输入 &lt;span class="math"&gt;\(x\in{\cal X}\)&lt;/span&gt; 表示实例的特征向量，对应于输入空间（特征空间）的点；输出 &lt;span class="math"&gt;\(y\in{\cal Y}\)&lt;/span&gt; 表示实例的类别。由输入空间到输出空间的如下函数：
&lt;div class="math"&gt;$$f(x)=\text{sign}(w\cdot x+b)$$&lt;/div&gt;
称为感知机。其中，&lt;span class="math"&gt;\(w\)&lt;/span&gt; 和 &lt;span class="math"&gt;\(b\)&lt;/span&gt; 为感知机模型参数，&lt;span class="math"&gt;\(w\in\mathbb{R}^n\)&lt;/span&gt; 叫做权值（weight）或权值向量（weight vector），&lt;span class="math"&gt;\(b\in\mathbb{R}\)&lt;/span&gt; 叫做偏置（bias），&lt;span class="math"&gt;\(w\cdot x\)&lt;/span&gt; 表示 &lt;span class="math"&gt;\(w\)&lt;/span&gt; 和 &lt;span class="math"&gt;\(x\)&lt;/span&gt; 的内积。sign 是符号函数，即：
&lt;div class="math"&gt;$$\text{sign}(x)=\begin{cases}+1, &amp;amp; x\geq0 \\ -1, &amp;amp; x&amp;lt;0\end{cases}$$&lt;/div&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;感知机是一种线性分类模型。感知机模型的假设空间是定义在特征空间中的所有线性分类模型（linear classification model）或线性分类器（linear classifier），即函数集合：&lt;span class="math"&gt;\(\{f|f(x)=w\cdot x+b\}\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;感知机的几何解释：对于线性方程
&lt;/p&gt;
&lt;div class="math"&gt;$$w\cdot x+b=0$$&lt;/div&gt;
&lt;p&gt;
对应于特征空间 &lt;span class="math"&gt;\(\mathbb{R}^n\)&lt;/span&gt; 中的一个超平面 &lt;span class="math"&gt;\(S\)&lt;/span&gt;，称为分离超平面（separating hyperplane），其中 &lt;span class="math"&gt;\(w\)&lt;/span&gt; 是超平面的法向量，&lt;span class="math"&gt;\(b\)&lt;/span&gt; 是超平面的截距。这个超平面将特征空间划分为两个部分。&lt;/p&gt;
&lt;h2&gt;2.2 感知机学习策略&lt;/h2&gt;
&lt;h3&gt;2.2.1 数据集的线性可分性&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;定义 2.2 （数据集的线性可分性）给定一个数据集
&lt;div class="math"&gt;$$T=\{(x_1,y_1),(x_2,y_2),\cdots,(x_N,y_N)\}$$&lt;/div&gt;
其中，&lt;span class="math"&gt;\(x_i\in{\cal X}=\mathbb{R}^n\)&lt;/span&gt;，&lt;span class="math"&gt;\(y_i\in{\cal Y}=\{+1,-1\}\)&lt;/span&gt;，&lt;span class="math"&gt;\(i=1,2,\cdots,N\)&lt;/span&gt;，如果存在某个超平面 &lt;span class="math"&gt;\(S\)&lt;/span&gt;
&lt;div class="math"&gt;$$w\cdot x+b=0$$&lt;/div&gt;
能够将数据集的正负实例完全正确的划分到超平面的两侧，则称数据集 &lt;span class="math"&gt;\(T\)&lt;/span&gt; 是线性可分数据集（linearly separable data set）；否则，则称数据集 &lt;span class="math"&gt;\(T\)&lt;/span&gt; 线性不可分。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;2.2.2 感知机学习策略&lt;/h3&gt;
&lt;p&gt;为了找出超平面，需要一个学习策略，即定义（经验）损失函数并将损失函数极小化。&lt;/p&gt;
&lt;p&gt;损失函数的一个自然选择是误分类点的总数。但是，这样的损失函数不是参数 &lt;span class="math"&gt;\(w\)&lt;/span&gt;、&lt;span class="math"&gt;\(b\)&lt;/span&gt; 的连续可导函数，不易优化。损失函数的另一个选择是误分类点到超平面 &lt;span class="math"&gt;\(S\)&lt;/span&gt; 的总距离，这是感知机所采用的。&lt;/p&gt;
&lt;p&gt;首先，输入空间 &lt;span class="math"&gt;\(\mathbb{R}^n\)&lt;/span&gt; 中任一点 &lt;span class="math"&gt;\(x_0\)&lt;/span&gt; 到超平面 &lt;span class="math"&gt;\(S\)&lt;/span&gt; 的距离为：
&lt;/p&gt;
&lt;div class="math"&gt;$$\frac{1}{||w||}|w\cdot x+b|$$&lt;/div&gt;
&lt;p&gt;
这里，&lt;span class="math"&gt;\(||w||\)&lt;/span&gt; 是 &lt;span class="math"&gt;\(w\)&lt;/span&gt; 的 &lt;span class="math"&gt;\(L_2\)&lt;/span&gt; 范数。&lt;/p&gt;
&lt;p&gt;其次，注意到对于误分类点数据 &lt;span class="math"&gt;\((x_i,y_i)\)&lt;/span&gt;，下式成立：
&lt;/p&gt;
&lt;div class="math"&gt;$$-y_i(w\cdot x_i+b)&amp;gt;0$$&lt;/div&gt;
&lt;p&gt;
因此，误分类点到超平面的总距离为：
&lt;/p&gt;
&lt;div class="math"&gt;$$-\frac{1}{||w||}\sum_{x_i\in M}y_i(w\cdot x_i+b)$$&lt;/div&gt;
&lt;p&gt;
其中，&lt;span class="math"&gt;\(M\)&lt;/span&gt; 是误分类点集合。不考虑 &lt;span class="math"&gt;\(\frac{1}{||w||}\)&lt;/span&gt;，就得到感知机学习的损失函数。&lt;/p&gt;
&lt;p&gt;给定训练数据集：
&lt;/p&gt;
&lt;div class="math"&gt;$$T=\{(x_1,y_1),(x_2,y_2),\cdots,(x_N,y_N)\}$$&lt;/div&gt;
&lt;p&gt;
感知机 &lt;span class="math"&gt;\(\text{sign}(w\cdot x+b)\)&lt;/span&gt; 学习的损失函数定义为：
&lt;/p&gt;
&lt;div class="math"&gt;$$L(w,b)=-\sum_{x_i\in M}y_i(w\cdot x_i+b)$$&lt;/div&gt;
&lt;p&gt;感知机学习的策略是在假设空间中选取使上面的损失函数最小的模型参数 &lt;span class="math"&gt;\(w\)&lt;/span&gt;，&lt;span class="math"&gt;\(b\)&lt;/span&gt;，即感知机模型。&lt;/p&gt;
&lt;h2&gt;2.3 感知机学习算法&lt;/h2&gt;
&lt;p&gt;为最优化上节的损失函数，采取随机梯度下降法（stochastic gradient descent）。&lt;/p&gt;
&lt;h3&gt;2.3.1 感知机学习算法的原始形式&lt;/h3&gt;
&lt;p&gt;感知机学习算法是对以下最优化问题的算法。给定训练数据集：
&lt;/p&gt;
&lt;div class="math"&gt;$$T=\{(x_1,y_1),(x_2,y_2),\cdots,(x_N,y_N)\}$$&lt;/div&gt;
&lt;p&gt;
其中 &lt;span class="math"&gt;\(x_i\in{\cal X}=\mathbb{R}^n\)&lt;/span&gt;，&lt;span class="math"&gt;\(y_i\in{\cal Y}=\{+1,-1\}\)&lt;/span&gt;，&lt;span class="math"&gt;\(i=1,2,\cdots,N\)&lt;/span&gt;，求参数 &lt;span class="math"&gt;\(w\)&lt;/span&gt;，&lt;span class="math"&gt;\(b\)&lt;/span&gt;，使其为以下损失函数极小化的一个解：
&lt;/p&gt;
&lt;div class="math"&gt;$$\min_{w,b} L(w,b)=-\sum_{x_i\in M}y_i(w\cdot x_i+b)$$&lt;/div&gt;
&lt;p&gt;
其中，&lt;span class="math"&gt;\(M\)&lt;/span&gt; 是误分类点集合。&lt;/p&gt;
&lt;p&gt;随机梯度下降法步骤如下：首先，任意选取一个超平面 &lt;span class="math"&gt;\(w_0\)&lt;/span&gt;，&lt;span class="math"&gt;\(b_0\)&lt;/span&gt;，然后用梯度下降法不断地极小化目标函数。极小化过程不是一次使 &lt;span class="math"&gt;\(M\)&lt;/span&gt; 中所有误分类法的梯度下降，而是一次随机选取一个误分类点使其梯度下降。&lt;/p&gt;
&lt;p&gt;假设误分类点集合 &lt;span class="math"&gt;\(M\)&lt;/span&gt; 是固定的，那么损失函数 &lt;span class="math"&gt;\(L(w,b)\)&lt;/span&gt; 的梯度为：
&lt;/p&gt;
&lt;div class="math"&gt;$$\begin{eqnarray}
\nabla_wL(w,b) &amp;amp;=&amp;amp; -\sum_{x_i\in M}y_ix_i \\
\nabla_bL(w,b) &amp;amp;=&amp;amp; -\sum_{x_i\in M}y_i
\end{eqnarray}$$&lt;/div&gt;
&lt;p&gt;随机选取一个误分类点 &lt;span class="math"&gt;\((x_i,y_i)\)&lt;/span&gt; 对 &lt;span class="math"&gt;\(w\)&lt;/span&gt;，&lt;span class="math"&gt;\(b\)&lt;/span&gt; 进行更新：
&lt;/p&gt;
&lt;div class="math"&gt;$$\begin{eqnarray}
w &amp;amp;\longleftarrow&amp;amp; w+\eta y_ix_i \\
b &amp;amp;\longleftarrow&amp;amp; b+\eta y_i
\end{eqnarray}$$&lt;/div&gt;
&lt;p&gt;
式中 &lt;span class="math"&gt;\(\eta\ (0&amp;lt;\eta\leq 1)\)&lt;/span&gt; 是步长，也称学习率（learning rate）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;算法 2.1 （感知机学习算法的原始形式)&lt;br&gt;
输入：训练数据集
&lt;div class="math"&gt;$$T=\{(x_1,y_1),(x_2,y_2),\cdots,(x_N,y_N)\}$$&lt;/div&gt;
其中
&lt;div class="math"&gt;$$x_i\in{\cal X}=\mathbb{R}^n,y_i\in{\cal Y}=\{+1,-1\},i=1,2,\cdots,N$$&lt;/div&gt;
学习率
&lt;div class="math"&gt;$$\eta\ (0&amp;lt;\eta\leq 1)$$&lt;/div&gt;
输出：&lt;span class="math"&gt;\(w\)&lt;/span&gt;，&lt;span class="math"&gt;\(b\)&lt;/span&gt;；
感知机模型
&lt;div class="math"&gt;$$f(x)=\text{sign}(w\cdot x+b)$$&lt;/div&gt;
(1) 选取初值 &lt;span class="math"&gt;\(w_0\)&lt;/span&gt;，&lt;span class="math"&gt;\(b_0\)&lt;/span&gt;&lt;br&gt;
(2) 在训练集中选取数据 &lt;span class="math"&gt;\((x_i,y_i)\)&lt;/span&gt;&lt;br&gt;
(3) 如果 &lt;span class="math"&gt;\(y_i(w\cdot x_i+b)\leq 0\)&lt;/span&gt;
&lt;div class="math"&gt;$$\begin{eqnarray}
w &amp;amp;\longleftarrow&amp;amp; w+\eta y_ix_i \\
b &amp;amp;\longleftarrow&amp;amp; b+\eta y_i
\end{eqnarray}$$&lt;/div&gt;
(4) 转至 (2)，直至训练集中没有误分类点&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;2.3.2 算法的收敛性&lt;/h3&gt;
&lt;p&gt;为便于推导，将偏置并入权重向量，记为 &lt;span class="math"&gt;\(\hat{w}=(w^\text{T},b)^\text{T}\)&lt;/span&gt;，同样也将输入向量加以扩充，加进常数 1，记作 &lt;span class="math"&gt;\(\hat{x}=(x^\text{T},1)^\text{T}\)&lt;/span&gt;。这样，&lt;span class="math"&gt;\(\hat{x}\in\mathbb{R}^{n+1}\)&lt;/span&gt;，&lt;span class="math"&gt;\(\hat{w}\in\mathbb{R}^{n+1}\)&lt;/span&gt;，显然 &lt;span class="math"&gt;\(\hat{w}\cdot\hat{x}=w\cdot x+b\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;定理 2.1 （Novikoff）设训练集
&lt;div class="math"&gt;$$T=\{(x_1,y_1),(x_2,y_2),\cdots,(x_N,y_N)\}$$&lt;/div&gt;
线性可分，则&lt;br&gt;
(1). 存在满足条件 &lt;span class="math"&gt;\(||\hat{w}_\text{opt}||=1\)&lt;/span&gt; 的超平面
&lt;div class="math"&gt;$$\hat{w}_\text{opt}\cdot\hat{x}=w_\text{opt}\cdot x_+b_\text{opt}=0$$&lt;/div&gt;
将训练数据集完全正确分开；切存在 &lt;span class="math"&gt;\(\gamma&amp;gt;0\)&lt;/span&gt;，对所有 &lt;span class="math"&gt;\(i=1,2,\cdots,N\)&lt;/span&gt;
&lt;div class="math"&gt;$$y_i(\hat{w}_\text{opt}\cdot\hat{x}_i)=y_i(w_\text{opt}\cdot x_i+b_\text{opt})\geq\gamma$$&lt;/div&gt;
(2). 令
&lt;div class="math"&gt;$$R=\max_{1\leq i\leq N}||\hat{x}_i||$$&lt;/div&gt;，则感知机算法 2.1 在训练数据集上的误分类次数 &lt;span class="math"&gt;\(k\)&lt;/span&gt; 满足不等式
&lt;div class="math"&gt;$$k\leq\left(\frac{R}{\gamma}\right)^2$$&lt;/div&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;证明：（1）由线性可分性的定义即可证明，其中：
&lt;/p&gt;
&lt;div class="math"&gt;$$\gamma=\min_i\{y_i(w_\text{opt}\cdot x_i+b_\text{opt})\}$$&lt;/div&gt;
&lt;p&gt;
（2）感知机算法从 &lt;span class="math"&gt;\(\hat{w}_0\)&lt;/span&gt; 开始，如果实例被误分类，则更新权重。令 &lt;span class="math"&gt;\(\hat{w}_{k-1}\)&lt;/span&gt; 是第 &lt;span class="math"&gt;\(k\)&lt;/span&gt; 个误分类实例之前的扩充权重向量，即：
&lt;/p&gt;
&lt;div class="math"&gt;$$\hat{w}_{k-1}=(w_{k-1}^\text{T},b_{k-1})^\text{T}$$&lt;/div&gt;
&lt;p&gt;
则第 &lt;span class="math"&gt;\(k\)&lt;/span&gt; 个被误分类实例的条件是
&lt;/p&gt;
&lt;div class="math"&gt;$$y_i(\hat{w}_{k-1}\cdot\hat{x}_i)=y_i(w_{k-1}\cdot x_i+b_{k-1})\leq0$$&lt;/div&gt;
&lt;p&gt;
若 &lt;span class="math"&gt;\((x_i,y_i)\)&lt;/span&gt; 是被 &lt;span class="math"&gt;\(\hat{w}_{k-1}\)&lt;/span&gt; 误分类的数据，则 &lt;span class="math"&gt;\(w\)&lt;/span&gt; 和 &lt;span class="math"&gt;\(b\)&lt;/span&gt; 的更新为
&lt;/p&gt;
&lt;div class="math"&gt;$$\begin{eqnarray}
w_k &amp;amp;\longleftarrow&amp;amp; w_{k-1}+\eta y_ix_i \\
b_k &amp;amp;\longleftarrow&amp;amp; b_{k-1}+\eta y_i
\end{eqnarray}$$&lt;/div&gt;
&lt;p&gt;
即
&lt;/p&gt;
&lt;div class="math"&gt;$$\hat{w}_k\longleftarrow \hat{w}_{k-1}+\eta y_i\hat{x}_i$$&lt;/div&gt;
&lt;p&gt;下面推导两个不等式：&lt;/p&gt;
&lt;p&gt;i. &lt;span class="math"&gt;\(\hat{w}_k\cdot\hat{w}_\text{opt}\geq k\eta\gamma\)&lt;/span&gt;
&lt;/p&gt;
&lt;div class="math"&gt;$$\hat{w}_k\cdot\hat{w}_\text{opt}=(\hat{w}_{k-1}+\eta y_i\hat{x}_i)\cdot\hat{w}_\text{opt}\geq\hat{w}_{k-1}\cdot\hat{w}_\text{opt}+\eta\gamma\geq\cdots\geq k\eta\gamma$$&lt;/div&gt;
&lt;p&gt;
ii. &lt;span class="math"&gt;\(||\hat{w}_k||^2\leq k\eta^2R^2\)&lt;/span&gt;
&lt;/p&gt;
&lt;div class="math"&gt;$$
\begin{eqnarray}
||\hat{w}_k||^2 &amp;amp;=&amp;amp; ||\hat{w}_{k-1}+\eta y_i\hat{x}_i||^2 \\
&amp;amp;=&amp;amp; ||\hat{w}_{k-1}||^2+2\eta y_i\hat{w}_{k-1}\cdot\hat{x}_i+\eta^2||\hat{x}_i||^2 \\
&amp;amp;\leq&amp;amp; ||\hat{w}_{k-1}||^2+\eta^2||\hat{x}_i||^2 \\
&amp;amp;\leq&amp;amp; ||\hat{w}_{k-1}||^2+\eta^2R^2\leq\cdots\leq k\eta^2R^2
\end{eqnarray}$$&lt;/div&gt;
&lt;p&gt;由上述两个不等式
&lt;/p&gt;
&lt;div class="math"&gt;$$k\eta\gamma\leq\hat{w}_k\cdot\hat{w}_\text{opt}\leq||\hat{w}_k||\ ||\hat{w}_\text{opt}||\leq\sqrt{k}\eta R$$&lt;/div&gt;
&lt;p&gt;
于是
&lt;/p&gt;
&lt;div class="math"&gt;$$k\leq\left(\frac{R}{\gamma}\right)^2$$&lt;/div&gt;
&lt;p&gt;定理表明，误分类次数是有上界的，经过有限次搜索可以找到将训练数据完全正确分开的分离超平面。&lt;/p&gt;
&lt;p&gt;感知机学习算法存在许多解，这些解既依赖于初值的选择，也依赖于迭代过程中误分类点的选择顺序。&lt;/p&gt;
&lt;p&gt;当训练集线性不可分时，感知机学习算法不收敛，迭代结果会发生震荡。&lt;/p&gt;
&lt;h3&gt;2.3.3 感知机学习算法的对偶形式&lt;/h3&gt;
&lt;p&gt;对偶形式的基本想法是，将 &lt;span class="math"&gt;\(w\)&lt;/span&gt; 和 &lt;span class="math"&gt;\(b\)&lt;/span&gt; 表示为实例 &lt;span class="math"&gt;\(x_i\)&lt;/span&gt; 和标记 &lt;span class="math"&gt;\(y_i\)&lt;/span&gt; 的线性组合的形式，通过求解其系数而求得 &lt;span class="math"&gt;\(w\)&lt;/span&gt; 和 &lt;span class="math"&gt;\(b\)&lt;/span&gt;。不失一般性，在算法 2.1 中可以假设初始值 &lt;span class="math"&gt;\(w_0\)&lt;/span&gt; 和 &lt;span class="math"&gt;\(b_0\)&lt;/span&gt; 均为 0，对误分类点 &lt;span class="math"&gt;\((x_i,y_i)\)&lt;/span&gt; 通过
&lt;/p&gt;
&lt;div class="math"&gt;$$\begin{eqnarray}
w &amp;amp;\longleftarrow&amp;amp; w+\eta y_ix_i \\
b &amp;amp;\longleftarrow&amp;amp; b+\eta y_i
\end{eqnarray}$$&lt;/div&gt;
&lt;p&gt;
逐步修改 &lt;span class="math"&gt;\(w\)&lt;/span&gt;，&lt;span class="math"&gt;\(b\)&lt;/span&gt;，设修改 &lt;span class="math"&gt;\(n\)&lt;/span&gt;次（随机梯度下降，一个点可能被选择多次），则 &lt;span class="math"&gt;\(w\)&lt;/span&gt; 和 &lt;span class="math"&gt;\(b\)&lt;/span&gt; 关于 &lt;span class="math"&gt;\((x_i,y_i)\)&lt;/span&gt;  的增量分别是 &lt;span class="math"&gt;\(\alpha_iy_ix_i\)&lt;/span&gt; 和 &lt;span class="math"&gt;\(\alpha_iy_i\)&lt;/span&gt; 这里
&lt;/p&gt;
&lt;div class="math"&gt;$$\alpha_i=n_i\eta$$&lt;/div&gt;
&lt;p&gt;
这样，从学习过程不难看出，最后学习到的 &lt;span class="math"&gt;\(w\)&lt;/span&gt; 和 &lt;span class="math"&gt;\(b\)&lt;/span&gt; 可以分别表示为
&lt;/p&gt;
&lt;div class="math"&gt;$$\begin{eqnarray}
w &amp;amp;=&amp;amp; \sum_{i=1}^N\alpha_iy_ix_i \\
b &amp;amp;=&amp;amp; \sum_{i=1}^N\alpha_iy_i
\end{eqnarray}$$&lt;/div&gt;
&lt;p&gt;
这里，&lt;span class="math"&gt;\(\alpha_i\geq0\)&lt;/span&gt;，&lt;span class="math"&gt;\(i=1,2,\cdots,N\)&lt;/span&gt;，当 &lt;span class="math"&gt;\(\eta=1\)&lt;/span&gt; 时，表示第 &lt;span class="math"&gt;\(i\)&lt;/span&gt; 个实例点由于误分类而进行更新的次数。实例点更新次数越多，意味着它距离分离超平面越近，也就越难正确分类。换句话说，这样的实例对学习结果影响很大。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;算法 2.2 （感知机学习算法的对偶形式）&lt;br&gt;
输入：训练数据集
&lt;div class="math"&gt;$$T=\{(x_1,y_1),(x_2,y_2),\cdots,(x_N,y_N)\}$$&lt;/div&gt;
其中
&lt;div class="math"&gt;$$x_i\in{\cal X}=\mathbb{R}^n,y_i\in{\cal Y}=\{+1,-1\},i=1,2,\cdots,N$$&lt;/div&gt;
学习率
&lt;div class="math"&gt;$$\eta\ (0&amp;lt;\eta\leq 1)$$&lt;/div&gt;
输出：&lt;span class="math"&gt;\(\alpha\)&lt;/span&gt;，&lt;span class="math"&gt;\(b\)&lt;/span&gt;；
感知机模型
&lt;div class="math"&gt;$$f(x)=\text{sign}(\sum_{j=1}^N\alpha_jy_jx_j\cdot x+b)$$&lt;/div&gt;
其中 &lt;span class="math"&gt;\(\alpha=(\alpha_1,\alpha_2,\cdots,\alpha_N)^\text{T}\)&lt;/span&gt;&lt;br&gt;
(1) &lt;span class="math"&gt;\(\alpha\longleftarrow0\)&lt;/span&gt;， &lt;span class="math"&gt;\(b\longleftarrow0\)&lt;/span&gt;&lt;br&gt;
(2) 在训练集中选取数据 &lt;span class="math"&gt;\((x_i,y_i)\)&lt;/span&gt;&lt;br&gt;
(3) 如果 &lt;span class="math"&gt;\(y_i\left(\sum_{j=1}^N\alpha_jy_jx_j\cdot x_i+b\right)\leq 0\)&lt;/span&gt;
&lt;div class="math"&gt;$$\begin{eqnarray}
\alpha_i &amp;amp;\longleftarrow&amp;amp; \alpha_i+\eta \\
b &amp;amp;\longleftarrow&amp;amp; b+\eta y_i
\end{eqnarray}$$&lt;/div&gt;
(4) 转至 (2)，直至训练集中没有误分类点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对偶形式中训练实例仅以内积的形式出现。为了方便，可以预先将训练集中实例间的内积计算出来并以矩阵的形式存储，这个矩阵就是所谓的 Gram 矩阵（Gram matrix）
&lt;/p&gt;
&lt;div class="math"&gt;$$G=[x_i\cdot x_j]_{N\times N}$$&lt;/div&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="统计学习"></category><category term="机器学习"></category></entry><entry><title>统计学习方法 第一章 统计学习方法概论</title><link href="https://xutree.github.io/pages/2018/11/04/1/" rel="alternate"></link><published>2018-11-04T12:54:21+08:00</published><updated>2018-11-09T11:16:50+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-11-04:/pages/2018/11/04/1/</id><summary type="html">&lt;h2&gt;1.1 统计学习&lt;/h2&gt;
&lt;h3&gt;1.1.1 特点&lt;/h3&gt;
&lt;p&gt;统计学习（statistical learning）是关于计算机基于&lt;strong&gt;数据&lt;/strong&gt;构建概率统计模型并运用模型对数据进行&lt;strong&gt;预测与分析&lt;/strong&gt;的一门学科。&lt;/p&gt;
&lt;p&gt;赫尔伯特·西蒙（Herbert A.Simon）对“学习”给出如下定义：如果一个系统能够通过执行某个过程改变它的性能，这就是学习。&lt;/p&gt;
&lt;h3&gt;1.1.2 对象&lt;/h3&gt;
&lt;p&gt;统计学习的对象是数据。&lt;/p&gt;
&lt;p&gt;统计学习关于数据的基本假设是同类数据具有一定的统计规律性，这是统计学习的前提。&lt;/p&gt;
&lt;h3&gt;1.1.3 目的&lt;/h3&gt;
&lt;p&gt;统计学习用于对数据进行预测和分析，特别是对未知新数据进行预测与分析。&lt;/p&gt;
&lt;h3&gt;1.1.4 方法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;监督学习（supervised learning）&lt;/li&gt;
&lt;li&gt;非监督学习（unsupervised learning）&lt;/li&gt;
&lt;li&gt;半监督学习（semi-supervised …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;h2&gt;1.1 统计学习&lt;/h2&gt;
&lt;h3&gt;1.1.1 特点&lt;/h3&gt;
&lt;p&gt;统计学习（statistical learning）是关于计算机基于&lt;strong&gt;数据&lt;/strong&gt;构建概率统计模型并运用模型对数据进行&lt;strong&gt;预测与分析&lt;/strong&gt;的一门学科。&lt;/p&gt;
&lt;p&gt;赫尔伯特·西蒙（Herbert A.Simon）对“学习”给出如下定义：如果一个系统能够通过执行某个过程改变它的性能，这就是学习。&lt;/p&gt;
&lt;h3&gt;1.1.2 对象&lt;/h3&gt;
&lt;p&gt;统计学习的对象是数据。&lt;/p&gt;
&lt;p&gt;统计学习关于数据的基本假设是同类数据具有一定的统计规律性，这是统计学习的前提。&lt;/p&gt;
&lt;h3&gt;1.1.3 目的&lt;/h3&gt;
&lt;p&gt;统计学习用于对数据进行预测和分析，特别是对未知新数据进行预测与分析。&lt;/p&gt;
&lt;h3&gt;1.1.4 方法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;监督学习（supervised learning）&lt;/li&gt;
&lt;li&gt;非监督学习（unsupervised learning）&lt;/li&gt;
&lt;li&gt;半监督学习（semi-supervised learning）&lt;/li&gt;
&lt;li&gt;强化学习（reinforcement learning）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;1.1.5 统计学习方法三要素&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;模型（model）&lt;/strong&gt;：即假设空间（hypothesis space），假设空间是一个集合，这个集合包含要学习的模型&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;策略（strategy）&lt;/strong&gt;：模型选择的准则&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;算法（algorithm）&lt;/strong&gt;：模型学习的算法&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;1.2 监督学习&lt;/h2&gt;
&lt;p&gt;监督学习（supervised learning）的任务是学习一个模型，使模型能够对任意给定的输入，对其相应的输出做出一个好的预测。&lt;/p&gt;
&lt;h3&gt;1.2.1 基本概念&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;输入空间（input space）&lt;/strong&gt;：输入的所有可能取值的集合，表示为 &lt;span class="math"&gt;\({\cal X}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;输出空间（output space）&lt;/strong&gt;：输出的所有可能取值的集合，表示为 &lt;span class="math"&gt;\({\cal Y}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实例（instance）&lt;/strong&gt;：每个具体的输入，通常由特征向量（feature vector）表示&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;特征空间（feature space）&lt;/strong&gt;：所有特征向量存在的空间，每一维度对应一个特征&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;训练数据（training data）&lt;/strong&gt;：由输入（或特征向量）与输出对组成&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;联合概率分布（joint probability distribution）&lt;/strong&gt;：监督学习假设输入与输出的随机变量 &lt;span class="math"&gt;\(X\)&lt;/span&gt; 和 &lt;span class="math"&gt;\(Y\)&lt;/span&gt; 遵循联合概率分布 &lt;span class="math"&gt;\(P(X,Y)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;假设空间（hypothesis space）&lt;/strong&gt;：模型属于由输入空间到输出空间的映射的集合，这个集合就是假设空间。假设空间的确定意味着学习范围的确定&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;注1&lt;/strong&gt;：输入和输出空间可以使有限集也可以是整个欧式空间；输入与输出空间可以使用一个空间，也可以是不同的空间；通常输出空间远小于输入空间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注2&lt;/strong&gt;：有时假设输入空间与特征空间为相同的空间，对它们不予区分；有时假设输入空间与特征空间为不同的空间，将实例从输入空间映射到特征空间。模型实际上都是定义在特征空间上的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注3&lt;/strong&gt;：在学习过程中，假设联合概率分布存在，但对于学习系统来说，联合概率分布的具体定义是未知的。训练数据与测试数据被看作是依联合概率分布 &lt;span class="math"&gt;\(P(X,Y)\)&lt;/span&gt; 独立同分布（independent and identically distribution）产生的。统计学习假设数据存在一定的统计规律，&lt;span class="math"&gt;\(X\)&lt;/span&gt; 和 &lt;span class="math"&gt;\(Y\)&lt;/span&gt; 遵循联合概率分布 &lt;span class="math"&gt;\(P(X,Y)\)&lt;/span&gt; 就是监督学习关于数据的基本假设。&lt;/p&gt;
&lt;p&gt;在监督学习过程中，将输入和输出看做是定义在输入（特征）空间与输出空间上的随机变量的取值。输入、输出变量用大写字母表示，输入、输出变量所取的值用小写字母表示。&lt;/p&gt;
&lt;p&gt;输入实例 &lt;span class="math"&gt;\(x\)&lt;/span&gt; 的特征向量记作
&lt;/p&gt;
&lt;div class="math"&gt;$$x=\left(x^{(1)},x^{(2)},\dots,x^{(n)}\right)^\text{T}$$&lt;/div&gt;
&lt;p&gt;&lt;span class="math"&gt;\(x^{(i)}\)&lt;/span&gt; 表示 &lt;span class="math"&gt;\(x\)&lt;/span&gt; 的第 &lt;span class="math"&gt;\(i\)&lt;/span&gt; 个特征。&lt;/p&gt;
&lt;p&gt;多个输入变量的第 &lt;span class="math"&gt;\(i\)&lt;/span&gt; 个记作
&lt;/p&gt;
&lt;div class="math"&gt;$$x_i=\left(x_i^{(1)},x_i^{(2)},\dots,x_i^{(n)}\right)^\text{T}$$&lt;/div&gt;
&lt;p&gt;训练集：&lt;span class="math"&gt;\(T=\{(x_1,y_1),(x_2,y_2),\dots,(x_N,y_N)\}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;监督学习的模型可以是概率模型或非概率模型，由条件概率分布 &lt;span class="math"&gt;\(P(Y|X)\)&lt;/span&gt; 或决策函数（decision function）&lt;span class="math"&gt;\(Y=f(X)\)&lt;/span&gt; 表示。对具体的输入进行相应的输出预测时，写作 &lt;span class="math"&gt;\(P(y|x)\)&lt;/span&gt; 或 &lt;span class="math"&gt;\(y=f(x)\)&lt;/span&gt;。&lt;/p&gt;
&lt;h2&gt;1.3 统计学习三要素&lt;/h2&gt;
&lt;h3&gt;1.3.1 模型&lt;/h3&gt;
&lt;p&gt;统计学习首要考虑的问题是学习什么样的模型。模型的假设空间包含所有可能的条件概率分布或决策函数。假设空间中的模型一般有无穷多个。&lt;/p&gt;
&lt;p&gt;假设空间用 &lt;span class="math"&gt;\(\cal{F}\)&lt;/span&gt; 表示。假设空间可以定义为决策函数或条件概率分布的集合
&lt;/p&gt;
&lt;div class="math"&gt;$${\cal F}=\{f|Y=f_\theta(X),\theta \in \mathbb R^n\}$$&lt;/div&gt;
&lt;p&gt;
或
&lt;/p&gt;
&lt;div class="math"&gt;$${\cal F}=\{P|P_\theta(Y|X),\theta \in \mathbb R^n\}$$&lt;/div&gt;
&lt;p&gt;
参数向量 &lt;span class="math"&gt;\(\theta\)&lt;/span&gt; 取值于 &lt;span class="math"&gt;\(n\)&lt;/span&gt; 维欧式空间 &lt;span class="math"&gt;\(\mathbb R^n\)&lt;/span&gt;，称为参数空间（parameter space）。&lt;/p&gt;
&lt;h3&gt;1.3.2 策略&lt;/h3&gt;
&lt;p&gt;有了模型的假设空间，统计学习接着需要考虑的是按照什么样的准则学习或选择最优的模型。&lt;/p&gt;
&lt;h4&gt;损失函数和风险函数&lt;/h4&gt;
&lt;p&gt;损失函数（loss function）或代价函数（cost function）用来度量预测错误的程度。损失函数是 &lt;span class="math"&gt;\(f(X)\)&lt;/span&gt; 和 &lt;span class="math"&gt;\(Y\)&lt;/span&gt; 的非负实值函数，记作 &lt;span class="math"&gt;\(L(Y,f(X))\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;统计学习常用的损失函数有以下几种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;0-1 损失函数（0-1 loss function）
&lt;div class="math"&gt;$$L(Y,f(X))=\begin{cases}
1, &amp;amp; Y\neq f(X) \\
0, &amp;amp; Y=f(X)
\end{cases}$$&lt;/div&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;平方损失函数（quadratic loss function）
&lt;div class="math"&gt;$$L(Y,f(X))=(Y-f(X))^2$$&lt;/div&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;绝对损失函数（absolute loss function）
&lt;div class="math"&gt;$$L(Y,f(X))=|Y-f(X)|$$&lt;/div&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对数损失函数（logarithmic loss function）或对数似然损失函数（log-likelihood loss function）
&lt;div class="math"&gt;$$L(Y,P(Y|X))=-\log P(Y|X)$$&lt;/div&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;风险函数（risk function）或期望损失（expected loss）：理论上模型 &lt;span class="math"&gt;\(f(X)\)&lt;/span&gt; 关于联合分布 &lt;span class="math"&gt;\(P(X,Y)\)&lt;/span&gt; 平均意义下的损失，记作 &lt;span class="math"&gt;\(R_\text{exp}\)&lt;/span&gt;。
&lt;/p&gt;
&lt;div class="math"&gt;$$R_\text{exp}(f)=\text{E}_P[L(Y,f(X))]=\int_{{\cal X}\times{\cal Y}}L(y,f(x))P(x,y)dxdy$$&lt;/div&gt;
&lt;p&gt;经验风险（empirical risk）或经验损失（empirical loss）：模型 &lt;span class="math"&gt;\(f(X)\)&lt;/span&gt; 关于训数据集的平均损失，记作 &lt;span class="math"&gt;\(R_\text{emp}\)&lt;/span&gt;。
&lt;/p&gt;
&lt;div class="math"&gt;$$R_\text{emp}(f)=\frac{1}{N}\sum_{i=1}^NL\left(y_i,f(x_i)\right)$$&lt;/div&gt;
&lt;h4&gt;经验风险最小化&lt;/h4&gt;
&lt;p&gt;经验风险最小化（empirical risk minimization，ERM）策略认为：经验风险最小的模型是最优的模型。即求解下面的最优化问题
&lt;/p&gt;
&lt;div class="math"&gt;$$ \min_{f\in {\cal F}} \frac{1}{N}\sum_{i=1}^NL\left(y_i,f(x_i)\right)$$&lt;/div&gt;
&lt;p&gt;
其中 &lt;span class="math"&gt;\({\cal F}\)&lt;/span&gt; 是假设空间。&lt;/p&gt;
&lt;p&gt;当样本容量足够大时，经验风险最小化能保证有很好的学习效果。例如，极大似然估计（maximum likelihood estimation）就是经验风险最小化的一个例子。当模型是条件概率分布，损失函数是对数损失函数时，经验风险最小化就等价于极大似然估计。&lt;/p&gt;
&lt;p&gt;但是，当样本容量很小时，经验风险最小化学习的效果就未必很好，会产生“过拟合（over-fitting）现象”。&lt;/p&gt;
&lt;h4&gt;结构风险最小化&lt;/h4&gt;
&lt;p&gt;结构风险最小化（structural risk minimization，SRM）是为了防止过拟合而提出来的策略。结构风险最小化等价于正则化（regularization）。结构风险在经验风险上加上表示模型复杂度的正则化项（regularizer）或罚项（penalty term），定义如下
&lt;/p&gt;
&lt;div class="math"&gt;$$R_\text{srm}=\frac{1}{N}\sum_{i=1}^NL\left(y_i,f(x_i)\right)+\lambda J(f)$$&lt;/div&gt;
&lt;p&gt;
其中 &lt;span class="math"&gt;\(J(f)\)&lt;/span&gt; 为模型的复杂度，是定义在假设空间 &lt;span class="math"&gt;\({\cal F}\)&lt;/span&gt; 上的泛函。模型 &lt;span class="math"&gt;\(f\)&lt;/span&gt; 越复杂，&lt;span class="math"&gt;\(J(f)\)&lt;/span&gt; 越大。也就是说，复杂度表示了对复杂模型的惩罚，&lt;span class="math"&gt;\(\lambda\geq 0\)&lt;/span&gt; 是系数，用以权衡经验风险和模型复杂度。&lt;/p&gt;
&lt;p&gt;结构风险小需要经验风险与模型复杂度同时小，结构风险小的模型往往对训练数据以及未知的测试数据都有较好的预测。结构化风险最小化策略认为：结构风险最小的模型是最优的模型。即求解下面的最优化问题
&lt;/p&gt;
&lt;div class="math"&gt;$$ \min_{f\in {\cal F}} \frac{1}{N}\sum_{i=1}^NL\left(y_i,f(x_i)\right)+\lambda J(f)$$&lt;/div&gt;
&lt;p&gt;
贝叶斯估计中的最大后验概率估计（maximum posterior probability estimation，MAP）就是结构化风险最小化的一个例子。当模型是条件概率分布，损失函数是对数损失函数，模型复杂度由模型的先验概率表示时，结构风险最小化就等价于最大后验概率估计。&lt;/p&gt;
&lt;h3&gt;1.3.3 算法&lt;/h3&gt;
&lt;p&gt;算法是指学习模型的具体计算方法。统计学习基于训练数据集，根据学习策略，从假设空间中选择最优模型，最后需要考虑用什么样的计算方法求解最优模型。&lt;/p&gt;
&lt;p&gt;如果最优化问题有显式的解析解，这个最优化问题就比较简单，但通常解析解不存在，这就需要用数值方法求解。如何保证找到全局最优解，并使求解的过程非常高效，就成为一个重要问题。&lt;/p&gt;
&lt;h2&gt;1.4 模型评估与模型选择&lt;/h2&gt;
&lt;h3&gt;1.4.1 训练误差&lt;/h3&gt;
&lt;p&gt;假设学习到的模型是 &lt;span class="math"&gt;\(Y=\hat{f}(X)\)&lt;/span&gt;，训练误差（training error）是模型 &lt;span class="math"&gt;\(Y=\hat{f}(X)\)&lt;/span&gt; 关于训练数据集的平均损失
&lt;/p&gt;
&lt;div class="math"&gt;$$R_\text{emp}(\hat{f})=\frac{1}{N}\sum_{i=1}^NL(y_i,\hat{f}(x_i))$$&lt;/div&gt;
&lt;p&gt;其中 &lt;span class="math"&gt;\(N\)&lt;/span&gt; 是训练样本容量。&lt;/p&gt;
&lt;h3&gt;1.4.2 测试误差&lt;/h3&gt;
&lt;p&gt;测试误差是模型 &lt;span class="math"&gt;\(Y=\hat{f}(X)\)&lt;/span&gt; 关于测试数据集的平均损失
&lt;/p&gt;
&lt;div class="math"&gt;$$e_\text{test}(\hat{f})=\frac{1}{N'}\sum_{i=1}^{N'}L(y_i,\hat{f}(x_i))$$&lt;/div&gt;
&lt;p&gt;其中 &lt;span class="math"&gt;\(N'\)&lt;/span&gt; 是测试样本容量。&lt;/p&gt;
&lt;p&gt;例如，当损失函数是 0-1 损失时，测试误差就变成了常见的测试数据集上的误差率（error rate）
&lt;/p&gt;
&lt;div class="math"&gt;$$e_\text{test}=\frac{1}{N'}\sum_{i=1}^{N'}{\mathbb I}(y_i\neq \hat{f}(x_i))$$&lt;/div&gt;
&lt;p&gt;
这里 &lt;span class="math"&gt;\({\mathbb I}\)&lt;/span&gt; 是指示函数，即 &lt;span class="math"&gt;\(y_i\neq \hat{f}(x_i)\)&lt;/span&gt; 时为 1，否则为 0。&lt;/p&gt;
&lt;p&gt;相应的，常见的测试数据集上的准确率（accuracy）为
&lt;/p&gt;
&lt;div class="math"&gt;$$r_\text{test}=\frac{1}{N'}\sum_{i=1}^{N'}{\mathbb I}(y_i=\hat{f}(x_i))$$&lt;/div&gt;
&lt;p&gt;训练误差的大小，对判断给定的问题是不是一个容易学习的问题是有意义的，但本质上不重要。&lt;/p&gt;
&lt;p&gt;测试误差反应了学习方法对未知的测试数据集的预测能力，是学习中的重要概念。&lt;/p&gt;
&lt;h3&gt;1.4.3 过拟合&lt;/h3&gt;
&lt;p&gt;当假设空间含有不同复杂度（例如，不同的参数个数）的模型时，就要面临模型选择（model selection）的问题。我们希望选择或学习一个合适的模型。&lt;/p&gt;
&lt;p&gt;如果一味追求提高对训练数据的预测能力，所选模型的复杂度则往往会比真模型更高，这种现象称为过拟合。&lt;/p&gt;
&lt;p&gt;过拟合是指学习时选择的模型所包含的参数过多，以致于出现这一模型对已知数据预测得很好，但对未知数据预测很差的现象。&lt;/p&gt;
&lt;p&gt;训练误差与测试误差和模型复杂度关系如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="训练误差与测试误差和模型复杂度" src="https://xutree.github.io/images/statistical_learning_1.3.png"&gt;&lt;/p&gt;
&lt;h2&gt;1.5 正则化与交叉验证&lt;/h2&gt;
&lt;p&gt;正则化与交叉验证是两种常用的模型选择方法。&lt;/p&gt;
&lt;h3&gt;1.5.1 正则化&lt;/h3&gt;
&lt;p&gt;正则化是结构风险最小化策略的实现。正则化项一般是模型复杂度的单调递增函数，模型越复杂，正则化值就越大。&lt;/p&gt;
&lt;p&gt;正则化一般形式形式
&lt;/p&gt;
&lt;div class="math"&gt;$$ \min_{f\in {\cal F}} \frac{1}{N}\sum_{i=1}^NL\left(y_i,f(x_i)\right)+\lambda J(f)$$&lt;/div&gt;
&lt;p&gt;
其中，第一项是经验风险，第二项是正则化项，&lt;span class="math"&gt;\(\lambda\geq 0\)&lt;/span&gt; 为调整两者关系之间的系数。&lt;/p&gt;
&lt;p&gt;正则化项可以取不同的形式。例如：回归问题中，损失函数是平方损失，正则化项可以是参数向量的 &lt;span class="math"&gt;\(L_2\)&lt;/span&gt; 范数
&lt;/p&gt;
&lt;div class="math"&gt;$$L(w)=\frac{1}{N}\sum_{i=1}^N\left(f(x_i;w)-y_i\right)^2+\frac{\lambda}{2}||w||^2$$&lt;/div&gt;
&lt;p&gt;
这里，&lt;span class="math"&gt;\(||w||\)&lt;/span&gt; 表示参数向量 &lt;span class="math"&gt;\(w\)&lt;/span&gt; 的 &lt;span class="math"&gt;\(L_2\)&lt;/span&gt; 范数。&lt;/p&gt;
&lt;h3&gt;1.5.2 交叉验证&lt;/h3&gt;
&lt;p&gt;另一种常用的模型选择方法是交叉验证（cross validation）。&lt;/p&gt;
&lt;p&gt;如果给定的样本数据充足，进行模型选择的一种简单方法是随机的将数据集切成三部分：训练集、验证集和测试集。训练集用来训练模型，验证集用于模型选择，测试集用于最终对学习方法的评估。&lt;/p&gt;
&lt;p&gt;但是，在许多实际应用中数据是不充足的。为了选择好的模型，可以采用交叉验证的方法。&lt;/p&gt;
&lt;p&gt;交叉验证的基本思想是重复的使用数据：把给定的数据进行切分，将切分的数据集组合为训练集与测试集，在此基础上反复进行训练、测试以及模型选择。&lt;/p&gt;
&lt;h4&gt;简单交叉验证&lt;/h4&gt;
&lt;p&gt;首先随机的将已给数据分成两部分：训练集、测试集。然后用训练集在各种条件下（例如，不同的参数个数）训练模型，从而得到不同的模型。然后，在测试集上评价各个模型的测试误差，选出测试误差最小的模型。&lt;/p&gt;
&lt;h4&gt;&lt;span class="math"&gt;\(S\)&lt;/span&gt; 折交叉验证&lt;/h4&gt;
&lt;p&gt;应用最多的是 &lt;span class="math"&gt;\(S\)&lt;/span&gt; 折交叉验证（S-fold cross validation），方法如下：首先随机的将已给数据切分为 &lt;span class="math"&gt;\(S\)&lt;/span&gt; 个互不相交的大小相同的子集；然后利用 &lt;span class="math"&gt;\(S-1\)&lt;/span&gt; 个子集的数据训练模型，利用余下的子集测试模型；将这一过程对可能的 &lt;span class="math"&gt;\(S\)&lt;/span&gt; 种选择重复进行；最后选出 &lt;span class="math"&gt;\(S\)&lt;/span&gt; 次评估中平均测试误差最小的模型。&lt;/p&gt;
&lt;h4&gt;留一交叉验证&lt;/h4&gt;
&lt;p&gt;&lt;span class="math"&gt;\(S\)&lt;/span&gt; 折交叉验证的特殊情形是 &lt;span class="math"&gt;\(S=N\)&lt;/span&gt;，称为留一交叉验证（leave-one-out cross validation），往往在数据缺乏的情况下使用。这里 &lt;span class="math"&gt;\(N\)&lt;/span&gt; 是给定数据集的容量。&lt;/p&gt;
&lt;h2&gt;1.6 泛化能力&lt;/h2&gt;
&lt;h3&gt;1.6.1 泛化误差&lt;/h3&gt;
&lt;p&gt;学习方法的泛化能力（generalization ability）是指由该学习方法学到的模型对未知数据的预测能力。&lt;/p&gt;
&lt;p&gt;泛化误差（generalization error）：如果学到的模型是 &lt;span class="math"&gt;\(\hat{f}\)&lt;/span&gt;，那么用这个模型对未知数据预测的误差即为泛化误差。
&lt;/p&gt;
&lt;div class="math"&gt;$$R_\text{exp}(\hat{f})=\text{E}_P[L(Y,f(X))]=\int_{{\cal X}\times{\cal Y}}L(y,\hat{f}(x))P(x,y)dxdy$$&lt;/div&gt;
&lt;p&gt;
实际上，泛化误差就是所学习到的模型的期望风险。&lt;/p&gt;
&lt;h3&gt;1.6.2 泛化误差上界&lt;/h3&gt;
&lt;p&gt;学习方法的泛化能力分析往往使用过研究泛化误差的概率上界进行的，简称为泛化误差上界（generalization error bound）。也就是说，可以通过比较两种学习方法的泛化误差上界的大小来比较它们的优劣。&lt;/p&gt;
&lt;p&gt;泛化误差上界具有如下性质：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它是样本容量的函数，当样本容量增加时，泛化误差上界趋于 0&lt;/li&gt;
&lt;li&gt;它是假设空间容量（capacity）的函数，假设空间容量越大，模型就越难学，泛化误差上界就越大&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;1.6.3 二分类问题的泛化误差上界&lt;/h3&gt;
&lt;p&gt;考虑二分类问题。已知训练数据集 &lt;span class="math"&gt;\(T=\{(x_1,y_1),(x_2,y_2),\dots,(x_N,y_N)\}\)&lt;/span&gt;，它是从联合概率分布 &lt;span class="math"&gt;\(P(X,Y)\)&lt;/span&gt; 独立同分布产生的，&lt;span class="math"&gt;\(X\in \mathbb R^n\)&lt;/span&gt;，&lt;span class="math"&gt;\(Y\in \{-1,1\}\)&lt;/span&gt;。假设空间是函数的有限集合 &lt;span class="math"&gt;\({\cal F}=\{f_1.f_2.\dots,f_d\}\)&lt;/span&gt;，&lt;span class="math"&gt;\(d\)&lt;/span&gt; 是函数个数。设 &lt;span class="math"&gt;\(f\)&lt;/span&gt; 是从 &lt;span class="math"&gt;\({\cal F}\)&lt;/span&gt; 中选取的函数。损失函数是 0-1 损失。关于 &lt;span class="math"&gt;\(f\)&lt;/span&gt; 的期望风险和经验风险分别是
&lt;/p&gt;
&lt;div class="math"&gt;$$\begin{eqnarray}
R_\text{exp}(f)&amp;amp;=&amp;amp;\text{E}_P[L(Y,f(X))]\\
R_\text{emp}(f)&amp;amp;=&amp;amp;\frac{1}{N}\sum_{i=1}^NL(y_i,f(x_i))
\end{eqnarray}$$&lt;/div&gt;
&lt;p&gt;
经验风险最小化函数是
&lt;/p&gt;
&lt;div class="math"&gt;$$f_N=\arg \min_{f\in{\cal F}}R_\text{emp}(f)$$&lt;/div&gt;
&lt;p&gt;
人们更关心的是 &lt;span class="math"&gt;\(f_N\)&lt;/span&gt; 的泛化能力
&lt;/p&gt;
&lt;div class="math"&gt;$$R(f_N)=\text{E}_P[L(Y,f_N(X))]$$&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;定理 1.1（泛化误差上界）对二分类问题，当假设空间是有限个函数的集合 &lt;span class="math"&gt;\({\cal F}=\{f_1.f_2.\dots,f_d\}\)&lt;/span&gt; 时，对任意一个函数 &lt;span class="math"&gt;\(f\in{\cal F}\)&lt;/span&gt;，至少以概率 &lt;span class="math"&gt;\(1-\delta\)&lt;/span&gt;，以下不等式成立
&lt;div class="math"&gt;$$R(f)\leq R_\text{emp}(f)+\epsilon(d,N,\delta)$$&lt;/div&gt;
其中，
&lt;div class="math"&gt;$$\epsilon(d,N,\delta)=\sqrt{\frac{1}{2N}\left(\log d+\log \frac{1}{\delta}\right)}$$&lt;/div&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上述定理表明：训练误差越小，泛化误差也越小；当 &lt;span class="math"&gt;\(N\)&lt;/span&gt; 趋于无穷时，第二项为 0；假设空间包含的函数越多，泛化误差越大。&lt;/p&gt;
&lt;p&gt;证明：在证明过程中要用到 Hoeffding 不等式，先叙述如下：&lt;/p&gt;
&lt;p&gt;Hoeffding 不等式适用于有界的随机变量。设有两两独立的一系列随机变量 &lt;span class="math"&gt;\(X_{1},\dots ,X_{n}\)&lt;/span&gt;。假设对所有的 &lt;span class="math"&gt;\(1\leq i\leq n\)&lt;/span&gt;，&lt;span class="math"&gt;\(X_{i}\)&lt;/span&gt; 都是几乎有界的变量，即满足
&lt;/p&gt;
&lt;div class="math"&gt;$$\mathbb {P} (X_{i}\in [a_{i},b_{i}])=1$$&lt;/div&gt;
&lt;p&gt;
那么这 &lt;span class="math"&gt;\(n\)&lt;/span&gt; 个随机变量的经验期望
&lt;/p&gt;
&lt;div class="math"&gt;$$\overline {X}={\frac {X_{1}+\cdots +X_{n}}{n}}$$&lt;/div&gt;
&lt;p&gt;
满足以下的不等式
&lt;/p&gt;
&lt;div class="math"&gt;$$\begin{eqnarray}
\mathbb {P}({\overline {X}}-\mathbb {E} [{\overline {X}}]\geq t) &amp;amp;\leq&amp;amp; \exp \left(-{\frac {2t^{2}n^{2}}{\sum_{i=1}^{n}(b_{i}-a_{i})^{2}}}\right)\\
\mathbb {P} (|{\overline {X}}-\mathbb {E} [{\overline {X}}]|\geq t)&amp;amp;\leq&amp;amp; 2\exp \left(-{\frac {2t^{2}n^{2}}{\sum_{i=1}^{n}(b_{i}-a_{i})^{2}}}\right)
\end{eqnarray}$$&lt;/div&gt;
&lt;p&gt;
对任意函数 &lt;span class="math"&gt;\(f\in{\cal F}\)&lt;/span&gt;，&lt;span class="math"&gt;\(R_\text{emp}(f)\)&lt;/span&gt; 是 &lt;span class="math"&gt;\(N\)&lt;/span&gt; 个随机变量 &lt;span class="math"&gt;\(L(Y,f(X))\)&lt;/span&gt; 的样本均值，&lt;span class="math"&gt;\(R(f)\)&lt;/span&gt; 是随机变量 &lt;span class="math"&gt;\(L(Y,f(X))\)&lt;/span&gt; 的期望值。如果损失函数取值于区间 [0,1]，则由 Hoeffding 不等式得到，对 &lt;span class="math"&gt;\(\epsilon&amp;gt;0\)&lt;/span&gt;，以下不等式成立
&lt;/p&gt;
&lt;div class="math"&gt;$$P(R(f)-R_\text{emp}(f)\geq\epsilon)\leq\exp (-2N\epsilon^2)$$&lt;/div&gt;
&lt;p&gt;
由于 &lt;span class="math"&gt;\({\cal F}=\{f_1;f_2,\dots,f_d\}\)&lt;/span&gt; 是一个有限集合，故
&lt;/p&gt;
&lt;div class="math"&gt;$$\begin{eqnarray}
P\left(\exists f\in{\cal F}:R(f)-R_\text{emp}(f\right)\geq\epsilon)&amp;amp;=&amp;amp;P\left(\bigcup_{f\in{\cal F}}\{R(f)-R_\text{emp}(f)\geq\epsilon\}\right)\\
&amp;amp;\leq&amp;amp;\sum_{f\in{\cal F}}P(R(f)-R_\text{emp}(f)\geq\epsilon)\\
&amp;amp;\leq&amp;amp; d\exp(-2N\epsilon^2)
\end{eqnarray}$$&lt;/div&gt;
&lt;p&gt;
或者等价的，对任意的 &lt;span class="math"&gt;\(f\in{\cal F}\)&lt;/span&gt;，有 &lt;/p&gt;
&lt;div class="math"&gt;$$P(R(f)-R_\text{emp}(f)\geq\epsilon))\geq1-d\exp(-2N\epsilon^2)$$&lt;/div&gt;
&lt;p&gt;
令
&lt;/p&gt;
&lt;div class="math"&gt;$$\delta=d \exp(-2N\epsilon^2)$$&lt;/div&gt;
&lt;p&gt;
则
&lt;/p&gt;
&lt;div class="math"&gt;$$P(R(f)&amp;lt;R_\text{emp}(f)+\epsilon)\geq1-\delta$$&lt;/div&gt;
&lt;p&gt;
证毕。&lt;/p&gt;
&lt;h2&gt;1.7 生成模型与判别模型&lt;/h2&gt;
&lt;p&gt;监督学习方法也可以分为生成方法（generative approach）和判别方法（discriminative approach）。所学到的模型分别称为生成模型（generative model）和判别模型（discriminative model）。&lt;/p&gt;
&lt;h3&gt;1.7.1 生成方法&lt;/h3&gt;
&lt;p&gt;生成方法由数据学习联合概率分布 &lt;span class="math"&gt;\(P(X,Y)\)&lt;/span&gt;，然后求出条件概率分布 &lt;span class="math"&gt;\(P(Y|X)\)&lt;/span&gt; 作为预测的模型，即生成模型
&lt;/p&gt;
&lt;div class="math"&gt;$$P(Y|X)=\frac{P(X,Y)}{P(X)}$$&lt;/div&gt;
&lt;p&gt;
这样的方法之所以称为生成方法，是因为模型表示了给定输入 &lt;span class="math"&gt;\(X\)&lt;/span&gt; 产生输出 &lt;span class="math"&gt;\(Y\)&lt;/span&gt; 的生成关系。&lt;/p&gt;
&lt;p&gt;典型的生成模型有：朴素贝叶斯法和隐马尔科夫模型。&lt;/p&gt;
&lt;h3&gt;1.7.2 判别方法&lt;/h3&gt;
&lt;p&gt;判别方法由数据直接学习策略函数 &lt;span class="math"&gt;\(f(X)\)&lt;/span&gt; 或者条件概率分布 &lt;span class="math"&gt;\(P(Y|X)\)&lt;/span&gt; 作为预测的模型。判别方法关心的是对给定的输入 &lt;span class="math"&gt;\(X\)&lt;/span&gt;，应该预测什么样的输出 &lt;span class="math"&gt;\(Y\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;典型的判别模型有：&lt;span class="math"&gt;\(k\)&lt;/span&gt; 近邻法，感知机，决策树，logistic 回归模型，最大熵模型，支持向量机，提升方法和条件随机场等。&lt;/p&gt;
&lt;h3&gt;1.7.3 不同方法的特点&lt;/h3&gt;
&lt;p&gt;生成方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;生成方法可以还原出联合概率分布 &lt;span class="math"&gt;\(P(X,Y)\)&lt;/span&gt;，而判别方法则不能&lt;/li&gt;
&lt;li&gt;生成方法的学习收敛速度更快，即当样本容量增加时，学到的模型可以更快的收敛到真实模型&lt;/li&gt;
&lt;li&gt;当存在隐变量时，仍可以使用生成方法，此时判别方法就不能用了&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;判别方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;判别方法直接学习的是条件概率 &lt;span class="math"&gt;\(P(Y|X)\)&lt;/span&gt; 或决策函数 &lt;span class="math"&gt;\(f(X)\)&lt;/span&gt;，直接面对预测，往往学习的准确率更高&lt;/li&gt;
&lt;li&gt;由于直接学习 &lt;span class="math"&gt;\(P(Y|X)\)&lt;/span&gt; 或 &lt;span class="math"&gt;\(f(X)\)&lt;/span&gt;，可以对数据进行各种程度上的抽象、定义特征并使用特征，因此可以简化学习问题&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;1.8 分类问题&lt;/h2&gt;
&lt;p&gt;在监督学习中，当输出变量 &lt;span class="math"&gt;\(Y\)&lt;/span&gt; 取有限个离散值时，预测问题便成为分类问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分类器（classifier）&lt;/strong&gt;：从数据中学习到的一个分类模型或分类决策函数。&lt;/p&gt;
&lt;p&gt;评价分类器性能的指标一般是&lt;strong&gt;分类准确率（accuracy）&lt;/strong&gt;：对于给定的测试数据集，分类器正确分类的样本数与总样本数之比。&lt;/p&gt;
&lt;p&gt;对于二分类问题常用的评价指标是&lt;strong&gt;精确率（precision）&lt;/strong&gt;和&lt;strong&gt;召回率（recall）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;通常以关注的类为正类，其他类为负类，分类器在测试数据集上的预测或正确或不正确，4 种情况出现的总数分别记为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TP：将正类预测为正类的数目&lt;/li&gt;
&lt;li&gt;FN：将正类预测为负类的数目&lt;/li&gt;
&lt;li&gt;FP：将负类预测为正类的数目&lt;/li&gt;
&lt;li&gt;TN：将负类预测为负类的数目&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;精确率定义
&lt;/p&gt;
&lt;div class="math"&gt;$$P=\frac{TP}{TP+FP}$$&lt;/div&gt;
&lt;p&gt;
召回率定义
&lt;/p&gt;
&lt;div class="math"&gt;$$R=\frac{TP}{TP+FN}$$&lt;/div&gt;
&lt;p&gt;
&lt;span class="math"&gt;\(F_1\)&lt;/span&gt; 值
&lt;/p&gt;
&lt;div class="math"&gt;$$\frac{2}{F_1}=\frac{1}{P}+\frac{1}{R}\longrightarrow
F_1=\frac{2TP}{2TP+FP+FN}$$&lt;/div&gt;
&lt;p&gt;许多统计学习方法可以用于分类，包括 &lt;span class="math"&gt;\(k\)&lt;/span&gt; 近邻法，感知机，朴素贝叶斯法，决策树，决策列表，logistic 回归模型，支持向量机，提升方法，贝叶斯网络，神经网络，Winnow 等。&lt;/p&gt;
&lt;p&gt;一个分类应用的例子：垃圾邮件、非垃圾邮件分类。&lt;/p&gt;
&lt;h2&gt;1.9 标注问题&lt;/h2&gt;
&lt;p&gt;标注（tagging）也是一个监督学习问题，可以认为标注问题是分类问题的一个推广，标注问题又是更复杂的结构预测（structure prediction）问题的简单形式。&lt;/p&gt;
&lt;p&gt;标注问题的输入是一个观测序列，输出是一个标记序列或状态序列。标注问题的目标在于学习一个模型，使它能够对观测序列给出标记序列作为预测。注意，可能的标记个数是有限的，但其组合所成的标记序列的个数是依序列长度呈指数级增长的。&lt;/p&gt;
&lt;p&gt;评价标注模型的指标和分类模型一样，常用的有标注准确率、精确率和召回率。&lt;/p&gt;
&lt;p&gt;标注常用的统计学习方法有：隐马尔科夫模型，条件随机场。&lt;/p&gt;
&lt;p&gt;一个标注的例子：对英文文章进行标注，英文单词是一个观察，英文句子是一个观察序列，标记表示名词短语的“开始”、“结束”和“其他”。&lt;/p&gt;
&lt;h2&gt;1.10 回归问题&lt;/h2&gt;
&lt;p&gt;回归（regression）是监督学习的另一个重要问题。回归用于预测输入变量（自变量）和输出变量（因变量）之间的关系，特别是当输入变量的值发生变化时，输出变量的值随之发生的变化。回归问题等价于函数拟合：选择一条函数曲线使其很好的拟合已知数据且很好的预测未知数据。&lt;/p&gt;
&lt;p&gt;回归问题按照输入变量的个数，分为一元回归和多元回归；按照输入变量和输出变量之间的关系分为线性回归和非线性回归。&lt;/p&gt;
&lt;p&gt;回归学习中最常用的损失函数是平方损失函数，在此情况下，回归问题可以用最小二乘法（least squares）求解。&lt;/p&gt;
&lt;p&gt;一个回归的例子：市场趋势预测。&lt;/p&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="统计学习"></category><category term="机器学习"></category></entry><entry><title>最大子数组问题</title><link href="https://xutree.github.io/pages/2018/10/27/find_maximum_subarray/" rel="alternate"></link><published>2018-10-27T22:26:28+08:00</published><updated>2018-10-28T13:02:31+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-27:/pages/2018/10/27/find_maximum_subarray/</id><summary type="html">&lt;p&gt;寻找数组中和最大的非空连续子数组。&lt;/p&gt;
&lt;h2&gt;暴力求解&lt;/h2&gt;
&lt;p&gt;先找出从第1个元素开始的最大子数组，而后再从第2个元素开始找出从第2个元素开始的最大子数组，依次类推，比较得出最大的子数组。&lt;/p&gt;
&lt;p&gt;时间复杂度 &lt;span class="math"&gt;\(O(n^2)\)&lt;/span&gt;。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;tuple&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="kr"&gt;typedef&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;tuple&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kr"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kr"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kr"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;array_info_message&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;array_info_message&lt;/span&gt; &lt;span class="nf"&gt;find_max_subarray&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[],&lt;/span&gt; &lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="n"&gt;sum&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="n"&gt;max_left&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;max_right&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//每次开始累加的起始位置的循环&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;max_left&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="c1"&gt;//向后累加的循环&lt;/span&gt;
                &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><content type="html">&lt;p&gt;寻找数组中和最大的非空连续子数组。&lt;/p&gt;
&lt;h2&gt;暴力求解&lt;/h2&gt;
&lt;p&gt;先找出从第1个元素开始的最大子数组，而后再从第2个元素开始找出从第2个元素开始的最大子数组，依次类推，比较得出最大的子数组。&lt;/p&gt;
&lt;p&gt;时间复杂度 &lt;span class="math"&gt;\(O(n^2)\)&lt;/span&gt;。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;tuple&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="kr"&gt;typedef&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;tuple&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kr"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kr"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kr"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;array_info_message&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;array_info_message&lt;/span&gt; &lt;span class="nf"&gt;find_max_subarray&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[],&lt;/span&gt; &lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="n"&gt;sum&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="n"&gt;max_left&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;max_right&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//每次开始累加的起始位置的循环&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;max_left&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="c1"&gt;//向后累加的循环&lt;/span&gt;
                &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                        &lt;span class="n"&gt;temp&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
                        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;temp&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                                &lt;span class="n"&gt;sum&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                                &lt;span class="n"&gt;max_right&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                        &lt;span class="p"&gt;}&lt;/span&gt;
                &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;make_tuple&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;max_left&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;max_right&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;分治算法&lt;/h2&gt;
&lt;p&gt;时间复杂度 &lt;span class="math"&gt;\(O(nlgn)\)&lt;/span&gt;。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;limits&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;tuple&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="kr"&gt;typedef&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;tuple&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kr"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kr"&gt;int&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kr"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;array_info_message&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kr"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;find_max_cross_subarray&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[],&lt;/span&gt; &lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="n"&gt;low&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="n"&gt;mid&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                                           &lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="n"&gt;high&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="n"&gt;left_sum&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;numeric_limits&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kr"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="nf"&gt;min&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="n"&gt;right_sum&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;numeric_limits&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kr"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="nf"&gt;min&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="n"&gt;sum&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="n"&gt;max_left&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;mid&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="n"&gt;max_right&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;mid&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;mid&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;low&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;sum&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;left_sum&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                        &lt;span class="n"&gt;left_sum&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                        &lt;span class="n"&gt;max_left&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="n"&gt;sum&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;mid&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;high&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;sum&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;right_sum&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                        &lt;span class="n"&gt;right_sum&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                        &lt;span class="n"&gt;max_right&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;make_tuple&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;max_left&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;max_right&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;left_sum&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;right_sum&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;array_info_message&lt;/span&gt; &lt;span class="nf"&gt;find_max_subarray&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[],&lt;/span&gt; &lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="n"&gt;low&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="n"&gt;high&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;array_info_message&lt;/span&gt; &lt;span class="n"&gt;r1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;r2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;r3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;low&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;high&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;make_tuple&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;low&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;high&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;low&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="c1"&gt;// 第一次这里处理成减号了，找了半天 bug&lt;/span&gt;
                &lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="n"&gt;mid&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;static_cast&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kr"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;high&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;low&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                &lt;span class="n"&gt;r1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;find_max_subarray&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;low&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;mid&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                &lt;span class="n"&gt;r2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;find_max_subarray&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;mid&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;high&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                &lt;span class="n"&gt;r3&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;find_max_cross_subarray&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;low&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;mid&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;high&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;get&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;r1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;get&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;r2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;
                    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;get&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;r1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;get&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;r3&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;r1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;get&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;r2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;get&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;r1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;
                     &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;get&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;r2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;get&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;r3&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
                        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;r2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;get&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;r3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;get&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;r1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;
                     &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;get&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;r3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;get&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;r2&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
                        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;r3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;make_tuple&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;动态规划：Kadane 算法&lt;/h2&gt;
&lt;p&gt;Kadane 算法扫描一次整个数列的所有数值，在每一个扫描点计算以该点数值为结束点的子数列的最大和（正数和）。该子数列由两部分组成：以前一个位置为结束点的最大子数列、该位置的数值。因为该算法用到了“最佳子结构”（以每个位置为终点的最大子数列都是基于其前一位置的最大子数列计算得出）。&lt;/p&gt;
&lt;p&gt;Kadane 算法时间复杂度为 &lt;span class="math"&gt;\(O(n)\)&lt;/span&gt;，空间复杂度为 &lt;span class="math"&gt;\(O(1)\)&lt;/span&gt;。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;array_info_message&lt;/span&gt; &lt;span class="nt"&gt;find_max_subarray&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;int&lt;/span&gt; &lt;span class="nt"&gt;a&lt;/span&gt;&lt;span class="cp"&gt;[]&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;int&lt;/span&gt; &lt;span class="nt"&gt;n&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="err"&gt;void&lt;/span&gt; &lt;span class="err"&gt;maxSubArray(int&lt;/span&gt; &lt;span class="err"&gt;a&lt;/span&gt;&lt;span class="cp"&gt;[]&lt;/span&gt;&lt;span class="err"&gt;,&lt;/span&gt; &lt;span class="err"&gt;int&lt;/span&gt; &lt;span class="err"&gt;n)&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;
    &lt;span class="err"&gt;int&lt;/span&gt; &lt;span class="err"&gt;max&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;numeric_limits&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="nf"&gt;min&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="err"&gt;int&lt;/span&gt; &lt;span class="err"&gt;sum&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt; &lt;span class="err"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="err"&gt;int&lt;/span&gt; &lt;span class="err"&gt;left&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt; &lt;span class="err"&gt;0,&lt;/span&gt; &lt;span class="err"&gt;right&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt; &lt;span class="err"&gt;0,&lt;/span&gt; &lt;span class="err"&gt;max_left&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt; &lt;span class="err"&gt;0,&lt;/span&gt; &lt;span class="err"&gt;max_right&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt; &lt;span class="err"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="err"&gt;for&lt;/span&gt; &lt;span class="err"&gt;(int&lt;/span&gt; &lt;span class="err"&gt;i&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt; &lt;span class="err"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="err"&gt;i&lt;/span&gt; &lt;span class="err"&gt;&amp;lt;&lt;/span&gt; &lt;span class="err"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="err"&gt;i++)&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;
            &lt;span class="err"&gt;if&lt;/span&gt; &lt;span class="err"&gt;(sum&lt;/span&gt; &lt;span class="err"&gt;+&lt;/span&gt; &lt;span class="err"&gt;a&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt; &lt;span class="err"&gt;&amp;gt;&lt;/span&gt; &lt;span class="err"&gt;a&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="err"&gt;)&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;
                    &lt;span class="err"&gt;sum&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt; &lt;span class="err"&gt;sum&lt;/span&gt; &lt;span class="err"&gt;+&lt;/span&gt; &lt;span class="err"&gt;a&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                    &lt;span class="err"&gt;right&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt; &lt;span class="err"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="nt"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                    &lt;span class="err"&gt;sum&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt; &lt;span class="err"&gt;a&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                    &lt;span class="err"&gt;left&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt; &lt;span class="err"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                    &lt;span class="err"&gt;right&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt; &lt;span class="err"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
            &lt;span class="nt"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;sum&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nt"&gt;max&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                    &lt;span class="err"&gt;max&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt; &lt;span class="err"&gt;sum&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                    &lt;span class="err"&gt;max_left&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt; &lt;span class="err"&gt;left&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                    &lt;span class="err"&gt;max_right&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt; &lt;span class="err"&gt;right&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="err"&gt;}&lt;/span&gt;
    &lt;span class="nt"&gt;return&lt;/span&gt; &lt;span class="nt"&gt;std&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nd"&gt;make_tuple&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;max_left&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;max_right&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;max&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;若我们只需要求最大和，则有如下简洁解法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;int&lt;/span&gt; &lt;span class="nt"&gt;find_max_subarray&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;int&lt;/span&gt; &lt;span class="nt"&gt;a&lt;/span&gt;&lt;span class="cp"&gt;[]&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;int&lt;/span&gt; &lt;span class="nt"&gt;n&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="err"&gt;int&lt;/span&gt; &lt;span class="err"&gt;max&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;numeric_limits&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="nf"&gt;min&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="err"&gt;int&lt;/span&gt; &lt;span class="err"&gt;sum&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt; &lt;span class="err"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="err"&gt;for&lt;/span&gt; &lt;span class="err"&gt;(int&lt;/span&gt; &lt;span class="err"&gt;i&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt; &lt;span class="err"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="err"&gt;i&lt;/span&gt; &lt;span class="err"&gt;&amp;lt;&lt;/span&gt; &lt;span class="err"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="err"&gt;i++)&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;
                &lt;span class="err"&gt;sum&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt; &lt;span class="err"&gt;sum&lt;/span&gt; &lt;span class="err"&gt;+&lt;/span&gt; &lt;span class="err"&gt;a&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt; &lt;span class="err"&gt;&amp;gt;&lt;/span&gt; &lt;span class="err"&gt;a&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt; &lt;span class="err"&gt;?&lt;/span&gt; &lt;span class="err"&gt;sum&lt;/span&gt; &lt;span class="err"&gt;+&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="err"&gt;max&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt; &lt;span class="err"&gt;sum&lt;/span&gt; &lt;span class="err"&gt;&amp;gt;&lt;/span&gt; &lt;span class="err"&gt;max&lt;/span&gt; &lt;span class="err"&gt;?&lt;/span&gt; &lt;span class="n"&gt;sum&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="nt"&gt;return&lt;/span&gt; &lt;span class="nt"&gt;max&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="算法"></category></entry><entry><title>排序算法</title><link href="https://xutree.github.io/pages/2018/10/26/sort/" rel="alternate"></link><published>2018-10-26T23:08:38+08:00</published><updated>2018-11-01T22:21:00+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-26:/pages/2018/10/26/sort/</id><summary type="html">&lt;h2&gt;插入排序&lt;/h2&gt;
&lt;p&gt;插入排序（英语：Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用 in-place 排序（即只需用到 &lt;span class="math"&gt;\(O(1)\)&lt;/span&gt; 的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;void insertion_sort(int arr[], int len) {
        for (int i = 1; i &amp;lt; len; i++) {
                int key = arr[i];
                int j;
                for (j = i - 1; j &amp;gt;= 0 &amp;amp;&amp;amp; key &amp;lt; arr[j]; j-- …&lt;/pre&gt;&lt;/div&gt;&lt;script type='text/javascript'&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</summary><content type="html">&lt;h2&gt;插入排序&lt;/h2&gt;
&lt;p&gt;插入排序（英语：Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用 in-place 排序（即只需用到 &lt;span class="math"&gt;\(O(1)\)&lt;/span&gt; 的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;void insertion_sort(int arr[], int len) {
        for (int i = 1; i &amp;lt; len; i++) {
                int key = arr[i];
                int j;
                for (j = i - 1; j &amp;gt;= 0 &amp;amp;&amp;amp; key &amp;lt; arr[j]; j--) {
                        arr[j + 1] = arr[j];
                        arr[j] = key;
                }
        }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果目标是把 &lt;span class="math"&gt;\(n\)&lt;/span&gt; 个元素的序列升序排列，那么采用插入排序存在最好情况和最坏情况。最好情况就是，序列已经是升序排列了，在这种情况下，需要进行的比较操作需 &lt;span class="math"&gt;\(n-1\)&lt;/span&gt; 次即可。最坏情况就是，序列是降序排列，那么此时需要进行的比较共有 &lt;span class="math"&gt;\(\frac {1}{2}n(n-1)\)&lt;/span&gt; 次。插入排序的赋值操作是比较操作的次数减去 &lt;span class="math"&gt;\(n-1\)&lt;/span&gt; 次，（因为 &lt;span class="math"&gt;\(n-1\)&lt;/span&gt; 次循环中，每一次循环的比较都比赋值多一个，多在最后那一次比较并不带来赋值）。平均来说插入排序算法复杂度为 &lt;span class="math"&gt;\(O(n^{2})\)&lt;/span&gt;。因而，插入排序不适合对于数据量比较大的排序应用。但是，如果需要排序的数据量很小，例如，量级小于千；或者若已知输入元素大致上按照顺序排列，那么插入排序还是一个不错的选择。 插入排序在工业级库中也有着广泛的应用，在 STL 的 sort 算法和 stdlib 的 qsort 算法中，都将插入排序作为快速排序的补充，用于少量元素的排序（通常为8个或以下）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最坏时间复杂度：&lt;span class="math"&gt;\(O(n^2)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;最优时间复杂度：&lt;span class="math"&gt;\(O(n)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;平均时间复杂度：&lt;span class="math"&gt;\(\Theta (n^2)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;最坏空间复杂度：&lt;span class="math"&gt;\(O(1)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;稳定排序&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;归并排序&lt;/h2&gt;
&lt;p&gt;归并排序（英语：Merge sort，或 mergesort），是创建在归并操作上的一种有效的排序算法，效率为 &lt;span class="math"&gt;\(O(n\log n)\)&lt;/span&gt;。1945年由约翰·冯·诺伊曼首次提出。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;typename&lt;/span&gt; &lt;span class="nt"&gt;Iterator&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;void&lt;/span&gt; &lt;span class="nt"&gt;merge&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;Iterator&lt;/span&gt; &lt;span class="nt"&gt;begin&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;Iterator&lt;/span&gt; &lt;span class="nt"&gt;end&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;Iterator&lt;/span&gt; &lt;span class="nt"&gt;middle&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="err"&gt;typedef&lt;/span&gt; &lt;span class="err"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;iterator_traits&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Iterator&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="n"&gt;value_type&lt;/span&gt;
                &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="err"&gt;//&lt;/span&gt; &lt;span class="err"&gt;迭代器指向对象的值类型&lt;/span&gt;
        &lt;span class="err"&gt;if&lt;/span&gt; &lt;span class="err"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="nf"&gt;distance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kc"&gt;middle&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nf"&gt;distance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kc"&gt;middle&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kc"&gt;end&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                &lt;span class="n"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nf"&gt;result&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kc"&gt;end&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="err"&gt;//暂存结果&lt;/span&gt;
        &lt;span class="err"&gt;auto&lt;/span&gt; &lt;span class="err"&gt;current&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt; &lt;span class="err"&gt;result.begin()&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="err"&gt;auto&lt;/span&gt; &lt;span class="err"&gt;left_current&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt; &lt;span class="err"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="err"&gt;//左侧序列当前比较位置&lt;/span&gt;
        &lt;span class="err"&gt;auto&lt;/span&gt; &lt;span class="err"&gt;right_current&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt; &lt;span class="err"&gt;middle&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="err"&gt;//右序列当前比较位置&lt;/span&gt;
        &lt;span class="err"&gt;while&lt;/span&gt; &lt;span class="err"&gt;(left_current&lt;/span&gt; &lt;span class="err"&gt;!=&lt;/span&gt; &lt;span class="err"&gt;middle&lt;/span&gt; &lt;span class="err"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="err"&gt;right_current&lt;/span&gt; &lt;span class="err"&gt;!=&lt;/span&gt; &lt;span class="err"&gt;end)&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;
                &lt;span class="err"&gt;if&lt;/span&gt; &lt;span class="err"&gt;(*left_current&lt;/span&gt; &lt;span class="err"&gt;&amp;lt;&lt;/span&gt; &lt;span class="err"&gt;*right_current)&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;
                        &lt;span class="err"&gt;*current++&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt; &lt;span class="err"&gt;*left_current++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="err"&gt;//左侧较小&lt;/span&gt;

                &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="nt"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                        &lt;span class="err"&gt;*current++&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt; &lt;span class="err"&gt;*right_current++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="err"&gt;//左侧较小&lt;/span&gt;
                &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="err"&gt;}&lt;/span&gt;
        &lt;span class="nt"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;left_current&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nt"&gt;middle&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="nt"&gt;right_current&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nt"&gt;end&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="nt"&gt;当左侧序列为搬空&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="nf"&gt;copy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;right_current&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kc"&gt;end&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="nt"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;right_current&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nt"&gt;end&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="nt"&gt;left_current&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nt"&gt;middle&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="nt"&gt;当右侧序列搬空&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="nf"&gt;copy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;left_current&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kc"&gt;middle&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="nt"&gt;std&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nd"&gt;copy&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;result&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;begin&lt;/span&gt;&lt;span class="o"&gt;(),&lt;/span&gt; &lt;span class="nt"&gt;result&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;end&lt;/span&gt;&lt;span class="o"&gt;(),&lt;/span&gt;
                  &lt;span class="nt"&gt;begin&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; &lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="nt"&gt;复制回原序列&lt;/span&gt;&lt;span class="err"&gt;，&lt;/span&gt;&lt;span class="nt"&gt;因此是非原地的&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;

&lt;span class="nt"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;typename&lt;/span&gt; &lt;span class="nt"&gt;Iterator&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nt"&gt;void&lt;/span&gt; &lt;span class="nt"&gt;merge_sort&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;Iterator&lt;/span&gt; &lt;span class="nt"&gt;begin&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;Iterator&lt;/span&gt; &lt;span class="nt"&gt;end&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="err"&gt;auto&lt;/span&gt; &lt;span class="err"&gt;size&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="nf"&gt;distance&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kc"&gt;end&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="err"&gt;if&lt;/span&gt; &lt;span class="err"&gt;(size&lt;/span&gt; &lt;span class="err"&gt;&amp;gt;&lt;/span&gt; &lt;span class="err"&gt;1)&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;
                &lt;span class="err"&gt;Iterator&lt;/span&gt; &lt;span class="err"&gt;middle&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt; &lt;span class="err"&gt;begin&lt;/span&gt; &lt;span class="err"&gt;+&lt;/span&gt; &lt;span class="err"&gt;size&lt;/span&gt; &lt;span class="err"&gt;/&lt;/span&gt; &lt;span class="err"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="err"&gt;merge_sort(begin,&lt;/span&gt; &lt;span class="err"&gt;middle)&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="err"&gt;merge_sort(middle,&lt;/span&gt; &lt;span class="err"&gt;end)&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="err"&gt;merge(begin,&lt;/span&gt; &lt;span class="err"&gt;end,&lt;/span&gt; &lt;span class="err"&gt;middle)&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;比较操作的次数介于 &lt;span class="math"&gt;\(\frac{1}{2}n\log n\)&lt;/span&gt; 和 &lt;span class="math"&gt;\(n\log n-n+1\)&lt;/span&gt; 之间。 赋值操作的次数是 &lt;span class="math"&gt;\(2n\log n\)&lt;/span&gt;。归并算法的空间复杂度为：&lt;span class="math"&gt;\(\Theta (n)\)&lt;/span&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最坏时间复杂度：&lt;span class="math"&gt;\(O(n\log n)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;最优时间复杂度：&lt;span class="math"&gt;\(\Omega(n \log n)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;平均时间复杂度：&lt;span class="math"&gt;\(\Theta (n\log n)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;最坏空间复杂度：&lt;span class="math"&gt;\(O(n)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;稳定排序&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;堆排序&lt;/h2&gt;
&lt;p&gt;堆排序（英语：Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。&lt;/p&gt;
&lt;h3&gt;堆节点的访问&lt;/h3&gt;
&lt;p&gt;通常堆是通过一维数组来实现的。在数组起始位置为0的情形中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;父节点 &lt;span class="math"&gt;\(i\)&lt;/span&gt; 的左子节点在位置 &lt;span class="math"&gt;\(2i+1\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;父节点 &lt;span class="math"&gt;\(i\)&lt;/span&gt; 的右子节点在位置 &lt;span class="math"&gt;\(2i+2\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;子节点 &lt;span class="math"&gt;\(i\)&lt;/span&gt; 的父节点在位置 &lt;span class="math"&gt;\(\text{floor}((i-1)/2)\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;堆的操作&lt;/h3&gt;
&lt;p&gt;堆中定义以下几种操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最大堆调整（Max Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点&lt;/li&gt;
&lt;li&gt;创建最大堆（Build Max Heap）：将堆中的所有数据重新排序&lt;/li&gt;
&lt;li&gt;堆排序（HeapSort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="n"&gt;using&lt;/span&gt; &lt;span class="n"&gt;namespace&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;//最大堆调整，i 为要调整节点，n 为最大堆尺寸&lt;/span&gt;
&lt;span class="kr"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;max_heapify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[],&lt;/span&gt; &lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="n"&gt;largest&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="n"&gt;l&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//左孩子&lt;/span&gt;
        &lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//右孩子&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;l&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;largest&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
                &lt;span class="n"&gt;largest&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;largest&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
                &lt;span class="n"&gt;largest&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;largest&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;largest&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
                &lt;span class="n"&gt;heapify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;largest&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;//堆排序&lt;/span&gt;
&lt;span class="kr"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;heapSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[],&lt;/span&gt; &lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;//建堆&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                &lt;span class="n"&gt;max_heapify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="c1"&gt;//排序&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="c1"&gt;//交换堆顶和尾元素&lt;/span&gt;
                &lt;span class="n"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
                &lt;span class="n"&gt;max_heapify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kr"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;printArray&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[],&lt;/span&gt; &lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;11&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;13&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
        &lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kr"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="kr"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
        &lt;span class="n"&gt;heapSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Sorted array is &lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;printArray&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;最坏时间复杂度：&lt;span class="math"&gt;\(O(n\log n)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;最优时间复杂度：&lt;span class="math"&gt;\(O(n\log n)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;平均时间复杂度：&lt;span class="math"&gt;\(\Theta (n\log n)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;最坏空间复杂度：&lt;span class="math"&gt;\(O(1)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;不稳定排序&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;快速排序&lt;/h2&gt;
&lt;p&gt;快速排序（英语：Quicksort），又称划分交换排序（partition-exchange sort），简称快排，一种排序算法，最早由东尼·霍尔提出。在平均状况下，排序 &lt;span class="math"&gt;\(n\)&lt;/span&gt; 个项目要 &lt;span class="math"&gt;\(O(n\log n)\)&lt;/span&gt; 次比较。在最坏状况下则需要 &lt;span class="math"&gt;\(O(n^{2})\)&lt;/span&gt; 次比较，但这种状况并不常见。事实上，快速排序 &lt;span class="math"&gt;\(\Theta (n\log n)\)&lt;/span&gt; 通常明显比其他算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地达成。&lt;/p&gt;
&lt;p&gt;快速排序是二叉查找树（二叉搜索树）的一个空间最优化版本。不是循序地把数据项插入到一个明确的树中，而是由快速排序组织这些数据项到一个由递归调用所隐含的树中。这两个算法完全地产生相同的比较次数，但是顺序不同。对于排序算法的稳定性指标，原地分割版本的快速排序算法是不稳定的。其他变种是可以通过牺牲性能和空间来维护稳定性的。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;typename&lt;/span&gt; &lt;span class="nt"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;void&lt;/span&gt; &lt;span class="nt"&gt;quick_sort_recursive&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;T&lt;/span&gt; &lt;span class="nt"&gt;arr&lt;/span&gt;&lt;span class="cp"&gt;[]&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;int&lt;/span&gt; &lt;span class="nt"&gt;start&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;int&lt;/span&gt; &lt;span class="nt"&gt;end&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="err"&gt;if&lt;/span&gt; &lt;span class="err"&gt;(start&lt;/span&gt; &lt;span class="err"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="err"&gt;end)&lt;/span&gt;
        &lt;span class="err"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="err"&gt;T&lt;/span&gt; &lt;span class="err"&gt;mid&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt; &lt;span class="err"&gt;arr&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;end&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="err"&gt;int&lt;/span&gt; &lt;span class="err"&gt;left&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt; &lt;span class="err"&gt;start,&lt;/span&gt; &lt;span class="err"&gt;right&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt; &lt;span class="err"&gt;end&lt;/span&gt; &lt;span class="err"&gt;-&lt;/span&gt; &lt;span class="err"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="err"&gt;while&lt;/span&gt; &lt;span class="err"&gt;(left&lt;/span&gt; &lt;span class="err"&gt;&amp;lt;&lt;/span&gt; &lt;span class="err"&gt;right)&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt; &lt;span class="err"&gt;//在整个范围内搜寻比枢纽元值小或大的元素，然后将左侧元素与右侧元素交换&lt;/span&gt;
        &lt;span class="err"&gt;while&lt;/span&gt; &lt;span class="err"&gt;(arr&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;left&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt; &lt;span class="err"&gt;&amp;lt;&lt;/span&gt; &lt;span class="err"&gt;mid&lt;/span&gt; &lt;span class="err"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="err"&gt;left&lt;/span&gt; &lt;span class="err"&gt;&amp;lt;&lt;/span&gt; &lt;span class="err"&gt;right)&lt;/span&gt; &lt;span class="err"&gt;//试图在左侧找到一个比枢纽元更大的元素&lt;/span&gt;
            &lt;span class="err"&gt;left++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="err"&gt;while&lt;/span&gt; &lt;span class="err"&gt;(arr&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;right&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt; &lt;span class="err"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="err"&gt;mid&lt;/span&gt; &lt;span class="err"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="err"&gt;left&lt;/span&gt; &lt;span class="err"&gt;&amp;lt;&lt;/span&gt; &lt;span class="err"&gt;right)&lt;/span&gt; &lt;span class="err"&gt;//试图在右侧找到一个比枢纽元更小的元素&lt;/span&gt;
            &lt;span class="err"&gt;right--&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="nf"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;left&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;right&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="err"&gt;//交换元素&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="nt"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;arr&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;left&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="nt"&gt;arr&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;end&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
        &lt;span class="nt"&gt;std&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nd"&gt;swap&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;arr&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;left&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;arr&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;end&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="nt"&gt;else&lt;/span&gt;
        &lt;span class="nt"&gt;left&lt;/span&gt;&lt;span class="o"&gt;++;&lt;/span&gt;
    &lt;span class="nt"&gt;quick_sort_recursive&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;arr&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;start&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;left&lt;/span&gt; &lt;span class="nt"&gt;-&lt;/span&gt; &lt;span class="nt"&gt;1&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
    &lt;span class="nt"&gt;quick_sort_recursive&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;arr&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;left&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="nt"&gt;1&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;end&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="nt"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;typename&lt;/span&gt; &lt;span class="nt"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="nt"&gt;整数或浮点数皆可使用&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt;&lt;span class="nt"&gt;若要使用类时必須定义&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;小于&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;(&amp;lt;)&lt;/span&gt;&lt;span class="err"&gt;、&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;大于&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;(&amp;gt;)&lt;/span&gt;&lt;span class="err"&gt;、&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;不小于&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;(&amp;gt;=)&lt;/span&gt;&lt;span class="nt"&gt;操作&lt;/span&gt;
&lt;span class="nt"&gt;void&lt;/span&gt; &lt;span class="nt"&gt;quick_sort&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;T&lt;/span&gt; &lt;span class="nt"&gt;arr&lt;/span&gt;&lt;span class="cp"&gt;[]&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;int&lt;/span&gt; &lt;span class="nt"&gt;len&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="err"&gt;quick_sort_recursive(arr,&lt;/span&gt; &lt;span class="err"&gt;0,&lt;/span&gt; &lt;span class="err"&gt;len&lt;/span&gt; &lt;span class="err"&gt;-&lt;/span&gt; &lt;span class="err"&gt;1)&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;随机算法&lt;/h3&gt;
&lt;p&gt;当划分产生的两个子问题分别包含 &lt;span class="math"&gt;\(n-1\)&lt;/span&gt; 和0个元素时，最坏情况发生。划分操作的时间复杂度为 &lt;span class="math"&gt;\(\Theta(n)\)&lt;/span&gt;，&lt;span class="math"&gt;\(T(0)=\Theta(1)\)&lt;/span&gt;，这时算法运行时间的递归式为：&lt;span class="math"&gt;\(T(n) = T(n-1) + T(0) + \Theta(n) = T(n-1) + \Theta(n)\)&lt;/span&gt;，解为 &lt;span class="math"&gt;\(T(n) = \Theta(n^2)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;当划分产生的两个子问题分别包含 &lt;span class="math"&gt;\(\lfloor n/2 \rfloor\)&lt;/span&gt; 和 &lt;span class="math"&gt;\(\lceil n/2 \rceil-1\)&lt;/span&gt; 个元素时，最好情况发生。算法运行时间递归式为：&lt;span class="math"&gt;\(T(n) = 2T(n/2) + \Theta(n)\)&lt;/span&gt;，解为 &lt;span class="math"&gt;\(T(n) = \Theta(n\lg n)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;可以通过在算法中引入随机性，使得算法对所有输入都能获得较好的期望性能。随机算法保证了对任何的输入而言，都可以保证 &lt;span class="math"&gt;\(\Theta (n\lg n)\)&lt;/span&gt; 的时间复杂度。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;void&lt;/span&gt; &lt;span class="nt"&gt;rand_quick_sort&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;T&lt;/span&gt; &lt;span class="nt"&gt;arr&lt;/span&gt;&lt;span class="cp"&gt;[]&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;int&lt;/span&gt; &lt;span class="nt"&gt;begin&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;int&lt;/span&gt; &lt;span class="nt"&gt;end&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="err"&gt;if&lt;/span&gt; &lt;span class="err"&gt;(end-begin&lt;/span&gt; &lt;span class="err"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="err"&gt;1)&lt;/span&gt;
        &lt;span class="err"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="err"&gt;int&lt;/span&gt; &lt;span class="err"&gt;pindex&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt; &lt;span class="err"&gt;rand()&lt;/span&gt; &lt;span class="err"&gt;%&lt;/span&gt; &lt;span class="err"&gt;(end-begin)&lt;/span&gt; &lt;span class="err"&gt;+&lt;/span&gt; &lt;span class="err"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="nf"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;end&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;pindex&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="err"&gt;quick_sort(arr,&lt;/span&gt; &lt;span class="err"&gt;end&lt;/span&gt; &lt;span class="err"&gt;-&lt;/span&gt; &lt;span class="err"&gt;begin&lt;/span&gt; &lt;span class="err"&gt;+&lt;/span&gt; &lt;span class="err"&gt;1)&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;最坏时间复杂度：&lt;span class="math"&gt;\(\Theta(n^2)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;最优时间复杂度：&lt;span class="math"&gt;\(\Theta(n\log n)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;平均时间复杂度：&lt;span class="math"&gt;\(\Theta (n\log n)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;空间复杂度：&lt;span class="math"&gt;\(O(\log n)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;不稳定排序&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;计数排序&lt;/h2&gt;
&lt;p&gt;计数排序（Counting sort）是一种稳定的线性时间排序算法。计数排序使用一个额外的数组 &lt;span class="math"&gt;\(C\)&lt;/span&gt; ，其中第 &lt;span class="math"&gt;\(i\)&lt;/span&gt; 个元素是待排序数组 &lt;span class="math"&gt;\(A\)&lt;/span&gt; 中值等于 &lt;span class="math"&gt;\(i\)&lt;/span&gt; 的元素的个数。然后根据数组 &lt;span class="math"&gt;\(C\)&lt;/span&gt; 来将 &lt;span class="math"&gt;\(A\)&lt;/span&gt; 中的元素排到正确的位置。&lt;/p&gt;
&lt;p&gt;当输入的元素是 &lt;span class="math"&gt;\(n\)&lt;/span&gt; 个 &lt;span class="math"&gt;\([0,k]\)&lt;/span&gt; 之间的整数时，它的运行时间是 &lt;span class="math"&gt;\(\Theta (n+k)\)&lt;/span&gt;。计数排序不是比较排序，排序的速度快于任何比较排序算法。&lt;/p&gt;
&lt;p&gt;由于用来计数的数组 &lt;span class="math"&gt;\(C\)&lt;/span&gt; 的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。例如：计数排序是用来排序0到100之间的数字的最好的算法，但是它不适合按字母顺序排序人名。但是，计数排序可以用在基数排序算法中，能够更有效的排序数据范围很大的数组。&lt;/p&gt;
&lt;p&gt;当原数组有重复数据时，为保证稳定排序，最后要反向填充目标数组，以及将每个数字的统计减去1。&lt;/p&gt;
&lt;h3&gt;步骤&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;找出待排序的数组中最大和最小的元素&lt;/li&gt;
&lt;li&gt;统计数组中每个值为 &lt;span class="math"&gt;\(i\)&lt;/span&gt; 的元素出现的次数，存入数组 &lt;span class="math"&gt;\(C\)&lt;/span&gt; 的第 &lt;span class="math"&gt;\(i\)&lt;/span&gt; 项&lt;/li&gt;
&lt;li&gt;对所有的计数累加（从 &lt;span class="math"&gt;\(C\)&lt;/span&gt; 中的第一个元素开始，每一项和前一项相加）&lt;/li&gt;
&lt;li&gt;反向填充目标数组：将每个元素 &lt;span class="math"&gt;\(i\)&lt;/span&gt; 放在新数组的第 &lt;span class="math"&gt;\(C[i]\)&lt;/span&gt; 项，每放一个元素就将 &lt;span class="math"&gt;\(C[i]\)&lt;/span&gt; 减去1&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;time.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;vector&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="n"&gt;using&lt;/span&gt; &lt;span class="n"&gt;namespace&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kr"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Counting_sort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[],&lt;/span&gt; &lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;//申请额外空间&lt;/span&gt;
        &lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;B&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="kr"&gt;int&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="kr"&gt;int&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//将 C 指向的数组所有元素置0&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="c1"&gt;//保存数组 A 中每个元素出现的个数&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="c1"&gt;//将所有计数次数累加&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="c1"&gt;//将元素重新输入&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="c1"&gt;//次数大小最小为1、数组开始为0&lt;/span&gt;
                &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
                &lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="c1"&gt;//不要忘了释放分配的空间&lt;/span&gt;
        &lt;span class="kr"&gt;delete&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kr"&gt;delete&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kr"&gt;char&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;56&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;56&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;59&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;
        &lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;max&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nf"&gt;max&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                        &lt;span class="nf"&gt;max&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
                &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="n"&gt;Counting_sort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nf"&gt;max&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;最坏时间复杂度 &lt;span class="math"&gt;\(O(n+k)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;最优时间复杂度 &lt;span class="math"&gt;\(O(n+k)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;平均时间复杂度 &lt;span class="math"&gt;\(O(n+k)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;最坏空间复杂度 &lt;span class="math"&gt;\(O(n+k)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;稳定排序&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;基数排序&lt;/h2&gt;
&lt;p&gt;基数排序（英语：Radix sort）是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。&lt;/p&gt;
&lt;p&gt;它是这样实现的：将所有待比较数值（正整数）统一为同样的数字长度，数字较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。&lt;/p&gt;
&lt;p&gt;基数排序的时间复杂度是 &lt;span class="math"&gt;\(O(k\cdot n)\)&lt;/span&gt;，其中 &lt;span class="math"&gt;\(n\)&lt;/span&gt; 是排序元素个数，&lt;span class="math"&gt;\(k\)&lt;/span&gt; 是数字位数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最坏时间复杂度 &lt;span class="math"&gt;\(O(k\cdot n)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;最坏时间复杂度 &lt;span class="math"&gt;\(O(n^2)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;最坏空间复杂度 &lt;span class="math"&gt;\(O(k+n)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;稳定排序&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int maxbit(int data[], int n) //辅助函数，求数据的最大位数
{
        int maxData = data[0]; ///&amp;lt; 最大数
        /// 先求出最大数，再求其位数
        for (int i = 1; i &amp;lt; n; ++i) {
                if (maxData &amp;lt; data[i])
                        maxData = data[i];
        }
        int d = 1;
        int p = 10;
        while (maxData &amp;gt;= p) {
                maxData /= 10;
                ++d;
        }
        return d;
}
void radixsort(int data[], int n) //基数排序
{
        int d = maxbit(data, n);
        int *tmp = new int[n];
        int *count = new int[10]; //计数器
        int i, j, k;
        int radix = 1;
        for (i = 1; i &amp;lt;= d; i++) //进行 d 次排序
        {
                //每一次都是计数排序
                for (j = 0; j &amp;lt; 10; j++)
                        count[j] = 0; //每次分配前清空计数器
                for (j = 0; j &amp;lt; n; j++) {
                        k = (data[j] / radix) % 10; //统计每个桶中的记录数
                        count[k]++;
                }
                for (j = 1; j &amp;lt; 10; j++)
                        count[j] = count[j - 1] + count[j]; //将tmp中的位置依次分配给每个桶
                for (j = n - 1; j &amp;gt;= 0; j--) //将所有桶中记录依次收集到tmp中
                {
                        k = (data[j] / radix) % 10;
                        tmp[count[k] - 1] = data[j];
                        count[k]--;
                }
                for (j = 0; j &amp;lt; n; j++) //将临时数组的内容复制到data中
                        data[j] = tmp[j];
                radix = radix * 10;
        }
        delete[] tmp;
        delete[] count;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;桶排序&lt;/h2&gt;
&lt;p&gt;桶排序（Bucket sort）或所谓的箱排序，是一个排序算法，工作的原理是将数组分到有限数量的桶里。每个桶再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。桶排序是鸽巢排序的一种归纳结果。当要被排序的数组内的数值是均匀分配的时候，桶排序使用线性时间 &lt;span class="math"&gt;\(\Theta (n)\)&lt;/span&gt;。桶排序不是比较排序。&lt;/p&gt;
&lt;h3&gt;步骤&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;设置一个定量的数组当作空桶子&lt;/li&gt;
&lt;li&gt;寻访序列，并且把项目一个一个放到对应的桶子去&lt;/li&gt;
&lt;li&gt;对每个不是空的桶子进行排序&lt;/li&gt;
&lt;li&gt;从不是空的桶子里把项目再放回原来的序列中&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;实现&lt;/h3&gt;
&lt;p&gt;转自：&lt;a href="https://blog.csdn.net/misayaaaaa/article/details/66969486"&gt;https://blog.csdn.net/misayaaaaa/article/details/66969486&lt;/a&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;cstdlib&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;vector&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;

&lt;span class="n"&gt;using&lt;/span&gt; &lt;span class="n"&gt;namespace&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kr"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Bucket_sort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;double&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[],&lt;/span&gt; &lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kr"&gt;double&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="kr"&gt;double&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt; &lt;span class="c1"&gt;// p数组存放十个double指针，分为10个桶&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="kr"&gt;double&lt;/span&gt;
                       &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt; &lt;span class="c1"&gt;//每个指针都指向一块10个double的数组，每个桶都可以包含100个元素&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt; &lt;span class="c1"&gt;//元素全为0的数组&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="kr"&gt;double&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
                &lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="n"&gt;flag&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;temp&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;//判断每个元素属于哪个桶&lt;/span&gt;
                &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;flag&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;flag&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//将每个元素放入到对应的桶中，从0开始&lt;/span&gt;
                &lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;flag&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//将对应桶的计数加1&lt;/span&gt;

                &lt;span class="c1"&gt;//在本桶之中与之前的元素做比较，比较替换（插入排序）&lt;/span&gt;
                &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;flag&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                        &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;flag&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;flag&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
                &lt;span class="p"&gt;}&lt;/span&gt;
                &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;flag&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;temp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="c1"&gt;//元素全部放完之后，需要进行重新链接的过程&lt;/span&gt;
        &lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;j&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="c1"&gt;//桶中元素的个数count[i]&lt;/span&gt;
                &lt;span class="p"&gt;{&lt;/span&gt;
                        &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;][&lt;/span&gt;&lt;span class="n"&gt;j&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
                &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="c1"&gt;//申请内存的释放&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="kr"&gt;delete&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
                &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="kr"&gt;delete&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;//随机初始化数组[0,1)&lt;/span&gt;
&lt;span class="kr"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Initial_array&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;double&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[],&lt;/span&gt; &lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;rand&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;static_cast&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kr"&gt;double&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;RAND_MAX&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kr"&gt;char&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kr"&gt;double&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="n"&gt;Initial_array&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="n"&gt;Bucket_sort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;时间复杂度为 &lt;span class="math"&gt;\(O(n)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;空间复杂度为 &lt;span class="math"&gt;\(O(n+M)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;稳定排序&lt;/li&gt;
&lt;/ul&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content><category term="算法"></category></entry><entry><title>C++ Primer 第十七章 标准库特殊设施</title><link href="https://xutree.github.io/pages/2018/10/21/C++_Primer_Chapter_17/" rel="alternate"></link><published>2018-10-21T17:04:34+08:00</published><updated>2018-10-21T17:04:34+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-21:/pages/2018/10/21/C++_Primer_Chapter_17/</id><summary type="html">&lt;h2&gt;tuple 类型&lt;/h2&gt;
&lt;p&gt;当我们希望将一些数据组合成单一对象，但又不想麻烦地定义一个新数据结构来表示这些数据时，可以使用&lt;code&gt;tuple&lt;/code&gt;类型。与&lt;code&gt;pair&lt;/code&gt;类似，但&lt;code&gt;tuple&lt;/code&gt;可以有任意数量的成员。它的一个常见用途就是从一个函数返回多个值。&lt;code&gt;tuple&lt;/code&gt;定义在同名的头文件中。&lt;/p&gt;
&lt;p&gt;支持的操作：&lt;/p&gt;
&lt;p&gt;&lt;img alt="tuple支持的操作" src="https://xutree.github.io/images/c++17-1.jpg"&gt;&lt;/p&gt;
&lt;p&gt;要访问一个&lt;code&gt;tuple&lt;/code&gt;的成员，使用&lt;code&gt;get&lt;/code&gt;标准库模板。为了使用&lt;code&gt;get&lt;/code&gt;，我们必须指定一个显式模板参数，它指明我们想要访问第几个成员。这个显式模板参数必须是一个整型常量表达式，从0开始计数，返回指定成员的引用。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;auto book = get&amp;lt;0&amp;gt;(item);  // 返回 item 的第一个成员
get&amp;lt;0&amp;gt;(item) *= 0.8;       // 修改书的单价
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;借助辅助类模板&lt;code&gt;tuple_size&lt;/code&gt;和&lt;code&gt;tuple_element&lt;/code&gt;，可以查询&lt;code&gt;tuple …&lt;/code&gt;&lt;/p&gt;</summary><content type="html">&lt;h2&gt;tuple 类型&lt;/h2&gt;
&lt;p&gt;当我们希望将一些数据组合成单一对象，但又不想麻烦地定义一个新数据结构来表示这些数据时，可以使用&lt;code&gt;tuple&lt;/code&gt;类型。与&lt;code&gt;pair&lt;/code&gt;类似，但&lt;code&gt;tuple&lt;/code&gt;可以有任意数量的成员。它的一个常见用途就是从一个函数返回多个值。&lt;code&gt;tuple&lt;/code&gt;定义在同名的头文件中。&lt;/p&gt;
&lt;p&gt;支持的操作：&lt;/p&gt;
&lt;p&gt;&lt;img alt="tuple支持的操作" src="https://xutree.github.io/images/c++17-1.jpg"&gt;&lt;/p&gt;
&lt;p&gt;要访问一个&lt;code&gt;tuple&lt;/code&gt;的成员，使用&lt;code&gt;get&lt;/code&gt;标准库模板。为了使用&lt;code&gt;get&lt;/code&gt;，我们必须指定一个显式模板参数，它指明我们想要访问第几个成员。这个显式模板参数必须是一个整型常量表达式，从0开始计数，返回指定成员的引用。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;auto book = get&amp;lt;0&amp;gt;(item);  // 返回 item 的第一个成员
get&amp;lt;0&amp;gt;(item) *= 0.8;       // 修改书的单价
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;借助辅助类模板&lt;code&gt;tuple_size&lt;/code&gt;和&lt;code&gt;tuple_element&lt;/code&gt;，可以查询&lt;code&gt;tuple&lt;/code&gt;成员的数量和类型。不过使用这两个类，必须知道 &lt;code&gt;tuple&lt;/code&gt;对象的类型，这可以通过&lt;code&gt;decltype&lt;/code&gt;很简单地得到：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;typedef decltype(item) trans;
// 返回 trans 类型对象中成员的数量
size_t sz = tuple_size&amp;lt;trans&amp;gt;::value;  // 返回 3
// cnt 的类型与 item 中第二个成员相同，是一个 int
tuple_element&amp;lt;1, trans&amp;gt;::type cnt = get&amp;lt;1&amp;gt;(item);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;只有两个&lt;code&gt;tuple&lt;/code&gt;具有相同数量的成员，且每对成员使用&lt;code&gt;==&lt;/code&gt;或&lt;code&gt;&amp;lt;&lt;/code&gt;是合法时，才能比较两个&lt;code&gt;tuple&lt;/code&gt;。另外，由于&lt;code&gt;tuple&lt;/code&gt;定义了&lt;code&gt;&amp;lt;&lt;/code&gt;和&lt;code&gt;==&lt;/code&gt;运算符，可以将&lt;code&gt;tuple&lt;/code&gt;序列传递给算法，并且可以在无序容器中将&lt;code&gt;tuple&lt;/code&gt;作为关键字类型。&lt;/p&gt;
&lt;h2&gt;bitset 类型&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;bitset&lt;/code&gt;类，可以方便地将整型运算对象当作二进制位集合处理，并且能够处理超过最长整型类型大小的位集合。&lt;code&gt;bitset&lt;/code&gt;定义在同名的头文件中。&lt;/p&gt;
&lt;p&gt;支持的操作：&lt;/p&gt;
&lt;p&gt;&lt;img alt="bitset支持的操作" src="https://xutree.github.io/images/c++17-2.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用字符串初始化&lt;code&gt;bitset&lt;/code&gt;时，下标最小的字符对应&lt;code&gt;bitset&lt;/code&gt;中的高位。&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;bitset&amp;lt;32&amp;gt; bitvec4(&amp;quot;1100&amp;quot;);   // 2、3两位为1，剩余位为0
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img alt="bitset支持的操作" src="https://xutree.github.io/images/c++17-3.jpg"&gt;&lt;/p&gt;
&lt;h2&gt;正则表达式&lt;/h2&gt;
&lt;p&gt;RE 库定义在头文件&lt;code&gt;regex&lt;/code&gt;中。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;组件&lt;/th&gt;
&lt;th align="left"&gt;意义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;regex&lt;/td&gt;
&lt;td align="left"&gt;表示有一个正则表达式的类&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;regex_match&lt;/td&gt;
&lt;td align="left"&gt;将一个字符序列与一个正则表达式匹配，整串匹配返回&lt;code&gt;true&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;regex_search&lt;/td&gt;
&lt;td align="left"&gt;寻找第一个与正则表达式匹配的子序列，有子串匹配，返回&lt;code&gt;true&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;regex_replace&lt;/td&gt;
&lt;td align="left"&gt;使用给定格式替换一个正则表达式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;regex_iterator&lt;/td&gt;
&lt;td align="left"&gt;迭代器适配器，调用&lt;code&gt;regex_search&lt;/code&gt;来遍历一个&lt;code&gt;string&lt;/code&gt;中所有匹配的子串&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;smatch&lt;/td&gt;
&lt;td align="left"&gt;容器类，保存&lt;code&gt;string&lt;/code&gt;中搜索的结果&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;ssub_match&lt;/td&gt;
&lt;td align="left"&gt;&lt;code&gt;string&lt;/code&gt;中匹配的子表达式的结果&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;regex_search&lt;/code&gt;和&lt;code&gt;regex_search&lt;/code&gt;的参数如下，这些操作都返回&lt;code&gt;bool&lt;/code&gt;，指出是否找到匹配：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;(seq, m, r, mft)&lt;/code&gt;或&lt;code&gt;(seq, r, mft)&lt;/code&gt;：在字符序列 seq 中查找 regex 对象 r 中的正则表达式。seq 可以是一个&lt;code&gt;string&lt;/code&gt;、表示范围的一对迭代器以及一个指向空字符结尾的字符数组的指针。m 是一个&lt;code&gt;match&lt;/code&gt;对象，用来保存匹配结果的相关细节。m 和 seq 必须具有兼容的类型。mft 是一个可选的&lt;code&gt;regex_constants::match_flag_type&lt;/code&gt;值，它们会影响匹配过程。&lt;/p&gt;
&lt;p&gt;待续...&lt;/p&gt;</content><category term="C++"></category></entry><entry><title>C++ Primer 第十六章 模板与泛型编程</title><link href="https://xutree.github.io/pages/2018/10/21/C++_Primer_Chapter_16/" rel="alternate"></link><published>2018-10-21T10:23:30+08:00</published><updated>2018-10-21T13:39:16+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-21:/pages/2018/10/21/C++_Primer_Chapter_16/</id><summary type="html">&lt;p&gt;面向对象编程（OOP）和泛型编程都能处理在编写程序时不知道类型的情况。不同之处是：OOP能处理类型在程序运行之前都未知的情况；而在泛型编程中，在编译时就能获知类型了。&lt;/p&gt;
&lt;p&gt;容器、迭代器和算法都是泛型编程的例子。模板是 C++ 中泛型编程的基础。一个模板就是一个创建类或函数的蓝图或者说公式。&lt;/p&gt;
&lt;h2&gt;定义模板&lt;/h2&gt;
&lt;h3&gt;函数模板&lt;/h3&gt;
&lt;p&gt;模板的定义以关键字&lt;code&gt;template&lt;/code&gt;开始，后面跟一个模板参数列表，用&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;括起来。&lt;/p&gt;
&lt;p&gt;模板有类型参数（type parameter）和非类型参数（nontype parameter）之分。&lt;/p&gt;
&lt;h4&gt;类型参数&lt;/h4&gt;
&lt;p&gt;我们可以将类型参数看作类型说明符，就像内置类型或类类型说明符一样使用。&lt;/p&gt;
&lt;p&gt;类型参数可以用来指定返回类型或函数的参数类型，以及在函数体内用于变量声明或类型转换。&lt;/p&gt;
&lt;p&gt;参数列表中，类型参数前必须使用关键字&lt;code&gt;class&lt;/code&gt;或&lt;code&gt;typename&lt;/code&gt;。在模板定义中，模板参数列表不能为空。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;// 错误，U 之前必须加上 class 或 typename
template &amp;lt;typename T, U …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;面向对象编程（OOP）和泛型编程都能处理在编写程序时不知道类型的情况。不同之处是：OOP能处理类型在程序运行之前都未知的情况；而在泛型编程中，在编译时就能获知类型了。&lt;/p&gt;
&lt;p&gt;容器、迭代器和算法都是泛型编程的例子。模板是 C++ 中泛型编程的基础。一个模板就是一个创建类或函数的蓝图或者说公式。&lt;/p&gt;
&lt;h2&gt;定义模板&lt;/h2&gt;
&lt;h3&gt;函数模板&lt;/h3&gt;
&lt;p&gt;模板的定义以关键字&lt;code&gt;template&lt;/code&gt;开始，后面跟一个模板参数列表，用&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;括起来。&lt;/p&gt;
&lt;p&gt;模板有类型参数（type parameter）和非类型参数（nontype parameter）之分。&lt;/p&gt;
&lt;h4&gt;类型参数&lt;/h4&gt;
&lt;p&gt;我们可以将类型参数看作类型说明符，就像内置类型或类类型说明符一样使用。&lt;/p&gt;
&lt;p&gt;类型参数可以用来指定返回类型或函数的参数类型，以及在函数体内用于变量声明或类型转换。&lt;/p&gt;
&lt;p&gt;参数列表中，类型参数前必须使用关键字&lt;code&gt;class&lt;/code&gt;或&lt;code&gt;typename&lt;/code&gt;。在模板定义中，模板参数列表不能为空。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;// 错误，U 之前必须加上 class 或 typename
template &amp;lt;typename T, U&amp;gt;
T calc(const T&amp;amp;, const U&amp;amp;);
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;非类型参数&lt;/h4&gt;
&lt;p&gt;除了定义类型参数，还可以在模板中定义非类型参数，通过一个特定的类型名而非关键字&lt;code&gt;class&lt;/code&gt;或&lt;code&gt;typename&lt;/code&gt;来指定非类型参数。&lt;/p&gt;
&lt;p&gt;因为编译器需要在编译时实例化模板，此时非类型参数会被一个用户提供的或编译器推断出的值所代替，所以这些值必须是常量表达式。&lt;/p&gt;
&lt;p&gt;非类型参数可以是一个整型，对应的模板实参必须是常量表达式。而在模板定义内，可以将这个非类型参数用在任何需要常量表达式的地方，如指定数组大小。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;template &amp;lt;unsigned N, unsigned M&amp;gt;
int compare(const cahr (&amp;amp;p1)[N], const cahr (&amp;amp;p2)[M])
[
   return strcmp(p1, p2);
}
compare(&amp;quot;hi&amp;quot;, &amp;quot;mom&amp;quot;);
// 上式调用会实例化处如下版本，注意字符串字面常量的末尾有一个空字符！
int compare(const cahr (&amp;amp;p1)[3], const cahr (&amp;amp;p2)[4])
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;也可以是一个指向对象或函数类型的指针或（左值）引用。绑定到指针或引用非类型参数的实参必须具有静态的生存期。&lt;/p&gt;
&lt;h4&gt;inline 和 constexpr 的函数模板&lt;/h4&gt;
&lt;p&gt;函数模板可以声明为&lt;code&gt;inline&lt;/code&gt;或&lt;code&gt;constexpr&lt;/code&gt;的，如同非模板函数一样。&lt;code&gt;inline&lt;/code&gt;或&lt;code&gt;constexpr&lt;/code&gt;说明符放在模板参数列表之后，返回类型之前：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//正确，inline 说明符跟在模板参数列表之后
template &amp;lt;typename T&amp;gt; inline T min(const T&amp;amp;, const T&amp;amp;);
//错误：inline 说明符的位置不正确
inline template &amp;lt;typename T&amp;gt; T min(const T&amp;amp;, const T&amp;amp;);
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;编写类型无关的代码&lt;/h4&gt;
&lt;p&gt;为了提高适用性，模板程序应尽量减少对实参类型的要求。&lt;/p&gt;
&lt;p&gt;模板中的函数参数是&lt;code&gt;const&lt;/code&gt;的引用。这样做一方面保证了即使参数类型不支持拷贝，模板程序也能正确运行；另一方面引用不会引起对象的拷贝构造，提高运行性能。&lt;/p&gt;
&lt;p&gt;模板中使用到的类型相关的函数或运算符应尽可能的少。&lt;/p&gt;
&lt;h4&gt;模板编译&lt;/h4&gt;
&lt;p&gt;当编译器遇到一个模板定义时，它并不生成代码。只有当我们实例化出模板的一个特定版本时，编译器才会生成代码。&lt;/p&gt;
&lt;p&gt;通常，当我们调用一个函数时，编译器只需要掌握函数的声明。类似的，当我们使用一个类类型的对象时，类定义必须是可用的，但成员函数的定义不必已经出现。因此，我们将类定义和函数声明放在头文件中，而普通函数和类的成员函数的定义放在源文件中。&lt;/p&gt;
&lt;p&gt;为了生成一个实例化版本，编译器需要掌握函数模板或类模板成员函数的定义。因此，与非模板代码不同，模板不能分离式编译，其头文件中通常既包括声明也包括定义。&lt;/p&gt;
&lt;h4&gt;大多数编译错误在实例化期间报告&lt;/h4&gt;
&lt;p&gt;模板直到实例化时才会生成代码，大多数编译错误在实例化期间报告。通常，编译器会在三个阶段报告错误。&lt;/p&gt;
&lt;p&gt;第一个阶段是编译模板本身时。这个阶段，编译器可以检查语法错误，如忘记分号或者变量名拼错等。&lt;/p&gt;
&lt;p&gt;第二个阶段是编译器遇到模板使用时。对于函数模板调用，会检查实参数目是否正确和参数类型是否匹配。对于类模板，则只检查模板实参数目是否正确。&lt;/p&gt;
&lt;p&gt;第三个阶段是模板实例化时，只有这个阶段才能发现类型相关的错误。依赖于编译器如何管理实例化，这类错误可能在链接时才报告。&lt;/p&gt;
&lt;h3&gt;类模板&lt;/h3&gt;
&lt;p&gt;类模板（class template）是用来生成类的蓝图的。与函数模板的不同之处是，编译器不能为类模板推断模板参数类型。使用时，必须显式提供模板实参。&lt;/p&gt;
&lt;h4&gt;定义类模板&lt;/h4&gt;
&lt;p&gt;在类模板（及其成员）的定义中，我们将模板参数当做替身，代替使用模板时用户需要提供的类型或值：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;typename&lt;/span&gt; &lt;span class="nx"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;Bolb&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="kr"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="nx"&gt;typedef&lt;/span&gt; &lt;span class="nx"&gt;T&lt;/span&gt; &lt;span class="nx"&gt;value_type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nx"&gt;typedef&lt;/span&gt; &lt;span class="nx"&gt;typename&lt;/span&gt; &lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="nx"&gt;size_type&lt;/span&gt; &lt;span class="nx"&gt;size_type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="c1"&gt;//构造函数&lt;/span&gt;
    &lt;span class="nx"&gt;Bolb&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="nx"&gt;Bolb&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;initializer_list&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nx"&gt;il&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="c1"&gt;//Bolb中的元素数目&lt;/span&gt;
    &lt;span class="nx"&gt;size_type&lt;/span&gt; &lt;span class="nx"&gt;size&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;data&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="nx"&gt;size&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="nx"&gt;empty&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;data&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="nx"&gt;empty&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="c1"&gt;//添加和删除元素&lt;/span&gt;
    &lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="nx"&gt;push_back&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;T&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nx"&gt;data&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="nx"&gt;push_back&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;t&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="c1"&gt;//移动版本&lt;/span&gt;
    &lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="nx"&gt;push_back&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;T&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nx"&gt;data&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="nx"&gt;push_back&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;move&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;t&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="nx"&gt;pop_back&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="c1"&gt;//元素访问&lt;/span&gt;
    &lt;span class="nx"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="nx"&gt;back&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="nx"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="nx"&gt;operator&lt;/span&gt;&lt;span class="p"&gt;[](&lt;/span&gt;&lt;span class="nx"&gt;size_type&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="kr"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;shared_ptr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="nx"&gt;data&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="c1"&gt;//若data[i]无效，则抛出msg&lt;/span&gt;
    &lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="nx"&gt;check&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;size_type&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;const&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;实例化模板&lt;/h4&gt;
&lt;p&gt;当使用一个类模板时，我们必须提供额外信息。我们现在知道这些额外信息是显式模板实参（explicit template argument）列表，它们被绑定到模板参数。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Bolb&amp;lt;int&amp;gt; ia;   //空 Bolb&amp;lt;int&amp;gt;
Bolb&amp;lt;int&amp;gt; ia2 = {0,1,2,3,4};    //有5个元素的 Bolb&amp;lt;int&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;一个类模板的每个实例都形成一个独立的类。Bolb&lt;string&gt; 与任何其他 Bolb 类型没有关联，也不会对任何其他 Bolb 类型的成员有特殊访问权限。&lt;/p&gt;
&lt;h4&gt;类模板的成员函数&lt;/h4&gt;
&lt;p&gt;我们既可以在类模板内部，也可以在外部为其定义成员函数。定义在类模板之外的成员函数必须以关键字&lt;code&gt;template&lt;/code&gt;开始，后接类模板参数列表。&lt;/p&gt;
&lt;p&gt;默认情况下，一个类模板的成员函数只有当程序用到它时才进行实例化。这一特性使得即使某种类型不能完全符合模板操作的要求，仍然能用该类型实例化类，但相应操作无法使用！&lt;/p&gt;
&lt;h4&gt;在类代码内简化模板类型的使用&lt;/h4&gt;
&lt;p&gt;在类模板自己的作用域中，我们可以直接使用模板名而不提供实参，其他情况下都必须提供模板实参。：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;typename&lt;/span&gt; &lt;span class="nx"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;BolbPtr&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="kr"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="c1"&gt;//递增和递减&lt;/span&gt;
&lt;span class="nx"&gt;BolbPtr&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="nx"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  &lt;span class="c1"&gt;//前置运算符&lt;/span&gt;
&lt;span class="nx"&gt;BolbPtr&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="nx"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上述 BolbPtr 的前置递增和递减成员返回 BolbPtr&amp;amp;，而不是 BolbPtr&lt;T&gt;&amp;amp;。当我们处于一个类模板的作用域时，编译器处理模板自身引用时就好像我们已经提供了与模板参数匹配的实参一样。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;template &amp;lt;typename T&amp;gt;
// 返回类型，处于类的作用域之外，需要提供模板实参
BlobPtr&amp;lt;T&amp;gt; BlobPtr&amp;lt;T&amp;gt;::operator++(int)
{
   // 函数体内，处于类的作用域之内
   BlobPtr ret = *this;
   ...
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;类模板和友元&lt;/h4&gt;
&lt;p&gt;如果一个类模板包含一个非模板友元，则友元被授权可以访问所有模板实例；如果友元自身是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例。&lt;/p&gt;
&lt;p&gt;一对一友好关系。用相同模板实参实例化的友元是该类的友元，可以访问非&lt;code&gt;public&lt;/code&gt;部分，而对于用其他实参实例化的实例则没有特殊访问权限。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// 为了在 Blob 中声明友元，需要前置声明&lt;/span&gt;
&lt;span class="nx"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;typename&lt;/span&gt; &lt;span class="nx"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;BlobPtr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nx"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;typename&lt;/span&gt; &lt;span class="nx"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;Blob&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="c1"&gt;// 声明运算符 == 中的参数所需要的&lt;/span&gt;
&lt;span class="nx"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;typename&lt;/span&gt; &lt;span class="nx"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
  &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="nx"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;Blob&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;lhs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;Blob&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="nx"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;typename&lt;/span&gt; &lt;span class="nx"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;Blob&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
   &lt;span class="c1"&gt;// 每个 Blob 实例将访问权限授予用相同类型实例化的 BlobPtr 和相等运算符&lt;/span&gt;
   &lt;span class="nx"&gt;friend&lt;/span&gt; &lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;BlobPtr&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
   &lt;span class="nx"&gt;friend&lt;/span&gt; &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="nx"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;==&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;MyBlobPtr&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;lhs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;MyBlobPtr&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
   &lt;span class="c1"&gt;// 其它成员定义&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="c1"&gt;// BlobPtr&amp;lt;char&amp;gt; 的成员可以访问 ca（或任何其它 Blob&amp;lt;char&amp;gt;对象）的非 public 部分&lt;/span&gt;
&lt;span class="nx"&gt;Blob&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kr"&gt;char&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nx"&gt;ca&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nx"&gt;Blob&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kr"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nx"&gt;ia&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;通用和特定的模板友好关系。为了让所有实例成为友元，友元声明中必须使用与类模板本身不同的模板参数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// 前置声明，在将模板的一个特定实例声明为友元时要用到&lt;/span&gt;
&lt;span class="nx"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;typename&lt;/span&gt; &lt;span class="nx"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;Pal&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;C&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;   &lt;span class="c1"&gt;// C是一个普通的非模板类&lt;/span&gt;
   &lt;span class="nx"&gt;friend&lt;/span&gt; &lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;Pal&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;C&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="c1"&gt;// 用类 C 实例化的 Pal 是 C 的一个友元&lt;/span&gt;
   &lt;span class="c1"&gt;// Pal2 的所有实例都是 C 的友元，这种情况无须前置声明&lt;/span&gt;
   &lt;span class="nx"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;typename&lt;/span&gt; &lt;span class="nx"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nx"&gt;friend&lt;/span&gt; &lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;Pal2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="nx"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;typename&lt;/span&gt; &lt;span class="nx"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;C2&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;  &lt;span class="c1"&gt;// C2 本身是一个模板&lt;/span&gt;
   &lt;span class="c1"&gt;// C2 的每个实例将相同实例化的 Pal 声明为友元&lt;/span&gt;
   &lt;span class="nx"&gt;friend&lt;/span&gt; &lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;Pal&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="c1"&gt;// Pal 的模板声明必须在作用域之内&lt;/span&gt;
   &lt;span class="c1"&gt;// Pal2 的所有实例都是 C2 的每个实例的友元，不需要前置声明&lt;/span&gt;
   &lt;span class="nx"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;typename&lt;/span&gt; &lt;span class="nx"&gt;X&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nx"&gt;friend&lt;/span&gt; &lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;Pal2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
   &lt;span class="c1"&gt;// Pal3 是一个非模板类，它是 C2 所有实例的友元&lt;/span&gt;
   &lt;span class="nx"&gt;friend&lt;/span&gt; &lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;Pal3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="c1"&gt;// 不需要 Pal3 的前置声明&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;令模板自己的类型参数成为友元。在 C++11 新标准中，我们可以将模板类型参数声明为友元：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;typename&lt;/span&gt; &lt;span class="nx"&gt;Type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;Bar&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;friend&lt;/span&gt; &lt;span class="nx"&gt;Type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;//将访问权限授予用来实例化 Bar 的类型&lt;/span&gt;
    &lt;span class="c1"&gt;//...&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;因此，对于某个类型名 Foo，Foo 将成为 Bar&lt;Foo&gt; 的友元。&lt;/p&gt;
&lt;h4&gt;模板类型别名&lt;/h4&gt;
&lt;p&gt;类模板的一个实例定义了一个类型，与任何其他类类型一样，我们可以定义一个&lt;code&gt;typedef&lt;/code&gt;来引用实例化的类：&lt;code&gt;typedef Blob&amp;lt;string&amp;gt; StrBlob;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;由于模板不是一个类型，我们不能定义一个&lt;code&gt;typedef&lt;/code&gt;引用一个模板。即，无法定义一个&lt;code&gt;typedef&lt;/code&gt;引用 Blob&lt;T&gt;。&lt;/p&gt;
&lt;p&gt;但是，C++11 新标准允许我们为类模板定义一个类型别名：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;template &amp;lt;typename T&amp;gt;
using twin = pair&amp;lt;T,T&amp;gt;;
twin&amp;lt;string&amp;gt; authors;   //autohors 是一个 pair&amp;lt;string,string&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当我们定义一个模板类型别名时，可以固定一个或多个模板参数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;template &amp;lt;typename T&amp;gt;
using partNo = pair&amp;lt;T, unsigned&amp;gt;;
partNo&amp;lt;string&amp;gt; books;   //books 是一个 pair&amp;lt;string, unsigned&amp;gt;
partNo&amp;lt;Vehicle&amp;gt; cars;   //cars 是一个 pair&amp;lt;Vehicle, unsigned&amp;gt;
partNo&amp;lt;Student&amp;gt; kids;   //kids 是一个 pair&amp;lt;Student, unsigned&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;类模板的 static 成员&lt;/h4&gt;
&lt;p&gt;对于类模板 Foo 中的&lt;code&gt;static&lt;/code&gt;成员 ctr，对于任意给定类型 X，都有一个 Foo::ctr 成员。所有 Foo 类型的对象共享相同的 ctr 成员：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;typename&lt;/span&gt; &lt;span class="nt"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nt"&gt;class&lt;/span&gt; &lt;span class="nt"&gt;Foo&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="n"&gt;public&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
   &lt;span class="kc"&gt;static&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;size_t&lt;/span&gt; &lt;span class="nf"&gt;count&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt; &lt;span class="n"&gt;return&lt;/span&gt; &lt;span class="n"&gt;ctr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
   &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="nt"&gt;其它接口成员&lt;/span&gt;
&lt;span class="nt"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
   &lt;span class="nt"&gt;static&lt;/span&gt; &lt;span class="nt"&gt;std&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nd"&gt;size_t&lt;/span&gt; &lt;span class="nt"&gt;ctr&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
   &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="nt"&gt;其它数据成员&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="nt"&gt;所有三个对象共享相同的&lt;/span&gt; &lt;span class="nt"&gt;Foo&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nd"&gt;ctr&lt;/span&gt; &lt;span class="nt"&gt;和&lt;/span&gt; &lt;span class="nt"&gt;Foo&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nd"&gt;count&lt;/span&gt; &lt;span class="nt"&gt;成员&lt;/span&gt;
&lt;span class="nt"&gt;Foo&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nt"&gt;fi&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;fi2&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;fi3&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;类模板的&lt;code&gt;static&lt;/code&gt;成员，可以通过类类型对象来访问，也可以用作用域运算符直接访问该成员，不过必须提供一个特定的模板实参。另外，&lt;code&gt;static&lt;/code&gt;成员函数也是只在使用时才会被初始化：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;Foo&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nt"&gt;fi&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;                  &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="nt"&gt;实例化&lt;/span&gt; &lt;span class="nt"&gt;Foo&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nt"&gt;类和&lt;/span&gt; &lt;span class="nt"&gt;static&lt;/span&gt; &lt;span class="nt"&gt;数据成员&lt;/span&gt; &lt;span class="nt"&gt;ctr&lt;/span&gt;
&lt;span class="nt"&gt;auto&lt;/span&gt; &lt;span class="nt"&gt;ct&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nt"&gt;Foo&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nd"&gt;count&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;  &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="nt"&gt;实例化&lt;/span&gt; &lt;span class="nt"&gt;Foo&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nd"&gt;count&lt;/span&gt;
&lt;span class="nt"&gt;ct&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nt"&gt;fi&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;count&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;              &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="nt"&gt;使用&lt;/span&gt; &lt;span class="nt"&gt;Foo&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nd"&gt;count&lt;/span&gt;
&lt;span class="nt"&gt;ct&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nt"&gt;Foo&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nd"&gt;count&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;            &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="nt"&gt;错误&lt;/span&gt;&lt;span class="err"&gt;，&lt;/span&gt;&lt;span class="nt"&gt;无法确定使用哪个模板实例化的&lt;/span&gt; &lt;span class="nt"&gt;count&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;模板参数&lt;/h3&gt;
&lt;p&gt;一个模板参数的名字也没有什么内在含义，我们通常将类型参数命名为 T，但实际上我们可以使用任何名字。&lt;/p&gt;
&lt;p&gt;模板参数名的可用范围是在其声明之后，至模板声明或定义结束之前。模板参数会隐藏外层作用域中声明的相同名字，但是在模板内不能重用模板参数名。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;typedef double A;
template &amp;lt;typename A, typename B&amp;gt; void f(A a, B b)
{
   A tmp = a;  // tmp的类型为模板参数 A 的类型，而非 double
   double B;   // 错误，重声明模板参数 B
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;模板声明必须包含模板参数，声明中的模板参数的名字不必与定义中相同。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;template &amp;lt;typename T&amp;gt; class Blob;  // 声明但不定义
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;使用类的类型成员&lt;/h4&gt;
&lt;p&gt;假定 T 是一个模板类型参数，当编译器遇到类似 T::mem 这样的代码时，它不知道 mem 是一个类型成员还是一个&lt;code&gt;static&lt;/code&gt;数据成员，直至实例化时才会知道。&lt;/p&gt;
&lt;p&gt;但是为了处理模板，编译器必须知道名字是否表示一个类型。例如：&lt;code&gt;T::size_type * p;&lt;/code&gt;。编译器需要知道我们是在定义一个名为 p 的变量还是将一个名为 size_type 的&lt;code&gt;static&lt;/code&gt;数据成员与名为 p 的变量相乘。&lt;/p&gt;
&lt;p&gt;默认情况，C++ 语言假定通过作用域运算符访问的名字不是类型。因此，如果我们希望使用一个模板类型参数的类型成员，就必须显式告诉编译器该名字是一个类型。&lt;/p&gt;
&lt;p&gt;我们通过使用关键字&lt;code&gt;typename&lt;/code&gt;来实现这一点：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;typename&lt;/span&gt; &lt;span class="nt"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;typename&lt;/span&gt; &lt;span class="nt"&gt;T&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nd"&gt;value_type&lt;/span&gt; &lt;span class="nt"&gt;top&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;const&lt;/span&gt; &lt;span class="nt"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="nt"&gt;c&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="err"&gt;if&lt;/span&gt; &lt;span class="err"&gt;(!c.empty())&lt;/span&gt;
        &lt;span class="err"&gt;return&lt;/span&gt; &lt;span class="err"&gt;c.back()&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="err"&gt;else&lt;/span&gt;
        &lt;span class="err"&gt;return&lt;/span&gt; &lt;span class="err"&gt;typename&lt;/span&gt; &lt;span class="n"&gt;T&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="nf"&gt;value_type&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;默认模板实参&lt;/h4&gt;
&lt;p&gt;在新标准中，我们可以为函数和类模板提供默认实参。而更早的 C++ 标准只允许为类模板提供默认实参。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//compare有一个默认模板实参 less&amp;lt;T&amp;gt; 和一个默认函数实参 F()
template &amp;lt;typename T, typename F = less&amp;lt;T&amp;gt;&amp;gt;
int compare(const T &amp;amp;v1, const T &amp;amp;b2, F f = F())
{
    if (f(v1, v2)) return -1;
    if (f(v2, v1)) return 1;
    return 0;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果一个类模板为其所有模板参数都提供了模板实参，且我们希望使用这些默认实参，就必须在模板名之后跟一个空尖括号对。&lt;/p&gt;
&lt;h3&gt;成员模板&lt;/h3&gt;
&lt;p&gt;一个类可以包含本身是模板的成员函数。这种成员被称为成员模板（member template）。成员模板不能是虚函数（Member template functions cannot be declared virtual.Current compiler technology experts to be able to determine the size of a class’s virtual function table when the class is parsed.Allowing virtual member template functions woule require knowing all calls to such member functions everywhere in the program ahead of time.This is not feasible,especially for multi-file projects.）&lt;/p&gt;
&lt;h4&gt;普通（非模板）类的成员模板&lt;/h4&gt;
&lt;p&gt;我们定义一个类，类似&lt;code&gt;unique_ptr&lt;/code&gt;所使用的默认删除器类型：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;//函数对象类，对给定指针执行 delete&lt;/span&gt;
&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;DebugDelete&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="kr"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="nx"&gt;DebugDelete&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;ostream&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;s&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;cerr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;os&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
    &lt;span class="c1"&gt;//与任何函数模板相同，T 的类型由编译器推断&lt;/span&gt;
    &lt;span class="nx"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;typename&lt;/span&gt; &lt;span class="nx"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="nx"&gt;operator&lt;/span&gt;&lt;span class="p"&gt;()(&lt;/span&gt;&lt;span class="nx"&gt;T&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;p&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;const&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nx"&gt;os&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;deleting unqiue_ptr&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;delete&lt;/span&gt; &lt;span class="nx"&gt;p&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kr"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;ostream&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;os&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们可以用这个类代替&lt;code&gt;delete&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;double *p = new double;
DebugDelete d;  //可像 delete 表达式一样使用的对象
d(p);   //调用 DebugDelete::operator()(double*),释放 p
int* ip = new int;
//在一个临时 DebugDelete 对象上调用 operator()(int*)
DebugDelete()(ip);
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;类模板的成员模板&lt;/h4&gt;
&lt;p&gt;在此情况下，类和成员各有自己的独立的模板参数。例如，我们将 Blob 类定义一个构造函数，它接受两个迭代器，表示要拷贝的元素范围，我们希望支持不同类型序列的迭代器：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;typename&lt;/span&gt; &lt;span class="nx"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;Blob&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;typename&lt;/span&gt; &lt;span class="nx"&gt;It&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nx"&gt;Blob&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;It&lt;/span&gt; &lt;span class="nx"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;It&lt;/span&gt; &lt;span class="nx"&gt;e&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="c1"&gt;//...&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当我们在类模板外定义一个成员模板时，必须同时为类模板和成员模板提供模板参数列表。类模板的参数列表在前，后跟成员自己的模板参数列表：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;template &amp;lt;typename T&amp;gt;
template &amp;lt;typename It&amp;gt;
    Blob&amp;lt;T&amp;gt;::Blob(It b, It e) :
        data(std::make_shared&amp;lt;std::vector&amp;lt;T&amp;gt;(b,e)) {}
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;实例化成员模板&lt;/h4&gt;
&lt;p&gt;为了实例化一个类模板的成员模板，我们必须同时提供类和函数模板的实参：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int ia[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
vector&amp;lt;long&amp;gt; vi = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
list&amp;lt;const char*&amp;gt; w = {&amp;quot;now&amp;quot;, &amp;quot;is&amp;quot;, &amp;quot;the&amp;quot;, &amp;quot;time&amp;quot;};
//实例化 Blob&amp;lt;int&amp;gt; 类及其接受两个 int* 参数的构造函数
Blob&amp;lt;int&amp;gt; a1(begin(ia), end(ia));
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;控制实例化&lt;/h3&gt;
&lt;p&gt;模板被使用时才会进行实例化，这意味着，当两个或多个独立编译的源文件使用了相同的模板，并提供了相同的模板参数时，每个文件中就都会有该模板的一个实例。&lt;/p&gt;
&lt;p&gt;相同的实例可能出现在多个对象文件中，在多个文件中实例化相同模板的额外开销可能非常大。在新标准中，我们可以通过显示实例化（explicit instantiation）来避免这种开销。&lt;/p&gt;
&lt;p&gt;形式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;extern template declaration;        //实例化声明
template declaration;        //实例化定义
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;declaration 是一个类或函数声明，其中所有模板参数已被替换为模板实参，例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//实例化声明与定义
extern template class Blob&amp;lt;string&amp;gt;; //声明
template int compare(const int&amp;amp;, const int&amp;amp;);   //定义
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当编译器遇到&lt;code&gt;extern&lt;/code&gt;模板声明时，它不会在本文件中生成实例代码。将一个实例化声明为&lt;code&gt;extern&lt;/code&gt;就表示承诺在程序其他位置有该实例化的一个非&lt;code&gt;extern&lt;/code&gt;声明（定义）。对于一个给定的实例化版本，可能有多个&lt;code&gt;extern&lt;/code&gt;声明，但必须只有一个定义。&lt;/p&gt;
&lt;p&gt;由于编译器在使用一个模板时自动对其实例化，因此&lt;code&gt;extern&lt;/code&gt;声明必须出现在任何使用此实例化版本的代码之前：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;// Application.cc
// 这些模板类型必须在程序其它位置进行实例化
extern template class Blob&amp;lt;string&amp;gt;;
extern template int compare(const int&amp;amp;, const int&amp;amp;);
Blob&amp;lt;string&amp;gt; sa1, sa2;  // 实例化会出现在其他位置
// Blob&amp;lt;int&amp;gt;及其接受 initializer_list 的构造函数在本文件中实例化
Blob&amp;lt;int&amp;gt; a1 = {0, 1, 2, 3, 4};
Blob&amp;lt;int&amp;gt; a2(a1);  // 拷贝构造函数在本文件中实例化
int i = compare(a1[0], a2[0]);  // 实例化出现在其他位置
// templateBuild.cc
// 实例化文件必须为每个在其他文件中声明为 extern 的类型和函数提供一个（非 extern）的定义
template int compare(const int&amp;amp;, const int&amp;amp;);
template class Blob&amp;lt;string&amp;gt;;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;与类模板的普通实例化不同，类模板的显式实例化定义会实例化该模板的所有成员。因此，用来显示实例化一个类模板的类型，必须能用于模板的所有成员。&lt;/p&gt;
&lt;h3&gt;效率与灵活性&lt;/h3&gt;
&lt;p&gt;对模板设计者所面对的设计选择，标准库智能指针类型给出了一个很好的展示。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;shared_ptr&lt;/code&gt;和&lt;code&gt;unique_ptr&lt;/code&gt;之间的明显不同是它们管理所保存的指针的策略——前者给予我们共享指针所有权的能力；后置则独占指针。&lt;/p&gt;
&lt;p&gt;这两个类的另一差异是它们允许用户重载默认删除器的方式：我们可以很容器地重载一个&lt;code&gt;shared_ptr&lt;/code&gt;的删除器，只要在创建或&lt;code&gt;reset&lt;/code&gt;指针时传递给他一个可调用对象即可；与之相反，删除器类型是&lt;code&gt;unique_ptr&lt;/code&gt;对象类型的一部分，用户必须在定义&lt;code&gt;unique_ptr&lt;/code&gt;时以显示模板实参的形式提供删除器的类型。&lt;/p&gt;
&lt;h4&gt;在运行时绑定删除器（shared_ptr）&lt;/h4&gt;
&lt;p&gt;虽然我们不知道标准库类型是如何实现的，但可以推断出，&lt;code&gt;shared_ptr&lt;/code&gt;必须能直接访问其删除器。即删除器必须保存为一个指针或封装了指针的类。&lt;/p&gt;
&lt;p&gt;我们可以确定&lt;code&gt;shared_ptr&lt;/code&gt;不是将删除器直接保存为一个成员，因为删除器的类型运行时才会知道。&lt;/p&gt;
&lt;h4&gt;在编译时绑定删除器（unique_ptr）&lt;/h4&gt;
&lt;p&gt;现在，让我来考察&lt;code&gt;unique_ptr&lt;/code&gt;可能的工作方式：&lt;/p&gt;
&lt;p&gt;在这个类中，删除器的类型是类类型的一部分。即&lt;code&gt;unique_ptr&lt;/code&gt;有两个模板参数，一个表示它所管理的指针，另一个表示删除器的类型。&lt;/p&gt;
&lt;p&gt;由于删除器类型是&lt;code&gt;unique_ptr&lt;/code&gt;的一部分，因此删除器成员的类型在编译时是知道的，从而删除器可以直接保存在&lt;code&gt;unique_ptr&lt;/code&gt;对象中。&lt;/p&gt;
&lt;p&gt;总结：通过在编译时绑定删除器，&lt;code&gt;unique_ptr&lt;/code&gt;避免了间接调用删除器的运行时开销。通过在运行时绑定删除器，&lt;code&gt;shared_ptr&lt;/code&gt;使用户重载删除器更为方便。&lt;/p&gt;
&lt;h2&gt;模板实参推断&lt;/h2&gt;
&lt;p&gt;我们已经看到，对于函数模板，编译器利用调用中的函数实参来确定其模板实参。从函数实参来确定模板实参的过程被称为模板实参推断（template argument deduction）。&lt;/p&gt;
&lt;h3&gt;类型转换与模板类型参数&lt;/h3&gt;
&lt;p&gt;只有很有限的几种类型转换会自动地应用于模板实参，编译器通常不是对实参进行类型转换，而是生成一个新的模板实例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;顶层&lt;code&gt;const&lt;/code&gt;，无论是在形参还是实参中，都会被忽略&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const&lt;/code&gt;转换，可以将一个非&lt;code&gt;const&lt;/code&gt;对象的引用（或指针）传递给一个&lt;code&gt;const&lt;/code&gt;的引用（或指针）形参&lt;/li&gt;
&lt;li&gt;数组或函数指针转换：如果函数形参不是引用类型，则可以对数组或函数类型的实参应用正常的指针转换&lt;/li&gt;
&lt;li&gt;其他类型转换，如算术转换，派生类向基类转换以及用户定义的转换都不能应用于函数模板&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;template &amp;lt;typename T&amp;gt;
T fobj(T, T);   //实参被拷贝
template &amp;lt;typename T&amp;gt;
T fref(const T&amp;amp;, const T&amp;amp;); //引用捕获方式；c 显示捕获，值捕获方式
string s1(&amp;quot;a value&amp;quot;);
const string s2(&amp;quot;another value&amp;quot;);
fobj(s1, s2);   //调用 fobj(string, string);const 被忽略
fref(s1, s2);   //调用 fref(const string&amp;amp;, const string&amp;amp;),将 s1 转换为 const 是允许的

int a[10], b[42];
fobj(a, b); //调用 f(int*, int*)
fref(a, b); //错误：数组类型不匹配
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;将实参传递给带模板类型的函数形参时，能够自动应用的类型转换只有&lt;code&gt;const&lt;/code&gt;转换以及数组或函数到指针的转换。&lt;/strong&gt;&lt;/p&gt;
&lt;h4&gt;正常类型转换应用于普通函数实参&lt;/h4&gt;
&lt;p&gt;函数模板可以有用普通类型定义的参数，即，不涉及模板类型参数的类型。这种函数实参不进行特殊处理；它们正常转换为对应形参的类型。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;template &amp;lt;typename T&amp;gt;
ostream &amp;amp;print(ostream &amp;amp;os, const T &amp;amp;obj)
{
    return os &amp;lt;&amp;lt; obj;
}
//第一个函数参数是一个已知类型 ostream&amp;amp;。第二个参数 obj 则是模板参数类型
//由于 os 的类型是固定的，因此当调用 print 时，传递给它的实参会进行正常的
//类型转换
print(const , 42);  //实例化 print(ostream&amp;amp;, int)
ofstream f(&amp;quot;output&amp;quot;);
print(f, 10);   //使用 print(ostream&amp;amp;, int);将 f 转换为 ostream&amp;amp;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;如果函数参数类型不是模板参数，则对实参进行正常的类型转换。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;函数模板显式实参&lt;/h3&gt;
&lt;p&gt;在某些情况下，编译器无法推断出模板实参的类型。其他一些情况下，我们希望允许用户控制模板实例化。&lt;/p&gt;
&lt;h4&gt;指定显式模板实参&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//编译器无法推断 T1，它未出现在函数参数列表中
template &amp;lt;typename T1, typename T2, typename T3&amp;gt;
T1 sum(T2, T3);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;本例中，没有任何函数实参的类型可用来推断 T1 的类型。每次调用 sum 时调用者都必须为 T1 提供一个显式模板实参（explicit template argument）。如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//T1 是显示指定的，T2 和 T3 是从函数实参类型推断而来的
auto val3 = sum&amp;lt;long long&amp;gt;(i, lng); //long long sum(int, long)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;显示模板实参按由左至右的顺序与对应的模板参数匹配。推断不出的模板参数的类型在定义时应该放在参数列表的最左边。&lt;/p&gt;
&lt;h4&gt;正常类型转换应用于普通函数实参&lt;/h4&gt;
&lt;p&gt;对于模板类型参数已经显式指定了的函数实参，可以进行正常的类型转换。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;long lng;
compare(lng, 1024);           // 错误，模板参数不匹配
compare&amp;lt;long&amp;gt;(lng, 1024);     // 正确，1024自动转化为 long
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;尾置返回类型与类型转换&lt;/h3&gt;
&lt;p&gt;例如，我们可能希望编写一个函数，接受表示序列的一对迭代器和返回序列中一个元素的引用。但是，我们并不知道返回结果的准确类型，但知道所需类型是处理的序列的元素类型。由于尾置返回出现在参数列表之后，它可以使用函数的参数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//尾置返回允许我们在参数列表之后声明返回类型
template &amp;lt;typename It&amp;gt;
auto fcn(It beg, It end) -&amp;gt; decltype(*beg)
{
    //处理序列
    return *beg;    //返回序列中一个元素的引用
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;使用类型转换的标准库模板类&lt;/h4&gt;
&lt;p&gt;为了获取元素类型，我们可以使用标准库的类型转换（type transformation）模板。这些模板定义在头文件&lt;code&gt;type_traits&lt;/code&gt;中。这个头文件的类通常用于模板元编程设计。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;// 返回一个序列中的元素值
// 为了使用模板参数的类型成员，必须使用 typename
template &amp;lt;typename It&amp;gt;
auto fcn(It beg, It end) -&amp;gt;
   typename remove_reference&amp;lt;decltype(*beg)&amp;gt;::type;
{
   // 处理序列
   return *beg;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img alt="标准类型转换模板" src="https://xutree.github.io/images/c++16-1.jpg"&gt;&lt;/p&gt;
&lt;h3&gt;函数指针和实参推断&lt;/h3&gt;
&lt;p&gt;使用函数模板初始化一个函数指针或为一个函数指针赋值时，编译器使用指针的类型来推断模板实参。如果不能从函数指针类型确定模板实参，则产生错误。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;template &amp;lt;typename T&amp;gt; int compare(const T&amp;amp;, const T&amp;amp;);
// func 的重载版本，每个版本接受一个不同的函数指针类型
void func(int(*)(const string&amp;amp;, const string&amp;amp;));
void func(int(*)(const int&amp;amp;, const int&amp;amp;));
func(compare);   // 错误，不能确定使用哪一个实例
// 正确的做法是可以显式指出实例化哪个版本
func(compare&amp;lt;int&amp;gt;);
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;模板实参推断和引用&lt;/h3&gt;
&lt;p&gt;&lt;img alt="模板实参推断和引用" src="https://xutree.github.io/images/c++16-2.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="模板实参推断和引用" src="https://xutree.github.io/images/c++16-3.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="模板实参推断和引用" src="https://xutree.github.io/images/c++16-4.jpg"&gt;&lt;/p&gt;
&lt;h4&gt;从左值引用函数参数推断类型&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;template &amp;lt;typename T&amp;gt; void f(T &amp;amp;p)&lt;/code&gt;：实参必须是一个左值。如果实参是&lt;code&gt;const&lt;/code&gt;的，则 T 将被推断为&lt;code&gt;const&lt;/code&gt;类型。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;template &amp;lt;typename T&amp;gt; void f(const T &amp;amp;p)&lt;/code&gt;：实参可以是任意类型(包括右值在内)，即使实参是&lt;code&gt;const&lt;/code&gt;的，T 的推断类型也不会是一个&lt;code&gt;const&lt;/code&gt;类型。&lt;/p&gt;
&lt;h4&gt;从右值引用函数参数推断类型&lt;/h4&gt;
&lt;p&gt;传递的实参为右值。推断出的 T 的类型是该右值实参的类型。&lt;/p&gt;
&lt;p&gt;传递的实参为左值。此时得到的模板参数和函数参数都是左值引用。&lt;/p&gt;
&lt;p&gt;对于接受右值引用参数的模板函数，当分别传递右值和左值实参时，模板参数类型可能是普通类型，也可能是引用类型。有时这可能会造成意想不到的结果。解决这种问题的办法是，使用基于函数参数的模板重载，来将实参分别为右值或左值时的情况分离开来：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;template &amp;lt;typename T&amp;gt; void f3(T&amp;amp;&amp;amp;)
{
   T t = val;    // 实参为右值时，赋值语句
                 // 实参为左值时，绑定引用
   t = fcn(t);   // 实参为右值时，只改变 t
                 // 实参为左值时，既改变 t，也改变 val
}
// 定义一组重载函数，解决上述问题
template &amp;lt;typename T&amp;gt; void f(T&amp;amp;&amp;amp;);         // 绑定到非 const 右值
template &amp;lt;typename T&amp;gt; void f(const T&amp;amp;);    // 绑定到左值和 const 右值
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;理解 std::move&lt;/h3&gt;
&lt;p&gt;由于&lt;code&gt;move&lt;/code&gt;本质上可以接受任何类型的实参，因此我们不会惊讶于它是一个函数模板。&lt;/p&gt;
&lt;p&gt;标准库是这样定义&lt;code&gt;move&lt;/code&gt;的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//在返回类型和类型转换中也要用到 typename
template &amp;lt;typename T&amp;gt;
typename remove_reference&amp;lt;T&amp;gt;::type&amp;amp;&amp;amp; move(T&amp;amp;&amp;amp; t)
{
    //特例：可以使用 static_cast 显式地将左值转换为右值
    return static_cast&amp;lt;typename remove_reference&amp;lt;T&amp;gt;::type&amp;amp;&amp;amp;&amp;gt;(t);
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;转发&lt;/h3&gt;
&lt;p&gt;某些函数需要将其一个或多个实参连同类型不变地转发给其它参数，需要保持转发实参的所有性质，包括实参类型是否是&lt;code&gt;const&lt;/code&gt;的以及实参是左值还是右值。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;// 该模板将两个额外参数逆序传递给指定的可调用对象
template&amp;lt;typename F, typename T1, typename T2&amp;gt;
   void flip1(F f, T1 t1, T2 t2)
{
   f(t2, t1);
}
// flip1 一般情况下工作的很好，但是当用它调用一个接受引用参数的函数时会出现问题
void f(int v1, int &amp;amp;v2)
{
    cout &amp;lt;&amp;lt; v1 &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; ++v2 &amp;lt;&amp;lt; endl;
}
f(42, i);        // f 改变了实参 i
flip1(f, j, 42)  // j 的值不会改变
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果一个函数参数是指向模板类型参数的右值引用（如 T&amp;amp;&amp;amp;），它对应的实参的&lt;code&gt;const&lt;/code&gt;属性和左值/右值属性将得到保持。使用这种方案改写上面的 flip1 函数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;// 该模板将两个额外参数逆序传递给指定的可调用对象
template&amp;lt;typename F, typename T1, typename T2&amp;gt;
   void flip2(F f, T1 &amp;amp;&amp;amp;t1, T2 &amp;amp;&amp;amp;t2)
{
   f(t2, t1);
}
// flip2 对接受左值引用函数工作的很好，但不能用于接受右值引用的函数
void g(int &amp;amp;&amp;amp;v1, int &amp;amp;v2)
{
    cout &amp;lt;&amp;lt; v1 &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; v2 &amp;lt;&amp;lt; endl;
}
g(42, i);        // 正确
flip1(g, i, 42)  // 错误，g 中接收到的 “42” 是左值
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当我们试图通过 flip2 调用 g，则参数 t2 将被传递给 g 的右值引用参数（即使我们传递一个右值给 filp2，也会被拷贝到 t2）。函数参数是左值表达式，不能用于实例化右值。&lt;/p&gt;
&lt;p&gt;当用于一个指向模板参数类型的右值引用函数（T&amp;amp;&amp;amp;）时，&lt;code&gt;forward&lt;/code&gt;会保持实参类型的所有细节。与&lt;code&gt;move&lt;/code&gt;不同，&lt;code&gt;forward&lt;/code&gt;必须通过显式模板实参来调用。&lt;code&gt;forward&lt;/code&gt;也定义在&lt;code&gt;utility&lt;/code&gt;头文件中。下面使用&lt;code&gt;forward&lt;/code&gt;重写翻转函数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;typename&lt;/span&gt; &lt;span class="nt"&gt;F&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;typename&lt;/span&gt; &lt;span class="nt"&gt;T1&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;typename&lt;/span&gt; &lt;span class="nt"&gt;T2&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;void&lt;/span&gt; &lt;span class="nt"&gt;flip3&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;F&lt;/span&gt; &lt;span class="nt"&gt;f&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;T1&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class="nt"&gt;t1&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;T2&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class="nt"&gt;t2&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="err"&gt;f(&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;forward&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T2&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;t2&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;forward&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;T1&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;t1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;重载与模板&lt;/h2&gt;
&lt;p&gt;函数模板可以被另一个模板或一个普通非函数模板重载，与往常一样，名字相同的函数，必须具有不同数量或类型的参数。如果涉及函数模板，则函数匹配规则会在以下几个方面受到影响:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于一个调用，其候选函数包括所有模板实参推断成功的函数模板实例&lt;/li&gt;
&lt;li&gt;候选的函数模板总是可行的，因为模板实参推断会排除任何不可行的模板&lt;/li&gt;
&lt;li&gt;与往常一样，可行函数（模板与非模板）按类型转换（如果对此调用需要的话）来排序。当然，可以用于函数模板调用的类型转换是非常有限的（参考前文）&lt;/li&gt;
&lt;li&gt;与往常一样，如果恰有一个函数提供比任何其他函数都更好的匹配，则选择此函数。但是如果有多个函数提供同样好的匹配，则：（1）如果同样好的函数中只有一个是非模板函数，则选择此函数；（2）如果同样好的函数中没有非模板函数，而有多个函数模板，且其中一个模板比其它模板更特例化则选择此模板；（3）否则，此调用有歧义&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="nt"&gt;通用模板&lt;/span&gt;&lt;span class="err"&gt;，&lt;/span&gt;&lt;span class="nt"&gt;返回&lt;/span&gt; &lt;span class="nt"&gt;T&lt;/span&gt; &lt;span class="nt"&gt;型对象&lt;/span&gt; &lt;span class="nt"&gt;t&lt;/span&gt; &lt;span class="nt"&gt;的&lt;/span&gt; &lt;span class="nt"&gt;string&lt;/span&gt; &lt;span class="nt"&gt;表示&lt;/span&gt;
&lt;span class="nt"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;typename&lt;/span&gt; &lt;span class="nt"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;string&lt;/span&gt; &lt;span class="nt"&gt;debug_rep&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;const&lt;/span&gt; &lt;span class="nt"&gt;T&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nt"&gt;t&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;ostringstream&lt;/span&gt; &lt;span class="n"&gt;ret&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="err"&gt;ret&lt;/span&gt; &lt;span class="err"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="err"&gt;t&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="err"&gt;return&lt;/span&gt; &lt;span class="err"&gt;ret.str()&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="nt"&gt;通用模板&lt;/span&gt;&lt;span class="err"&gt;，&lt;/span&gt;&lt;span class="nt"&gt;返回&lt;/span&gt; &lt;span class="nt"&gt;T&lt;/span&gt; &lt;span class="nt"&gt;型指针&lt;/span&gt; &lt;span class="nt"&gt;p&lt;/span&gt; &lt;span class="nt"&gt;的&lt;/span&gt; &lt;span class="nt"&gt;string&lt;/span&gt; &lt;span class="nt"&gt;表示&lt;/span&gt;
&lt;span class="nt"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;typename&lt;/span&gt; &lt;span class="nt"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;string&lt;/span&gt; &lt;span class="nt"&gt;debug_rep&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;T&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;ostringstream&lt;/span&gt; &lt;span class="n"&gt;ret&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="err"&gt;//&lt;/span&gt; &lt;span class="err"&gt;打印指针本身的值&lt;/span&gt;
    &lt;span class="err"&gt;ret&lt;/span&gt; &lt;span class="err"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="err"&gt;&amp;quot;&lt;/span&gt;&lt;span class="n"&gt;pointer&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot; &amp;lt;&amp;lt; p;&lt;/span&gt;
&lt;span class="s2"&gt;    // p不为空，则打印 p指向的值&lt;/span&gt;
&lt;span class="s2"&gt;    if (p)&lt;/span&gt;
&lt;span class="s2"&gt;        ret &amp;lt;&amp;lt; &amp;quot;&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot; &amp;lt;&amp;lt; debug_rep(*p);&lt;/span&gt;
&lt;span class="s2"&gt;    else&lt;/span&gt;
&lt;span class="s2"&gt;        ret &amp;lt;&amp;lt; &amp;quot;&lt;/span&gt; &lt;span class="n"&gt;null&lt;/span&gt; &lt;span class="kc"&gt;pointer&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;;&lt;/span&gt;
&lt;span class="s2"&gt;    return ret.str();&lt;/span&gt;
&lt;span class="s2"&gt;}&lt;/span&gt;
&lt;span class="s2"&gt;// 对于下面的代码调用，只会使用第一个模板&lt;/span&gt;
&lt;span class="s2"&gt;string s(&amp;quot;&lt;/span&gt;&lt;span class="n"&gt;hi&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;);&lt;/span&gt;
&lt;span class="s2"&gt;cout &amp;lt;&amp;lt; debug_rep(s) &amp;lt;&amp;lt; endl;&lt;/span&gt;
&lt;span class="s2"&gt;// 对于下面的代码调用，最终会调用第二个模板&lt;/span&gt;
&lt;span class="s2"&gt;cout &amp;lt;&amp;lt; debug_rep(&amp;amp;s) &amp;lt;&amp;lt; endl;&lt;/span&gt;
&lt;span class="s2"&gt;// 对于下面的代码调用，最终会调用第二个模板&lt;/span&gt;
&lt;span class="s2"&gt;const string *sp = &amp;quot;&lt;/span&gt;&lt;span class="n"&gt;hi&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;;&lt;/span&gt;
&lt;span class="s2"&gt;cout &amp;lt;&amp;lt; debug_rep(sp) &amp;lt;&amp;lt; endl;&lt;/span&gt;
&lt;span class="s2"&gt;// 再定义一个普通非模板函数，打印双引号包围的 string&lt;/span&gt;
&lt;span class="s2"&gt;string debug_rep(const string &amp;amp;s)&lt;/span&gt;
&lt;span class="s2"&gt;{&lt;/span&gt;
&lt;span class="s2"&gt;    cout &amp;lt;&amp;lt; &amp;#39;&amp;quot;&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39; + s + &amp;#39;&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;#39;;&lt;/span&gt;
&lt;span class="s2"&gt;}&lt;/span&gt;
&lt;span class="s2"&gt;// 对于下面的代码调用，会使用普通非模板函数&lt;/span&gt;
&lt;span class="s2"&gt;cout &amp;lt;&amp;lt; debug_rep(s) &amp;lt;&amp;lt; endl;&lt;/span&gt;
&lt;span class="s2"&gt;// 对于下面的代码调用，最终会调用第二个模板&lt;/span&gt;
&lt;span class="s2"&gt;cout &amp;lt;&amp;lt; debug_rep(&amp;quot;&lt;/span&gt;&lt;span class="n"&gt;hi&lt;/span&gt;&lt;span class="err"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;对于第一个模板参数&lt;code&gt;const T &amp;amp;t&lt;/code&gt;，当实例化&lt;code&gt;string *&lt;/code&gt;参数时，模板参数是&lt;code&gt;string *&lt;/code&gt;，而函数参数是&lt;code&gt;string * const &amp;amp;t&lt;/code&gt;，表示 t 是引用，引用自&lt;code&gt;string&lt;/code&gt;型指针（本身是常量）。在进行模板实参推断之后会进行普通函数的函数匹配过程。而 &lt;code&gt;string * const &amp;amp;t&lt;/code&gt;中的顶层&lt;code&gt;const&lt;/code&gt;属性也会被略去，即&lt;code&gt;f(string * const &amp;amp;t)和 f(string *t)&lt;/code&gt;存在二义性。此时后者更特例化，所以编译器实际执行的是后者。&lt;/p&gt;
&lt;p&gt;对于第一个模板参数&lt;code&gt;const T &amp;amp;t&lt;/code&gt;，当实例化&lt;code&gt;const string *&lt;/code&gt;参数时，模板参数是&lt;code&gt;const string *&lt;/code&gt;，而函数参数是 &lt;code&gt;const string * const &amp;amp;t&lt;/code&gt;，表示 t 是引用，引用自&lt;code&gt;string&lt;/code&gt;型指针（指向常量，且本身是常量）。所以，同样地，&lt;code&gt;f(const string * const &amp;amp;t)和 f(const string *t)&lt;/code&gt;存在二义性。此时后者更特例化，所以编译器实际执行的是后者。&lt;/p&gt;
&lt;p&gt;对于第一个模板，T 的类型为&lt;code&gt;char[3]&lt;/code&gt;；对于第二个模板，T 的类型是&lt;code&gt;const char&lt;/code&gt;；对于普通非模板函数，要求从&lt;code&gt;const char*&lt;/code&gt;到&lt;code&gt;string&lt;/code&gt;的类型转换。此时，3个候选函数都是可行的。普通函数由于需要进行类型转换，可以首先排除掉。而剩下两个模板函数，后者更特例化，所以编译器实际执行的是后者。&lt;/p&gt;
&lt;p&gt;在定义任何函数之前，记得声明所有重载的函数版本。这样就不必担心编译器由于未遇到你希望调用的函数，而实例化一个并非你所需的版本:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;template &amp;lt;typename T&amp;gt; string debug_rep(const T &amp;amp;t);
template &amp;lt;typename T&amp;gt; string debug_rep(T *p);
// 为了使 debug_rep(char*) 的定义正确工作，下面的声明必须在作用域中
string debug_rep(const string &amp;amp;);
string debug_rep(char *p)
{
   // 如果接受一个 const string&amp;amp;的版本的声明不在作用域中，
   // 返回语句将调用 debug_rep(const T &amp;amp;t) 的 T 实例化为 string 的版本
   return debug_rep(string(p));
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;可变参数模板&lt;/h2&gt;
&lt;p&gt;一个可变参数模板（variadic template）就是一个接受可变数目参数的模板函数或模板类。可变数目的参数被称为参数包（parameter packet）。存在两种参数包：模板参数包，函数参数包。&lt;/p&gt;
&lt;p&gt;在一个模板参数列表中，&lt;code&gt;class...&lt;/code&gt;或&lt;code&gt;typename...&lt;/code&gt;指出，接下来的参数表是零个或多个类型的列表；一个类型名后面跟一个省略号表示零个或多个给定类型的非类型参数的列表。在函数参数列表中，如果一个参数的类型是一个模板参数包，则此参数也是一个函数参数包。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;// Args 是一个模板参数包； rest 是一个函数参数包
// Args 表示零个或多个模板类型参数
// rest 表示零个或多个函数参数
template &amp;lt;typename T, typename... Args&amp;gt;
void foo(const T &amp;amp;t, const Args&amp;amp; ... rest);
// 对于下面调用
int i = 0;
foo(i, &amp;quot;hi&amp;quot;);  // 包中有一个参数，实例化为 foo(const int &amp;amp;, const char[3]&amp;amp;);
foo(&amp;quot;hi&amp;quot;);     // 空包，实例化为 foo(const char[3]&amp;amp;);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;sizeof...&lt;/code&gt;运算符可以返回一个常量表达式，表示包中的元素个数，而且不会对其实参求值：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;template&amp;lt;typename... Args&amp;gt; void g(Args... args) {
   cout &amp;lt;&amp;lt; sizeof...(Args) &amp;lt;&amp;lt; endl;  // 类型参数的数目
   cout &amp;lt;&amp;lt; sizeof...(args) &amp;lt;&amp;lt; endl;  // 类型参数的数目
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;编写可变参数函数模板&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;initializer_list&lt;/code&gt;用来表示一组类型相同的可变数目参数，而当类型也是未知时，则需要使用可变参数函数模板。可变参数函数通常是递归的，第一步调用处理包中的第一个实参，然后用剩余实参调用自身。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;// 用来终止递归并打印最后一个元素的函数
// 此函数必须在可变参数版本的 print 定义之前声明
template&amp;lt;typename T&amp;gt;
ostream&amp;amp; print(ostream &amp;amp;os, const T &amp;amp;t)
{
   return os &amp;lt;&amp;lt; t;  // 包中最后一个元素之后不打印分隔符
}
// 包中除了最后一个元素之外的其他元素都会调用这个版本的 print
template&amp;lt;typename T, typename... Args&amp;gt;
ostream&amp;amp; print(ostream &amp;amp;os, const T &amp;amp;t, const Args&amp;amp;... rest)
{
   os &amp;lt;&amp;lt; t &amp;lt;&amp;lt; &amp;quot;, &amp;quot;; // 打印第一个实参
   return print(os, rest...);  // 递归调用，打印其他实参
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;给定 print(cout, i, s, 42)，其调用过程如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="编写可变参数函数模板" src="https://xutree.github.io/images/c++16-5.jpg"&gt;&lt;/p&gt;
&lt;p&gt;对于最后一次递归调用 print(cout, 42)，两个 print 版本都是可行的。但是因为非可变参数模板比可变参数模板更特例化，因此编译器选择非可变参数版本。另外，定义可变参数版本的 print 时，非可变参数版本的声明必须在作用域中，否则，可变参数版本会无限递归。&lt;/p&gt;
&lt;h3&gt;包扩展&lt;/h3&gt;
&lt;p&gt;当扩展一个包时，可以提供用于每个扩展元素的模式。扩展一个包就是将它分解为构成的元素，对每个元素应用模式，获得扩展后的列表。通过在模式右边放一个省略号（...）来触发扩展操作。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;template&amp;lt;typename T, typename... Args&amp;gt;
ostream&amp;amp; print(ostream &amp;amp;os, const T &amp;amp;t, const Args&amp;amp;... rest)  // 扩展 Args
{
   os &amp;lt;&amp;lt; t &amp;lt;&amp;lt; &amp;quot;, &amp;quot;;
   return print(os, rest...);                                 // 扩展 rest
}
// 对 Args 的扩展中，将模式 const Arg&amp;amp; 应用到模板参数包 Args 中的每个元素
print(cout, i, s, 42);
// 实例化的形式为
ostream&amp;amp;
print(ostream &amp;amp;, const int&amp;amp;, const string&amp;amp;, const int&amp;amp;);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;print 中的函数参数包扩展仅仅将包扩展为其构成元素，还可以进行更复杂的扩展模式。比如，对其每个实参调用之前出现过的  debug_rep：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;template&amp;lt;typename... Args&amp;gt;
ostream&amp;amp; errorMsg(ostream &amp;amp;os, const Args&amp;amp;... rest)
{
   print(os, debug_rep(rest)...);
   // 上式等价于
   print(os, debug_rep(a1), debug_rep(a2), ..., debug_rep(a3));
   // 注意，不可以写成下式形式
   print(os, debug_rep(rest...));  // 错误，此调用无匹配函数
   return os;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;扩展中的模式会独立地应用于包中的每个元素。&lt;/p&gt;
&lt;h3&gt;转发参数包&lt;/h3&gt;
&lt;p&gt;可变参数函数通常将它们的参数转发给其他函数，这种函数具有与容器中的&lt;code&gt;emplace_back&lt;/code&gt;函数一样的形式。work 调用中的扩展既扩展了模板参数包也扩展了函数参数包：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="nt"&gt;fun&lt;/span&gt; &lt;span class="nt"&gt;有零个或多个参数&lt;/span&gt;&lt;span class="err"&gt;，&lt;/span&gt;&lt;span class="nt"&gt;每个参数都是一个模板参数类型的右值引用&lt;/span&gt;
&lt;span class="nt"&gt;template&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;typename&lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt; &lt;span class="nt"&gt;Args&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;void&lt;/span&gt; &lt;span class="nt"&gt;fun&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;Args&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;...&lt;/span&gt; &lt;span class="nt"&gt;args&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;  &lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="nt"&gt;将&lt;/span&gt; &lt;span class="nt"&gt;Args&lt;/span&gt; &lt;span class="nt"&gt;扩展为一个右值引用的列表&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
   &lt;span class="err"&gt;//&lt;/span&gt; &lt;span class="err"&gt;work的实参既扩展&lt;/span&gt; &lt;span class="err"&gt;Args又扩展&lt;/span&gt; &lt;span class="err"&gt;args&lt;/span&gt;
   &lt;span class="err"&gt;work(&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;forward&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Args&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;模板特例化&lt;/h2&gt;
&lt;p&gt;在某些情况下，通用模板的定义可能编译失败、做的不正确，或者利用特定知识来编写更高效的代码，而不是从通用模板实例化。这时可以定义类或函数模板的一个特例化版本。&lt;/p&gt;
&lt;p&gt;当我们特例化一个函数模板时，必须为元模板中的每个模板参数都提供实参。为了指出我们正在实例化一个模板，应使用关键字 &lt;code&gt;template&lt;/code&gt;后跟一个空尖括号对（&amp;lt;&amp;gt;）。空尖括号指出我们将为原模板的所有模板参数提供实参。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;// 第一个版本，可以比较任意两个类型
template &amp;lt;typename T&amp;gt;
int compare(const T&amp;amp;, const T&amp;amp;);
// 第二个版本，处理字符串字面常量
template &amp;lt;size_t N, size_t M&amp;gt;
int compare(const cahr (&amp;amp;p1)[N], const cahr (&amp;amp;p2)[M]);
const char *p1 = &amp;quot;hi&amp;quot;, *p2 = &amp;quot;mom&amp;quot;;
compare(p1, p2);          // 调用第一个版本
compare(&amp;quot;hi&amp;quot;, &amp;quot;mom&amp;quot;);     // 调用第二个版本
// compare 的特例化版本，处理字符数组的指针
template &amp;lt;&amp;gt;
int compare(const char* const &amp;amp;p1, const char* const &amp;amp;p2)
{
    return strcmp(p1, p2);
}
// 参数类型为指针，不能调用第二个版本，这里调用的是特例化版本
compare(p1, p2);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们希望定义此函数的一个特例化版本，其中 T 的类型为&lt;code&gt;const char *&lt;/code&gt;。我们的函数要求一个指向此类型的&lt;code&gt;const&lt;/code&gt;版本的引用。所以 p1 是一个指向&lt;code&gt;const char&lt;/code&gt;的&lt;code&gt;const&lt;/code&gt;指针的引用。&lt;/p&gt;
&lt;h3&gt;函数重载与模板特例化&lt;/h3&gt;
&lt;p&gt;当定义函数模板的特例化版本时，我们本质上接管了编译器的工作，一个特例化版本本质上是一个实例，而非函数名的一个重载版本。因此，特例化不影响函数匹配。&lt;/p&gt;
&lt;p&gt;模板及其特例化版本应该声明在同一个头文件中。所有同名模板的声明应该放在前面，然后是这些模板的特例化版本。&lt;/p&gt;
&lt;h3&gt;类模板特例化&lt;/h3&gt;
&lt;p&gt;作为例子，这里为 Sales_data 类定义特例化版本的&lt;code&gt;hash&lt;/code&gt;模板。而定义了&lt;code&gt;hash&lt;/code&gt;模板的特例化版本的类类型，可以存储在无序容器中。为了让 Sales_data 类的用户能使用&lt;code&gt;hash&lt;/code&gt;的特例化版本，应该在 Sales_data 的头文件中定义该特例化版本。一个特例化&lt;code&gt;hash&lt;/code&gt;类必须定义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个重载的调用运算符，它接受一个容器关键字类型的对象，返回一个&lt;code&gt;size_t&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;两个类型成员，&lt;code&gt;result_type&lt;/code&gt;和&lt;code&gt;argument_type&lt;/code&gt;，分别表示调用运算符的返回类型和参数类型&lt;/li&gt;
&lt;li&gt;默认构造函数和拷贝赋值运算符（可以隐式定义）&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;typename&lt;/span&gt; &lt;span class="nx"&gt;T&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nx"&gt;struct&lt;/span&gt; &lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;Sales_data&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
   &lt;span class="nx"&gt;friend&lt;/span&gt; &lt;span class="nx"&gt;struct&lt;/span&gt; &lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;hash&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;Sales_data&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
   &lt;span class="c1"&gt;// 其它数据成员&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="c1"&gt;// 为了使 Sales_data 能存储在无序容器中，特例化 hash 模板&lt;/span&gt;
&lt;span class="c1"&gt;// 注意， Sales_data 类应支持 == 操作&lt;/span&gt;
&lt;span class="nx"&gt;namespace&lt;/span&gt; &lt;span class="nx"&gt;std&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;template&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;gt;&lt;/span&gt;
    &lt;span class="nx"&gt;struct&lt;/span&gt; &lt;span class="nx"&gt;hash&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;Sales_data&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;typedef&lt;/span&gt; &lt;span class="nx"&gt;size_t&lt;/span&gt; &lt;span class="nx"&gt;result_type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="nx"&gt;typedef&lt;/span&gt; &lt;span class="nx"&gt;Sales_data&lt;/span&gt; &lt;span class="nx"&gt;argument_type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="nx"&gt;size_t&lt;/span&gt; &lt;span class="nx"&gt;operator&lt;/span&gt;&lt;span class="p"&gt;()(&lt;/span&gt;&lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;Sales_data&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;const&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;};&lt;/span&gt;
    &lt;span class="nx"&gt;inline&lt;/span&gt; &lt;span class="nx"&gt;size_t&lt;/span&gt;
    &lt;span class="nx"&gt;hash&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;Sales_data&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;::&lt;/span&gt;&lt;span class="nx"&gt;operator&lt;/span&gt;&lt;span class="p"&gt;()(&lt;/span&gt;&lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;Sales_data&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="nx"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;const&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;hash模板的 Sales_data特例化版本&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;hash&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;()(&lt;/span&gt;&lt;span class="nx"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;bookNo&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;^&lt;/span&gt;
            &lt;span class="nx"&gt;hash&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;unsigned&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;()(&lt;/span&gt;&lt;span class="nx"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;units_sold&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;^&lt;/span&gt;
            &lt;span class="nx"&gt;hash&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kr"&gt;double&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;()(&lt;/span&gt;&lt;span class="nx"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;revenue&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;类模板部分特例化&lt;/h3&gt;
&lt;p&gt;可以指定一部分而非所有模板参数，或是参数的一部分而非全部特性。一个类模板的部分特例化本身是一个模板，使用它时用户还必须为那些在特例化版本中未指定的模板参数提供实参。只能部分特例化类模板，而不能部分特例化函数模板。&lt;/p&gt;
&lt;h3&gt;特例化成员而不是类&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;template &amp;lt;typename T&amp;gt; struct Foo {
   Foo(cosnt T &amp;amp;t = T()) : men(t) {}
   void Bar() { /* ... */ }
   T men;
   // Foo 的其他成员
};
template&amp;lt;&amp;gt;                  // 表示正在特例化一个模板
void Foo&amp;lt;int&amp;gt;::Bar()        // 正在特例化 Foo&amp;lt;int&amp;gt; 的成员 Bar
{
   // 进行应用于 int的特例化处理
}
Foo&amp;lt;string&amp;gt; fs;        // 实例化 Foo&amp;lt;string&amp;gt;::Foo()
fs.Bar();              // 实例化 Foo&amp;lt;string&amp;gt;::Bar()
Foo&amp;lt;int&amp;gt; fi;           // 实例化 Foo&amp;lt;int&amp;gt;::Foo()
fi.Bar();              // 使用特例化版本的 Foo&amp;lt;int&amp;gt;::Bar()
&lt;/pre&gt;&lt;/div&gt;</content><category term="C++"></category></entry><entry><title>C++ Primer 第十五章 面向对象程序设计</title><link href="https://xutree.github.io/pages/2018/10/20/C++_Primer_Chapter_15/" rel="alternate"></link><published>2018-10-20T23:05:36+08:00</published><updated>2018-10-20T23:05:36+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-20:/pages/2018/10/20/C++_Primer_Chapter_15/</id><summary type="html">&lt;h2&gt;OOP：概述&lt;/h2&gt;
&lt;p&gt;面向对象程序设计（object-oriented programming）的核心思想是数据抽象、继承和动态绑定。&lt;/p&gt;
&lt;h3&gt;继承&lt;/h3&gt;
&lt;p&gt;通过继承（inheritance）联系在一起的类构成一种层次关系。在 C++ 语言中，基类将类型相关的函数与派生类不做改变直接继承的函数区分对待。对于某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明成虚函数（virtual function）。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;Quote&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="kr"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt; &lt;span class="nx"&gt;isbn&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="kr"&gt;const&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nx"&gt;virtual&lt;/span&gt; &lt;span class="kr"&gt;double&lt;/span&gt; &lt;span class="nx"&gt;net_price&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;size_t&lt;/span&gt; &lt;span class="nx"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;const&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;派生类必须通过使用派生列表（class derivation list）明确指出它是从哪个(哪些)基类继承而来的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;Bulk_quote&lt;/span&gt; : &lt;span class="kt"&gt;public&lt;/span&gt; &lt;span class="nx"&gt;Quote&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="kr"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="kr"&gt;double&lt;/span&gt; &lt;span class="nx"&gt;net_price&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;size_t …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;h2&gt;OOP：概述&lt;/h2&gt;
&lt;p&gt;面向对象程序设计（object-oriented programming）的核心思想是数据抽象、继承和动态绑定。&lt;/p&gt;
&lt;h3&gt;继承&lt;/h3&gt;
&lt;p&gt;通过继承（inheritance）联系在一起的类构成一种层次关系。在 C++ 语言中，基类将类型相关的函数与派生类不做改变直接继承的函数区分对待。对于某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明成虚函数（virtual function）。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;Quote&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="kr"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt; &lt;span class="nx"&gt;isbn&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="kr"&gt;const&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nx"&gt;virtual&lt;/span&gt; &lt;span class="kr"&gt;double&lt;/span&gt; &lt;span class="nx"&gt;net_price&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;size_t&lt;/span&gt; &lt;span class="nx"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;const&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;派生类必须通过使用派生列表（class derivation list）明确指出它是从哪个(哪些)基类继承而来的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;Bulk_quote&lt;/span&gt; : &lt;span class="kt"&gt;public&lt;/span&gt; &lt;span class="nx"&gt;Quote&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="kr"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="kr"&gt;double&lt;/span&gt; &lt;span class="nx"&gt;net_price&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;size_t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;override&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;派生类必须在其内部对所有重新定义的虚函数进行声明。派生类可以在这样的函数之前加上&lt;code&gt;virtual&lt;/code&gt;关键字，但是并不是非得这么做。并且，C++11 新标准允许派生类显式地注明它将使用哪个成员函数改写基类的虚函数，具体措施是在改函数的形参列表之后增加一个&lt;code&gt;override&lt;/code&gt;关键字。&lt;/p&gt;
&lt;h3&gt;动态绑定&lt;/h3&gt;
&lt;p&gt;函数的运行版本由实参决定，即在运行时选择函数的版本，所以动态绑定有时又称为运行时绑定（run-time binding）。&lt;/p&gt;
&lt;p&gt;在 C++ 语言中，当我们使用基类的引用（或指针）调用一个虚函数时将发生动态绑定。&lt;/p&gt;
&lt;h2&gt;定义基类和派生类&lt;/h2&gt;
&lt;h3&gt;定义基类&lt;/h3&gt;
&lt;p&gt;基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。&lt;/p&gt;
&lt;h4&gt;成员函数与继承&lt;/h4&gt;
&lt;p&gt;基类必须将它的两种成员函数区分开来：一种是基类希望其派生类进行覆盖的函数，基类通常将其定义为虚函数；另一种是基类希望派生类直接继承而不要改变的函数。&lt;/p&gt;
&lt;p&gt;任何构造函数之外的非静态函数都可以是虚函数，关键字&lt;code&gt;virtual&lt;/code&gt;只能出现在类内部的声明语句之前而不能用于类外部的函数定义。&lt;/p&gt;
&lt;p&gt;如果基类把一个函数声明为虚函数，则该函数在派生类中隐式地也是虚函数。&lt;/p&gt;
&lt;p&gt;成员函数如果没被声明为虚函数，则其解析过程发生在编译时而非运行时。&lt;/p&gt;
&lt;h4&gt;访问控制与继承&lt;/h4&gt;
&lt;p&gt;派生类可以继承定义在基类中的成员，但是派生类的成员函数不一定有权访问从基类继承而来的成员。&lt;strong&gt;派生类能访问公有成员，而不能访问私有成员。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不过在某些时候，基类中还有一种成员，基类希望它的派生类有权访问该成员，同时禁止其他用户访问。我们用受保护的（protected）访问运算符说明这样的成员。&lt;/p&gt;
&lt;h3&gt;定义派生类&lt;/h3&gt;
&lt;h4&gt;派生类中的虚函数&lt;/h4&gt;
&lt;p&gt;派生类经常（但不总是）覆盖它继承的虚函数。如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为类似于其他的普通成员，派生类会直接继承其在基类中的版本。&lt;/p&gt;
&lt;p&gt;C++ 新标准允许派生类显式地注明它使用某个成员函数覆盖了它继承的虚函数。具体做法是在函数后面加上关键字&lt;code&gt;override&lt;/code&gt;。&lt;/p&gt;
&lt;h4&gt;派生类对象及派生类向基类的类型转换&lt;/h4&gt;
&lt;p&gt;在派生类对象中含有与其基类对应的组成部分，所以我们能把派生类的对象当成基类对象来使用，而且我们也能将基类的指针或引用绑定到派生类对象中的基类部分上。&lt;/p&gt;
&lt;p&gt;这种转换通常称为派生类到基类的(derived-to-base)类型转换。和其他类型转换一样，编译器会隐式地执行这种转换。&lt;/p&gt;
&lt;p&gt;在派生类对象中含有与其基类对应的组成部分，这一事实是继承的关键所在。&lt;/p&gt;
&lt;h4&gt;派生类构造函数&lt;/h4&gt;
&lt;p&gt;派生类并不能直接初始化这些从基类继承来的成员，派生类必须使用基类的构造函数来初始化它的基类部分。&lt;/p&gt;
&lt;p&gt;每个类控制它自己的成员初始化过程。&lt;/p&gt;
&lt;p&gt;除非我们特别指出，否则派生类对象的基类部分会向数据成员一样执行默认初始化。如果想使用其他的基类构造函数，就需要以类名加圆括号内的实参列表的形式为构造函数提供初始值。&lt;/p&gt;
&lt;p&gt;首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员。&lt;/p&gt;
&lt;h4&gt;派生类使用基类的成员&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;派生类可以访问基类的共有成员和受保护的成员。&lt;/strong&gt;&lt;/p&gt;
&lt;h4&gt;继承与静态成员&lt;/h4&gt;
&lt;p&gt;如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。不论从基类中派生出来多少个派生类，对于每个静态成员来说都只存在唯一的实例。&lt;/p&gt;
&lt;p&gt;静态成员遵循通用的访问控制规则，如果基类中的成员是&lt;code&gt;private&lt;/code&gt;的，则派生类无权访问它。假设某静态成员是可访问的，则我们既能通过基类也能通过派生类使用它。&lt;/p&gt;
&lt;h4&gt;派生类的声明&lt;/h4&gt;
&lt;p&gt;派生类的声明与其他类型差别不大，声明中包含类名但不包含它的派生列表：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;Bulk_quote&lt;/span&gt; : &lt;span class="kt"&gt;public&lt;/span&gt; &lt;span class="nx"&gt;Quote&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;//错误&lt;/span&gt;
&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;Bulk_quote&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="c1"&gt;//正确&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;被用作基类的类&lt;/h4&gt;
&lt;p&gt;如果我们想要将某个类用作基类，则该类必须已经定义而非仅仅声明。这一规定的原因显而易见：派生类中包含并且可以使用它从基类继承而来的成员，为了使用这些成员，派生类当然要知道它们是什么。因此这一规定还有一层隐含的含义，即一个类不能派生它本身。&lt;/p&gt;
&lt;h4&gt;防止继承的发生（final）&lt;/h4&gt;
&lt;p&gt;C++11 新标准提供了一种防止继承发生的方法，即在类名后跟一个关键字&lt;code&gt;final&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;NoDerived&lt;/span&gt; &lt;span class="kr"&gt;final&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="cm"&gt;/* */&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt; &lt;span class="c1"&gt;//NoDerived 不能作为基类&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;类型转换与继承&lt;/h3&gt;
&lt;p&gt;理解基类和派生类之间的类型转换是理解 C++ 语言面向对象编程的关键所在。&lt;/p&gt;
&lt;p&gt;我们可以将基类的指针或引用绑定到派生类对象上。和内置指针一样，智能指针类也支持派生类向基类的类型转换，这意味着我们可以将一个派生类对象的指针存储在一个基类的智能指针内。&lt;/p&gt;
&lt;h4&gt;静态类型与动态类型&lt;/h4&gt;
&lt;p&gt;静态类型在编译时总是已知的，动态类型则是变量或表达式表示的内存中的对象的类型，动态类型直到运行时才可知。&lt;/p&gt;
&lt;p&gt;基类的指针或引用的静态类型可能与其动态类型不一致。&lt;/p&gt;
&lt;p&gt;如果表达式既不是引用也不是指针，则它的动态类型永远与静态类型一致。&lt;/p&gt;
&lt;p&gt;不存在从基类向派生类的隐式类型转换。&lt;/p&gt;
&lt;p&gt;在对象之间不存在类型转换：派生类向基类的自动类型转换只能对指针或引用类型有效，在派生类类型和基类类型之间不存在这样的转换。&lt;/p&gt;
&lt;p&gt;当我们用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中基类部分会被拷贝、移动或赋值，它的派生类部分将被忽略掉。&lt;/p&gt;
&lt;h2&gt;虚函数&lt;/h2&gt;
&lt;p&gt;我们必须为每一个虚函数都提供定义，而不管它是否被用到，这是因为连编译器也无法确定到底会使用哪个虚函数。&lt;/p&gt;
&lt;h3&gt;对虚函数的调用可能在运行时才被解析&lt;/h3&gt;
&lt;p&gt;必须搞清楚的一点是，动态绑定只有当我们通过指针或者引用调用虚函数才会发生。&lt;/p&gt;
&lt;p&gt;OOP 的核心思想是多态性（polymorphism）。我们把具有继承关系的多个类型称为多态类型。引用或指针的静态类型与动态类型不同这一事实正是 C++ 语言支持多态性的根本所在。&lt;/p&gt;
&lt;h3&gt;派生类中的虚函数&lt;/h3&gt;
&lt;p&gt;一旦某个函数被声明为虚函数，则在所有派生类中它都是虚函数。&lt;/p&gt;
&lt;p&gt;一个派生类的函数如果覆盖了某个继承来的虚函数，则它的形参类型必须与被覆盖的基类函数完全一致。该规则有一个例外，当类的虚函数返回类型是类本身的指针或引用时，派生类的虚函数可以返回派生类的指针或引用，只要求从派生类到基类的类型转换是可访问的。&lt;/p&gt;
&lt;h3&gt;final 和 override 说明符&lt;/h3&gt;
&lt;p&gt;C++11 新标准中我们可以使用&lt;code&gt;override&lt;/code&gt;关键字来说明派生类中的虚函数，这么做的好处是使得程序员的意图更加清晰的同时让编译器可以为我们发现一些错误。&lt;/p&gt;
&lt;p&gt;我们还能把某个函数指定为&lt;code&gt;final&lt;/code&gt;，如果我们已经把函数定义成&lt;code&gt;final&lt;/code&gt;了，则之后任何尝试覆盖该函数的操作都将引发错误。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;final&lt;/code&gt;和&lt;code&gt;override&lt;/code&gt;说明符出现在形参列表（包括任何&lt;code&gt;const&lt;/code&gt;或引用修饰符）以及尾置返回类型之后。&lt;/p&gt;
&lt;h3&gt;虚函数与默认实参&lt;/h3&gt;
&lt;p&gt;如果某次函数调用使用了默认实参，则该实参值由本次调用的&lt;strong&gt;静态类型&lt;/strong&gt;决定。如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致。&lt;/p&gt;
&lt;h3&gt;回避虚函数机制&lt;/h3&gt;
&lt;p&gt;某些情况下，我们希望对虚函数的调用不要进行动态绑定，而是强迫其执行虚函数的某个特定版本。使用作用域运算符可以实现：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="nt"&gt;强制调用基类中定义的函数版本而不管&lt;/span&gt; &lt;span class="nt"&gt;baseP&lt;/span&gt; &lt;span class="nt"&gt;的动态类型是什么&lt;/span&gt;
&lt;span class="nt"&gt;double&lt;/span&gt; &lt;span class="nt"&gt;undiscounted&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nt"&gt;baseP-&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="nt"&gt;Quote&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nd"&gt;net_price&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;42&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;该调用将在编译时完成解析。&lt;/p&gt;
&lt;h2&gt;抽象基类&lt;/h2&gt;
&lt;h3&gt;纯虚函数&lt;/h3&gt;
&lt;p&gt;我们可以将函数定义成纯虚（pure virtual）函数，这样做可以清晰明了地告诉用户这个函数是没有实际意义的。&lt;/p&gt;
&lt;p&gt;一个纯虚函数无需定义。通过在函数体的位置（声明语句的分号之前）书写&lt;code&gt;= 0&lt;/code&gt;就可以将一个虚函数说明为纯虚函数。其中&lt;code&gt;= 0&lt;/code&gt;只能出现在类内部的虚函数声明语句处：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;//用于保存折扣值和购买量的类，派生类使用这些数据可以实现不同的价格策略&lt;/span&gt;
&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;Disc_quote&lt;/span&gt; : &lt;span class="kt"&gt;public&lt;/span&gt; &lt;span class="nx"&gt;Quote&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="kr"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="nx"&gt;Disc_quote&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nx"&gt;Disc_quote&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="nx"&gt;book&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kr"&gt;double&lt;/span&gt; &lt;span class="nx"&gt;price&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                &lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;size_t&lt;/span&gt; &lt;span class="nx"&gt;qty&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kr"&gt;double&lt;/span&gt; &lt;span class="nx"&gt;disc&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
                &lt;span class="nx"&gt;Quote&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;book&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nx"&gt;price&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="nx"&gt;quantity&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;qty&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="nx"&gt;discount&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;disc&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
    &lt;span class="kr"&gt;double&lt;/span&gt; &lt;span class="nx"&gt;net_price&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;size_t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kr"&gt;protected&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="nx"&gt;std&lt;/span&gt;:&lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="nx"&gt;quantity&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;//折扣适用的购买量&lt;/span&gt;
    &lt;span class="kr"&gt;double&lt;/span&gt; &lt;span class="nx"&gt;discount&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;//表示折扣的小数值&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们也可以为纯虚函数提供定义，不过函数体必须定义在类的外部。&lt;/p&gt;
&lt;h3&gt;含有纯虚函数的类是抽象基类&lt;/h3&gt;
&lt;p&gt;含有（或未经覆盖直接继承）纯虚函数的类是抽象基类（abstruct base class）。&lt;/p&gt;
&lt;p&gt;抽象基类负责定义接口，而后续的其他类可以覆盖该接口。&lt;/p&gt;
&lt;p&gt;我们不能创建抽象基类的对象。&lt;/p&gt;
&lt;p&gt;派生类构造函数只初始化它的直接基类&lt;/p&gt;
&lt;h3&gt;重构&lt;/h3&gt;
&lt;p&gt;重构负责重新设计类的体系以便将操作和/或数据从一个类移动到另一个类中。对于面向对象的应用程序来说，重构是一种很普遍的现象。&lt;/p&gt;
&lt;h2&gt;访问控制与继承&lt;/h2&gt;
&lt;h3&gt;受保护的成员&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;protected&lt;/code&gt;说明符可以看做是&lt;code&gt;public&lt;/code&gt;和&lt;code&gt;private&lt;/code&gt;中和后的产物：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;和私有成员类似，受保护的成员对于类的用户来说是不可访问的&lt;/li&gt;
&lt;li&gt;和公有成员类似，受保护的成员对于派生类的成员和友元来说是可访问的&lt;/li&gt;
&lt;li&gt;派生类的成员或友元只能通过派生类对象来访问基类的受保护成员。派生类对于一个基类对象中的受保护成员没有任何访问特权&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了便于理解第（3）条，请看如下示例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;Base&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="kr"&gt;protected&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="nx"&gt;prot_mem&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="c1"&gt;//protected 成员&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;Sneaky&lt;/span&gt; : &lt;span class="kt"&gt;public&lt;/span&gt; &lt;span class="nx"&gt;Base&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;friend&lt;/span&gt; &lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="nx"&gt;clobber&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;Sneaky&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   &lt;span class="c1"&gt;//能访问 Sneaky::prot_mem&lt;/span&gt;
    &lt;span class="nx"&gt;friend&lt;/span&gt; &lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="nx"&gt;clobber&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;Base&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;//不能访问 Base::prot_mem&lt;/span&gt;
    &lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="nx"&gt;j&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;//j默认是private&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="c1"&gt;//正确：clobber 能访问 Sneaky 对象的 private 和 protected 成员&lt;/span&gt;
&lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="nx"&gt;clobber&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;Sneaky&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nx"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;j&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;s&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;prot_mem&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="c1"&gt;//错误：clobber 不能访问 Base 的 protected 成员&lt;/span&gt;
&lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="nx"&gt;clobber&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;Base&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="nx"&gt;b&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;prot_mem&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;理解下面两点很重要：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在类内部，类成员函数可访问类的任何一个成员（&lt;code&gt;public&lt;/code&gt;，&lt;code&gt;pirvate&lt;/code&gt;，&lt;code&gt;protected&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;但是，在类的外部（比如 main 函数中），类的&lt;code&gt;pirvate&lt;/code&gt;成员不管是对该类的对象还是该类派生类的对象，都是无访问权限的&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;公有、私有和受保护继承&lt;/h3&gt;
&lt;p&gt;某个类对其继承而来的成员的访问权限受到两个因素影响：一是在基类中该成员的访问说明符，二是在派生类的派生列表中的访问说明符。三种不同的继承方式下的基类特性和派生类特性：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;继承方式&lt;/th&gt;
&lt;th align="left"&gt;public&lt;/th&gt;
&lt;th align="left"&gt;public&lt;/th&gt;
&lt;th align="left"&gt;private&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;公有继承&lt;/td&gt;
&lt;td align="left"&gt;public&lt;/td&gt;
&lt;td align="left"&gt;protected&lt;/td&gt;
&lt;td align="left"&gt;不可见&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;私有继承&lt;/td&gt;
&lt;td align="left"&gt;private&lt;/td&gt;
&lt;td align="left"&gt;private&lt;/td&gt;
&lt;td align="left"&gt;不可见&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;保护继承&lt;/td&gt;
&lt;td align="left"&gt;protected&lt;/td&gt;
&lt;td align="left"&gt;protected&lt;/td&gt;
&lt;td align="left"&gt;不可见&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;派生类向基类转换的可访问性&lt;/h3&gt;
&lt;p&gt;假定 D 继承自 B：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只有当 D 公有地继承 B 时，用户代码才能使用派生类向基类的转换；如果 D 继承 B 的方式是受保护的或者私有的，则用户代码不能使用该转换&lt;/li&gt;
&lt;li&gt;不论 D 以什么方式继承 B，D 的成员函数和友元都是使用派生类向基类的转换：派生类向其直接基类的类型转换对于派生类的成员和友元来说永远是可访问的&lt;/li&gt;
&lt;li&gt;如果 D 继承 B 的方式是公有或者受保护的，则 D 的派生类的成员和友元可以使用 D 向 B 的类型转换；反之，如果 D 继承 B 的方式是私有的，则不能使用&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;友元与继承&lt;/h3&gt;
&lt;p&gt;就像友元关系不能传递一样，友元关系也不能继承。每个类负责控制各自成员的访问权限。&lt;/p&gt;
&lt;h3&gt;改变个别成员的可访问性&lt;/h3&gt;
&lt;p&gt;有时我们需要改变派生类继承的某个名字的访问级别，通过使用&lt;code&gt;using&lt;/code&gt;声明可以达到这一目的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;Base&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="kr"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;size_t&lt;/span&gt; &lt;span class="nx"&gt;size&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kr"&gt;protected&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;size_t&lt;/span&gt; &lt;span class="nx"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;Derived&lt;/span&gt; : &lt;span class="kt"&gt;private&lt;/span&gt; &lt;span class="nx"&gt;Base&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;//注意 private 继承&lt;/span&gt;
&lt;span class="kr"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="c1"&gt;//保持对象尺寸相关的成员的访问级别&lt;/span&gt;
    &lt;span class="nx"&gt;using&lt;/span&gt; &lt;span class="nx"&gt;Base&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kr"&gt;protected&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="nx"&gt;using&lt;/span&gt; &lt;span class="nx"&gt;Base&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;派生类只能为那些它可以访问的名字提供&lt;code&gt;using&lt;/code&gt;声明。&lt;/p&gt;
&lt;h2&gt;继承中的类作用域&lt;/h2&gt;
&lt;p&gt;每个类定义自己的作用域，在这个作用域内我们定义类的成员。当存在继承关系时，派生类的作用域在其基类的作用域之内。如果一个名字在派生类作用域内无法正确解析，则编译器将继续在外层的基类作用域中寻找该名字的定义。&lt;/p&gt;
&lt;p&gt;在编译时进行名字查找。&lt;/p&gt;
&lt;h3&gt;名字冲突与继承&lt;/h3&gt;
&lt;p&gt;派生类能重用定义在其基类或间接基类中的名字，此时定义在内层作用域（即派生类）的名字将隐藏定义在外层作用域（即基类）的名字。&lt;/p&gt;
&lt;h3&gt;通过作用域运算符来使用隐藏的成员&lt;/h3&gt;
&lt;p&gt;我们可以通过作用域运算符来使用一个被隐藏的基类成员。&lt;/p&gt;
&lt;p&gt;&lt;img alt="名字查找先于类型检查" src="https://xutree.github.io/images/c++15-1.jpg"&gt;&lt;/p&gt;
&lt;h3&gt;名字查找先于类型检查&lt;/h3&gt;
&lt;p&gt;如前所述，声明在内层作用域的函数并不会重载声明在外层作用域的函数。同理，定义在派生类中的函数也不会重载其基类中的成员。如果派生类的成员与基类的某个成员同名，则派生类将在其作用域内隐藏（非重载）该基类成员。即使它们的形参列表不一致，基类成员也会被隐藏掉。&lt;/p&gt;
&lt;h3&gt;虚函数与作用域&lt;/h3&gt;
&lt;p&gt;假如基类与派生类的虚函数接受的实参不同，则我们就无法通过基类的引用或指针调用派生类的虚函数了。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;Base&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="kr"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="nx"&gt;virtual&lt;/span&gt; &lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="nx"&gt;fcn&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;D1&lt;/span&gt; : &lt;span class="kt"&gt;public&lt;/span&gt; &lt;span class="nx"&gt;Base&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="kr"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="c1"&gt;//隐藏基类的 fcn，这个 fcn 不是虚函数&lt;/span&gt;
    &lt;span class="c1"&gt;//D1 继承了 Base::fcn() 的定义&lt;/span&gt;
    &lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="nx"&gt;fcn&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;int&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   &lt;span class="c1"&gt;//形参列表与 Base 中的 fcn 不一致&lt;/span&gt;
    &lt;span class="nx"&gt;virtual&lt;/span&gt; &lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="nx"&gt;f2&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  &lt;span class="c1"&gt;//是一个新的虚函数，在 Base 中不存在&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;D2&lt;/span&gt; : &lt;span class="kt"&gt;public&lt;/span&gt; &lt;span class="nx"&gt;D1&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="kr"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="nx"&gt;fcn&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;int&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   &lt;span class="c1"&gt;//是一个非虚函数，隐藏了 D1::fcn(int)&lt;/span&gt;
    &lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="nx"&gt;fcn&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  &lt;span class="c1"&gt;//覆盖了 Base 的虚函数 fcn&lt;/span&gt;
    &lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="nx"&gt;f2&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  &lt;span class="c1"&gt;//覆盖了 D1 的虚函数 f2&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;通过基类调用隐藏的虚函数&lt;/h3&gt;
&lt;p&gt;基于上述定义的类，我们看下面的代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Base bobj;
D1 d1obj;
D2 d2obj;

Base *bp1 = &amp;amp;bobj, *bp2 = d1obj, *bp3 = d2obj;
bp1-&amp;gt;fcn(); //虚调用，将在运行时调用 Base::fcn
bp2-&amp;gt;fcn(); //虚调用，将在运行时调用 Base::fcn
bp3-&amp;gt;fcn(); //虚调用，将在运行时调用 D2::fcn
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;D1 *d1p = &amp;amp;d1obj;
D2 *d2p = &amp;amp;d2obj;

bp2-&amp;gt;f2();  //错误：Base 没有名为 f2 的成员
d1p-&amp;gt;f2();  //虚调用，将在运行时调用 D1::f2()
d2p-&amp;gt;f2();  //虚调用，将在运行时调用 D2::f2()
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Base *p1 = &amp;amp;d2obj;
D1 *p2 = &amp;amp;d2obj;
D2 *p3 = &amp;amp;d2obj;

p1-&amp;gt;fcn(42);    //错误：Base中 没有接受一个 int 的 fcn
p2-&amp;gt;fcn(42);    //静态绑定，调用 D1::fcn(int)
p3-&amp;gt;fcn(42);    //静态绑定，调用 D2::fcn(int)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;基类指针指向派生类对象，则调用基类中的成员函数（该类中无虚函数，实现静态绑定）。&lt;/p&gt;
&lt;p&gt;若想让基类指针调用派生类中的成员，则需将该成员函数声明为虚函数（实现动态绑定）。&lt;/p&gt;
&lt;h2&gt;构造函数与拷贝控制&lt;/h2&gt;
&lt;h3&gt;虚析构函数&lt;/h3&gt;
&lt;p&gt;继承关系对基类拷贝控制最直接的影响是基类通常应该定义一个虚析构函数，这样我们就能动态分配继承体系中的对象了。&lt;/p&gt;
&lt;p&gt;如前所述，当我们&lt;code&gt;delete&lt;/code&gt;一个动态分配对象的指针时将执行析构函数。如果该指针指向继承体系中的某个类型，则可能出现指针的静态类型与被删除对象的动态类型不符的情况。通过在基类中将析构函数定义成虚函数以确保执行正确的析构函数版本：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;Quote&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="kr"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="c1"&gt;//如果我们删除的是一个指向派生类对象的基类指针，则需要虚析构函数&lt;/span&gt;
    &lt;span class="nx"&gt;virtual&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="nx"&gt;Quote&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//动态绑定析构函数&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;和其他虚函数一样，析构函数的虚属性也会被继承。只要基类的析构函数是虚函数，就能确保当我们&lt;code&gt;delete&lt;/code&gt;基类指针时将运行正确的析构函数版本：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Quote *itemP = new Quote;   //静态类型与动态类型一致
delete itemP;   //调用 Quote 的析构函数
itemP = new Bulk_quote; //静态类型与动态类型不一致
delete itemP;   //调用 Bulk_quote 的析构函数
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果基类的析构函数不是虚函数，则&lt;code&gt;delete&lt;/code&gt;一个指向派生类对象的基类指针将产生未定义的行为。&lt;/p&gt;
&lt;h4&gt;虚析构函数将阻止合成移动操作&lt;/h4&gt;
&lt;p&gt;如果一个类定义了析构函数，即使它通过&lt;code&gt;= default&lt;/code&gt;的形式使用了合成的版本，编译器也不会为这个类合成移动操作。&lt;/p&gt;
&lt;h3&gt;合成拷贝控制与继承&lt;/h3&gt;
&lt;h4&gt;派生类中删除的拷贝控制与基类的关系&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;如果基类中的默认构造函数、拷贝控制函数、拷贝赋值运算符或析构函数是被删除的或者不可访问，则派生类中对应的成员将是被删除的，原因是编译器不能使用基类成员来执行派生类对象基类部分的构造、赋值或销毁操作&lt;/li&gt;
&lt;li&gt;如果在基类中有一个不可访问或删除掉的析构函数，则派生类中合成的默认和拷贝构造函数将是被删除的，因为编译器无法销毁派生类对象的基类部分&lt;/li&gt;
&lt;li&gt;编译器将不会合成一个删除掉的析构函数。当我们使用&lt;code&gt;= default&lt;/code&gt;请求一个移动操作时，如果基类中的对应操作是删除的或不可访问的，那么派生类中该函数将是删除的，原因是派生类对象的基类部分不可移动。同样，如果基类的析构函数是删除的或不可访问的，则派生类的移动构造函数也将是删除的&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;B&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="kr"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="nx"&gt;B&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="nx"&gt;B&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;B&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;delete&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="c1"&gt;//其他成员，不含移动构造函数&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;D&lt;/span&gt; : &lt;span class="kt"&gt;public&lt;/span&gt; &lt;span class="nx"&gt;B&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;//没有声明任何构造函数&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="nx"&gt;D&lt;/span&gt; &lt;span class="nx"&gt;d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;//正确：D 的合成默认构造函数使用B的默认构造函数&lt;/span&gt;
&lt;span class="nx"&gt;D&lt;/span&gt; &lt;span class="nx"&gt;d2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;d&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;    &lt;span class="c1"&gt;//错误：D 的合成拷贝构造函数是被删除的&lt;/span&gt;
&lt;span class="nx"&gt;D&lt;/span&gt; &lt;span class="nx"&gt;d3&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;move&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;d&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt; &lt;span class="c1"&gt;//错误：隐式地使用 D 的被删除的拷贝构造函数&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;因为我们定义了拷贝构造函数，所以编译器不会为 B 合成一个移动构造函数。因此，我们既不能移动也不能拷贝 B 的对象。在实际编程过程中，如果在基类中没有默认、拷贝或移动构造函数，则一般情况下派生类也不会定义相应的操作。&lt;/p&gt;
&lt;h4&gt;移动操作与继承&lt;/h4&gt;
&lt;p&gt;如前所述，大多数基类都会定义一个虚析构函数。因此在默认情况下，基类通常不含有合成的移动操作，而且在它的派生类中也没有合成的移动操作。&lt;/p&gt;
&lt;p&gt;因为基类缺少移动操作会阻止派生类拥有自己的合成移动操作，所以当我们确实需要执行移动操作时应该首先在基类中进行定义。&lt;/p&gt;
&lt;h3&gt;派生类的拷贝控制成员&lt;/h3&gt;
&lt;p&gt;当派生类定义了拷贝或移动构造函数时，该操作负责拷贝或移动包括基类部分成员在内的整个对象。&lt;/p&gt;
&lt;h4&gt;定义派生类的拷贝或移动构造函数&lt;/h4&gt;
&lt;p&gt;当为派生类定义拷贝或移动构造函数时，我们通常使用对应的基类构造函数初始化对象的基类部分。在默认情况下，基类默认构造函数初始化派生类对象的基类部分。如果我们想拷贝（或移动）基类部分，则必须在派生类的构造函数初始值列表中显示地使用基类的拷贝（或移动）构造函数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;Base&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="cm"&gt;/*...*/&lt;/span&gt; &lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;D&lt;/span&gt; : &lt;span class="kt"&gt;public&lt;/span&gt; &lt;span class="nx"&gt;Base&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="kr"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="c1"&gt;//默认情况下，基类的默认构造函数初始化对象的基类部分&lt;/span&gt;
    &lt;span class="c1"&gt;//要想使用拷贝或移动构造函数，我们必须在构造函数初始值列表中&lt;/span&gt;
    &lt;span class="c1"&gt;//显示地调用该构造函数&lt;/span&gt;
    &lt;span class="nx"&gt;D&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;D&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="nx"&gt;d&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="nx"&gt;Base&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;d&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;       &lt;span class="c1"&gt;//拷贝基类成员&lt;/span&gt;
        &lt;span class="cm"&gt;/* D的成员的初始值*/&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="cm"&gt;/*...*/&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="nx"&gt;D&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;D&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="nx"&gt;d&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="nx"&gt;Base&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;move&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;d&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;     &lt;span class="c1"&gt;//移动基类成员&lt;/span&gt;
        &lt;span class="cm"&gt;/* D的成员的初始值*/&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="cm"&gt;/*...*/&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;派生类赋值运算符&lt;/h4&gt;
&lt;p&gt;与拷贝和移动构造函数一样，派生类的赋值运算符也必须显示地为其基类部分赋值：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="nt"&gt;Base&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nd"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;=(&lt;/span&gt;&lt;span class="nt"&gt;const&lt;/span&gt; &lt;span class="nt"&gt;Base&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;)&lt;/span&gt;&lt;span class="nt"&gt;不会被自动调用&lt;/span&gt;
&lt;span class="nt"&gt;D&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nt"&gt;D&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nd"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;=(&lt;/span&gt;&lt;span class="nt"&gt;const&lt;/span&gt; &lt;span class="nt"&gt;D&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nt"&gt;rhs&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Base&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   &lt;span class="err"&gt;//为基类部分赋值&lt;/span&gt;
    &lt;span class="err"&gt;//按照过去的方式为派生类的成员赋值&lt;/span&gt;
    &lt;span class="err"&gt;//酌情处理自赋值及释放已有资源等情况&lt;/span&gt;
    &lt;span class="err"&gt;return&lt;/span&gt; &lt;span class="err"&gt;*this&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;派生类析构函数&lt;/h4&gt;
&lt;p&gt;对象销毁的顺序正好与其创建顺序相反：派生类析构函数首先执行，然后是基类的析构函数。&lt;/p&gt;
&lt;h4&gt;在构造函数和析构函数中调用虚函数&lt;/h4&gt;
&lt;p&gt;如果构造函数或析构函数调用了某个虚函数，则我们应该执行与构造函数或析构函数所属类型相对应的虚函数版本。&lt;/p&gt;
&lt;h3&gt;继承的构造函数&lt;/h3&gt;
&lt;p&gt;在 C++11 新标准中，派生类能够重用其直接基类定义的构造函数。一个类只初始化它的直接基类，出于同样的原因，一个类也只继承其直接基类的构造函数。类不能继承默认、拷贝和移动构造函数。&lt;/p&gt;
&lt;p&gt;我们重新定义 Bulk_quote，令其继承 Disc_quote 类的构造函数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;Bulk_quote&lt;/span&gt; : &lt;span class="kt"&gt;public&lt;/span&gt; &lt;span class="nx"&gt;Disc_quote&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="kr"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="nx"&gt;using&lt;/span&gt; &lt;span class="nx"&gt;Disc_quote&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;Disc_quote&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="c1"&gt;//继承 Disc_quote 的构造函数&lt;/span&gt;
    &lt;span class="kr"&gt;double&lt;/span&gt; &lt;span class="nx"&gt;net_price&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;size_t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;const&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;继承的构造函数的特点&lt;/h4&gt;
&lt;p&gt;通常情况下，&lt;code&gt;using&lt;/code&gt;声明语句只是令某个名字在当前作用域可见。而当作用域构造函数时，&lt;code&gt;using&lt;/code&gt;声明语句将令编译器产生代码。对于基类的每个构造函数，编译器都生成一个与之对应的派生类构造函数。&lt;/p&gt;
&lt;p&gt;一个构造函数的&lt;code&gt;using&lt;/code&gt;声明不会改变构造函数的访问级别。&lt;/p&gt;
&lt;p&gt;一个&lt;code&gt;using&lt;/code&gt;声明语句不能指定&lt;code&gt;explicit&lt;/code&gt;或&lt;code&gt;constexpr&lt;/code&gt;。继承的构造函数的这两个性质与基类构造函数相同。&lt;/p&gt;
&lt;p&gt;当一个基类构造函数含有默认实参时，这些实参不会被继承。相反，派生类将获得多个继承的构造函数，其中每个构造函数分别省略掉一个含有默认实参的形参。&lt;/p&gt;
&lt;p&gt;大部分派生类会继承所有的基类构造函数：第一个例外，派生类可以继承一部分构造函数，而为其他构造函数定义自己的版本；第二个例外，默认、拷贝和移动构造函数不会被继承。这些构造函数按照正常规则被合成。&lt;/p&gt;
&lt;h2&gt;容器和继承&lt;/h2&gt;
&lt;p&gt;当我们使用容器存放继承体系中的对象时，通常必须采取间接存储的方式。因为不运行在容器中保存不同类型的元素，所以我们 不能把具有继承关系的多种类型的对象直接存放在容器当中。&lt;/p&gt;
&lt;p&gt;我们可以再容器中放置（智能）指针而非对象：当我们希望在容器中存放具有继承关系的对象时，我们实际上存放的通常是基类的指针（更好的选择是智能指针）。&lt;/p&gt;</content><category term="C++"></category></entry><entry><title>C++ Primer 第十四章 重载运算与类型转换</title><link href="https://xutree.github.io/pages/2018/10/20/C++_Primer_Chapter_14/" rel="alternate"></link><published>2018-10-20T20:59:28+08:00</published><updated>2018-10-20T20:59:28+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-20:/pages/2018/10/20/C++_Primer_Chapter_14/</id><summary type="html">&lt;h2&gt;基本概念&lt;/h2&gt;
&lt;p&gt;重载的运算符是具有特殊名字的函数：它们的名字由关键字&lt;code&gt;operator&lt;/code&gt;和其后要定义的运算符号共同组成。和其他函数一样，重载的运算符也包含返回类型、参数列表以及函数体。&lt;/p&gt;
&lt;p&gt;对一个运算符函数来说，它或者是类的成员，或者至少含有一个类类型的参数，这一约定意味着当运算符作用于内置类型的运算对象时，我们无法改变该运算符的含义：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//错误：不能为 int 重定义内置的运算符
int operator+(int, int);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们只能重载已存在的运算符，而无权发明新的运算符。重载运算符无法改变优先级和结合律。&lt;/p&gt;
&lt;p&gt;&lt;img alt="运算符重载表" src="https://xutree.github.io/images/c++14-1.jpg"&gt;&lt;/p&gt;
&lt;h3&gt;直接调用一个重载的运算符函数&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//一个非成员运算符函数的等价调用
data1 + data2;  //普通的表达式
operator+(data1, data2);    //等价的函数调用

//一个成员运算符函数的等价调用
data1 +=data2;  //基于“调用”的表达式
data1.operator+(data2); //等成员运算符函数的等价调用
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;选择作为成员或者非成员&lt;/h3&gt;
&lt;p&gt;当定义重载的运算符时，必须首先决定是将其声明为类的成员函数还是声明为一个普通的非成员函数。在某些时候我们别无选择，因为有的运算符必须作为成员；另一个情况下，运算符作为普通函数比作为成员更好 …&lt;/p&gt;</summary><content type="html">&lt;h2&gt;基本概念&lt;/h2&gt;
&lt;p&gt;重载的运算符是具有特殊名字的函数：它们的名字由关键字&lt;code&gt;operator&lt;/code&gt;和其后要定义的运算符号共同组成。和其他函数一样，重载的运算符也包含返回类型、参数列表以及函数体。&lt;/p&gt;
&lt;p&gt;对一个运算符函数来说，它或者是类的成员，或者至少含有一个类类型的参数，这一约定意味着当运算符作用于内置类型的运算对象时，我们无法改变该运算符的含义：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//错误：不能为 int 重定义内置的运算符
int operator+(int, int);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们只能重载已存在的运算符，而无权发明新的运算符。重载运算符无法改变优先级和结合律。&lt;/p&gt;
&lt;p&gt;&lt;img alt="运算符重载表" src="https://xutree.github.io/images/c++14-1.jpg"&gt;&lt;/p&gt;
&lt;h3&gt;直接调用一个重载的运算符函数&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//一个非成员运算符函数的等价调用
data1 + data2;  //普通的表达式
operator+(data1, data2);    //等价的函数调用

//一个成员运算符函数的等价调用
data1 +=data2;  //基于“调用”的表达式
data1.operator+(data2); //等成员运算符函数的等价调用
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;选择作为成员或者非成员&lt;/h3&gt;
&lt;p&gt;当定义重载的运算符时，必须首先决定是将其声明为类的成员函数还是声明为一个普通的非成员函数。在某些时候我们别无选择，因为有的运算符必须作为成员；另一个情况下，运算符作为普通函数比作为成员更好。下面的准则有助于选择：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;赋值(=)、下标([ ])、调用( () )和成员访问箭头(-&amp;gt;)运算符必须是成员&lt;/li&gt;
&lt;li&gt;复合赋值运算符一般来说应该是成员，但并非必须，这一点与赋值运算符略有不同&lt;/li&gt;
&lt;li&gt;改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减和解引用运算符，通常应该是成员&lt;/li&gt;
&lt;li&gt;具有对称性的运算符可能转换任意一端的运算对象，例如算术、相等性、关系和位运算符等，因此它们通常应该是普通的非成员函数&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;输入和输出运算符&lt;/h2&gt;
&lt;h3&gt;重载输出运算符 &amp;lt;&amp;lt;&lt;/h3&gt;
&lt;p&gt;通常，输出运算符的第一个形参是一个非常量&lt;code&gt;ostream&lt;/code&gt;对象的引用。之所以&lt;code&gt;ostream&lt;/code&gt;是非常量是因为向流写入内容会改变其状态；而该形参是引用是因为我们无法直接复制一个&lt;code&gt;ostream&lt;/code&gt;对象。&lt;/p&gt;
&lt;p&gt;第二个形参一般来说是一个常量的引用，该常量是我们想要打印的类类型。第二个形参是引用的原因是我们希望避免复制实参；而之所以该形参可以是常量是因为(通常情况下)打印对象不会改变对象的内容。&lt;/p&gt;
&lt;p&gt;为了与其他输出运算符保持一致，&lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt;一般要返回它的&lt;code&gt;ostream&lt;/code&gt;形参。&lt;/p&gt;
&lt;p&gt;Sales_data的输出运算符：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ostream &amp;amp;operat&amp;lt;&amp;lt; (ostream &amp;amp;os, const Sales_data &amp;amp;item)
{
    os &amp;lt;&amp;lt; item.isbn() &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; item.units_sold &amp;lt;&amp;lt; &amp;quot; &amp;quot;
        &amp;lt;&amp;lt; item.revenue &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; item.avg_price();
    return os;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;输出运算符尽量减少格式化操作通常，输出运算符应该主要负责打印对象的内容而非控制格式，输出运算符不应该打印换行符。&lt;/p&gt;
&lt;p&gt;输入输出运算符必须是非成员函数：与&lt;code&gt;iostream&lt;/code&gt;标准库兼容的输入输出运算符必须是普通的非成员函数，而不能是类的成员函数。否则，它们的左侧运算对象将是我们的类的一个对象：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Sales_data data;
data &amp;lt;&amp;lt; cout;    //如果 operator&amp;lt;&amp;lt; 是 Sales_data 的成员
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;假设输入输出运算符是某个类的成员，则它们也必须是&lt;code&gt;istream&lt;/code&gt;或&lt;code&gt;ostream&lt;/code&gt;的成员。然而，这两个类属于标准库，并且我们无法给标准库中的类添加任何成员。因此，我们必须将其定义成非成员函数。当然，&lt;code&gt;IO&lt;/code&gt;运算符通常需要读写类的非公有数据成员，所以&lt;code&gt;IO&lt;/code&gt;运算符一般被声明为友元。&lt;/p&gt;
&lt;h3&gt;重载输入运算符 &amp;gt;&amp;gt;&lt;/h3&gt;
&lt;p&gt;通常，输入运算符的第一个形参是运算符将要读取的流的引用，第二个形参是将要读入到的(非常量)对象的引用。该运算符通常会返回某个给定流的引用。第二个形参之所以是个非常量是因为输入运算符的目的就是将数据读入到这个对象中。&lt;/p&gt;
&lt;p&gt;Sales_data的输入运算符：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;istream &amp;amp;operator&amp;gt;&amp;gt;(istream &amp;amp;is, Sales_data &amp;amp;item)
{
    double price;   //不需要初始化，因为我们将先读入数据到 price，之后才使用它
    is &amp;gt;&amp;gt; item.bookNo &amp;gt;&amp;gt; item.units_sold &amp;gt;&amp;gt; price;
    if (is) //检查输入是否成功
        item.revenue = item.units_sold * price;
    else
        item = Sales_data();    //输入失败：对象被赋予默认的状态
    return is;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;输入运算符必须处理输入可能失败的情况，而输出运算符不需要。当读取操作发生错误时，输入运算符应该负责从错误中恢复。&lt;/p&gt;
&lt;h2&gt;算术和关系运算符&lt;/h2&gt;
&lt;p&gt;通常情况下，我们将算术和关系运算符定义成非成员函数以允许对左侧或右侧的运算对象进行转换。因为这些运算符一般不需要改变运算对象的状态，所以形参都是常量的引用。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Sales_data operator+(const Sales_data &amp;amp;lhs, const Sales_data &amp;amp;rhs)
{
    Sales_data sum = lhs;   //把lhs的数据成员拷贝给sum
    sum += rhs; //将rhs加到sum中
    return sum;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果类同时定义了算术运算符和相关的复合赋值运算符，则通常情况下应该使用复合赋值来实现算术运算符。&lt;/p&gt;
&lt;h3&gt;相等运算符&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;bool operator==(const Sales_data &amp;amp;lhs,const Sales_data &amp;amp;rhs)
{
    return lhs.isbn() == rhs.isbn() &amp;amp;&amp;amp;
            lhs.units_sold == rhs.units_sold &amp;amp;&amp;amp;
            lhs.revenue == rhs.revenue;
}
bool operator!=(const Sales_data &amp;amp;lhs, const Sales_data &amp;amp;rhs)
{
    return !(lhs == rhs);
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果某个类在逻辑上有相等性的含义，则该类应该定义&lt;code&gt;operator==&lt;/code&gt;，这样做可以使得用户更容易使用标准库算法来处理这个类。&lt;/p&gt;
&lt;h3&gt;关系运算符&lt;/h3&gt;
&lt;p&gt;定义了相等运算符的类也常常(但不总是)包含关系运算符。特别是，因为关联容器和一些算法要用到小于运算符，所以定义&lt;code&gt;operator&amp;lt;&lt;/code&gt;会比较有用。&lt;/p&gt;
&lt;h2&gt;赋值运算符&lt;/h2&gt;
&lt;p&gt;我们可以重载赋值运算符。不论形参 的类型是什么，赋值运算符都必须定义为成员函数。&lt;/p&gt;
&lt;h3&gt;复合赋值运算符&lt;/h3&gt;
&lt;p&gt;复合赋值运算符不非得是类的成员，不过我们还是倾向于把包括复合赋值在内的所有赋值运算都定义在类的内部。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//作为成员的二元运算符：左侧运算对象绑定到隐式地 this 指针
//假定两个对象表示的是同一本书
Sales_data&amp;amp; Sales_data::operator+=(const Sales_data &amp;amp;rhs)
{
    units_sold += rhs.units_sold;
    revenue += rhs.revenue;
    return *this;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这两类运算符都应该返回左侧运算对象的引用。&lt;/p&gt;
&lt;h2&gt;下标运算符&lt;/h2&gt;
&lt;p&gt;表示容器的类通常可以通过元素在容器中的位置访问元素，这些类一般会定义下标运算符&lt;code&gt;operator[]&lt;/code&gt;。下标运算符必须是成员函数。&lt;/p&gt;
&lt;p&gt;为了与下标的原始定义兼容，下标运算符通常以所访问元素的引用作为返回值，这样做的好处是下标可以出现在赋值运算符的任意一端。&lt;/p&gt;
&lt;p&gt;如果一个类包含下标运算符，则它通常会定义两个版本：一个返回普通引用，另一个是类的常量成员并且返回常量引用。&lt;/p&gt;
&lt;h2&gt;递增和递减运算符&lt;/h2&gt;
&lt;p&gt;C++ 语言并不要求递增和递减运算符必须的类的成员，但是因为它们改变的正好是所操作对象的状态，所以建议将其设定为成员函数。&lt;/p&gt;
&lt;p&gt;定义递增和递减运算符的应该同时定义前置后后置版本。这些运算符通常应该被定义成类的成员。&lt;/p&gt;
&lt;h3&gt;定义前置递增/递减运算符&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;StrBlobPtr&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="kr"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="c1"&gt;//递增和递减运算符&lt;/span&gt;
    &lt;span class="nx"&gt;StrBlobPtr&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="nx"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;   &lt;span class="c1"&gt;//前置运算符&lt;/span&gt;
    &lt;span class="nx"&gt;StrBlobPtr&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="nx"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="c1"&gt;//其他成员和之前版本一致&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="c1"&gt;//前置版本：返回递增/递减对象的引用&lt;/span&gt;
&lt;span class="nx"&gt;StrBlobPtr&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="nx"&gt;StrBlobPtr&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;//如果curr已经指向了容器的尾后位置，则无法递增它&lt;/span&gt;
    &lt;span class="nx"&gt;check&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;curr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;increment past end of StrBlobPtr&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="nx"&gt;curr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//将curr在当前状态下向前移动一个元素&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="nx"&gt;StrBlobPtr&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="nx"&gt;StrBlobPtr&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;//如果curr是0，则继续递减它将产生一个无效下标&lt;/span&gt;
    &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="nx"&gt;curr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//将curr在当前状态下向后移动一个元素&lt;/span&gt;
    &lt;span class="nx"&gt;check&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;curr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;decrement past begin of StrBlobPtr&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;区分前置和后置运算符&lt;/h3&gt;
&lt;p&gt;后置版本接受一个额外的(不使用)&lt;code&gt;int&lt;/code&gt;类型的形参。这个形参的唯一作用就是区分前置版本和后置版本的函数，而不是真的要在实现后置版本时参与运算。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;StrBlobPtr&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="kr"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="c1"&gt;//递增和递减运算符&lt;/span&gt;
    &lt;span class="nx"&gt;StrBlobPtr&lt;/span&gt; &lt;span class="nx"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;int&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;//后置运算符&lt;/span&gt;
    &lt;span class="nx"&gt;StrBlobPtr&lt;/span&gt; &lt;span class="nx"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;int&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="c1"&gt;//其他成员和之前版本一致&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="c1"&gt;//后置版本：递增/递减对象的值但是返回原值&lt;/span&gt;
&lt;span class="nx"&gt;StrBlobPtr&lt;/span&gt; &lt;span class="nx"&gt;StrBlobPtr&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;//此处无须检查有效性，调用前置递增运算时才需要检查&lt;/span&gt;
    &lt;span class="nx"&gt;StrBlobPtr&lt;/span&gt; &lt;span class="nx"&gt;ret&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//记录当前的值&lt;/span&gt;
    &lt;span class="o"&gt;++*&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;//向前移动一个元素，前置++需要检查递增的有效性&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;ret&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//返回之前记录的状态&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="nx"&gt;StrBlobPtr&lt;/span&gt; &lt;span class="nx"&gt;StrBlobPtr&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;//此处无须检查有效性，调用前置递减运算时才需要检查&lt;/span&gt;
    &lt;span class="nx"&gt;StrBlobPtr&lt;/span&gt; &lt;span class="nx"&gt;ret&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//记录当前值&lt;/span&gt;
    &lt;span class="o"&gt;--*&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;//向后移动一个元素，前置--需要检查递减的有效性&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;ret&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//返回之前记录的状态&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;显示地调用后置运算符&lt;/h3&gt;
&lt;p&gt;如果我们想通过函数调用的方式调用后置版本，则必须为它的整型参数传递一个值：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;StrBlobPtr p(a1);   //p 指向 a1 中的 vector
p.operator++(0);    //调用后置版本的 operator++
p.operator++();     //调用前置版本的 operator++
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;成员访问运算符&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;StrBlobPtr&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="kr"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="nx"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="kr"&gt;const&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;auto&lt;/span&gt; &lt;span class="nx"&gt;p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;check&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;curr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;dereference past end&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;p&lt;/span&gt;&lt;span class="p"&gt;)[&lt;/span&gt;&lt;span class="nx"&gt;curr&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;  &lt;span class="c1"&gt;//(*p)是对象所指的 vector&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nx"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="kr"&gt;const&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;//将实际工作委托给解引用运算符&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="nx"&gt;opreator&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="c1"&gt;//其他成员与之前的版本一致&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;解引用运算符首先检测 curr 是否仍在作用范围内，如果是，则返回 curr 所指元素的一个引用。箭头运算符不执行任何自己的操作，而是调用解引用运算符并返回解引用结果元素的地址。&lt;/p&gt;
&lt;p&gt;箭头运算符必须是类的成员，解引用运算符通常也是类的成员，尽管并非必须如此。&lt;/p&gt;
&lt;p&gt;值得注意的是，我们将这两个运算符定义成了&lt;code&gt;const&lt;/code&gt;成员，这是因为与递增和递减运算符不一样，获取一个元素并不会改变 StrBlobPtr 对象的状态。&lt;/p&gt;
&lt;h2&gt;函数调用运算符&lt;/h2&gt;
&lt;p&gt;如果类重载了函数调用运算符，则我们可以像使用函数一样使用该类的对象。&lt;/p&gt;
&lt;p&gt;举个🌰 ，下面这个名为 absInt 的&lt;code&gt;struct&lt;/code&gt;含有一个调用运算符，该运算符负责返回其参数的绝对值：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="s s-Atom"&gt;struct&lt;/span&gt; &lt;span class="s s-Atom"&gt;absInt&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="s s-Atom"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;operator&lt;/span&gt;&lt;span class="p"&gt;()(&lt;/span&gt;&lt;span class="s s-Atom"&gt;int&lt;/span&gt; &lt;span class="s s-Atom"&gt;val&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="s s-Atom"&gt;const&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="s s-Atom"&gt;return&lt;/span&gt; &lt;span class="s s-Atom"&gt;val&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="s s-Atom"&gt;?&lt;/span&gt; &lt;span class="nn"&gt;val&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="s s-Atom"&gt;val&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们使用调用运算符的方式是令一个 absInt 对象作用于一个实参列表，这一过程看起来非常像调用函数的过程：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int i = -42;
absInt absObj;  //含有函数调用运算符的对象
int ui = absObj(i); //将 i 传递给 absObj.operator()
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;函数调用运算符必须是成员函数。一个类可以定义多个不同版本的调用运算符，相互之间应该在参数数量或类型上有所区别。
如果定义了调用运算符，则该类的对象称为函数对象（function object）。&lt;/p&gt;
&lt;h3&gt;含有状态的函数对象类&lt;/h3&gt;
&lt;p&gt;和其他类一样，函数对象除了&lt;code&gt;operator()&lt;/code&gt;之外也可以包含其他成员。函数对象类通常含有一些数据成员，这些成员被用于定制调用运算符中的操作。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;PrintString&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="kr"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="nx"&gt;PrintString&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;ostream&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;o&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;cout&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kr"&gt;char&lt;/span&gt; &lt;span class="nx"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39; &amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="nx"&gt;os&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;o&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="nx"&gt;sep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;c&lt;/span&gt;&lt;span class="p"&gt;){}&lt;/span&gt;
&lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="nx"&gt;operator&lt;/span&gt;&lt;span class="p"&gt;()(&lt;/span&gt;&lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;string&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="nx"&gt;os&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="nx"&gt;s&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="nx"&gt;sep&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;
&lt;span class="kr"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="nx"&gt;ostream&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;os&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;//用于写入的目的流&lt;/span&gt;
    &lt;span class="kr"&gt;char&lt;/span&gt; &lt;span class="nx"&gt;sep&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="c1"&gt;//用于将不同输出隔开的字符&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当定义 PrintString 的对象时，对于分隔符及输出流即可以使用默认值也可以提供自己的值：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;PrintString printer;    //使用默认值，打印到 cout
printer(s); //在 cout 中打印 s，后面跟一个空格
PrintString errors(cerr, &amp;#39;\n&amp;#39;);
errors(s);  //在 cerr 中打印 s，后面跟一个换行符
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;函数对象常常作为泛型算法的实参：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//例如可以使用标准库 for_each 算法和我自己的 PrintString 类来打印容器内容
for_each(vs.begin(), vs.end(), PrintString(cerr, &amp;#39;\n&amp;#39;));
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;lambda 是函数对象&lt;/h3&gt;
&lt;p&gt;当我们编写了一个&lt;code&gt;lambda&lt;/code&gt;后，编译器将该表达式翻译成一个未命名类的未命名对象。在&lt;code&gt;lambda&lt;/code&gt;表达式产生的类中含有一个重载的函数调用运算符。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;stable_sort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;words&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="nx"&gt;words&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;end&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;
            &lt;span class="p"&gt;[](&lt;/span&gt;&lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;string&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;size&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="nx"&gt;b&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;size&lt;/span&gt;&lt;span class="p"&gt;();});&lt;/span&gt;
&lt;span class="c1"&gt;//其行为类似于下面这个类的一个未命名对象&lt;/span&gt;
&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;ShorterString&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="kr"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="nx"&gt;operator&lt;/span&gt;&lt;span class="p"&gt;()(&lt;/span&gt;&lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;string&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;s1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;string&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;s2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;const&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;s1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;size&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="nx"&gt;s2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;size&lt;/span&gt;&lt;span class="p"&gt;();}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;产生的类只有一个函数调用运算符成员它负责接受两个&lt;code&gt;string&lt;/code&gt;并比较他们的长度，它的形参列表和函数体与lambda表达式完全一样。&lt;/p&gt;
&lt;p&gt;默认情况下&lt;code&gt;lambda&lt;/code&gt;不能改变它捕获的变量。因此在默认情况下，由&lt;code&gt;lambda&lt;/code&gt;产生的类当中的函数调用运算符是一个&lt;code&gt;const&lt;/code&gt;成员函数。如果&lt;code&gt;lambda&lt;/code&gt;被声明为可变的，则调用运算符就不是&lt;code&gt;const&lt;/code&gt;的了。&lt;/p&gt;
&lt;h4&gt;表示 lambda 及相应捕获行为的类&lt;/h4&gt;
&lt;p&gt;当一个&lt;code&gt;lambda&lt;/code&gt;表达式通过引用捕获变量时，将有程序负责确保&lt;code&gt;lambda&lt;/code&gt;执行时引用所引的对象确实存在。因此编译器可以直接使用该引用而无须在&lt;code&gt;lambda&lt;/code&gt;产生的类中将其存储为数据成员。&lt;/p&gt;
&lt;p&gt;相反，通过值捕获的变量被拷贝到&lt;code&gt;lambda&lt;/code&gt;中。因此，这种&lt;code&gt;lambda&lt;/code&gt;产生的类必须为每个值捕获的变量建立对应的数据成员，同时创建构造函数，令其使用捕获的变量的值来初始化数据成员。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;lambda&lt;/code&gt;表达式产生的类不含默认构造函数、赋值构造函数及默认析构函数，它是否含有默认的拷贝/移动构造函数则通常要视捕获的数据成员类型而定。&lt;/p&gt;
&lt;h3&gt;标准库定义的函数对象&lt;/h3&gt;
&lt;p&gt;下表所列的类型定义在&lt;code&gt;functional&lt;/code&gt;头文件中：&lt;/p&gt;
&lt;p&gt;&lt;img alt="标准库定义的函数对象" src="https://xutree.github.io/images/c++14-2.jpg"&gt;&lt;/p&gt;
&lt;h4&gt;在算法中使用标准库函数对象&lt;/h4&gt;
&lt;p&gt;在默认情况下排序算法使用&lt;code&gt;operator&amp;lt;&lt;/code&gt;将序列按照升序排列。如果要执行降序排列的话，我们可以传入一个&lt;code&gt;greater&lt;/code&gt;类型的对象。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//svec 是一个 vector&amp;lt;string&amp;gt;
//传入一个临时的函数对象用于执行两个 string 对象的 &amp;gt; 比较运算
sort(svec.begin(), svec.end(), greater&amp;lt;string&amp;gt;());
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;则上面的语句将按照降序对 svec 进行排序。第三个实参是&lt;code&gt;greater&amp;lt;string&amp;gt;&lt;/code&gt;类型的一个未命名的对象。&lt;/p&gt;
&lt;p&gt;需要特别注意的是，标准库规定其函数对象对于指针同样适用。我们之前曾介绍过比较两个无关指针将产生未定义的行为，然而我们可能会希望通过比较指针的内存地址来&lt;code&gt;sort&lt;/code&gt;指针的&lt;code&gt;vector&lt;/code&gt;。直接这么做会产生未定义的行为，但是我们可以用标准库函数对象来实现：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;vector&amp;lt;string *&amp;gt; nameTable;
sort(nameTable.begin(), nameTable.end(), [] (string *a, sting *b { return a &amp;lt; b; }));   //错误
sort(nameTable.begin(), nameTable.end(), less&amp;lt;string *&amp;gt;()); //正确
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;可调用对象和 function&lt;/h3&gt;
&lt;p&gt;C++ 语言中的几种可调用对象：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函数&lt;/li&gt;
&lt;li&gt;函数指针&lt;/li&gt;
&lt;li&gt;lambda 表达式&lt;/li&gt;
&lt;li&gt;bind 创建的对象&lt;/li&gt;
&lt;li&gt;重载了函数调用运算符的类&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;与其他对象一样，可调用的对象也有类型。例如，每个&lt;code&gt;lambda&lt;/code&gt;有它自己唯一的（未命名）的类型；函数及函数指针的类型则由其返回值类型和实参类型决定。&lt;/p&gt;
&lt;p&gt;调用形式：指明了调用返回的类型以及传递给调用的实参类型。&lt;/p&gt;
&lt;h3&gt;不同类型可能具有相同的调用形式&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//普通函数
int add(int i, int j) { return i + j; }
//lambda，其产生一个未命名的函数对象类
auto mod = [] (int i, int j) { return i % j; }
//函数对象类
struct divide{
    int operator()(int denominator, int divisor){
        return denominator / divisor;
    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面的类型共享同一个调用形式：&lt;code&gt;int(int, int)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;若我们想把它们存入同一个函数表：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;map&amp;lt;string, int(*)(int, int)&amp;gt; binops;
binops.insert({&amp;quot;+&amp;quot;, add});  //正确，add 是一个指向正确类型函数的指针
binops.insert({&amp;quot;%&amp;quot;,mod});   //错误，mod 不是一个函数指针
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;标准库 function 类型&lt;/h3&gt;
&lt;p&gt;我们可以使用一个名为&lt;code&gt;function&lt;/code&gt;的新标准库类型解决上述问题，它定义在&lt;code&gt;functional&lt;/code&gt;头文件中，支持的操作如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="标准库function类型" src="https://xutree.github.io/images/c++14-3.jpg"&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;map&amp;lt;string, function&amp;lt;int(int, int)&amp;gt;&amp;gt; binops = {
    {&amp;quot;+&amp;quot;, add}, //函数指针
    {&amp;quot;-&amp;quot;, std::minus&amp;lt;int&amp;gt;()},   //标准库函数对象
    {&amp;quot;/&amp;quot;, divide()},    //未命名的 lambda
    {&amp;quot;*&amp;quot;, [] (int i, int j) { return i * j; }}, //命名了的 lambda
    {&amp;quot;%&amp;quot;, mod}};    //
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;重载的函数与 function&lt;/h4&gt;
&lt;p&gt;我们不能（直接）将重载函数的名字存入&lt;code&gt;function&lt;/code&gt;类型的对象中：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int add(int i, int j) { return i + j; }
Sales_data add(const Sales_data&amp;amp;, const Sales_data&amp;amp;);
map&amp;lt;string, function&amp;lt;int(int, int)&amp;gt;&amp;gt; binops;
binops.insert({&amp;quot;+&amp;quot;, add});  //错误，哪个 add？
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;解决上述二义性问题的一条途径是存储函数指针而非函数名字：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int (*fp)(int, int) = add;
binops.insert({&amp;quot;+&amp;quot;,fp});
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;同样，也可以使用&lt;code&gt;lambda&lt;/code&gt;来消除二义性：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;binops.insert({&amp;quot;+&amp;quot;, [] (int i, int j) { return add(i, j); }});
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;重载、类型转换与运算符&lt;/h2&gt;
&lt;h3&gt;类型转换运算符&lt;/h3&gt;
&lt;p&gt;类型转换运算符（conversion operator）是类的一种特殊成员函数，它负责将一个类类型的值转换成其他类型。一般形式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;operator type() const;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中type表示某种类型。&lt;/p&gt;
&lt;p&gt;我们不允许转换成数组或函数类型，但允许转换成指针(包括数组指针及函数指针)或引用类型。&lt;/p&gt;
&lt;p&gt;类型转换运算符既没有显示的返回类型，也没有形参，而且必须定义成类的成员函数。类型转换运算符通常不应该改变待转换对象的内容，因此，类型转换运算符一般被定义成&lt;code&gt;const&lt;/code&gt;成员。&lt;/p&gt;
&lt;h4&gt;定义含有类型转换符的类&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;SmallInt&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="kr"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="nx"&gt;SmallInt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;val&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;255&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;out_of_range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Bad SmallInt value&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="nx"&gt;operator&lt;/span&gt; &lt;span class="kr"&gt;int&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;val&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kr"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;size_t&lt;/span&gt; &lt;span class="nx"&gt;val&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;SmallInt 类既定义了向类类型的转换，也定义了从类类型向其他类型的转换。其中构造函数将算符类型的值转换成 SmallInt 对象，而类型转换运算符将 SmallInt 对象转换成&lt;code&gt;int&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;SmallInt si;
si = 4;    //首先将4隐式地转换成 SmallInt，然后调用 SmallInt::operator=
si + 3;    //首先将 si 隐式地转换成 int，然后执行整数的加法
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;尽管编译器一次只能执行一个用户定义的类型转换，但是隐式的用户定义类型转换可以置于一个标准（内置）类型转换之前或之后：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//内置类型转换将 double 实参转换为 int
SmallInt si = 3.14; //调用 SmallInt(int) 构造函数
//SmallInt 的类型转换运算符将 si 转换为 int
si + 3.14;  //内置类型转换将所得的 int 继续转换成 double
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;类型转换运算符可能产生意外结果&lt;/h4&gt;
&lt;p&gt;在实践中，类很少提供类型转换运算符。在大多数情况下，如果类型转换自动发生，用户可能会感到比较意外，而不是感到受到了帮助。然而这条经验法则存在一种例外情况：对于类来说，定义向&lt;code&gt;bool&lt;/code&gt;的类型转换还是比较普遍的现象。&lt;/p&gt;
&lt;p&gt;在 C++ 标准的早期版本中，如果类想定义一个向&lt;code&gt;bool&lt;/code&gt;的类型转换，则它常常遇到一个问题：因为&lt;code&gt;bool&lt;/code&gt;是一种算术类型，所以类类型的对象转换成&lt;code&gt;bool&lt;/code&gt;后就能被用在任何需要算术类型的上下文中。这样的类型转换可能引发意想不到的结果，特别是当&lt;code&gt;istream&lt;/code&gt;含有向&lt;code&gt;bool&lt;/code&gt;的类型转换时，下面的代码仍能编译通过：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int i = 42;
cin &amp;lt;&amp;lt; i;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;该程序试图将输出运算符作用在输入流。因为&lt;code&gt;istream&lt;/code&gt;本身没有定义&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;，所以本来这段代码应该产生错误。然而，该代码能使用&lt;code&gt;istream&lt;/code&gt;的&lt;code&gt;bool&lt;/code&gt;类型转换运算符将&lt;code&gt;cin&lt;/code&gt;转换成&lt;code&gt;bool&lt;/code&gt;，而这个&lt;code&gt;bool&lt;/code&gt;值会接着被提升成&lt;code&gt;int&lt;/code&gt;并用作内置的左移运算符的左侧运算对象。这样一来，提升后的&lt;code&gt;bool&lt;/code&gt;值（1或0）最终会被左移42个位置。这一结果显然与我们的预期大相径庭。&lt;/p&gt;
&lt;h4&gt;显示的类型转换运算符&lt;/h4&gt;
&lt;p&gt;为了防止这样的异常情况发生，C++ 11新标准引入了显示的类型转换运算符（explicit conversion operator）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;SmallInt&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="kr"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="c1"&gt;//编译器不会自动执行这一类型转换&lt;/span&gt;
    &lt;span class="nx"&gt;explicit&lt;/span&gt; &lt;span class="nx"&gt;operator&lt;/span&gt; &lt;span class="kr"&gt;int&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;val&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="c1"&gt;//其他成员与之前的版本一致&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;和显示的构造函数一样，编译器(通常)也不会将一个显式的类型转换运算符用于隐式类型转换：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;SmallInt si = 3;    //正确：SmallInt 的构造函数不是显式的
si + 3; //错误：此处需要隐式的类型转换，但类的运算符是显式的
static_cast&amp;lt;int&amp;gt;(si) + 3;   //正确：显式地请求类型转换
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;该规定存在一个例外，即如果表达式被用作条件，则编译器会将显式地类型转换自动应用于它。换句话说，当表达式出现在下列位置时，显示的类型转换将被隐式地执行：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;if&lt;/code&gt;、&lt;code&gt;while&lt;/code&gt;及&lt;code&gt;do&lt;/code&gt;语句的条件部分&lt;/li&gt;
&lt;li&gt;&lt;code&gt;for&lt;/code&gt;语句头的条件表达式&lt;/li&gt;
&lt;li&gt;逻辑非运算符(&lt;code&gt;!&lt;/code&gt;)、逻辑或(&lt;code&gt;||&lt;/code&gt;)、逻辑与(&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;)的运算对象&lt;/li&gt;
&lt;li&gt;条件表达式(&lt;code&gt;? :&lt;/code&gt;)的条件表达式&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;转换为 bool&lt;/h4&gt;
&lt;p&gt;在标准库的早期版本中，&lt;code&gt;IO&lt;/code&gt;类型定义了向&lt;code&gt;void*&lt;/code&gt;的转换规则，以避免上面提到的问题。但 C++ 11新标准通过显示的类型转换运算符实现同样的目的。&lt;/p&gt;</content><category term="C++"></category></entry><entry><title>C++ Primer 第十三章 拷贝控制</title><link href="https://xutree.github.io/pages/2018/10/20/C++_Primer_Chapter_13/" rel="alternate"></link><published>2018-10-20T16:41:10+08:00</published><updated>2018-10-20T19:14:52+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-20:/pages/2018/10/20/C++_Primer_Chapter_13/</id><summary type="html">&lt;p&gt;当定义一个类时，我们显示地或隐式地指定在此类型的对象拷贝、移动、赋值和销毁时做什么。一个类通过定义五种特殊的成员函数来控制这些操作，包括：拷贝构造函数（copy constructor）、拷贝赋值运算符（copy-assignment operator）、移动构造函数（move constructor）、移动赋值运算符（move-assignment operator）和析构函数（destructor）。&lt;/p&gt;
&lt;p&gt;拷贝和移动构造函数定义了当用同类型的另一个对象初始化本对象时做什么。&lt;/p&gt;
&lt;p&gt;拷贝和移动赋值运算符定义了将一个对象赋予同类型的另一个对象时做什么。&lt;/p&gt;
&lt;p&gt;析构函数定义了当此类型对象销毁时做什么。&lt;/p&gt;
&lt;p&gt;我们称这些操作为拷贝控制操作（copy control）。&lt;/p&gt;
&lt;h2&gt;拷贝、赋值和销毁&lt;/h2&gt;
&lt;h3&gt;拷贝构造函数&lt;/h3&gt;
&lt;p&gt;如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;Foo&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="kr"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="nx"&gt;Foo&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  &lt;span class="c1"&gt;//默认构造函数&lt;/span&gt;
    &lt;span class="nx"&gt;Foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;Foo&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;    &lt;span class="c1"&gt;//拷贝构造函数&lt;/span&gt;
    &lt;span class="c1"&gt;//...&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;拷贝构造函数的第一个参数必须是一个引用类型，虽然我们可以定义一个接受非&lt;code&gt;const&lt;/code&gt;引用的拷贝构造函数，但此参数几乎总是一个&lt;code&gt;const&lt;/code&gt;引用。拷贝构造函数在几种情况下都会被隐式地使用。因此 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;当定义一个类时，我们显示地或隐式地指定在此类型的对象拷贝、移动、赋值和销毁时做什么。一个类通过定义五种特殊的成员函数来控制这些操作，包括：拷贝构造函数（copy constructor）、拷贝赋值运算符（copy-assignment operator）、移动构造函数（move constructor）、移动赋值运算符（move-assignment operator）和析构函数（destructor）。&lt;/p&gt;
&lt;p&gt;拷贝和移动构造函数定义了当用同类型的另一个对象初始化本对象时做什么。&lt;/p&gt;
&lt;p&gt;拷贝和移动赋值运算符定义了将一个对象赋予同类型的另一个对象时做什么。&lt;/p&gt;
&lt;p&gt;析构函数定义了当此类型对象销毁时做什么。&lt;/p&gt;
&lt;p&gt;我们称这些操作为拷贝控制操作（copy control）。&lt;/p&gt;
&lt;h2&gt;拷贝、赋值和销毁&lt;/h2&gt;
&lt;h3&gt;拷贝构造函数&lt;/h3&gt;
&lt;p&gt;如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;Foo&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="kr"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="nx"&gt;Foo&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  &lt;span class="c1"&gt;//默认构造函数&lt;/span&gt;
    &lt;span class="nx"&gt;Foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;Foo&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;    &lt;span class="c1"&gt;//拷贝构造函数&lt;/span&gt;
    &lt;span class="c1"&gt;//...&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;拷贝构造函数的第一个参数必须是一个引用类型，虽然我们可以定义一个接受非&lt;code&gt;const&lt;/code&gt;引用的拷贝构造函数，但此参数几乎总是一个&lt;code&gt;const&lt;/code&gt;引用。拷贝构造函数在几种情况下都会被隐式地使用。因此，拷贝构造函数通常不应该是&lt;code&gt;explicit&lt;/code&gt;的。&lt;/p&gt;
&lt;h4&gt;合成拷贝构造函数（synthesized copy constructor）&lt;/h4&gt;
&lt;p&gt;如果我们没有为一个类定义拷贝构造函数，编译器会为我们定义一个。与合成默认构造函数不同，即使我们定义了其他构造函数，编译器也会为我们合成一个拷贝构造函数。&lt;/p&gt;
&lt;p&gt;每个成员的类型决定了它如何拷贝：对类类型成员，会使用其拷贝构造函数来拷贝；内置类型的成员则直接拷贝。Sales_data 类的合成拷贝构造函数等价于：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;Slaes_data&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="kr"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="c1"&gt;//其他成员和构造函数的定义，如前&lt;/span&gt;
    &lt;span class="c1"&gt;//与合成的拷贝构造函数等价的拷贝构造函数的声明&lt;/span&gt;
    &lt;span class="nx"&gt;Sales_data&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;Sales_data&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="kr"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt; &lt;span class="nx"&gt;bookNo&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="nx"&gt;units_sold&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kr"&gt;double&lt;/span&gt; &lt;span class="nx"&gt;revenue&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="c1"&gt;//与 Sales_data 的合成的拷贝构造函数等价&lt;/span&gt;
&lt;span class="nx"&gt;Sales_data&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;Sales_data&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;Sales_data&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;orig&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="nx"&gt;bookNo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;orig&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;bookNo&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;    &lt;span class="c1"&gt;//使用string的拷贝构造函数&lt;/span&gt;
    &lt;span class="nx"&gt;units_sold&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;orig&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;units_sold&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="err"&gt;，&lt;/span&gt;    &lt;span class="c1"&gt;//拷贝orig.units_sold&lt;/span&gt;
    &lt;span class="nx"&gt;revenue&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;orig&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;revenue&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;   &lt;span class="c1"&gt;//拷贝orig.revenue&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="c1"&gt;//空函数体&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;拷贝初始化（copy initialization）&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;string dots(10,&amp;#39;.&amp;#39;);    //直接初始化
string s(dots);     //直接初始化
string s2 = dots;   //拷贝初始化
string null_book = &amp;quot;9-999-99999-9&amp;quot;; //拷贝初始化
string nines = string(100, &amp;#39;9&amp;#39;);    //拷贝初始化
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当使用直接初始化时，我们实际上是要求编译器使用普通的函数匹配来选择与我们提供的实参最匹配的构造函数。当我们使用拷贝初始化时，我们要求编译器将右侧运算对象拷贝到正在创建的对象中，如果需要的话还要进行类型转换。&lt;/p&gt;
&lt;p&gt;拷贝初始化通常通过拷贝构造函数来完成，但是，如果一个类有一个移动构造函数，则拷贝初始化有时会使用移动构造函数而非拷贝构造函数来完成。&lt;/p&gt;
&lt;p&gt;拷贝初始化不仅在外面用=定义变量时会发生，在下列情况下也会发生：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将一个对象作为实参传递给一个非引用类型的形参&lt;/li&gt;
&lt;li&gt;从一个返回类型为非引用类型的函数返回一个对象&lt;/li&gt;
&lt;li&gt;用花括号列表初始化一个数组中的元素或一个聚合类中的成员&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;某些类类型还会对它们所分配的对象使用拷贝初始化。例如，当我们初始化标准库容器或是调用其&lt;code&gt;insert&lt;/code&gt;或&lt;code&gt;push&lt;/code&gt;成员时，容器会对其元素进行拷贝初始化。与之相对，用&lt;code&gt;emplace&lt;/code&gt;成员创建的元素都进行直接初始化。&lt;/p&gt;
&lt;h4&gt;参数和返回值&lt;/h4&gt;
&lt;p&gt;在函数调用过程中，具有非引用类型的参数要进行拷贝初始化。&lt;/p&gt;
&lt;p&gt;拷贝构造函数被用来初始化非引用类类型参数，这一特性解释了为什么拷贝构造函数自己的参数必须是引用类型。如果其参数不是引用类型，则调用永远也不会成功——为了调用拷贝构造函数，我们必须拷贝它的实参，但为了拷贝实参，我们又需要调用拷贝构造函数，如此无限循环。&lt;/p&gt;
&lt;h4&gt;拷贝初始化的限制&lt;/h4&gt;
&lt;p&gt;如前所述，如果我们使用的初始化值要求通过一个&lt;code&gt;explicit&lt;/code&gt;的构造函数来进行类型转换，那么使用拷贝初始化还是直接初始化就不是无关紧要的了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;vector&amp;lt;int&amp;gt; v1(10); //正确，直接初始化
vector&amp;lt;int&amp;gt; v2 = 10;    //错误：接受大小参数的构造函数是 explicit 的
void f(vector&amp;lt;int&amp;gt;);    //f 的参数进行拷贝初始化
f(10);  //错误：不能用一个 explicit 的构造函数拷贝一个实参
f(vector&amp;lt;int&amp;gt;(10)); //正确：从一个 int 直接构造一个临时的 vector
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;编译器可以绕过拷贝构造函数&lt;/h4&gt;
&lt;p&gt;在拷贝初始化的过程中，编译器可以（但不是必须）跳过拷贝/移动构造函数，直接创建对象。即，编译器允许将下面的代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;string null_book = &amp;quot;9-999-99999-9&amp;quot;; //拷贝初始化
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;改写为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;string null_book(&amp;quot;9-999-99999-9&amp;quot;);  //编译器略过了拷贝构造函数
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;但是，即使编译器略过拷贝/移动构造函数，但在这个程序点上，拷贝/移动构造函数必须是存在并且是可访问的（例如，不能是 private 的）。&lt;/p&gt;
&lt;h3&gt;拷贝赋值运算符&lt;/h3&gt;
&lt;p&gt;与控制其对象如何初始化一样，类也可以控制其对象如何赋值：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Sales_data trans, accum;
trans = accum;    //使用 Sales_data 的拷贝赋值运算符
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;重载赋值运算符&lt;/h4&gt;
&lt;p&gt;重载运算符本质上是函数，其名字由&lt;code&gt;operator&lt;/code&gt;关键字后接表示要定义的运算符的符号组成。因此，赋值运算符就是一个名为&lt;code&gt;operator=&lt;/code&gt;的函数。&lt;/p&gt;
&lt;p&gt;某些运算符，包括赋值运算符，必须定义为成员函数。如果一个运算符是一个成员函数，其左侧运算对象就绑定到隐式的&lt;code&gt;this&lt;/code&gt;参数。对于一个二元运算符，例如赋值运算符，其右侧运算对象作为显式参数传递。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;//拷贝赋值运算符接受一个与其所在类相同类型的参数&lt;/span&gt;
&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;Foo&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="kr"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="nx"&gt;Foo&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;Foo&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;//赋值运算符&lt;/span&gt;
    &lt;span class="c1"&gt;//...&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;为了与内置类型的赋值保持一致，赋值运算符通常返回一个指向其左侧运算对象的引用。&lt;/p&gt;
&lt;h4&gt;合成拷贝赋值运算符&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//等价于合成拷贝赋值运算符
Sales_data&amp;amp; Sales_data::operator=(const Sales_data &amp;amp;rhs)
{
    bookNo = rhs.bookNo；    //调用 string::operator=
    units_sold = rhs.units_sold;    //使用内置的 int 赋值
    revenue = rhs.revenue;  //使用内置的 double 赋值
    return *this;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;析构函数&lt;/h3&gt;
&lt;p&gt;析构函数执行与构造函数相反的操作：构造函数初始化对象的非&lt;code&gt;static&lt;/code&gt;数据成员，还可能做一些其他工作；析构函数释放对象使用的资源，并销毁对象的非&lt;code&gt;static&lt;/code&gt;数据成员。&lt;/p&gt;
&lt;p&gt;析构函数是类的一个成员函数，名字由波浪号接类名构成，没有返回值，也不接受参数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;Foo&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="kr"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="nx"&gt;Foo&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;//析构函数&lt;/span&gt;
    &lt;span class="c1"&gt;//...&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;由于析构函数不接受参数，因此它不能被重载。对一个给定类，只会有唯一一个析构函数。&lt;/p&gt;
&lt;p&gt;在一个析构函数中，首先执行函数体，然后销毁成员。成员按初始化顺序的逆序销毁。&lt;/p&gt;
&lt;p&gt;在一个析构函数中，不存在类似构造函数中初始化列表的东西来控制成员如何销毁，析构部分是隐式的。&lt;strong&gt;成员销毁时发生什么完全依赖于成员的类型。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;销毁类类型成员需要执行成员自己的析构函数。内置类型没有析构函数，因此销毁内置类型成员什么也不需要做。所以：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;隐式销毁一个内置指针类型的成员不会&lt;code&gt;delete&lt;/code&gt;它所指向的对象&lt;/li&gt;
&lt;li&gt;当指向一个对象的引用或指针离开作用域时，析构函数不会执行&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;{ //新作用域
    //p 和 p2 指向动态分配的内存
    Sales_data *p = new Sales_data; //p 是一个内置指针
    auto p2 = make_shared&amp;lt;Sales_data&amp;gt;();    //p2 是一个 shared_ptr
    Sales_data item(*p);    //拷贝构造函数将 p 拷贝到 item 中
    vector&amp;lt;Sales_data&amp;gt; vec; //局部变量
    vec.push_back(*p2); //拷贝 p2 指向的对象
    delete p;   //对 p 指向的对象进行析构函数
} //退出局部作用域；对 item、p2 和 vec 调用析构函数
  //销毁 p2 会递减其引用计数；如果引用计数为0，对象被释放
  //销毁 vec 会销毁它的元素
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;什么时候会调用析构函数&lt;/h4&gt;
&lt;p&gt;无论何时一个对象被销毁，就会自动调用其析构函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;变量在离开作用域时被销毁&lt;/li&gt;
&lt;li&gt;当一个对象被销毁时，其成员被销毁&lt;/li&gt;
&lt;li&gt;容器（无论是标准库容器还是数组）被销毁时，其元素被销毁&lt;/li&gt;
&lt;li&gt;对于动态分配的对象，当对指向它的指针应用&lt;code&gt;delete&lt;/code&gt;运算符时被销毁&lt;/li&gt;
&lt;li&gt;对于临时对象，当创建它的完整表达式结束时被销毁&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;合成析构函数（synthesized destructor）&lt;/h4&gt;
&lt;p&gt;当一个类未定义自己的析构函数时，编译器会为他定义一个合成析构函数。例如，下面的代码等价于 Sales_data 的合成析构函数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;Sales_data&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="kr"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="c1"&gt;//成员会被自动销毁，除此之外不需要做其他事情&lt;/span&gt;
    &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="nx"&gt;Sales_data() {&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="c1"&gt;//其他成员的定义，如前&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在（空）析构函数体执行完毕后，成员会被自动销毁。特别的，&lt;code&gt;string&lt;/code&gt;的析构函数会被调用，它将释放 bookNo 成员所用的内存。认识到析构函数本身并不直接销毁成员是非常重要的。成员是在析构函数体之后隐含的析构阶段中被销毁的。在整个对象销毁过程中，析构函数体是作为成员销毁步骤之外的另一部分而进行的。&lt;/p&gt;
&lt;h3&gt;三/五法则&lt;/h3&gt;
&lt;p&gt;如前所述，有三个基本操作可以控制类的拷贝操作：拷贝构造函数、拷贝赋值运算符和析构函数。而且，在新标准下，一个类还可以定义一个移动构造函数和一个移动赋值运算符。&lt;/p&gt;
&lt;h4&gt;需要析构函数的类也需要拷贝和赋值操作&lt;/h4&gt;
&lt;p&gt;当我们决定一个类是否要定义它自己版本的拷贝控制成员时，一个基本的原则是首先确定这个类是否需要一个析构函数。如果这个类需要一个自定义析构函数，我几乎可以肯定它也需要自定义拷贝构造函数和自定义拷贝赋值运算符。&lt;/p&gt;
&lt;p&gt;如果类在构造函数中分配动态内存。合成析构函数不会&lt;code&gt;delete&lt;/code&gt;一个指针数据成员。因此，此类需要定义一个析构函数来释放构造函数分配的内存。&lt;/p&gt;
&lt;h4&gt;需要拷贝操作的类也需要赋值操作，反之亦然&lt;/h4&gt;
&lt;p&gt;虽然很多类需要定义所有(或是不需要定义任何)拷贝控制成员，但某些类所要完成的工作，只需要拷贝或赋值操作，不需要析构函数。第二个基本原则：如果一个类需要一个拷贝构造函数，几乎可以肯定它也需要一个拷贝赋值运算符。反之亦然。&lt;/p&gt;
&lt;h3&gt;使用 =default&lt;/h3&gt;
&lt;p&gt;我们可以通过将拷贝控制成员定义为=default来显示地要求编译器生成合成的版本：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;Sales_data&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="kr"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="c1"&gt;//拷贝控制成员；使用default&lt;/span&gt;
    &lt;span class="nx"&gt;Sales_data&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nx"&gt;Sales_data&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;Sales_data&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nx"&gt;Sales_data&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="nx"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;Sales_data&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="nx"&gt;Sales_data&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="c1"&gt;//其他成员的定义，如前&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="nx"&gt;Sales_data&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="nx"&gt;Sales_data&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;Sales_data&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当我们在类内使用&lt;code&gt;=default&lt;/code&gt;修饰成员的声明时，合成的函数将隐式地声明为内联的。如果我们不希望合成的成员是内联函数，应该只对成员的类外定义使用&lt;code&gt;=default&lt;/code&gt;，就像对拷贝赋值运算符所做的那样。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们只能对具有合成版本的成员函数使用&lt;code&gt;=default&lt;/code&gt;(即，默认构造函数或拷贝控制成员)。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;阻止拷贝&lt;/h3&gt;
&lt;p&gt;大多数类应该定义默认构造函数、拷贝构造函数和拷贝赋值运算符，无论是隐式地还是显示地。&lt;/p&gt;
&lt;p&gt;但是，在某些情况下，定义类时必须采用某种机制阻止拷贝或赋值。例如，&lt;code&gt;iostream&lt;/code&gt;类阻止了拷贝，以避免多个对象写入或读取相同的 IO 缓冲。&lt;/p&gt;
&lt;p&gt;为了阻止拷贝，看起来可能应该不定义拷贝控制成员。但是，这种策略是无效的：如果我们的类未定义这些操作，编译器为它生成合成的版本。&lt;/p&gt;
&lt;h4&gt;定义删除的函数&lt;/h4&gt;
&lt;p&gt;在新标准下，我们可以通过将拷贝构造函数和拷贝赋值运算符定义为删除的函数（deleted function）来阻止拷贝。删除的函数是这样一种函数：我们虽然声明了它们但不能以任何方式使用它们：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;struct NoCopy{
    NoCopy() = default; //使用合成的默认构造函数
    NoCopy(const NoCopy&amp;amp;) = delete; //阻止拷贝
    NoCopy &amp;amp;operator=(const NoCopy&amp;amp;) = delete;  //阻止赋值
    ~NoCopy() = delete; //使用合成的析构函数
    //其他成员
};
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;&lt;code&gt;=delete&lt;/code&gt;通知编译器（以及我们代码的读者），我们不希望定义这些成员&lt;/li&gt;
&lt;li&gt;与&lt;code&gt;=default&lt;/code&gt;不同，&lt;code&gt;=delete&lt;/code&gt;必须出现在函数第一次声明的时候&lt;/li&gt;
&lt;li&gt;与&lt;code&gt;=default&lt;/code&gt;的另一不同之处是，我们可以对任何函数指定&lt;code&gt;=delete&lt;/code&gt;（我们只能对编译器可以合成的默认构造函数或拷贝控制成员使用&lt;code&gt;=default&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;析构函数不能是删除的成员&lt;/h4&gt;
&lt;p&gt;值得注意的是，我们不能删除析构函数。如果析构函数被删除，就无法销毁此类型的的对象了。对于析构函数已删除的类型，不能定义该类型的变量或释放指向该类型动态分配对象的指针，但是可以动态分配这种类型的对象（然而动态分配后不能释放）。&lt;/p&gt;
&lt;h4&gt;合成的拷贝控制成员可能是删除的&lt;/h4&gt;
&lt;p&gt;如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数将被定义为删除的。&lt;/p&gt;
&lt;h4&gt;private 拷贝控制&lt;/h4&gt;
&lt;p&gt;在新标准发布之前，类是通过将其拷贝构造函数和拷贝赋值运算符声明为&lt;code&gt;private&lt;/code&gt;的来阻止拷贝：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;PrivateCopy&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;//无访问说明符；接下来的成员默认为 private 的&lt;/span&gt;
    &lt;span class="c1"&gt;//拷贝控制成员是 private 的，因此普通用户代码无法访问&lt;/span&gt;
    &lt;span class="nx"&gt;PrivateCopy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;PrivateCopy&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="nx"&gt;PrivateCopy&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;PrivateCopy&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="c1"&gt;//其他成员&lt;/span&gt;
&lt;span class="kr"&gt;public&lt;/span&gt;&lt;span class="err"&gt;：&lt;/span&gt;
    &lt;span class="nx"&gt;PrivateCopy&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;//使用合成的默认构造函数&lt;/span&gt;
    &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="nx"&gt;PrivateCopy&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;//用户可以定义此类型的对象，但无法拷贝它们&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;为了阻止友元和成员函数进行拷贝，我们将这些拷贝控制成员声明为&lt;code&gt;private&lt;/code&gt;的，但并不定义它们。声明但不定义一个成员函数是合法的(例外：我们必须为每一个虚函数都提供定义，而不管它是否被用到，这是因为连编译器也无法确定到底会使用哪个虚函数)。&lt;/p&gt;
&lt;p&gt;通过声明（但不定义）&lt;code&gt;private&lt;/code&gt;的拷贝构造函数，我们可以预先阻止任何拷贝该类对象的企图：试图拷贝对象的用户代码将在编译阶段被标记为错误；成员函数或友元函数的拷贝操作将会导致链接时错误。&lt;/p&gt;
&lt;p&gt;建议：希望阻止拷贝的类应该使用&lt;code&gt;=delete&lt;/code&gt;来定义它们自己的拷贝构造函数和拷贝赋值运算符，而不应该将它们声明为&lt;code&gt;private&lt;/code&gt;的。&lt;/p&gt;
&lt;h2&gt;拷贝控制和资源管理&lt;/h2&gt;
&lt;p&gt;为了定义这些成员，我们首先必须确定此类型对象的拷贝语义。一般来说，有两种选择：可以定义拷贝操作，使类的行为看起来像一个值或者像一个指针。&lt;/p&gt;
&lt;p&gt;类的行为像一个值，意味着它应该也有自己的状态。当我们拷贝一个像值的对象时，副本和原对象是完全独立的。改变副本不会对原对象有任何影响，反之亦然；&lt;/p&gt;
&lt;p&gt;行为像指针的类则共享状态。当我们拷贝一个这种类的对象时，副本和原对象使用相同的底层数据。改变副本也会改变原对象，反之亦然。&lt;/p&gt;
&lt;h3&gt;行为像值的类&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;HasPtr&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="kr"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="nx"&gt;HasPtr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;s&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="nx"&gt;ps&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)),&lt;/span&gt;
            &lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="c1"&gt;//ps 指向的 string，每个 HasPtr 对象都有自己的拷贝&lt;/span&gt;
    &lt;span class="nx"&gt;HasPtr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;HasPtr&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;p&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
            &lt;span class="nx"&gt;ps&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;p&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;ps&lt;/span&gt;&lt;span class="p"&gt;)),&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;p&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
    &lt;span class="nx"&gt;HasPtr&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="nx"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;HasPtr&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="nx"&gt;HasPtr() {&lt;/span&gt;&lt;span class="k"&gt;delete&lt;/span&gt; &lt;span class="nx"&gt;ps&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;
&lt;span class="kr"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;ps&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;类值拷贝赋值运算符赋值运算符通常组合了析构函数和构造函数的操作：类似析构函数，赋值操作会销毁左侧运算对象的资源；类似拷贝构造函数，赋值操作会从右侧运算对象拷贝数据。&lt;/p&gt;
&lt;p&gt;本例中，通过先拷贝右侧运算对象，我们可以处理自赋值情况，并能保证异常发生时代码也是安全的。在完成拷贝后，我们释放左侧运算对象的资源，并更新指针指向新分配的&lt;code&gt;string&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;HasPtr&amp;amp; HasPtr::operator=(const HasPtr&amp;amp;rhs)
{
    auto newp = new string(*rhs.ps);    //拷贝底层 string，注意成员选择优先级大于解引用，故等价于*(rhs.ps)
    delete ps;  //释放旧内存
    ps = newp;  //从右侧运算对象拷贝数据到本对象
    i = rhs.i;
    return *this;   //返回本对象
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当你编写赋值运算符时，有两点需要记住：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果将一个对象赋予它自身，赋值运算符必须能正确工作&lt;/li&gt;
&lt;li&gt;大多数赋值运算符组合了析构函数和拷贝构造函数的工作&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当你编写一个赋值运算符时，一个好的模式是先将右侧运算对象拷贝到一个局部临时对象中。当拷贝完成后，销毁左侧运算对象的现有成员就是安全的了。一旦左侧运算对象的资源被销毁，就只剩下将数据从临时对象拷贝到左侧运算对象的成员中了。&lt;/p&gt;
&lt;p&gt;为了说明防范自赋值操作的重要性，看下面一个错误的例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//这样编写赋值运算符是错误的！
HasPtr&amp;amp; HasPtr::operator=(const HasPtr &amp;amp;rhs)
{
    delete ps;  //释放对象指向的 string
    //如果 rhs 和 *this 是同一个对象，我们就将从已释放的内存中拷贝数据！
    ps = new string(*(rhs.ps));
    i = rhs.i;
    return *this;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果 rhs 和本对象是同一个对象，&lt;code&gt;delete ps&lt;/code&gt;会释放&lt;code&gt;*this&lt;/code&gt;和 rhs 指向的&lt;code&gt;string&lt;/code&gt;。接下来，当我们在&lt;code&gt;new&lt;/code&gt;表达式中试图拷贝&lt;code&gt;*(rhs.ps)&lt;/code&gt;时，就会访问一个指向无效内存的指针，其行为和结果是未定义的。&lt;/p&gt;
&lt;h3&gt;定义行为像指针的类&lt;/h3&gt;
&lt;p&gt;对于行为类似指针的类，我们需要为其定义拷贝构造函数和拷贝赋值运算符，来拷贝指针成员本身而不是它指向的&lt;code&gt;string&lt;/code&gt;。我们的类仍然需要自己的析构函数来释放接受&lt;code&gt;string&lt;/code&gt;参数的构造函数分配的内存。但是，析构函数不能单方面地释放关联的&lt;code&gt;string&lt;/code&gt;，只有当最后一个指向&lt;code&gt;string&lt;/code&gt;的对象销毁时，才可以释放&lt;code&gt;string&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;令一个类展现类似指针的行为最好的方法是使用&lt;code&gt;shared_ptr&lt;/code&gt;来管理类中的资源。如果我们希望直接管理资源，可以使用引用计数（reference count）。下面我们不使用&lt;code&gt;shared_ptr&lt;/code&gt;而是使用引用计数来实现行为像指针的类。&lt;/p&gt;
&lt;h4&gt;引用计数&lt;/h4&gt;
&lt;p&gt;引用计数的工作方式如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;除了初始化对象之外，每个构造函数(拷贝构造函数除外)都要创建一个引用计数，用来记录有多少对象共享正在创建的对象共享状态，当创建一个对象时，引用计数为1，因为此时只有一个对象共享&lt;/li&gt;
&lt;li&gt;拷贝构造函数不分配新得引用计数器，拷贝给定对象的数据成员，包括引用计数器，拷贝构造函数递增共享的计数器，表示给定对象更的状态又被一个新用户所共享&lt;/li&gt;
&lt;li&gt;拷贝赋值运算符递减左侧运算对象的引用计数器，递增右侧对象的引用计数器，如果左侧对象的引用计数器为0，则销毁左侧对象&lt;/li&gt;
&lt;li&gt;析构函数判断引用计数是否为0，如果为0，则销毁左侧对象&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;引用计数的实现：我们假设有下面的情况：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;HasPtr h1;
HasPtr h2(h1);
HasPtr h3(h1);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;HasPtr 是一个行为像指针的类，新创建的 h1的引用计数为1，创建 h2，用 h1 初始化 h2，会递增 h1 的引用计数值，此时 h2 保存了 h1 中的引用计数，在创建 h3 的时候，递增了 h1 的引用计数值，而且我们必须做的是要更新 h2 中的引用计数值，此时无法更新 h2 中的引用计数值。因此，我们需要将引用计数保存在动态内存中，这样原对象和其他副本对象都会指向相同的计数器，这样就可以自动更新引用计数在每个共享对象中的状态。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;HasPtr&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="kr"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="c1"&gt;//构造函数分配新的 string 和新的计数器，将计数器置为1&lt;/span&gt;
    &lt;span class="nx"&gt;HasPtr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="nx"&gt;s&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;ps&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)),&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="nx"&gt;use&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;size_t&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
    &lt;span class="c1"&gt;//拷贝构造函数拷贝所以三个数据成员，并递增计数器&lt;/span&gt;
    &lt;span class="nx"&gt;HasPtr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;HasPtr&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;p&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt;  &lt;span class="nx"&gt;ps&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;p&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;ps&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;p&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="nx"&gt;use&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;p&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;use&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="o"&gt;++*&lt;/span&gt;&lt;span class="nx"&gt;use&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="nx"&gt;HasPtr&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="nx"&gt;operator&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;HasPtr&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="nx"&gt;HasPtr&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="kr"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;ps&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;size_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;use&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 引用计数&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="nx"&gt;HasPtr&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;HasPtr&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="nx"&gt;operator&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;HasPtr&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="nx"&gt;has&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="o"&gt;++*&lt;/span&gt;&lt;span class="nx"&gt;has&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;use&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//递增右侧运算对象的引用计数&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="o"&gt;--*&lt;/span&gt;&lt;span class="nx"&gt;use&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;//然后递减本对象的引用计数&lt;/span&gt;
        &lt;span class="k"&gt;delete&lt;/span&gt; &lt;span class="nx"&gt;ps&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;delete&lt;/span&gt; &lt;span class="nx"&gt;use&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="nx"&gt;ps&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;has&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;ps&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;has&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nx"&gt;use&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;has&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;use&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="nx"&gt;HasPtr&lt;/span&gt;&lt;span class="o"&gt;::~&lt;/span&gt;&lt;span class="nx"&gt;HasPtr() {&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;--*&lt;/span&gt;&lt;span class="nx"&gt;use&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;delete&lt;/span&gt; &lt;span class="nx"&gt;ps&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;delete&lt;/span&gt; &lt;span class="nx"&gt;use&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;交换操作&lt;/h2&gt;
&lt;p&gt;通常，管理资源的类除了定义拷贝控制成员之外，还会定义交换操作的函数&lt;code&gt;swap&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果一个类定义了自己的&lt;code&gt;swap&lt;/code&gt;，那么算法将使用类自定义版本，否则，将使用标准库定义的&lt;code&gt;swap&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;理论上来说，我们的&lt;code&gt;swap&lt;/code&gt;函数应该是这样的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//交换两个类值 HasPtr 对象的代码可能像下面这样：
HasPtr temp = v1;   //创建 v1 的值的一个临时副本
v1 = v2;    //将 v2 的值赋予 v1
v2 = temp;  //将保存的 v1 的值赋予 v2
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样的代码将 v1 中&lt;code&gt;string&lt;/code&gt;拷贝了两次，但是这样做是没有必要的，我们希望&lt;code&gt;swap&lt;/code&gt;交换指针，而不是分配&lt;code&gt;string&lt;/code&gt;的副本：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;string *temp = v1.ps;   //为 v1.ps 中的指针创建一个副本
v1.ps = v2.ps;  //将 v2.ps 中的指针赋予 v1.ps1
v2.ps = temp;   //将保存的 v1.ps 中原来的指针赋予 v2.ps
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;编写我们自己的 swap 函数&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;HasPtr&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;friend&lt;/span&gt; &lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="nx"&gt;swap&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;HasPtr&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;HasPtr&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="c1"&gt;//其他成员定义&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="nx"&gt;inline&lt;/span&gt; &lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="nx"&gt;swap&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;HasPtr&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;lhs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;HasPtr&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;using&lt;/span&gt; &lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nx"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;lhs&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;ps&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;ps&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   &lt;span class="c1"&gt;//交换指针，而不是string数据&lt;/span&gt;
    &lt;span class="nx"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;lhs&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;//交换 int 成员&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们首先将&lt;code&gt;swap&lt;/code&gt;定义为&lt;code&gt;friend&lt;/code&gt;以便能访问 HasPtr 的（private的）数据成员。由于&lt;code&gt;swap&lt;/code&gt;的存在就是为了优化代码，我们将其声明为&lt;code&gt;inline&lt;/code&gt;函数。&lt;/p&gt;
&lt;p&gt;与拷贝控制成员不同，&lt;code&gt;swap&lt;/code&gt;并不是必要的。但是，对于分配了资源的类，定义&lt;code&gt;swap&lt;/code&gt;可能是一种很重要的优化手段。&lt;/p&gt;
&lt;h3&gt;swap 函数应该调用 swap，而不是 std::swap&lt;/h3&gt;
&lt;p&gt;在&lt;code&gt;swap&lt;/code&gt;函数中，使用了&lt;code&gt;using std::swap&lt;/code&gt;，如果这个类有自己的&lt;code&gt;swap&lt;/code&gt;函数，匹配程度会高于标准库&lt;code&gt;swap&lt;/code&gt;，会优先使用类自己的&lt;code&gt;swap&lt;/code&gt;，如果没有，则使用标准库的&lt;code&gt;swap&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;swap&lt;/code&gt;里交换类的指针和&lt;code&gt;int&lt;/code&gt;成员，并不会发生递归循环，HasPtr 的数据成员是内置类型的，这时候会调用标准库版本的&lt;code&gt;swap&lt;/code&gt;。&lt;/p&gt;
&lt;h3&gt;在赋值运算符中使用 swap&lt;/h3&gt;
&lt;p&gt;定义&lt;code&gt;swap&lt;/code&gt;的类通常用&lt;code&gt;swap&lt;/code&gt;来定义它们的赋值运算符。这些运算符使用了一种名为拷贝并交换（copy and swap）的技术。这种技术将左侧运算对象与右侧运算对象的一个副本进行交换：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//注意 rhs 是按值传递的，意味着 HasPtr 的拷贝构造函数将
//右侧运算对象中的 string 拷贝到 rhs
HasPtr&amp;amp; HasPtr::operator=(HasPtr rhs)
{
    //交换左侧运算对象和局部变量 rhs 的内容
    swap(*this, rhs);   //rhs 现在指向本对象曾经使用的内存
    return *this;   //rhs 被销毁，从而 delete 了 rhs 中的指针
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在进行 HasPtr 类的赋值运算中，先将右侧对象拷贝到拷贝赋值运算符函数里，然后交换左侧对象的指针和右侧对象的指针，交换后，右侧对象赋值给了左侧对象，左侧对象相应的&lt;code&gt;string&lt;/code&gt;指针也指向了右侧对象副本的对应成员，而右侧对象的&lt;code&gt;string&lt;/code&gt;指针则指向了左侧对象的相应成员。在这个函数结束后，右侧对象的副本被销毁，于是原来左侧对象的资源被释放，而左侧对象现在保存的是右侧对象的成员。&lt;/p&gt;
&lt;p&gt;拷贝并交换的操作，和之前的拷贝赋值运算符的实现原理是相同的， 在改变左侧对象之前拷贝右侧对象。保证了这样的操作异常的安全。&lt;/p&gt;
&lt;h2&gt;对象移动&lt;/h2&gt;
&lt;p&gt;新标准的一个最主要的特性是可以移动而非拷贝对象的能力。在某些情况下对象拷贝后就立即被销毁了。在这些情况下，移动而非拷贝对象会大幅度提升性能。&lt;/p&gt;
&lt;p&gt;使用移动而不是拷贝的另一个原因源于&lt;code&gt;IO&lt;/code&gt;类或&lt;code&gt;unique_ptr&lt;/code&gt;这样的类。这些类都包括不能被共享的资源。因此，这些类型的对象不能拷贝但可以移动。&lt;/p&gt;
&lt;p&gt;类似的，在旧版本的标准库中，容器所保存的类必须是可拷贝的，但在新标准中，我们可以用容器保存不可拷贝的类型，只要它们能被移动就行。&lt;/p&gt;
&lt;p&gt;标准库容器、&lt;code&gt;string&lt;/code&gt;和&lt;code&gt;shared_ptr&lt;/code&gt;类既支持移动也支持拷贝。&lt;code&gt;IO&lt;/code&gt;类和&lt;code&gt;unique_ptr&lt;/code&gt;类可以移动但不能拷贝。&lt;/p&gt;
&lt;h3&gt;右值引用&lt;/h3&gt;
&lt;p&gt;为了支持移动操作，新标准引入了一种新的引用类型——右值引用（rvalue reference）。我们通过&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;而不是&lt;code&gt;&amp;amp;&lt;/code&gt;来获得右值引用。右值引用一个重要性质——只能绑定到一个将要销毁的对象。&lt;/p&gt;
&lt;p&gt;一般而言，一个左值表达式表示的是一个对象的身份，而一个右值表达式表示的是对象的值。&lt;/p&gt;
&lt;p&gt;对于常规引用(我们可以称之为左值引用)，我们不能将其绑定到要求转换的表达式、字面常量或是返回右值的表达式。右值引用有着完全相反的特性：我们可以将一个右值引用绑定到这类表达式上，但不能将一个右值引用直接绑定到一个左值上：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int i = 42;
int &amp;amp;r = i; //正确：r 引用 i
int &amp;amp;&amp;amp;rr = i;   //错误：不能将一个右值引用绑定到一个左值上
int &amp;amp;r2 = i * 42;   //错误：i * 42是一个右值
const int &amp;amp;r3 = i * 42; //正确：我们可以将一个 const 的引用绑定到一个右值上
int &amp;amp;&amp;amp;rr2 = i * 42; //正确：将 rr2 绑定到乘法结果上
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;返回左值引用的函数，连同赋值、下标、解引用和前置递增/递减运算符，都是返回左值的表达式的例子，我们可以将一个左值引用绑定到这类表达式的结果上。&lt;/p&gt;
&lt;p&gt;返回非引用类型的函数，连同算术、关系、位以及后置递增/递减运算符，都生成右值。我们不能将一个左值引用绑定到这类表达式上，但我们可以将一个&lt;code&gt;const&lt;/code&gt;的左值引用或者一个右值引用绑定到这类表达式上。&lt;/p&gt;
&lt;h4&gt;左值持久；右值短暂&lt;/h4&gt;
&lt;p&gt;由于右值引用只能绑定到临时对象，我们得知：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所引用的对象将要被销毁&lt;/li&gt;
&lt;li&gt;该对象没有其他用户&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这两个特性意味着：使用右值引用的代码可以自由地接管所引用的对象的资源。右值引用指向将要被销毁的对象。因此，我们可以从绑定到右值引用的对象“窃取”状态。&lt;/p&gt;
&lt;h4&gt;变量是左值&lt;/h4&gt;
&lt;p&gt;变量可以看作只有一个运算对象而没有运算符的表达式。变量表达式都是左值，这意味着我们不能讲一个右值引用绑定到一个右值引用类型的变量上：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int &amp;amp;&amp;amp;rr1 = 42;   //正确：字面常量是右值
it &amp;amp;&amp;amp;rr2 = rr1;   //错误：表达式 rr1 是左值！
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其实有了右值表示临时对象这一观察结果，变量是左值这一特性并不令人惊讶。毕竟，变量是持久的，直至离开作用域时才被销毁。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;变量是左值，因此我们不能将一个右值引用直接绑定到一个变量上，即使这个变量是右值引用类型也不行。&lt;/strong&gt;&lt;/p&gt;
&lt;h4&gt;标准库 move 函数&lt;/h4&gt;
&lt;p&gt;虽然不能将一个右值引用直接绑定到一个左值上，但我们可以显示地将一个左值转换为对应的右值引用类型。我们还可以通过调用一个名为&lt;code&gt;move&lt;/code&gt;的新标准库函数来获得绑定到左值上的右值引用。&lt;code&gt;move&lt;/code&gt;定义在头文件&lt;code&gt;utility&lt;/code&gt;中。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;#&lt;/span&gt;&lt;span class="nn"&gt;inclue&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;utility&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class="nt"&gt;rr3&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nt"&gt;std&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nd"&gt;move&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;rr1&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;   &lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="nt"&gt;ok&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;move&lt;/code&gt;调用告诉编译器：我们有一个左值，但我们希望像一个右值一样处理它。我们必须认识到，调用&lt;code&gt;move&lt;/code&gt;就意味承诺：除了对 rr1 赋值或销毁它外，我们将不再使用它。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们可以销毁一个移后源对象，也可以赋予它新值，但不能使用一个移后源对象的值。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对&lt;code&gt;move&lt;/code&gt;我们不提供&lt;code&gt;using&lt;/code&gt;声明。我们直接调用&lt;code&gt;std::move&lt;/code&gt;而不是&lt;code&gt;move&lt;/code&gt;。这样可以避免潜在的名字冲突。&lt;/p&gt;
&lt;h3&gt;移动构造函数和移动赋值运算符&lt;/h3&gt;
&lt;p&gt;类似&lt;code&gt;string&lt;/code&gt;类（及其他标准库类），如果我们自己的类也同时支持移动和拷贝，那么也能从中受益。这两个成员类似对应的拷贝操作，但它们从给定对象“窃取”资源而不是拷贝资源。&lt;/p&gt;
&lt;p&gt;类似拷贝构造函数，移动构造函数的第一个参数是该类类型的一个引用。不同于拷贝构造函数的是，这个引用参数在移动构造函数中是一个右值引用。与拷贝构造函数一样，任何额外的参数都必须有默认实参。&lt;/p&gt;
&lt;p&gt;除了完成资源移动，移动构造函数还必须确保移后源对象处于这样一个状态——销毁它是无害的。&lt;/p&gt;
&lt;p&gt;作为一个例子，我们为 StrVec 类定义移动构造函数，实现从一个 StrVec 到另一个 StrVec 的元素移动而非拷贝：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;StrVec::StrVec(StrVec &amp;amp;&amp;amp;s) noexcept //移动操作不应抛出任何异常
//c成员初始化器接管s中的资源
  ：elements(s.elements), first_free(s.first_free), cap(s.cap)
{
    //令s进入这样的状态———对其运行析构函数是安全的
    s.elements = s.first_free = s.cap = nullptr;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;移动操作、标准库容器和异常&lt;/h4&gt;
&lt;p&gt;由于移动操作“窃取”资源，它通常不分配任何资源。因此，移动操作通常不会抛出任何异常。一种通知标准库的方法是在我们的构造函数中指明&lt;code&gt;noexcept&lt;/code&gt;。&lt;code&gt;noexcept&lt;/code&gt;是新标准引入的。在一个构造函数中，&lt;code&gt;noexcept&lt;/code&gt;出现在参数列表被初始化列表开始的冒号之间。我们必须在类头文件声明和定义中（如果定义在类外的话）都指定&lt;code&gt;noexcept&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不抛出异常的移动构造函数和移动赋值运算符必须标记为&lt;code&gt;noexcept&lt;/code&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="为什么指定noexcept" src="https://xutree.github.io/images/c++13-1.jpg"&gt;&lt;/p&gt;
&lt;h4&gt;移动赋值运算符&lt;/h4&gt;
&lt;p&gt;移动赋值运算符执行与析构函数和移动构造函数相同的工作。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;StrVec &amp;amp;StrVec::operator=(StrVec &amp;amp;&amp;amp;rhs) noexcept
{
    //直接检测自赋值
    if (this != &amp;amp;rhs){
        free(); //释放已有元素
        elements = rhs.elements;    //从 rhs 接管资源
        first_free = rhs.first_free;
        cap = rhs.cap;
        //将 rhs 置于可析构状态
        rhs.elements = rhs.first_free = rhs.cap = nullptr;
    }
    return *this;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们进行自赋值检查的原因是此右值可能是&lt;code&gt;move&lt;/code&gt;调用的返回结果。&lt;/p&gt;
&lt;h4&gt;移后源对象必须可析构&lt;/h4&gt;
&lt;p&gt;在移动操作之后，移后源对象必须保持有效的、可析构的状态，但是用户不能对其值进行任何假设。&lt;/p&gt;
&lt;h4&gt;合成的移动操作&lt;/h4&gt;
&lt;p&gt;只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非&lt;code&gt;static&lt;/code&gt;数据成员都可以移动时，编译器才会为它合成移动构造函数或移动赋值运算符。&lt;/p&gt;
&lt;p&gt;与拷贝操作不同，移动操作永远不会隐式定义为删除的函数。但是，如果我们显示地要求编译器生成&lt;code&gt;=default&lt;/code&gt;的移动操作，且编译器不能移动所有成员，则编译器会将移动操作定义为删除的函数。&lt;/p&gt;
&lt;p&gt;移动操作和合成的拷贝控制成员之间还有最后一个相互作用关系：一个类是否定义了自己的移动操作对拷贝操作如何合成有影响。如果类定义了一个移动构造函数和/或一个移动赋值运算符，则该类的合成拷贝构造函数和拷贝赋值运算符会被定义为删除的。&lt;/p&gt;
&lt;h4&gt;移动右值，拷贝左值&lt;/h4&gt;
&lt;p&gt;如果一个类既有移动构造函数，也有拷贝构造函数，编译器使用普通的函数匹配规则来确定使用哪个构造函数。赋值操作的情况类似。&lt;/p&gt;
&lt;h4&gt;但如果没有移动构造函数，右值也被拷贝&lt;/h4&gt;
&lt;p&gt;使用拷贝构造函数代替移动构造函数几乎肯定是安全的。&lt;/p&gt;
&lt;h4&gt;拷贝并交换赋值运算符和移动操作&lt;/h4&gt;
&lt;p&gt;&lt;img alt="拷贝并交换赋值运算符和移动操作" src="https://xutree.github.io/images/c++13-2.jpg"&gt;&lt;/p&gt;
&lt;h4&gt;更新的三/五法则&lt;/h4&gt;
&lt;p&gt;一般来说，如果一个类定义了任何一个拷贝操作，它就应该定义所有五个操作。&lt;/p&gt;
&lt;h4&gt;移动迭代器&lt;/h4&gt;
&lt;p&gt;新标准库中定义了一种移动迭代器（move iterator）适配器。一个移动迭代器通过改变给定迭代器的解引用运算符的行为来适配此迭代器。一般来说，一个迭代器的解引用运算符返回一个指向元素的左值。与其他迭代器不同，移动迭代器的解引用运算符生成一个右值引用。&lt;/p&gt;
&lt;p&gt;我们通过调用标准库的&lt;code&gt;make_move_iterator&lt;/code&gt;函数将一个普通迭代器转换为一个移动迭代器。此函数接受一个迭代器参数，返回一个移动迭代器。&lt;/p&gt;
&lt;p&gt;原迭代器的所有其他操作在移动迭代器中都照常工作。由于移动迭代器支持正常的迭代器操作，我们可以将一对移动迭代器传递给算法。特别地，可以将移动迭代器传递给&lt;code&gt;uninitialized_copy&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;void StrVec::reallocate()
{
    //分配大小两倍于当前规模的内存空间
    auto newcapacity = size() ? 2 * size() : 1;
    auto first = alloc.allocate(newcapacity);
    //移动元素
    auto last = uninitialized_copy(make_move_iterator(begin()), make_move_iterator(end()), first);
    free(); //释放旧空间
    elements = first;   //更新指针
    first_free = last;
    cap = elements + newcapacity;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;不要随意使用移动操作，由于一个移后源对象具有不确定的状态，对其调用&lt;code&gt;std::move&lt;/code&gt;是危险的。当我们调用&lt;code&gt;move&lt;/code&gt;时，必须绝对确认移后源对象没有其他用户。&lt;/p&gt;
&lt;p&gt;通过在类代码中小心地使用&lt;code&gt;move&lt;/code&gt;，可以大幅度提升性能。而如果随意在普通用户代码（与类实现代码相对）中使用移动操作，很可能导致莫名其妙的、难以查找的错误，而难以提升应用程序性能。&lt;/p&gt;
&lt;h3&gt;右值引用和成员函数&lt;/h3&gt;
&lt;p&gt;除了构造函数和赋值运算符外，如果一个成员函数同时提供拷贝和移动操作，它也能从中受益。一个版本接受一个指向&lt;code&gt;const&lt;/code&gt;的左值引用，另一个版本接受指向非&lt;code&gt;const&lt;/code&gt;的右值引用。&lt;/p&gt;
&lt;p&gt;一般来说，我们不需要为函数操作定义接受一个&lt;code&gt;const X&amp;amp;&amp;amp;&lt;/code&gt;或是一个（普通的）&lt;code&gt;X&amp;amp;&lt;/code&gt;参数的版本。当我们希望从实参“窃取”数据时，通常传递一个右值引用。为了达到这一目的，实参不能是&lt;code&gt;const&lt;/code&gt;的。类似的，从一个对象进行拷贝的操作不应该改变该对象，因此，通常不需要定义一个接受（普通的）&lt;code&gt;X&amp;amp;&lt;/code&gt;参数的版本。&lt;/p&gt;
&lt;p&gt;区分移动和拷贝的重载函数通常有一个版本接受一个&lt;code&gt;const T&amp;amp;&lt;/code&gt;，而另一个版本接受&lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt;。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;StrVec&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="kr"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="nx"&gt;push_back&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;//移动元素&lt;/span&gt;
    &lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="nx"&gt;push_back&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;//拷贝元素&lt;/span&gt;
    &lt;span class="c1"&gt;//其他成员的定义&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="nx"&gt;StrVec&lt;/span&gt;:&lt;span class="kt"&gt;push_back&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="nx"&gt;s&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="nx"&gt;chk_n_alloc&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  &lt;span class="c1"&gt;//确保有空间容纳新元素&lt;/span&gt;
    &lt;span class="c1"&gt;//在 first_free 指向的元素中构造 s 的一个副本&lt;/span&gt;
    &lt;span class="nx"&gt;alloc&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="kr"&gt;constructor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;first_free&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;s&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="nx"&gt;StrVec&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;push_back&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;
    &lt;span class="nx"&gt;chk_n_alloc&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  &lt;span class="c1"&gt;//如果需要的话为 StrVec 重新分配内存&lt;/span&gt;
    &lt;span class="nx"&gt;alloc&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="kr"&gt;constructor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;first_free&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;move&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;s&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;constructor&lt;/code&gt;函数使用第二个和随后的实参类型来确定使用哪个构造函数。由于&lt;code&gt;move&lt;/code&gt;返回一个右值引用，因此，会使用&lt;code&gt;string&lt;/code&gt;的移动构造函数来构造新元素。&lt;/p&gt;
&lt;h4&gt;左值和右值引用成员函数&lt;/h4&gt;
&lt;p&gt;&lt;img alt="左值和右值引用成员函数" src="https://xutree.github.io/images/c++13-3.jpg"&gt;&lt;/p&gt;
&lt;h4&gt;重载和引用函数&lt;/h4&gt;
&lt;p&gt;就像一个成员函数可以根据是否有&lt;code&gt;const&lt;/code&gt;来区分其重载版本一样，引用限定符也可以区分重载版本。而且，我们可以综合引用限定符和&lt;code&gt;const&lt;/code&gt;来区分一个成员函数的重载版本。&lt;/p&gt;
&lt;p&gt;当我们定义&lt;code&gt;const&lt;/code&gt;成员函数时，可以定义两个版本，唯一的差别是一个版本有&lt;code&gt;const&lt;/code&gt;限定而另一个没有。引用限定的函数则不一样。如果我们定义两个或两个以上具有相同名字和相同参数列表的成员函数，就必须对所有函数都加上引用限定符，或者所有都不加。&lt;/p&gt;</content><category term="C++"></category></entry><entry><title>C++ Primer 第十二章 动态内存</title><link href="https://xutree.github.io/pages/2018/10/17/C++_Primer_Chapter_12/" rel="alternate"></link><published>2018-10-17T22:25:02+08:00</published><updated>2018-10-20T14:50:55+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-17:/pages/2018/10/17/C++_Primer_Chapter_12/</id><summary type="html">&lt;p&gt;一个由 C/C++ 编译的程序占用的内存分为以下几个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;栈区（stack）：由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈&lt;/li&gt;
&lt;li&gt;堆区（heap）：一般由程序员分配释放，若程序员不释放，程序结束时可能由 OS 回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表&lt;/li&gt;
&lt;li&gt;全局区（静态区）（static）：全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量、未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放&lt;/li&gt;
&lt;li&gt;文字常量区：常量字符串就是放在这里的。程序结束后由系统释放&lt;/li&gt;
&lt;li&gt;程序代码区：存放函数体的二进制代码&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;动态内存与智能指针&lt;/h2&gt;
&lt;p&gt;在 C++ 中，动态内存的管理是通过一对运算符来完成的：&lt;code&gt;new&lt;/code&gt;，在动态内存中为对象分配空间并返回一个指向该对象的指针，我们可以选择对对象进行初始化；&lt;code&gt;delete&lt;/code&gt;，接受一个动态指针，销毁该对象，并释放与之关联的内存。&lt;/p&gt;
&lt;p&gt;为了更容易地使用动态内存，新的标准提供了两种智能指针(smart pointer)类型来管理动态对象。&lt;code&gt;shared_ptr …&lt;/code&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;一个由 C/C++ 编译的程序占用的内存分为以下几个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;栈区（stack）：由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈&lt;/li&gt;
&lt;li&gt;堆区（heap）：一般由程序员分配释放，若程序员不释放，程序结束时可能由 OS 回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表&lt;/li&gt;
&lt;li&gt;全局区（静态区）（static）：全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量、未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放&lt;/li&gt;
&lt;li&gt;文字常量区：常量字符串就是放在这里的。程序结束后由系统释放&lt;/li&gt;
&lt;li&gt;程序代码区：存放函数体的二进制代码&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;动态内存与智能指针&lt;/h2&gt;
&lt;p&gt;在 C++ 中，动态内存的管理是通过一对运算符来完成的：&lt;code&gt;new&lt;/code&gt;，在动态内存中为对象分配空间并返回一个指向该对象的指针，我们可以选择对对象进行初始化；&lt;code&gt;delete&lt;/code&gt;，接受一个动态指针，销毁该对象，并释放与之关联的内存。&lt;/p&gt;
&lt;p&gt;为了更容易地使用动态内存，新的标准提供了两种智能指针(smart pointer)类型来管理动态对象。&lt;code&gt;shared_ptr&lt;/code&gt;允许多个指针指向同一个对象；&lt;code&gt;unique_ptr&lt;/code&gt;则“独占”所指向的对象。标准库还定义了一个名为&lt;code&gt;weak_ptr&lt;/code&gt;的伴随类，指向&lt;code&gt;shared_ptr&lt;/code&gt;所管理的对象。这三种类型都定义在&lt;code&gt;memory&lt;/code&gt;头文件中。&lt;/p&gt;
&lt;h3&gt;shared_ptr 类&lt;/h3&gt;
&lt;p&gt;类似&lt;code&gt;vector&lt;/code&gt;智能指针也是模板：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;shared_ptr&amp;lt;string&amp;gt; p1;  //shared_ptr，可以指向 string
shared_ptr&amp;lt;list&amp;lt;int&amp;gt;&amp;gt; p2;   //shared_ptr,可以指向 int 的 list
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当我们创建&lt;code&gt;shared_ptr&lt;/code&gt;时，可以传递一个（可选的）指向删除器函数的参数。&lt;/p&gt;
&lt;p&gt;智能指针操作：&lt;/p&gt;
&lt;p&gt;&lt;img alt="智能指针操作" src="https://xutree.github.io/images/c++12-1.jpg"&gt;&lt;/p&gt;
&lt;h4&gt;make_shared 函数&lt;/h4&gt;
&lt;p&gt;最安全的分配和使用动态内存的方法是调用一个名为&lt;code&gt;make_shared&lt;/code&gt;的标准库函数。此函数在动态内存中分配一个对象并初始化它，返回指向此对象的&lt;code&gt;shared_ptr&lt;/code&gt;。与智能指针一样，&lt;code&gt;make_shared&lt;/code&gt;也定义在&lt;code&gt;memory&lt;/code&gt;头文件中。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//指向一个值为42的 int 的 shared_ptr
shared_ptr&amp;lt;int&amp;gt; p3 = make_shared&amp;lt;int&amp;gt;(42);
//p4 指向一个值为”999999999”的 string
shared_ptr&amp;lt;string&amp;gt; p4 = make_shared&amp;lt;string&amp;gt;(10,&amp;#39;9&amp;#39;);
//p5 指向一个值初始化的 int，即，值为0
shared_ptr&amp;lt;int&amp;gt; p5 = make_shared&amp;lt;int&amp;gt;();
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;类似顺序容器的&lt;code&gt;emplace&lt;/code&gt;成员，&lt;code&gt;make_shared&lt;/code&gt;用其参数来构造给定类型的对象。例如，调用&lt;code&gt;make_shared&amp;lt;string&amp;gt;&lt;/code&gt;时传递的参数必须与&lt;code&gt;string&lt;/code&gt;的某个构造函数相匹配。&lt;/p&gt;
&lt;p&gt;当然，我们通常用&lt;code&gt;auto&lt;/code&gt;定义一个对象来保存&lt;code&gt;make_shared&lt;/code&gt;的结果，这种方式简单：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//p6 指向一个动态分配的空 vector&amp;lt;string&amp;gt;
auto p6 = make_shared&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt;();
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;shared_ptr 的拷贝和赋值&lt;/h4&gt;
&lt;p&gt;当进行拷贝或赋值操作时，每个&lt;code&gt;shared_ptr&lt;/code&gt;都会记录有多少个其他&lt;code&gt;shared_ptr&lt;/code&gt;指向相同的对象。&lt;/p&gt;
&lt;p&gt;我们可以认为每个&lt;code&gt;shared_ptr&lt;/code&gt;都有一个关联的计数器，通常称其为引用计数(reference count)。无论何时我们拷贝一个&lt;code&gt;shared_ptr&lt;/code&gt;，计数器都会递增；当我们给&lt;code&gt;shared_ptr&lt;/code&gt;赋予一个新值或是&lt;code&gt;shared_ptr&lt;/code&gt;被销毁时，计算器就会递减。
一旦一个&lt;code&gt;shared_ptr&lt;/code&gt;的计数器变为0，它就会自动释放自己所管理的对象。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;auto r = make_shared&amp;lt;int&amp;gt;(42);  //r 指向的 int 只有一个引用者
r = q;  //给 r 赋值，令它指向另一个地址
    //递增 q 指向的对象的引用计数
    //递减 r 原来指向对象的引用计数
    //r 原来指向的对象已没有引用者，会自动释放
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;shared_ptr&lt;/code&gt;自动销毁所管理的对象，还会自动释放相关联的内存。&lt;/p&gt;
&lt;p&gt;如果你将&lt;code&gt;shared_ptr&lt;/code&gt;存放于一个容器中，而后不再需要全部元素，要记得使用&lt;code&gt;erase&lt;/code&gt;删除不需要的那些元素，否则&lt;code&gt;shared_ptr&lt;/code&gt;在无用之后会仍然保留。&lt;/p&gt;
&lt;h3&gt;直接管理内存&lt;/h3&gt;
&lt;p&gt;C++ 语言定义了两个运算符来分配和释放动态内存。运算符&lt;code&gt;new&lt;/code&gt;分配内存，&lt;code&gt;delete&lt;/code&gt;释放&lt;code&gt;new&lt;/code&gt;分配的内存。相对于智能指针，使用这两个运算符管理内存非常容易出错。&lt;/p&gt;
&lt;h4&gt;使用 new 动态分配和初始化对象&lt;/h4&gt;
&lt;p&gt;在自由空间分配的内存是无名的，因此&lt;code&gt;new&lt;/code&gt;无法为其分配的对象命名，而是返回一个指向该对象的指针：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int *pi = new int;    //pi 指向一个动态分配的、未初始化的无名对象
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;默认情况下，动态分配的对象是默认初始化的，这意味着内置类型或组合类型的对象的值将是未定义的，而类类型对象将用默认构造函数进行初始化：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;string *ps = new string;    //初始化为空 string
int *pi = new int;  //pi 指向一个未初始化的 int

//可以使用直接初始化方式来初始化一个动态分配的对象
int *pi = new int(1024);    //pi 指向的对象的值为1024
string *ps = new string(10,&amp;#39;9&amp;#39;);    //*ps 为“999999999”
//vector 有10个元素，值依次从0到9
vector&amp;lt;int&amp;gt; *pv = new vector&amp;lt;int&amp;gt;{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;也可以对动态分配的对象进行值初始化，只需在类型名之后跟一对空括号即可：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;string *ps1 = new string;   //默认初始化为空 string
string *ps = new string();  //值初始化为空 string
int *pi1 = new int;     //默认初始化；*pi1 的值未定义
int *pi2 = new int();       //值初始化为0；*pi2 为0
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果我们提供了一个括号包围的初始化器，就可以用&lt;code&gt;auto&lt;/code&gt;从此初始化器推断我们想要分配的对象的类型。但是由于编译器要用初始化器类型来推断分配的类型，只有当括号中仅有单一初始化器时才可以使用&lt;code&gt;auto&lt;/code&gt;（这也意味着不能用&lt;code&gt;auto&lt;/code&gt;动态分配数组）。&lt;/p&gt;
&lt;h4&gt;动态分配的 const 对象&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//分配并初始化一个 const int
const int *pci = new const int(1024);
//分配并默认初始化一个 const 的空 string
const string *pcs =new const string;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;类似其他任何&lt;code&gt;const&lt;/code&gt;对象，一个动态分配的&lt;code&gt;const&lt;/code&gt;对象必须进行初始化。对于一个定义了默认构造函数的类类型，其&lt;code&gt;const&lt;/code&gt;动态对象可以隐式初始化，而其他类型的对象就必须显式初始化。由于分配的对象是&lt;code&gt;const&lt;/code&gt;的，&lt;code&gt;new&lt;/code&gt;返回的指针是一个指向&lt;code&gt;const&lt;/code&gt;的指针。&lt;/p&gt;
&lt;h4&gt;内存耗尽&lt;/h4&gt;
&lt;p&gt;默认情况下，如果&lt;code&gt;new&lt;/code&gt;不能分配所要求的内存空间，它会抛出一个类型为&lt;code&gt;bad_alloc&lt;/code&gt;的异常。我们可以改变使用&lt;code&gt;new&lt;/code&gt;的方式来阻止它抛出异常：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//若果分配失败，new返回一个空指针
int *p1 = new int;  //如果分配失败，new 抛出std::bad_alloc
int *p2 = new (nothrow) int;    //如果分配失败，new 返回一个空指针
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们称这种形式的&lt;code&gt;new&lt;/code&gt;为定位&lt;code&gt;new&lt;/code&gt;，&lt;code&gt;bad_alloc&lt;/code&gt;和&lt;code&gt;nothrow&lt;/code&gt;都定义在&lt;code&gt;new&lt;/code&gt;头文件中。&lt;/p&gt;
&lt;h4&gt;释放动态内存&lt;/h4&gt;
&lt;p&gt;为了防止内存耗尽，在动态内存使用完毕后，必须将其归还给系统。我们通过&lt;code&gt;delete&lt;/code&gt;表达式(delete expression)来将动态内存归还给系统。&lt;/p&gt;
&lt;p&gt;与&lt;code&gt;new&lt;/code&gt;类似，&lt;code&gt;delete&lt;/code&gt;表达式也执行两个动作：销毁给定的指针指向的对象；释放对应的内存。在&lt;code&gt;delete&lt;/code&gt;之后，指针就变成了人们所说的空悬指针，即指向一块曾经保存数据对象但现在已经无效的内存的指针。如果需要保留指针，可以在&lt;code&gt;delete&lt;/code&gt;之后将&lt;code&gt;nullptr&lt;/code&gt;赋予指针。&lt;/p&gt;
&lt;h4&gt;使用 new 和 delete 管理动态内存存在的三个常见问题&lt;/h4&gt;
&lt;p&gt;忘记&lt;code&gt;delete&lt;/code&gt;内存。忘记释放动态内存会导致人们常说的“内存泄露”问题，因为这种内存永远不可能归还给自由空间了。查找内存泄露错误是非常困难的。&lt;/p&gt;
&lt;p&gt;使用已经释放掉的对象。通过在释放内存后将指针置为空，有时可以检测出这种错误。&lt;/p&gt;
&lt;p&gt;同一块内存释放两次。当两个指针指向相同的动态分配对象时，可能发生这种错误。&lt;/p&gt;
&lt;h3&gt;shared_ptr 和 new 结合使用&lt;/h3&gt;
&lt;p&gt;如前所述，如果我们不初始化一个智能指针，他就会被初始化为一个空指针。如下表所示，我们还可以用&lt;code&gt;new&lt;/code&gt;返回的指针来初始化智能指针：&lt;/p&gt;
&lt;p&gt;&lt;img alt="智能指针其他操作" src="https://xutree.github.io/images/c++12-2.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="智能指针其他操作" src="https://xutree.github.io/images/c++12-3.jpg"&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;shared_ptr&amp;lt;double&amp;gt; p1;  //shared_ptr 可以指向一个 double
shared_ptr&amp;lt;int&amp;gt; p2(new int (42));   //p2 指向一个值为42的 int
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;接受指针参数的智能指针构造函数是&lt;code&gt;explicit&lt;/code&gt;的。因此，我们不能将一个内置指针隐式转换为一个智能指针，必须使用直接初始化形式来初始化一个智能指针：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;shared_ptr&amp;lt;int&amp;gt; p1 = new int(1024); //错误：必须使用直接初始化形式
shared_ptr&amp;lt;int&amp;gt; p2(new int (1024)); //正确：使用了直接初始化
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;出于相同的原因，一个返回&lt;code&gt;shared_ptr&lt;/code&gt;的函数不能在其返回语句中隐式转换一个普通指针：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;shared_ptr&amp;lt;int&amp;gt; clone(int p){
    return new int(p);  //错误：隐式转换为 shared_ptr&amp;lt;int&amp;gt;
}
//我们必须将 shared_ptr 显式绑定到一个想要返回的指针上：
shared_ptr&amp;lt;int&amp;gt; clone(int p){
    //正确：显式地用 int* 创建 shared_ptr&amp;lt;int&amp;gt;
    return shared_ptr&amp;lt;int&amp;gt;(new int(p));
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;默认情况下，一个用来初始化智能指针的普通指针必须指向动态内存，因为智能指针默认使用&lt;code&gt;delete&lt;/code&gt;释放它所关联的对象。&lt;/p&gt;
&lt;p&gt;不要混合使用普通指针和智能指针：&lt;/p&gt;
&lt;p&gt;&lt;img alt="不要混合使用普通指针和智能指针" src="https://xutree.github.io/images/c++12-4.jpg"&gt;&lt;/p&gt;
&lt;p&gt;也不要使用get初始化另一个智能指针或为智能指针赋值：&lt;/p&gt;
&lt;p&gt;&lt;img alt="不要使用get初始化另一个智能指针或为智能指针赋值" src="https://xutree.github.io/images/c++12-5.jpg"&gt;&lt;/p&gt;
&lt;h3&gt;unique_ptr 指针&lt;/h3&gt;
&lt;p&gt;一个&lt;code&gt;unique_ptr&lt;/code&gt;“拥有”它所指向的对象。与&lt;code&gt;shared_ptr&lt;/code&gt;不同，某个时刻只能有一个&lt;code&gt;unique_ptr&lt;/code&gt;指向一个给定对象。&lt;/p&gt;
&lt;p&gt;与&lt;code&gt;shared_ptr&lt;/code&gt;不同，没有类似&lt;code&gt;make_shared&lt;/code&gt;的标准库函数返回一个&lt;code&gt;unique_ptr&lt;/code&gt;。当我们定义一个&lt;code&gt;unique_ptr&lt;/code&gt;时，需要将其绑定到一个&lt;code&gt;new&lt;/code&gt;返回的指针上。类似&lt;code&gt;shared_ptr&lt;/code&gt;，初始化&lt;code&gt;unique_ptr&lt;/code&gt;必须采用直接初始化形式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;unique_ptr&amp;lt;double&amp;gt; p1;  //可以指向一个 double 的 unique_ptr
unique_ptr&amp;lt;int&amp;gt; p2(new int(42));    //p2 指向一个值为42的 int
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;由于一个&lt;code&gt;unique_ptr&lt;/code&gt;拥有它指向的对象，因此&lt;code&gt;unique_ptr&lt;/code&gt;不支持普通的拷贝或赋值操作：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;unique_ptr&amp;lt;string&amp;gt; p1(new string(&amp;quot;Stegosaurus&amp;quot;);
unique_ptr&amp;lt;string&amp;gt; p2(p1);  //错误：unique_ptr 不支持拷贝
unique_ptr&amp;lt;string&amp;gt; p3;
p3 = p2;    //错误：unique_ptr 不支持赋值
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;unique_ptr&lt;/code&gt;特有的操作：&lt;/p&gt;
&lt;p&gt;&lt;img alt="unique_ptr特有的操作" src="https://xutree.github.io/images/c++12-6.jpg"&gt;&lt;/p&gt;
&lt;p&gt;虽然我不能拷贝或赋值&lt;code&gt;unique_ptr&lt;/code&gt;，但可以通过调用&lt;code&gt;release&lt;/code&gt;或&lt;code&gt;reset&lt;/code&gt;将指针的所有权从一个（非&lt;code&gt;const&lt;/code&gt;）&lt;code&gt;unique_ptr&lt;/code&gt;转移给另一个&lt;code&gt;unique&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//将所有权从 p1（指向 string Stegosaurus）转移给 p2
unique_ptr&amp;lt;string&amp;gt; p2(p1.release());    //release 将 p1 置为空
unique_ptr&amp;lt;string&amp;gt; p3(new string(&amp;quot;Trex&amp;quot;));
//将所有权从 p3 转移给 p2
p2.reset(p3.release()); //reset 释放了 p2 原来指向的内存
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;调用&lt;code&gt;release&lt;/code&gt;会切断&lt;code&gt;unique_ptr&lt;/code&gt;和它原来管理的对象间的联系。&lt;code&gt;release&lt;/code&gt;返回的指针通常被用来初始化另一个智能指针或给另一个智能指针赋值。&lt;/p&gt;
&lt;h4&gt;传递 unique_ptr 参数和返回 unique_ptr&lt;/h4&gt;
&lt;p&gt;不能拷贝&lt;code&gt;unique_ptr&lt;/code&gt;的规则有一个例外：我们可以拷贝或赋值一个将要被销毁的&lt;code&gt;unique_ptr&lt;/code&gt;。最常见的例子是从函数返回一个&lt;code&gt;unique_ptr&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;unique_ptr&amp;lt;int&amp;gt; clone(int p){
    //正确：从int*创建一个unique_ptr&amp;lt;int&amp;gt;
    return unique_ptr&amp;lt;int&amp;gt;(new int(p));
}
//还可以返回一个局部对象的拷贝
unique_ptr&amp;lt;int&amp;gt; clone(int p){
    unique_ptr&amp;lt;int&amp;gt; ret(new int(p));
    //...
    return ret;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;对于两段代码，编译器都知道要返回的对象将要销毁。在此情况下，编译器执行一种特殊的“拷贝”。&lt;/p&gt;
&lt;h4&gt;向 unique_ptr 传递删除器&lt;/h4&gt;
&lt;p&gt;类似&lt;code&gt;shared_ptr&lt;/code&gt;，&lt;code&gt;unique_ptr&lt;/code&gt;默认情况下用&lt;code&gt;delete&lt;/code&gt;释放它指向的对象。与&lt;code&gt;shared_ptr&lt;/code&gt;一样，我们可以重载一个&lt;code&gt;unique_ptr&lt;/code&gt;中默认的删除器。与重载关联容器的比较操作类似，我们必须在尖括号中&lt;code&gt;unique_ptr&lt;/code&gt;指向类型之后提供删除器类型。在创建或&lt;code&gt;reset&lt;/code&gt;一个这种&lt;code&gt;unique_ptr&lt;/code&gt;类型对象时，必须提供一个指定类型的可调用对象（删除器）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//p指向一个类型为 objT 的对象，并使用一个类型为 delT 的对象释放 objT 对象
//它会调用一个名为 fcn 的 delT 类型对象
unique_ptr&amp;lt;objT, delT&amp;gt; p(new objT,fcn);

//作为一个更具体的例子，我们将重写连接程序，用 unique_ptr 代替 shared_ptr
void f(destination &amp;amp;d /*其他需要的参数*/)
{
    connection c = connect(&amp;amp;d); //打开连接
    //当 p 被销毁时，连接将会关闭
    unique_ptr&amp;lt;connection, decltype(end_connection)*&amp;gt;
        p(&amp;amp;c, end_connection);
    //使用连接
    //当 f 退出时，connection 会被正确关闭
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;weak_ptr&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;weak_ptr&lt;/code&gt;是一种不控制所指向对象生存期的智能指针，它指向由一个&lt;code&gt;shared_ptr&lt;/code&gt;管理的对象。将一个&lt;code&gt;weak_ptr&lt;/code&gt;绑定到一个&lt;code&gt;shared_ptr&lt;/code&gt;不会改变&lt;code&gt;shared_ptr&lt;/code&gt;的引用计数。&lt;/p&gt;
&lt;p&gt;一旦最后一个指向对象的&lt;code&gt;shared_ptr&lt;/code&gt;被销毁，对象就会被释放，即使有&lt;code&gt;weak_ptr&lt;/code&gt;指向对象。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;weak_ptr&lt;/code&gt;操作：&lt;/p&gt;
&lt;p&gt;&lt;img alt="weak_ptr操作" src="https://xutree.github.io/images/c++12-7.jpg"&gt;&lt;/p&gt;
&lt;p&gt;当创建一个&lt;code&gt;weak_ptr&lt;/code&gt;时，要用一个&lt;code&gt;shared_ptr&lt;/code&gt;来初始化它：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;auto p = make_shared&amp;lt;int&amp;gt;(42);
weak_ptr&amp;lt;int&amp;gt; wp(p);    //wp 弱共享 p；p 的引用计数未改变
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;由于对象可能不存在，我们不能使用&lt;code&gt;weak_ptr&lt;/code&gt;直接访问对象，而必须调用&lt;code&gt;lock&lt;/code&gt;。此函数检查&lt;code&gt;weak_ptr&lt;/code&gt;指向的对象是否存在。&lt;/p&gt;
&lt;h2&gt;动态数组&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;new&lt;/code&gt;和&lt;code&gt;delete&lt;/code&gt;运算符一次分配/释放一个对象，但某些应用需要一次为很多对象分配内存的功能。为了支持这种需求，C++ 语言和标准库提供了两种一次分配一个对象数组的方法。C++ 语言定义了一种&lt;code&gt;new&lt;/code&gt;表达式，可以分配并初始化一个对象数组。
标准库中包含一个名为&lt;code&gt;allocator&lt;/code&gt;的类，允许我们将分配和初始化分离。使用&lt;code&gt;allocator&lt;/code&gt;通常会提供更好的性能和更灵活的内存管理能力。&lt;/p&gt;
&lt;p&gt;大多数应用应该使用标准库容器而不是动态分配的数组。使用容器更为简单、更不容易出现内存管理错误并且可能有更好的性能。&lt;/p&gt;
&lt;h3&gt;new 和数组&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//调用 get_size 确定分配多少个 int
int *pia = new int[get_size];   //pia 指向第一个 int
//方括号中的大小必须是整型，但不必是常量
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;typedef int arrT[42];   //arrT 表示42个 int 的数组类型
int *p = new arrT;  //
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;分配一个数组会得到一个元素类型的指针&lt;/h4&gt;
&lt;p&gt;虽然我们通常称&lt;code&gt;new T[]&lt;/code&gt;分配的内存为“动态数组”，但这种叫法某种程度上有些误导。当用&lt;code&gt;new&lt;/code&gt;分配一个数组时，我们并未得到一个数组类型的对象，而是得到一个数组元素类型的指针。&lt;/p&gt;
&lt;p&gt;由于分配的内存并不是一个数组类型，因此不能对动态数组调用&lt;code&gt;begin&lt;/code&gt;和&lt;code&gt;end&lt;/code&gt;。这些函数使用数组维度来返回指向首元素和尾元素的指针。处于相同的原因，也不能用范围&lt;code&gt;for&lt;/code&gt;语句来处理（所谓的）动态数组中的元素。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;要记住我们所说的动态数组并不是数组类型，这是很重要的。&lt;/strong&gt;&lt;/p&gt;
&lt;h4&gt;初始化动态分配对象的数组&lt;/h4&gt;
&lt;p&gt;默认情况下，&lt;code&gt;new&lt;/code&gt;分配的对象，不管是单个分配的还是数组中的，都是默认初始化的。可以对数组中的元素进行值初始化，方法是在大小之后跟一对空括号。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int *pia = new int[10]; //10个未初始化的 int
int *pia2 = new int[10]();  //10个值初始化为0的 int
string *psa = new string[10];   //10个空 string
string *psa2 = new string[10]();    //10个空 string
//在新标准中，我们还提供一个元素初始化器的花括号列表：
//10个 int 分别用列表中对应的初始化器初始化
int *pia3 = new int[10] {0,1,2,3,4,5,6,7,8,9};
//10个 string，前4个用给定的初始化器初始化，剩余的进行值初始化
string *psa3 = new string[10]{&amp;quot;a&amp;quot;, &amp;quot;an&amp;quot;, &amp;quot;the&amp;quot;, string(3,&amp;#39;x&amp;#39;)};
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果初始化器数目大于元素数目，则&lt;code&gt;new&lt;/code&gt;表达式失败，不会分配任何内存，并抛出&lt;code&gt;bad_array_new_length&lt;/code&gt;的异常，类似于&lt;code&gt;bad_alloc&lt;/code&gt;，此类型定义在头文件&lt;code&gt;new&lt;/code&gt;中。&lt;/p&gt;
&lt;h4&gt;动态分配一个空数组是合法的&lt;/h4&gt;
&lt;p&gt;我们在使用&lt;code&gt;new&lt;/code&gt;分配一个动态数组时，可以指定分配数组的大小为0，这样做是合法的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;char *pc = new char(0);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;此时&lt;code&gt;new&lt;/code&gt;返回一个与其他&lt;code&gt;new&lt;/code&gt;表达式返回类型都不同的指针类型， 该指针不能解引用，就像一个数组的尾后迭代器一样。&lt;/p&gt;
&lt;h4&gt;释放动态数组&lt;/h4&gt;
&lt;p&gt;为了释放动态数组，我们使用一种特殊形式的&lt;code&gt;delete&lt;/code&gt;——在指针前加上一个空括号对：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;delete p;    //p 必须指向一个动态分配的对象或为空
delete [] pa;  //pa 必须指向一个动态分配的数组或为空
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;第二条语句销毁 pa 指向的数组中的元素，并释放对应的内存。数组中的元素按逆序销毁，即，最后一个元素首先被销毁，然后是倒数第二个，以此类推。&lt;/p&gt;
&lt;p&gt;当我们释放一个动态数组时，空方括号是必须的，它指示编译器此指针指向一个对象数组的第一个元素。 &lt;code&gt;delete&lt;/code&gt;一个动态数组时未添加空方括号或&lt;code&gt;delete&lt;/code&gt;一个普通指针时添加了空方括号，其行为都是未定义的。&lt;/p&gt;
&lt;p&gt;前面我们讲到， 可以使用&lt;code&gt;typedef&lt;/code&gt;来给动态数组起一个别名，这样在&lt;code&gt;new&lt;/code&gt;一个动态数组时就不必添加方括号&lt;code&gt;[]&lt;/code&gt;，即使这样，我们在释放一个动态数组时，仍然需要添加方括号&lt;code&gt;[]&lt;/code&gt;，因为它本质上还是一个动态数组。&lt;/p&gt;
&lt;h4&gt;智能指针和动态数组&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;unique_ptr&lt;/code&gt;智能指针有个可以管理&lt;code&gt;new&lt;/code&gt;分配的动态数组的版本，为了使用一个&lt;code&gt;unique_ptr&lt;/code&gt;来管理动态数组，需要在对象类型后加一个空方括号&lt;code&gt;[]&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;unique_ptr&amp;lt;int[]&amp;gt; up(new int[10]());
up.release(); // 自动调用 delete [] 销毁其指针
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当一个&lt;code&gt;unique_ptr&lt;/code&gt;指向一个数组时，我们不能使用点和箭头成员运算符，毕竟，&lt;code&gt;unique_ptr&lt;/code&gt;指向的是一个数组而不是单个对象。不过，我们可以使用下表运算符来访问数组中的元素：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;for (size_t i = 0; i &amp;lt; 10; ++i)
    up[i] = i;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;shared_ptr&lt;/code&gt;不支持动态数组，如果希望使用&lt;code&gt;shared_ptr&lt;/code&gt;管理一个动态数组，我们需要提供自己的删除器：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;shared_ptr&amp;lt;int&amp;gt; sp(new int[10], [](int* p){ delete [] p; });
sp.reset();
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们在这个例子中使用&lt;code&gt;lambda&lt;/code&gt;做为&lt;code&gt;shared_ptr&lt;/code&gt;的删除器，如果我们不提供删除器，这样的行为是未定义的，因为默认情况下&lt;code&gt;shared_ptr&lt;/code&gt;使用&lt;code&gt;delete&lt;/code&gt;来释放内存，使用&lt;code&gt;delete&lt;/code&gt;来释放一个动态数组的定位是未定义的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;shared_ptr&lt;/code&gt;不支持动态数组这一特性会影响我们访问数组中的元素：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;for (size_t i = 0; i != 10; ++i)
    *(sp.get() + i) = i;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;shared_ptr&lt;/code&gt;没有定义下标运算符，而且智能指针不支持指针算术运算。因此，为了访问数组中的元素，我们必须用&lt;code&gt;get&lt;/code&gt;成员函数获取一个内置指针，然后使用该内置指针来访问数租元素。&lt;/p&gt;
&lt;h3&gt;allocator 类&lt;/h3&gt;
&lt;p&gt;标准库&lt;code&gt;allocator&lt;/code&gt;类定义在头文件&lt;code&gt;memory&lt;/code&gt;中。它帮助我们将内存分配和构造分离开来，它分配的内存是原始的、未构造的。&lt;/p&gt;
&lt;p&gt;类似&lt;code&gt;vector&lt;/code&gt;，&lt;code&gt;allocator&lt;/code&gt;也是一个模板类，我们在定义一个&lt;code&gt;allocator&lt;/code&gt;类类型的时候需要制定它要分配内存的类型，它会根据给定的对象类型来确定恰当的内存大小和对齐位置：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;allocator&amp;lt;string&amp;gt; alloc;
auto const p = alloc.allocate(n); // 分配 n 个未初始化的 string
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;allocator&lt;/code&gt;类及其算法：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;操作&lt;/th&gt;
&lt;th align="left"&gt;意义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;allocator&lt;T&gt; a&lt;/td&gt;
&lt;td align="left"&gt;定义了一个名为 a 的 allocator 对象，可以为类型为 T 的对象分配内存&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;a.allocate(n)&lt;/td&gt;
&lt;td align="left"&gt;分配一段原始的、未构造的内存，保存 n 个类型为 T 的对象&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;a.deallocate(p, n)&lt;/td&gt;
&lt;td align="left"&gt;释放从 T* 指针 p 中地址开始的内存，这块内存保存了 n 个类型为 T 的对象；p 必须是一个先前由 allocate 成员函数返回的指针，且 n 必须是创建时候的大小，在调用 deallocate 之前，用户必须对每个在在这块内存中创建的对象调用 destroy 函数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;a.construct(p, args)&lt;/td&gt;
&lt;td align="left"&gt;p 必须是一个类型为 T* 的指针，指向一块原始内存，args 被传递给类型为 T 的构造函数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;a.destroy(p)&lt;/td&gt;
&lt;td align="left"&gt;p 为 T* 类型的指针，此算法对 p 执行析构函数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4&gt;allocator 分配未构造的内存&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;auto q = p; //q 指向最后构造的元素之后的位置
alloc.construct(q++);   //*q 为空字符串
alloc.construct(q++, 10, &amp;#39;c&amp;#39;);  //*q 为cccccccccc
alloc.construct(q++, &amp;quot;hi&amp;quot;); //*q 为hi
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;为了使用&lt;code&gt;allocate&lt;/code&gt;返回的内存，我们必须用&lt;code&gt;construct&lt;/code&gt;构造对象。使用未构造的内存，其行为是未定义的。&lt;/p&gt;
&lt;p&gt;当我们用完对象后，必须对每个构造的元素调用&lt;code&gt;destroy&lt;/code&gt;来销毁它们。函数&lt;code&gt;destroy&lt;/code&gt;接受一个指针，对指向的对象执行析构函数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;while(q != p)
    alloc.destroy(--q); //释放我们真正构造的 string
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;一旦元素被销毁后，就可以重新使用这部分内存来保存其他&lt;code&gt;string&lt;/code&gt;，也可以将其归还给系统。释放内存通过调用&lt;code&gt;deallocate&lt;/code&gt;来完成：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;alloc.deallocate(p, n);
//传递给 deallocate 的指针不能为空，它必须指向由 allocate 分配的内存
//传递给 deallcoate 的大小参数必须与调用 allocate 分配内存时提供的大小参数具有一样的值
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们只能对真正构造了的元素进行&lt;code&gt;destroy&lt;/code&gt;操作。&lt;/p&gt;
&lt;h4&gt;拷贝和填充为初始化内存的算法&lt;/h4&gt;
&lt;p&gt;标准库为&lt;code&gt;allocator&lt;/code&gt;类定义了两个伴随算法，可以在未初始化内存中创建对象：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;操作&lt;/th&gt;
&lt;th align="left"&gt;意义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;uninitialized_copy(b, e, b2)&lt;/td&gt;
&lt;td align="left"&gt;从迭代器 b 和 e 指出的输入范围中拷贝元素到迭代器 b2 指定的未构造的原始内存中，b2 指向的内存必须足够大，能容下输入序列中的元素的拷贝&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;uninitialized_copy_n(b, n, b2)&lt;/td&gt;
&lt;td align="left"&gt;从迭代器 b 指向的元素开始，拷贝 n 个元素到 b2 开始的原始内存中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;uninitialized_fill(b, e, t)&lt;/td&gt;
&lt;td align="left"&gt;在迭代器 b 和 e 指定的原始内存范围中创建对象，值均为 t 的拷贝&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;uninitialized_fill_n(b, n, t)&lt;/td&gt;
&lt;td align="left"&gt;从迭代器 b 指向的原始内存地址开始创建 n 个对象，b 必须指向足够大的未构造的原始内存，能容纳给定数量的对象&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;这些函数在给定目的位置创建元素，而不是由系统分配内存给他们。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;vector&amp;lt;int&amp;gt; vec{0, 1, 2, 3, 4, 5};
auto p = alloc.allocate(vec.size() * 2);
auto q = uninitialized_copy(vec.begin(), vec.end(), p);
uninitialize_fill_n(q, vec.size(), 42);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;uninitialized_copy&lt;/code&gt;在给定位置构造元素，函数返回递增后的目的位置迭代器。因此，一个&lt;code&gt;uninitialized_copy&lt;/code&gt;调用会返回一个指针，指向 最后一个构造的元素之后的位置。&lt;/p&gt;</content><category term="C++"></category></entry><entry><title>C++ Primer 第十一章 关联容器</title><link href="https://xutree.github.io/pages/2018/10/17/C++_Primer_Chapter_11/" rel="alternate"></link><published>2018-10-17T21:12:37+08:00</published><updated>2018-10-17T21:12:37+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-17:/pages/2018/10/17/C++_Primer_Chapter_11/</id><summary type="html">&lt;p&gt;关联容器和顺序容器有着根本的不同：关联容器中的元素是按关键字来保存和访问的。与之相对，顺序容器中的元素是按它们在容器中的位置来顺序保存和访问的。&lt;/p&gt;
&lt;p&gt;关联容器支持高效的关键字查找和访问。两个主要的关联容器（associative-container）类型是 &lt;strong&gt;map&lt;/strong&gt; 和 &lt;strong&gt;set&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;map&lt;/code&gt;中的元素是一些关键字-值（key-value）对：关键字起到索引的作用，值则表示与索引相关联的数据。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;set&lt;/code&gt;中每个元素只包含一个关键字，&lt;code&gt;set&lt;/code&gt;支持高效的关键字查询操作。&lt;/p&gt;
&lt;p&gt;类型&lt;code&gt;map&lt;/code&gt;和&lt;code&gt;multimap&lt;/code&gt;定义在头文件&lt;code&gt;map&lt;/code&gt;中；&lt;code&gt;set&lt;/code&gt;和&lt;code&gt;multiset&lt;/code&gt;定义在头文件&lt;code&gt;set&lt;/code&gt;中；无序容器则定义在头文件&lt;code&gt;unordered_map&lt;/code&gt;和&lt;code&gt;unordered_set&lt;/code&gt;中。无序容器使用哈希函数来组织元素。&lt;/p&gt;
&lt;p&gt;关联容器类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;按关键字有序保存元素&lt;ul&gt;
&lt;li&gt;map：关联数组，保存关键字-值对&lt;/li&gt;
&lt;li&gt;set：关键字即值，即只保存关键字的容器&lt;/li&gt;
&lt;li&gt;multimap：关键字可重复的 …&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;关联容器和顺序容器有着根本的不同：关联容器中的元素是按关键字来保存和访问的。与之相对，顺序容器中的元素是按它们在容器中的位置来顺序保存和访问的。&lt;/p&gt;
&lt;p&gt;关联容器支持高效的关键字查找和访问。两个主要的关联容器（associative-container）类型是 &lt;strong&gt;map&lt;/strong&gt; 和 &lt;strong&gt;set&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;map&lt;/code&gt;中的元素是一些关键字-值（key-value）对：关键字起到索引的作用，值则表示与索引相关联的数据。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;set&lt;/code&gt;中每个元素只包含一个关键字，&lt;code&gt;set&lt;/code&gt;支持高效的关键字查询操作。&lt;/p&gt;
&lt;p&gt;类型&lt;code&gt;map&lt;/code&gt;和&lt;code&gt;multimap&lt;/code&gt;定义在头文件&lt;code&gt;map&lt;/code&gt;中；&lt;code&gt;set&lt;/code&gt;和&lt;code&gt;multiset&lt;/code&gt;定义在头文件&lt;code&gt;set&lt;/code&gt;中；无序容器则定义在头文件&lt;code&gt;unordered_map&lt;/code&gt;和&lt;code&gt;unordered_set&lt;/code&gt;中。无序容器使用哈希函数来组织元素。&lt;/p&gt;
&lt;p&gt;关联容器类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;按关键字有序保存元素&lt;ul&gt;
&lt;li&gt;map：关联数组，保存关键字-值对&lt;/li&gt;
&lt;li&gt;set：关键字即值，即只保存关键字的容器&lt;/li&gt;
&lt;li&gt;multimap：关键字可重复的 map&lt;/li&gt;
&lt;li&gt;multiset：关键字可重复的 set&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;无序集合&lt;ul&gt;
&lt;li&gt;unordered_map：用哈希函数组织的 map&lt;/li&gt;
&lt;li&gt;unordered_set：用哈希函数组织的 set&lt;/li&gt;
&lt;li&gt;unordered_multimap：哈希组织的 map，关键字可重复出现&lt;/li&gt;
&lt;li&gt;unordered_multiset：哈希组织的 set，关键字可重复出现&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;关联容器概述&lt;/h2&gt;
&lt;p&gt;关联容器（有序和无序的）都支持如下的普通容器操作：&lt;/p&gt;
&lt;p&gt;&lt;img alt="普通容器操作" src="https://xutree.github.io/images/c++11-1.jpg"&gt;&lt;/p&gt;
&lt;p&gt;关联容器不支持顺序容器位置相关的操作，例如&lt;code&gt;push_front&lt;/code&gt;或&lt;code&gt;push_back&lt;/code&gt;，关联容器也不支持构造函数或插入操作这些接受一个元素值和一个数量值的操作。&lt;/p&gt;
&lt;p&gt;关联容器的迭代器都是双向的。&lt;/p&gt;
&lt;h3&gt;定义关联容器&lt;/h3&gt;
&lt;p&gt;每个关联容器都定义一个默认构造函数，它创建一个指定类型的空容器。我们可以将关联容器初始化为另一个同类型容器的拷贝，或者从一个值范围来初始化关联容器，只要这些值可以转换为容器所需类型就行。在新标准下，我们也可以对关联容器进行值初始化，与往常一样，初始化器必须能够转换为容器中元素的类型：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;map&amp;lt;string, size_t&amp;gt; word_count; //空容器
//列表初始化
set&amp;lt;string&amp;gt; exclude = {&amp;quot;the&amp;quot;, &amp;quot;but&amp;quot;, &amp;quot;and&amp;quot;};
//两个元素，列表初始化
map&amp;lt;string, string&amp;gt; authors = { {&amp;quot;Joyce&amp;quot;, &amp;quot;James&amp;quot;}, {&amp;quot;Austen&amp;quot;, &amp;quot;Jane&amp;quot;}  };
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;关键字类型的要求&lt;/h3&gt;
&lt;h4&gt;有序容器&lt;/h4&gt;
&lt;p&gt;关键字类型必须定义元素比较的方法，默认情况下，标准库使用关键字类型的&lt;code&gt;&amp;lt;&lt;/code&gt;运算符来比较两个关键字。&lt;/p&gt;
&lt;h4&gt;无序容器&lt;/h4&gt;
&lt;p&gt;默认情况下，无序容器使用关键字类型的&lt;code&gt;==&lt;/code&gt;运算符来比较元素，它们还使用一个&lt;code&gt;hash&amp;lt;key_type&amp;gt;&lt;/code&gt;类型的对象来生成每个元素的哈希值。标准库为内置类型（包括指针）提供了&lt;code&gt;hash&lt;/code&gt;模板。还为一些标准库类型，包括&lt;code&gt;string&lt;/code&gt;和智能指针类型定义了&lt;code&gt;hash&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;因此，我们可以直接定义关键字是内置类型（包括指针类型）、&lt;code&gt;string&lt;/code&gt;还有智能指针类型的无序容器。&lt;/p&gt;
&lt;p&gt;但是，我们不能直接定义关键字类型为自定义类类型的无序容器。我们必须提供自己的&lt;code&gt;hash&lt;/code&gt;模板版本。&lt;/p&gt;
&lt;h4&gt;使用关键字类型的比较函数&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;multiset&amp;lt;Sales_data, decltype(compareIsbn)*&amp;gt; bookstore(compareIsbn);
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;用尖括号指出要定义哪种类型的容器，自定义的操作类型必须在尖括号中紧跟着元素类型给出&lt;/li&gt;
&lt;li&gt;比较操作的类型应该是一种函数指针类型&lt;/li&gt;
&lt;li&gt;在尖括号中的类型仅仅是一个类型而已，当我们创建一个容器（对象）时，才会以构造函数参数的形式提供真正的比较操作（其类型必须与尖括号中指定的类型吻合）&lt;/li&gt;
&lt;li&gt;当使用&lt;code&gt;decltype&lt;/code&gt;来获得一个函数指针类型时，必须加上一个“*”来指出我们需要一个函数指针类型&lt;/li&gt;
&lt;li&gt;用于初始化 bookstore 对象的参数也可以写作&lt;code&gt;&amp;amp;compareIsbn&lt;/code&gt;，因为函数名会自动转换为函数指针&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;pair 类型&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;pair&lt;/code&gt;标准库类型定义在头文件&lt;code&gt;utility&lt;/code&gt;中。一个&lt;code&gt;pair&lt;/code&gt;保存两个数据成员。&lt;code&gt;pair&lt;/code&gt;是一个用来生成特定类型的模板。&lt;code&gt;pair&lt;/code&gt;的默认构造函数对数据成员进行值初始化。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pair&lt;/code&gt;的成员是&lt;code&gt;public&lt;/code&gt;的，两个成员为&lt;code&gt;first&lt;/code&gt;和&lt;code&gt;second&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;标准库定义的&lt;code&gt;pair&lt;/code&gt;操作：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;操作&lt;/th&gt;
&lt;th align="left"&gt;意义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;pair&lt;T1, T2&gt; p;&lt;/td&gt;
&lt;td align="left"&gt;p 是一个 pair，两个类型分布为 T1 和 T2 的成员都进行值初始化&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;pair&lt;T1, T2&gt; p(v1, v2);&lt;/td&gt;
&lt;td align="left"&gt;用 v1 和 v2 初始化&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left" v1_="v1," v2&gt;pair&lt;T1, T2&gt; p = &lt;/td&gt;
&lt;td align="left"&gt;同上&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;make_pair(v1, v2)&lt;/td&gt;
&lt;td align="left"&gt;返回一个用 v1 和 v2 初始化的 pair，pair 的类型由 v1 和 v2 推断而来&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;p.first, p.second&lt;/td&gt;
&lt;td align="left"&gt;成员&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;p1 &lt;em&gt;relop&lt;/em&gt; p2&lt;/td&gt;
&lt;td align="left"&gt;关系运算符按字典顺序定义。关系运算利用元素的 &amp;lt; 运算符实现&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;p1 == p2, p1 != p2&lt;/td&gt;
&lt;td align="left"&gt;相等性判定利用元素的 == 运算符实现&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4&gt;创建返回 pair 对象的函数&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pair&amp;lt;string, int&amp;gt; process(vector&amp;lt;string&amp;gt; &amp;amp;v)
{
    //处理 v
    if (!v.empty())
        //列表初始化
        return {v.back(), v.back().size()};
    else
        //隐式构造返回值
        return pair&amp;lt;string, int&amp;gt;();
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;关联容器操作&lt;/h2&gt;
&lt;p&gt;关联容器额外定义了一些类型别名：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;别名&lt;/th&gt;
&lt;th align="left"&gt;意义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;key_type&lt;/td&gt;
&lt;td align="left"&gt;此容器类型的关键字类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;mapped_type&lt;/td&gt;
&lt;td align="left"&gt;每个关键字关联的类型，只适用于&lt;code&gt;map&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;value_type&lt;/td&gt;
&lt;td align="left"&gt;对于&lt;code&gt;set&lt;/code&gt;，与 key_type 相同，对于&lt;code&gt;map&lt;/code&gt;，为 pair&lt;const key_type, mapped_type&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;由于我们不能改变一个元素的关键字，因此这些&lt;code&gt;pair&lt;/code&gt;的关键字部分是&lt;code&gt;const&lt;/code&gt;的。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;set&amp;lt;string&amp;gt;::value_type v1; //v1 是一个 string
set&amp;lt;string&amp;gt;::key_type v2;   //v2 是一个 string
map&amp;lt;string, int&amp;gt;::value_type v3;    //v3 是一个 pair&amp;lt;const string, int&amp;gt;
map&amp;lt;string, int&amp;gt;::key_type v4;  //v4 是一个 string
map&amp;lt;string, int&amp;gt;::mapped_type v5;   //v5 是一个 int
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;关联容器迭代器&lt;/h3&gt;
&lt;p&gt;当解引用一个关联容器迭代器时，我们会得到一个类型为容器的 value_type 的值的引用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对&lt;code&gt;map&lt;/code&gt;而言，得到&lt;code&gt;pair&lt;/code&gt;类型，其 first 成员保存&lt;code&gt;const&lt;/code&gt;关键字，second 成员保存值&lt;/li&gt;
&lt;li&gt;对&lt;code&gt;set&lt;/code&gt;而言，迭代器也是&lt;code&gt;const&lt;/code&gt;的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当使用一个迭代器遍历一个&lt;code&gt;map&lt;/code&gt;、&lt;code&gt;multimap&lt;/code&gt;、&lt;code&gt;set&lt;/code&gt;、&lt;code&gt;multiset&lt;/code&gt;时，迭代器按关键字升序遍历元素。&lt;/p&gt;
&lt;p&gt;我们通常不对关联容器使用泛型算法。在实际编程中，如果我们真的要对一个关联容器使用算法，要么将它作为一个源序列，要么将它作为一个目的位置。&lt;/p&gt;
&lt;h3&gt;添加元素&lt;/h3&gt;
&lt;p&gt;&lt;img alt="添加元素" src="https://xutree.github.io/images/c++11-2.jpg"&gt;&lt;/p&gt;
&lt;p&gt;返回值：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不包含重复关键字的容器：返回一个&lt;code&gt;pair&lt;/code&gt;，first 成员是一个迭代器，指向具有给定关键字的元素，second 成员是一个&lt;code&gt;bool&lt;/code&gt;值，关键字不存在，为&lt;code&gt;true&lt;/code&gt;，否则为&lt;code&gt;false&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;包含重复关键字的容器：返回一个指向新元素的迭代器&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;删除元素&lt;/h3&gt;
&lt;p&gt;&lt;img alt="删除元素" src="https://xutree.github.io/images/c++11-3.jpg"&gt;&lt;/p&gt;
&lt;h3&gt;map 下标操作&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;操作&lt;/th&gt;
&lt;th align="left"&gt;意义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;c[k]&lt;/td&gt;
&lt;td align="left"&gt;返回关键字为 k 的元素；如果 k 不在 c 中，添加一个关键字为 k 的元素，对其进行值初始化&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;c.at(k)&lt;/td&gt;
&lt;td align="left"&gt;访问关键字为 k 的元素，带参数检查；若 k 不在 c 中，抛出 out_of_range 异常&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;由于下标运算可能插入一个新元素，我们只可以对非&lt;code&gt;const&lt;/code&gt;的&lt;code&gt;map&lt;/code&gt;使用下标操作。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;map&lt;/code&gt;下标操作与其他下标操作不同的地方：对&lt;code&gt;map&lt;/code&gt;进行下标操作时，会得到一个 mapped_type 对象；但当解引用一个&lt;code&gt;map&lt;/code&gt;迭代器时，得到一个 value_type 对象。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;map&lt;/code&gt;下标操作与其他下标操作相同的地方：返回一个左值，可读也可写。&lt;/p&gt;
&lt;h3&gt;访问元素&lt;/h3&gt;
&lt;p&gt;&lt;img alt="访问元素" src="https://xutree.github.io/images/c++11-4.jpg"&gt;&lt;/p&gt;
&lt;p&gt;lower_bound 和 upper_bound 不适用于无序容器。&lt;/p&gt;
&lt;p&gt;下标和 at 操作只适用于非&lt;code&gt;const&lt;/code&gt;的&lt;code&gt;map&lt;/code&gt;和&lt;code&gt;unordered_map&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;对&lt;code&gt;map&lt;/code&gt;使用 find 代替下标操作，以防添加不存在元素。&lt;/p&gt;
&lt;h2&gt;无序容器&lt;/h2&gt;
&lt;p&gt;新标准定义了4个无序关联容器（unordered associative container）。这些容器不是使用比较运算符来组织元素，而是使用一个哈希函数和关键字类型的 == 运算符。&lt;/p&gt;
&lt;p&gt;除了哈希管理操作之外，无序容器还提供了与有序容器相同的操作。&lt;/p&gt;
&lt;h3&gt;管理桶&lt;/h3&gt;
&lt;p&gt;无序容器在存储上组织为一组桶，每个桶保存零个或多个元素。&lt;/p&gt;
&lt;p&gt;无序容器使用一个哈希函数将元素映射到桶。&lt;/p&gt;
&lt;p&gt;为了访问一个元素，容器首先计算元素的哈希值，它指出应该搜索哪个桶。&lt;/p&gt;
&lt;p&gt;容器将具有一个特定哈希值的所有元素都保存在相同的桶中。&lt;/p&gt;
&lt;p&gt;如果容器允许重复关键字，所有具有相同关键字的元素也都会在同一个桶中。&lt;/p&gt;
&lt;p&gt;无序容器的性能依赖于哈希函数的质量和桶的数量和大小。&lt;/p&gt;
&lt;p&gt;对于相同的参数，哈希函数必须总是产生相同的结果。&lt;/p&gt;
&lt;p&gt;理想情况下，哈希函数还能将每个特定的值映射到唯一的桶。但是将不同关键字的元素映射到相同的桶也是允许的。&lt;/p&gt;
&lt;p&gt;当一个桶保存多个元素时，需要顺序搜索这些元素来查找我们想要的那个。计算一个元素的哈希值和在桶中搜索通常都是很快的操作。但是如果一个桶保存了很多元素，那么查找一个特定元素就需要大量比较操作。&lt;/p&gt;
&lt;p&gt;无序容器提供了一组管理桶的函数：&lt;/p&gt;
&lt;p&gt;&lt;img alt="桶管理操作" src="https://xutree.github.io/images/c++11-5.jpg"&gt;&lt;/p&gt;
&lt;h3&gt;无序容器对关键字类型的要求&lt;/h3&gt;
&lt;p&gt;&lt;img alt="无序容器" src="https://xutree.github.io/images/c++11-6.jpg"&gt;&lt;/p&gt;</content><category term="C++"></category></entry><entry><title>C++ Primer 第十章 泛型算法</title><link href="https://xutree.github.io/pages/2018/10/17/C++_Primer_Chapter_10/" rel="alternate"></link><published>2018-10-17T16:10:44+08:00</published><updated>2018-10-17T17:10:03+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-17:/pages/2018/10/17/C++_Primer_Chapter_10/</id><summary type="html">&lt;p&gt;顺序容器只定义了很少的操作：在多数情况下，我们可以添加和删除元素。访问首尾元素、确定容器是否为空以及获得指向首元素或尾元素之后位置的迭代器。&lt;/p&gt;
&lt;p&gt;如果我们想要做：查找特定元素、替换或删除一个特定值、重排元素顺序等。标准库并未给每个容器都定义成员函数来实现这些操作，而是定义了一组泛型算法：称它们为“算法”，是因为它们实现了一些经典算法的公共接口，如排序和搜索；称它们是“泛型的”，是因为它们可用于不同类型的元素和多种容器类型（不仅包括标准库类型，如&lt;code&gt;vector&lt;/code&gt;或&lt;code&gt;list&lt;/code&gt;，还包括内置的数组类型）。&lt;/p&gt;
&lt;h2&gt;概述&lt;/h2&gt;
&lt;p&gt;大多数算法都定义在头文件&lt;code&gt;algorithm&lt;/code&gt;中。标准库还在头文件&lt;code&gt;numeric&lt;/code&gt;中定义了一组数值泛型算法。&lt;/p&gt;
&lt;p&gt;一般情况下，这些算法并不直接操作容器，而是遍历由两个迭代器指定的一个元素范围来进行操作。通常情况下，算法遍历范围，对其中每个元素进行一些处理。&lt;/p&gt;
&lt;p&gt;迭代器令算法不依赖于容器，但算法依赖于元素类型的操作。虽然迭代器的使用令算法不依赖于容器类型。但大多数算法都使用了一个(或多个)元素类型上的操作。例如，&lt;code&gt;find&lt;/code&gt;用元素的&lt;code&gt;==&lt;/code&gt;运算符完成每个元素与给定值的比较。其他算法可能要求元素类型支持&lt;code&gt;&amp;lt;&lt;/code&gt;运算符。不过 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;顺序容器只定义了很少的操作：在多数情况下，我们可以添加和删除元素。访问首尾元素、确定容器是否为空以及获得指向首元素或尾元素之后位置的迭代器。&lt;/p&gt;
&lt;p&gt;如果我们想要做：查找特定元素、替换或删除一个特定值、重排元素顺序等。标准库并未给每个容器都定义成员函数来实现这些操作，而是定义了一组泛型算法：称它们为“算法”，是因为它们实现了一些经典算法的公共接口，如排序和搜索；称它们是“泛型的”，是因为它们可用于不同类型的元素和多种容器类型（不仅包括标准库类型，如&lt;code&gt;vector&lt;/code&gt;或&lt;code&gt;list&lt;/code&gt;，还包括内置的数组类型）。&lt;/p&gt;
&lt;h2&gt;概述&lt;/h2&gt;
&lt;p&gt;大多数算法都定义在头文件&lt;code&gt;algorithm&lt;/code&gt;中。标准库还在头文件&lt;code&gt;numeric&lt;/code&gt;中定义了一组数值泛型算法。&lt;/p&gt;
&lt;p&gt;一般情况下，这些算法并不直接操作容器，而是遍历由两个迭代器指定的一个元素范围来进行操作。通常情况下，算法遍历范围，对其中每个元素进行一些处理。&lt;/p&gt;
&lt;p&gt;迭代器令算法不依赖于容器，但算法依赖于元素类型的操作。虽然迭代器的使用令算法不依赖于容器类型。但大多数算法都使用了一个(或多个)元素类型上的操作。例如，&lt;code&gt;find&lt;/code&gt;用元素的&lt;code&gt;==&lt;/code&gt;运算符完成每个元素与给定值的比较。其他算法可能要求元素类型支持&lt;code&gt;&amp;lt;&lt;/code&gt;运算符。不过，我们将会看到，大多数算法提供了一种方法，允许我们使用自定义的操作来代替默认的运算符。&lt;/p&gt;
&lt;p&gt;泛型算法本身不会执行容器的操作，它们只会运行与迭代器之上，执行迭代器的操作。泛型算法运行于迭代器之上而不会执行容器操作的特性带来了一个令人惊讶但非常必要的编程假定：算法永远不会改变底层容器的大小。算法可能改变容器中保存的元素的值，也可能在容器内移动元素，但永远不会直接添加或删除元素。&lt;/p&gt;
&lt;h2&gt;初识泛型算法&lt;/h2&gt;
&lt;p&gt;除了少数例外，标准库算法都对一个范围内的元素进行操作。我们将此元素范围称为“输入范围”。接受输入范围的算法总是使用前两个参数来表示此范围，两个参数分别是指想要处理的第一个元素和尾元素之后位置的迭代器。&lt;/p&gt;
&lt;h3&gt;只读算法&lt;/h3&gt;
&lt;p&gt;一些算法只会读取其输入范围内的元素，而从不改变元素。&lt;code&gt;find&lt;/code&gt;就是这样一种算法。&lt;/p&gt;
&lt;h4&gt;accumulate&lt;/h4&gt;
&lt;p&gt;另一个只读算法是&lt;code&gt;accumulate&lt;/code&gt;，它定义在头文件&lt;code&gt;numeric&lt;/code&gt;中。&lt;code&gt;accumulate&lt;/code&gt;函数接受三个参数，前两个指出了需要求和的元素的范围，第三个参赛是和的初值。假定 vec 是一个整数序列，则：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//对 vec 中元素的求和，和的初值是0
int sum = accumulate(vec.cbegin(), vec.cend(), 0);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这条语句将 sum 设置为 vec 中元素的和，和的初值被设置为0.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;accumulate&lt;/code&gt;的第三个参数的类型决定了函数中使用哪个加法运算符以及返回值的类型。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;accumulate&lt;/code&gt;将第三个参数作为求和起点，这蕴含着一个编程假定：将元素类型加到和的类型上的操作必须是可行的。即，序列中元素的类型必须与第三个参数匹配，或者能够转换为第三个参数的类型。&lt;/p&gt;
&lt;p&gt;下面是另一个例子，由于&lt;code&gt;string&lt;/code&gt;定义了&lt;code&gt;+&lt;/code&gt;运算符，所有我们可以通过调用&lt;code&gt;accumulate&lt;/code&gt;来将&lt;code&gt;vector&lt;/code&gt;中所有&lt;code&gt;string&lt;/code&gt;元素连接起来：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;string sum = accumulate(v.cbegin(), v.cend(), string(&amp;quot;&amp;quot;));
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;此调用将 v 中每个元素连接到一个&lt;code&gt;string&lt;/code&gt;上，该&lt;code&gt;string&lt;/code&gt;初始时是空串。注意，我们通过第三个参数显式地创建了一个&lt;code&gt;string&lt;/code&gt;。将空串当做一个字符串字面值传递给第三个参数是不可以的，会导致一个编译错误：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//错误：const char*上没有定义+运算符
string sum = accumulate(v.cbegin(), v.cend(), &amp;quot;&amp;quot;);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;原因在于，如果我们传递了一个字符串字面值，用于保存和的对象的类型将是&lt;code&gt;const char*&lt;/code&gt;。如前所述，此类型决定了使用哪个&lt;code&gt;+&lt;/code&gt;运算符。由于&lt;code&gt;const char*&lt;/code&gt;并没有+运算符，此调用将产生编译错误。&lt;/p&gt;
&lt;p&gt;操作两个序列的算法&lt;/p&gt;
&lt;h4&gt;equal&lt;/h4&gt;
&lt;p&gt;另一个只读算法是&lt;code&gt;equal&lt;/code&gt;，用于确定两个序列是否保存相同的值，它将第一个序列中的每个元素与第二个序列中的对应元素进行比较。如果所有对应元素都相等，则返回&lt;code&gt;true&lt;/code&gt;，否则返回&lt;code&gt;false&lt;/code&gt;。此算法接受三个迭代器：前两个表示第一个序列中的元素的范围，第三个表示第二个序列的首元素：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//roster2 中的元素数目应该至少与 roster1 一样多
equal(roster1.cbegin(), roster1.cend(), roster2.cbegin());
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;由于&lt;code&gt;equal&lt;/code&gt;利用迭代器完成操作，因此我们可以通过调用&lt;code&gt;equal&lt;/code&gt;来比较两个不同类型的容器中的元素。而且，元素类型也不必一样，只要我们能用&lt;code&gt;==&lt;/code&gt;来比较两个元素类型即可。例如，在此例中，roster1 可以是&lt;code&gt;vector&amp;lt;string&amp;gt;&lt;/code&gt;,而 roster2 是&lt;code&gt;list&amp;lt;const char*&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;但是，&lt;code&gt;equal&lt;/code&gt;基于一个非常重要的假设：它假定第二个序列至少与第一个序列一样长。此算法要处理第一个序列中的每个元素，它假定每个元素在第二个序列中都有一个与之对应的元素。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那些只接受一个单一迭代器来表示第二个序列的算法，都假定第二个序列至少与第一个序列一样长。确保算法不会试图访问第二个序列中不存在的元素是程序员的责任。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;写容器元素的算法&lt;/h3&gt;
&lt;p&gt;一些算法将新值赋予序列中的元素。当我们使用这类算法时，必须注意确保序列原大小至少不小于我们要求算法写入的元素数目。记住，算法不会执行容器操作，因此它们自身不可能改变容器的大小。&lt;/p&gt;
&lt;p&gt;一些算法会自己向输入范围写入元素，这些算法本质上并不危险，它们最多写入与给定序列一样多的元素。&lt;/p&gt;
&lt;p&gt;例如，算法&lt;code&gt;fill&lt;/code&gt;接受一对迭代器表示一个范围，还接受一个值作为第三个参数。&lt;code&gt;fill&lt;/code&gt;将给定的这个值赋予输入序列中的每个元素：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;fill(vec.begin(), vec.end(), 0); //将每个元素重置为0
//将容器的一个子序列设置为10
fill(vec.begin(), vec.begin()+vec.size()/2, 10);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;由于&lt;code&gt;fill&lt;/code&gt;向给定输入序列中写入数据，因此，只要我们传递一个有效的输入序列，写入操作就是安全的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;算法不检查写操作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一些算法接受一个迭代器来指出一个单独的目的位置。这些算法将新值赋予一个序列中的元素，该序列从目的位置迭代器指向的元素开始。例如，函数&lt;code&gt;fill_n&lt;/code&gt;接受一个单迭代器、一个计数值和一个值。它将给定值赋予迭代器指向的元素开始的指定个元素。我们可以用&lt;code&gt;fill_n&lt;/code&gt;将一个新值赋予&lt;code&gt;vector&lt;/code&gt;中的元素：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;vector&amp;lt;int&amp;gt; vec;  //空vector
//使用vec，赋予它不同值
fill_n(vec.begin(), vec.size(), 0);  //将所有元素重置为0
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;函数&lt;code&gt;fill_n&lt;/code&gt;假定写入指定个元素是安全的。即，如下形式的调用：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;fill_n(dest, n, val)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;函数&lt;code&gt;fill_n&lt;/code&gt;假定 dest 指向一个元素，而 dest 开始的序列至少包含 n 个元素。&lt;/p&gt;
&lt;p&gt;一个初学者非常容易犯的错误是在一个空容器上调用&lt;code&gt;fill_n&lt;/code&gt;（或类似的写元素的算法）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;vector&amp;lt;int&amp;gt; vec;  //空向量
//灾难：修改vec中10个（不存在）元素
fill_n(vec.begin(), 10, 0);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个调用是一场灾难，我们指定了要写入10个元素，但 vec 中并没有元素——它是空的，这条语句的结果是未定义的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;向目的迭代器写入数据的算法假定目的位置是足够大，能容纳要写入的元素。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;介绍 back_inserter&lt;/h3&gt;
&lt;p&gt;一种保证算法有足够元素空间来容纳输出数据的方法是使用插入迭代器。插入迭代器是一种向容器中添加元素的迭代器。通常情况下，当我们通过一个迭代器向容器元素赋值时，值被赋予迭代器指向的元素。而当我们通过一个插入迭代器赋值时，一个赋值号右侧值相等的元素被添加到容器中。&lt;/p&gt;
&lt;p&gt;为了展示如何用算法向容器中写入数据，我们现在将使用&lt;code&gt;back_inserter&lt;/code&gt;，它是定义在头文件&lt;code&gt;iterator&lt;/code&gt;中的一个函数。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;back_inserter&lt;/code&gt;接受一个&lt;strong&gt;指向容器的引用&lt;/strong&gt;，返回一个与该容器绑定的插入迭代器。当我们通过此迭代器赋值时，赋值运算符会调用&lt;code&gt;push_back&lt;/code&gt;将一个具有给定值的元素&lt;strong&gt;添加&lt;/strong&gt;到容器中：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;vector&amp;lt;int&amp;gt; vec;   //空容器
auto it = back_inserter(vec); //通过它赋值会将元素添加到vec中
*it = 42;//vec现在有一个元素，值为42
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们常常使用&lt;code&gt;back_inserter&lt;/code&gt;来创建一个迭代器，作为算法的目的位置来使用。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;vector&amp;lt;int&amp;gt; vec;  //空向量
//正确：back_inserter 创建一个插入迭代器，可以用来向 vec 添加元素
fill_n(back_inserter(vec), 10, 0);  //添加10个元素到 vec
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在每步迭代中，&lt;code&gt;fill_n&lt;/code&gt;向给定容器序列的一个元素赋值。由于我们传递的参数是&lt;code&gt;back_inserter&lt;/code&gt;返回的迭代器，因此每次赋值都会在 vec 上调用&lt;code&gt;push_back&lt;/code&gt;。最终，这条&lt;code&gt;fill_n&lt;/code&gt;调用语句向 vec 的末尾添加了10个元素，每个元素的值都是0.&lt;/p&gt;
&lt;h3&gt;拷贝算法&lt;/h3&gt;
&lt;p&gt;拷贝算法是另一个向目的位置迭代器指向的输出序列中的元素写入数据的算法。此算法接受三个迭代器，前两个表示一个输入范围，第三个表示目的序列的起始位置。此算法将输入范围中的元素拷贝到目的序列中。传递给&lt;code&gt;copy&lt;/code&gt;的目的序列至少要包含与输入序列一样多的元素，这一点很重要。&lt;/p&gt;
&lt;p&gt;我们可以用&lt;code&gt;copy&lt;/code&gt;实现内置数组的拷贝，如下面代码所示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int a[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
int a2[sizeof(a1) / sizeof(*a1)];
auto ret = copy(begin(a1), end(a1), a2); //把a1的内容拷贝到a2
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;copy&lt;/code&gt;返回的是其目的位置迭代器（递增后）的值。即，ret 恰好指向拷贝到 a2 的尾元素之后的位置。&lt;/p&gt;
&lt;p&gt;多个算法都提供所谓的“拷贝”版本。这些算法计算新元素的值，但不会将它们放置在输入序列的末尾，而是创建以新序列保存这些结果。&lt;/p&gt;
&lt;p&gt;例如，&lt;code&gt;replace&lt;/code&gt;算法读入一个序列，并将其中所有等于给定值的元素都改为另一个值。此算法接受4个参数：前两个是迭代器，表示输入序列，后两个一个是要搜索的值，另一个是新值。它将所有等于第一个值的元素替换为第二个值：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//将所有值为0的元素改为42
replace(ilist.begin(), ilist.end(), 0, 42);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;此调用将序列中所有0都替换为42,。如果我们希望保留原序列不变，可以调用&lt;code&gt;replace_copy&lt;/code&gt;。此算法接受额外第三个迭代器参数，指出调整后序列的保存位置：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//使用back_inserter按需要增长目标序列
replace_copy(ilist.begin(), ilist.end(), back_inserter(ivec), 0, 42);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;此调用后，ilis 并未改变，ivec 包含 ilist 的一份拷贝，不过原来在 ilist 中值为0的元素在 ivec 中都变为42。&lt;/p&gt;
&lt;h3&gt;重排容器元素的算法&lt;/h3&gt;
&lt;h4&gt;sort&lt;/h4&gt;
&lt;p&gt;某些算法会重排容器中元素的顺序，一个明显的例子是&lt;code&gt;sort&lt;/code&gt;。调用&lt;code&gt;sort&lt;/code&gt;会重排输入序列中的元素，使之有序，它是利用元素类型的&lt;code&gt;&amp;lt;&lt;/code&gt;运算符来实现排序的。&lt;/p&gt;
&lt;h4&gt;unique&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;unique&lt;/code&gt;算法重排输入序列，将相邻的重复项“消除”，并返回一个指向不重复范围末尾的迭代器。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;unique&lt;/code&gt;并不真正的删除任何元素，它只是覆盖相邻的重复元素，使得不重复元素出现在序列开始部分，&lt;code&gt;unique&lt;/code&gt;返回的迭代器指向最后一个不重复元素之后的位置。此位置之后的元素仍然存在，但我们不知道它们的值是什么。&lt;/p&gt;
&lt;p&gt;标准库算法对迭代器而不是容器进行操作。因此，算法不能（直接）添加或删除元素。为了真正删除无用元素，我们必须使用容器操作，例如&lt;code&gt;erase&lt;/code&gt;。&lt;/p&gt;
&lt;h2&gt;定制操作&lt;/h2&gt;
&lt;p&gt;很多算法都会比较输入序列中的元素。默认情况下，这类算法使用元素类型的&lt;code&gt;&amp;lt;&lt;/code&gt;或&lt;code&gt;==&lt;/code&gt;运算符完成比较。标准库还为这些算法定义了额外的版本，允许我们提供自己定义的操作来代替默认运算符。&lt;/p&gt;
&lt;p&gt;例如，&lt;code&gt;sort&lt;/code&gt;算法默认使用元素类型的&lt;code&gt;&amp;lt;&lt;/code&gt;运算符。但可能我们希望的排序顺序与&lt;code&gt;&amp;lt;&lt;/code&gt;所定义的顺序不同，或是我们的序列可能保存的是未定义&lt;code&gt;&amp;lt;&lt;/code&gt;运算符的元素类型。在这两种情况下，都需要重载&lt;code&gt;sort&lt;/code&gt;的默认行为。&lt;/p&gt;
&lt;h3&gt;向算法传递函数&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;sort&lt;/code&gt;的第二个版本是重载过的，它接受三个参数，此参数是一个&lt;strong&gt;谓词&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;谓词是一个可调用的表达式，其返回结果是一个能用作条件的值。标准库算法所使用的谓词分为两类：一元谓词（unary predicate 意味着它们只接受单一参数）和二元谓词（binary predicate 意味着它们接受两个参数）。接受谓词参数的算法对输入序列中的元素调用谓词。因此，元素类型必须能转换为谓词的参数类型。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//比较函数，用来比较长度排序单词
bool isShorter(const string &amp;amp;s1, const string &amp;amp;s2)
{
　　return s1.size() &amp;lt; s2.size();
}
//按长度由短至长排序words
sort(words.begin(), words.end(), isShorter);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;stable_sort&lt;/code&gt;算法：这种稳定排序算法维持相等元素的原有顺序。&lt;/p&gt;
&lt;h3&gt;lambda 表达式&lt;/h3&gt;
&lt;p&gt;根据算法接受一元谓词还是二元谓词，我们传递给算法的谓词必须严格接受一个或两个参数。但是，有时我们希望进行的操作需要更多参数，超出了算法对谓词的限制。这时候我们可以利用&lt;code&gt;lambda&lt;/code&gt;表达式。&lt;/p&gt;
&lt;p&gt;我们可以向一个算法传递任何类别的可调用对象。对于一个对象或一个表达式，如果可以对其使用调用运算符，则称它为可调用的。即，如果 e 是一个可调用的表达式，则我们可以编写代码 e(args),其中 args 是一个逗号分隔的一个或多个参数的列表。&lt;/p&gt;
&lt;p&gt;到目前为止，我们使用过的仅有的两种可调用对象是函数和函数指针。还有其他两种可调用对象：重载了函数调用运算符的类，以及&lt;code&gt;lambda&lt;/code&gt;表达式。&lt;/p&gt;
&lt;p&gt;一个&lt;code&gt;lambda&lt;/code&gt;表达式表示一个可调用的代码单元。我们可以将其理解为一个未命名的内联函数。与任何函数类似，一个&lt;code&gt;lambda&lt;/code&gt;具有一个返回返回类型、一个参数列表和一个函数体。但与函数不同，&lt;code&gt;lambda&lt;/code&gt;可能定义在函数内部。一个&lt;code&gt;lambda&lt;/code&gt;表达式具有如下形式&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;capture&lt;/span&gt; &lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parameter&lt;/span&gt; &lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;function&lt;/span&gt; &lt;span class="n"&gt;body&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中，&lt;code&gt;capture list&lt;/code&gt;(捕获列表)是一个&lt;code&gt;lambda&lt;/code&gt;所在函数中定义的局部变量列表（通常为空）；&lt;code&gt;return type&lt;/code&gt;、&lt;code&gt;parameter list&lt;/code&gt;和&lt;code&gt;function body&lt;/code&gt;与任何普通函数一样，分别表示返回类型、参数列表和函数体。但是，与普通函数不同，&lt;code&gt;lambda&lt;/code&gt;必须使用尾置返回来指定返回类型。&lt;/p&gt;
&lt;p&gt;我们可以忽略参数列表和返回类型，但必须永远包含捕获列表和函数体：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;auto f = [] { return 42; };
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;此例中，我们定义了一个可调用对象，它不接受参数，返回42.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;lambda&lt;/code&gt;的调用方式与普通函数的调用方式相同，都是使用调用运算符：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;cout &amp;lt;&amp;lt; f() &amp;lt;&amp;lt; endl; //打印42
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在&lt;code&gt;lambda&lt;/code&gt;中忽略括号和参数列表等价于指定一个空参数列表。在此例中，当调用 f 时，函数参数列表是空的。如果忽略返回类型，则返回类型从返回的表达式的类型推断而来。否则，返回类型为&lt;code&gt;void&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果&lt;code&gt;lambda&lt;/code&gt;的函数体包含任何单一&lt;code&gt;return&lt;/code&gt;语句之外的语句，且未指定返回类型，则返回&lt;code&gt;void&lt;/code&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;h4&gt;向 lambda 传递参数&lt;/h4&gt;
&lt;p&gt;与普通函数调用类似，调用一个&lt;code&gt;lambda&lt;/code&gt;时给定的实参类型被用来初始化&lt;code&gt;lambda&lt;/code&gt;的形参。通常，实参和形参的类型必须匹配，但与普通函数不同，&lt;code&gt;lambda&lt;/code&gt;不能有默认参数。因此，一个&lt;code&gt;lambda&lt;/code&gt;调用的实参数目永远与形参数目相等。一旦形参初始化完毕，就可以执行函数体了。&lt;/p&gt;
&lt;p&gt;作为一个带参数的&lt;code&gt;lambda&lt;/code&gt;的例子，我们可以编写一个与 isShorter 函数完成相同功能的&lt;code&gt;lambda&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;[] (const string &amp;amp;s1, const string &amp;amp;s2)
{ return s1.size() &amp;lt; s2.size(); }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;空捕获列表表明此&lt;code&gt;lambda&lt;/code&gt;不使用它所在函数中的任何局部变量。&lt;code&gt;lambda&lt;/code&gt;的参数与 isShorter 的参数类似，是&lt;code&gt;const string&lt;/code&gt;的引用。&lt;code&gt;lambda&lt;/code&gt;的函数体也与 isShorter 类型，比较两个参数的&lt;code&gt;size()&lt;/code&gt;，并根据两者的相对大小返回一个布尔值。&lt;/p&gt;
&lt;p&gt;如下所示，可以使用此&lt;code&gt;lambda&lt;/code&gt;来调用&lt;code&gt;stable_sort&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;stable_sort(words.begin(), words.end(), [] (const string &amp;amp;s1, const string &amp;amp;s2) { return s1.size()&amp;lt;s2.size(); });
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当&lt;code&gt;stable_sort&lt;/code&gt;需要比较两个元素时，它就会调用给定的这个&lt;code&gt;lambda&lt;/code&gt;表达式。&lt;/p&gt;
&lt;h4&gt;使用捕获列表&lt;/h4&gt;
&lt;p&gt;编写一个可以传递给&lt;code&gt;find_if&lt;/code&gt;的可调用表达式。我们希望这个表达式能将输入序列中每个&lt;code&gt;string&lt;/code&gt;的长度与 biggies 函数中的 sz 参数的值进行比较。&lt;/p&gt;
&lt;p&gt;虽然一个&lt;code&gt;lambda&lt;/code&gt;可以出现在一个函数中，使用其局部变量，但它只能使用那些明确指明的变量。一个&lt;code&gt;lambda&lt;/code&gt;通过将局部变量包含在其捕获列表中指出将会使用这些变量。捕获列表指引&lt;code&gt;lambda&lt;/code&gt;在其内部包含访问局部变量所需的信息。&lt;/p&gt;
&lt;p&gt;在本例中，我们的&lt;code&gt;lambda&lt;/code&gt;会捕获 sz，并只有单一的&lt;code&gt;string&lt;/code&gt;参数。其函数体会将&lt;code&gt;string&lt;/code&gt;的大小与捕获的 sz 的值进行比较：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;[sz] (const string &amp;amp;s) { return s.size() &amp;gt;= sz; };
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;lambda&lt;/code&gt;以一对&lt;code&gt;[]&lt;/code&gt;开始，我们可以在其中提供一个以逗号分隔的名字列表，这些名字都是它所在函数中定义的。&lt;/p&gt;
&lt;p&gt;如果我们给&lt;code&gt;lambda&lt;/code&gt;提供了一个空捕获列表，则代码会编译错误：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//错误：sz未捕获
[] (const string &amp;amp;s) { return s.size() &amp;gt;= sz; };
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;一个&lt;code&gt;lambda&lt;/code&gt;只有在其捕获列表中捕获一个所在函数中的局部变量，才能在函数体中使用该变量。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个&lt;code&gt;lambda&lt;/code&gt;可以直接使用定义在当前函数之外的名字。捕获列表只用于局部非&lt;code&gt;static&lt;/code&gt;变量，&lt;code&gt;lambda&lt;/code&gt;可以直接使用局部&lt;code&gt;static&lt;/code&gt;变量和在它所在函数之外声明的名字。&lt;/p&gt;
&lt;h4&gt;lambda 捕获和返回&lt;/h4&gt;
&lt;p&gt;当定义一个&lt;code&gt;lambda&lt;/code&gt;时，编译器生成一个与&lt;code&gt;lambda&lt;/code&gt;对应的新的（未命名的）类类型。当向一个函数传递一个&lt;code&gt;lambda&lt;/code&gt;时，同时定义了一个新类型和该类型的一个对象；传递的参数就是此编译器生成的类类型的未命名对象。类似的，当使用&lt;code&gt;auto&lt;/code&gt;定义一个用&lt;code&gt;lambda&lt;/code&gt;初始化的变量时，定义了一个从&lt;code&gt;lambda&lt;/code&gt;生成的类型的对象。&lt;/p&gt;
&lt;p&gt;默认情况下，从&lt;code&gt;lambda&lt;/code&gt;生成的类都包含一个对应该&lt;code&gt;lambda&lt;/code&gt;所捕获的变量的数据成员类似任何普通类的数据成员，&lt;code&gt;lambda&lt;/code&gt;的数据成员也在&lt;code&gt;lambda&lt;/code&gt;对象创建时被初始化。&lt;/p&gt;
&lt;h4&gt;值捕获&lt;/h4&gt;
&lt;p&gt;类似参数传递，变量的捕获方式也可以是值或引用。到目前为止，我们的&lt;code&gt;lambda&lt;/code&gt;采用值捕获的方式。与传值参数类似，采用值捕获的前提是变量可以拷贝。与参数不同，被捕获的变量的值是在&lt;code&gt;lambda&lt;/code&gt;创建时拷贝，而不是调用时拷贝：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;void fcn1()
{
　　size_t v1 = 42;  //局部变量
　　//将 v1 拷贝到名为 f 的可调用对象
　　auto f = [v1] { return v1; };
　　v1 = 0;
　　auto j = f(); //j 为42；f 保存了我们创建它时 v1 的拷贝
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;由于被捕获变量的值是在&lt;code&gt;lambda&lt;/code&gt;创建时拷贝，因此随后对其修改不会影响到&lt;code&gt;lambda&lt;/code&gt;内对应的值。&lt;/p&gt;
&lt;h4&gt;引用捕获&lt;/h4&gt;
&lt;p&gt;我们定义&lt;code&gt;lambda&lt;/code&gt;时可以采用引用方式捕获变量。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;void fcn2()
{
　　size_t v1 = 42;
　　//对象 f2 包含 v1 的引用
　　auto f2 = [&amp;amp;v1] { return v1; };
　　v1 = 0;
　　auto j = f2();  //j 为0；f2 保存 v1 的引用，而非拷贝
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;一个以引用方式捕获的变量与其他任何类型的引用的行为类似。当我们在&lt;code&gt;lambda&lt;/code&gt;函数体内使用此变量时，实际上使用的是引用所绑定的对象。引用捕获与返回引用有着相同的问题和限制。如果我们采用引用方式捕获一个变量，就必须确保被引用的对象在&lt;code&gt;lambda&lt;/code&gt;执行的时候是存在的。&lt;code&gt;lambda&lt;/code&gt;捕获的都是局部变量，这些变量在函数结束后就不复存在了。如果&lt;code&gt;lambda&lt;/code&gt;可能在函数结束后执行，捕获的引用指向的局部变量已经消失。&lt;/p&gt;
&lt;p&gt;我们不能拷贝&lt;code&gt;ostream&lt;/code&gt;对象，因此捕获&lt;code&gt;os&lt;/code&gt;的唯一方式就是捕获其引用（或指向&lt;code&gt;os&lt;/code&gt;的指针）。&lt;/p&gt;
&lt;p&gt;我们也可以从一个函数返回&lt;code&gt;lambda&lt;/code&gt;，函数可以直接返回一个可调用对象，或者返回一个类对象，该类含有可调用对象的数据成员。如果函数返回一个&lt;code&gt;lambda&lt;/code&gt;，则与函数不能返回一个局部变量的引用类似，此&lt;code&gt;lambda&lt;/code&gt;也不能包含引用捕获。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当以引用方式捕获一个变量时，必须保证在&lt;code&gt;lambda&lt;/code&gt;执行时变量是存在的。&lt;/strong&gt;&lt;/p&gt;
&lt;h4&gt;隐式捕获&lt;/h4&gt;
&lt;p&gt;除了显式列出我们希望使用的来自所在函数的变量外，还可以让编译器根据&lt;code&gt;lambda&lt;/code&gt;体中的代码来推断我们要使用哪些变量。为了指示编译器推断捕获列表，应在捕获列表中写一个&lt;code&gt;&amp;amp;&lt;/code&gt;或&lt;code&gt;=&lt;/code&gt;。&lt;code&gt;&amp;amp;&lt;/code&gt;告诉编译器采用捕获引用方式，&lt;code&gt;=&lt;/code&gt;则采用值捕获。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//sz为隐式捕获，值捕获方式
wc=find_if(words.begin(),words.end(),
　　[=] (const string &amp;amp;s) { return s.size()&amp;gt;=sz; });
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果我们希望对一部分变量采用值捕获，对其它变量采用引用捕获，可以混合使用隐式捕获和显式捕获：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;void biggies(vector&amp;lt;string&amp;gt; &amp;amp;words, vector&amp;lt;string&amp;gt;::size_type sz, ostream &amp;amp;os=cout, char c=&amp;#39; &amp;#39;)
{

　　//os 隐式捕获，引用捕获方式；c 显式捕获，值捕获方式
　　for_each(words.begin(), words.end(), [&amp;amp;, c] (const string &amp;amp;s) { os &amp;lt;&amp;lt; s &amp;lt;&amp;lt;c; });
　　//os 显式捕获，引用捕获方式；c 隐式捕获，值捕获方式
　　for_each(words.begin(), words.end(),[=, &amp;amp;os] (const string &amp;amp;s) { os &amp;lt;&amp;lt; s &amp;lt;&amp;lt;c; });
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当我们混合使用隐式捕获和显式捕获时，捕获列表中的第一个元素必须是一个&lt;code&gt;&amp;amp;&lt;/code&gt;或&lt;code&gt;=&lt;/code&gt;，此符号指定了默认捕获方式为引用或值。&lt;/p&gt;
&lt;p&gt;当混合使用隐式捕获和显式捕获时，显式捕获的变量必须使用与隐式捕获不同的方式。即，如果隐式捕获是引用方式（使用了&lt;code&gt;&amp;amp;&lt;/code&gt;），则显示捕获命名变量必须采用值方式，因此不能在其名字前使用&lt;code&gt;&amp;amp;&lt;/code&gt;。类似的，如果隐式捕获采用的是值方式（使用了&lt;code&gt;=&lt;/code&gt;），则显式捕获命名变量必须采用引用方式，即，在名字前使用&lt;code&gt;&amp;amp;&lt;/code&gt;。&lt;/p&gt;
&lt;h4&gt;可变 lambda&lt;/h4&gt;
&lt;p&gt;默认情况下，对于一个值被拷贝的变量，&lt;code&gt;lambda&lt;/code&gt;不会改变其值。如果我们希望能改变一个捕获的变量的值，就必须在参数列表首加上关键字&lt;code&gt;mutable&lt;/code&gt;。因此，可变&lt;code&gt;lambda&lt;/code&gt;能省略参数列表：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;void fcn3()
{
　　size_t v1 = 42; //局部变量
　　//f 可以改变它所捕获的变量的值
　　auto f = [v1] () mutable { return ++v1; };
　　v1=0;
　　auto j = f(); //j为43
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;一个引用捕获的变量是否（如往常一样）可以修改依赖于此引用指向的是一个&lt;code&gt;const&lt;/code&gt;类型还是一个非&lt;code&gt;const&lt;/code&gt;类型：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;void fcn4()
{
　　size_t v1 = 42;  //局部变量
　　//v1 是一个非 const 变量的引用
　　//可以通过 f2 中的引用来改变它

　　auto f2 = [&amp;amp;v1] { return ++v1; };
　　v1=0;
　　auto j = f2(); //j为1
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;指定 lambda 返回类型&lt;/h4&gt;
&lt;p&gt;默认情况下，如果一个&lt;code&gt;lambda&lt;/code&gt;体包含&lt;code&gt;return&lt;/code&gt;之外的任何语句，则编译器假定此&lt;code&gt;lambda&lt;/code&gt;返回&lt;code&gt;void&lt;/code&gt;。与其它返回&lt;code&gt;void&lt;/code&gt;的函数类型类似，被推断返回&lt;code&gt;void&lt;/code&gt;的&lt;code&gt;lambda&lt;/code&gt;不能返回值。&lt;/p&gt;
&lt;p&gt;当我们需要为一个&lt;code&gt;lambda&lt;/code&gt;定义返回类型时，必须使用尾置返回类型。&lt;/p&gt;
&lt;h3&gt;参数绑定&lt;/h3&gt;
&lt;p&gt;对于那种只有一两个地方使用的简单操作，&lt;code&gt;lambda&lt;/code&gt;表达式是最有用的。如果我们需要在很多地方使用相同的操作，通常应该定义一个函数，而不是多次编写相同的&lt;code&gt;lambda&lt;/code&gt;表达式。类似的，如果一个操作需要很多语句才能完成，通常使用函数更好。&lt;/p&gt;
&lt;p&gt;但是，对于捕获局部变量的&lt;code&gt;lambda&lt;/code&gt;，用函数来替换它就不是那么容易了。例如，我们用在&lt;code&gt;find_if&lt;/code&gt;调用中的&lt;code&gt;lambda&lt;/code&gt;比较一个&lt;code&gt;string&lt;/code&gt;和一个给定大小。我们可以很容易地编写一个完成同样工作的函数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;bool check_size(const string &amp;amp;s, string::size_type sz)
{
　　return s.size() &amp;gt;= sz;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;但是，我们不能用这个函数作为&lt;code&gt;find_if&lt;/code&gt;的一个参数。&lt;code&gt;find_if&lt;/code&gt;接受一个一元谓词，因此传递给&lt;code&gt;find_if&lt;/code&gt;的可调用对象必须接受单一参数。为了用 check_size 函数来代替&lt;code&gt;lambda&lt;/code&gt;，必须解决如何向 sz 形参传递一个参数的问题。&lt;/p&gt;
&lt;h4&gt;标准库 bind 函数&lt;/h4&gt;
&lt;p&gt;我们可以解决向 check_size 传递一个长度参数的问题，方法是使用一个新的名为&lt;code&gt;bind&lt;/code&gt;的标准库函数，它定义在头文件&lt;code&gt;functional&lt;/code&gt;中。可以将&lt;code&gt;bind&lt;/code&gt;函数看作一个通用的函数适配器，它接受一个可调用对象，生成一个新的可调用对象来“适应”原对象的参数列表。&lt;/p&gt;
&lt;p&gt;调用bind的一般形式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;auto newCallable = bind(callable, arg_list);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中，newCallable 本身是一个可调用对象，arg_list 是一个逗号分隔的参数列表，对应给定的 callable 的参数。即，当我们调用 newCallable 时，newCallable 会调用 callable，并传递给它 arg_list 中的参数。&lt;/p&gt;
&lt;p&gt;arg_list 中的参数可能包含形如 &lt;code&gt;_n&lt;/code&gt; 的名字，其中 n 是一个整数。这些参数是“占位符”，表示 newCallable 的参数，它们占据了传递给 newCallable 的参数的“位置”。数值n表示生成的可调用对象中参数的位置：&lt;code&gt;_1&lt;/code&gt;为newCallable的第一个参数，&lt;code&gt;_2&lt;/code&gt;为第二个参数，以此类推。&lt;/p&gt;
&lt;h4&gt;绑定 check_size 的 sz 参数&lt;/h4&gt;
&lt;p&gt;作为一个简单的例子，我们将使用&lt;code&gt;bind&lt;/code&gt;生成一个调用 check_size 的对象，如下所示，它用一个定值作为其大小参数来调用 check_size:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//check6 是一个可调用对象，接受一个 string 类型的参数
//并用此 string 和值6来调用 check_size
auto check6 = bind(check_size, _1, 6);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;此&lt;code&gt;bind&lt;/code&gt;调用只有一个占位符，表示 check6 只接受单一参数。占位符出现在 arg_list 的第一个位置，表示 check6 的此参数对应 check_size 的第一个参数。此参数是一个&lt;code&gt;const string&amp;amp;&lt;/code&gt;。因此，调用 check6 必须传递给它一个&lt;code&gt;string&lt;/code&gt;类型的参数，check6 会将此参数传递给 check_size。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;string s = &amp;quot;hello&amp;quot;;
bool b1 = check6(s); //check6(s) 会调用 check_size(s, 6)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;使用&lt;code&gt;bind&lt;/code&gt;，我们可以将原来基于&lt;code&gt;lambda&lt;/code&gt;的&lt;code&gt;find_if&lt;/code&gt;调用：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;auto wc = find_if(words.begin(), words.end(), [sz] (const string &amp;amp;s)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;替换为如下使用 check_size 的版本：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;auto wc = find_if(words.begin(), words.end(), bind(check_size, _1, sz));
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;此&lt;code&gt;bind&lt;/code&gt;调用生成一个可调用对象，将 check_size 的第二个参数绑定到 sz 的值。&lt;/p&gt;
&lt;h4&gt;placeholders&lt;/h4&gt;
&lt;p&gt;名字&lt;code&gt;_n&lt;/code&gt;都定义在一个名为&lt;code&gt;placeholders&lt;/code&gt;的命名空间中，而这个命名空间本身定义在&lt;code&gt;std&lt;/code&gt;命名空间中。为了使用这些名字，两个命名空间都要写上。例如，&lt;code&gt;_1&lt;/code&gt;对应的&lt;code&gt;using&lt;/code&gt;声明为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;using&lt;/span&gt; &lt;span class="nt"&gt;std&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nd"&gt;placeholders&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nd"&gt;_1&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;此声明说明我们要使用的名字&lt;code&gt;_1&lt;/code&gt;定义在命名空间&lt;code&gt;placeholders&lt;/code&gt;中，而此命名空间又定义在命名空间&lt;code&gt;std&lt;/code&gt;中。&lt;/p&gt;
&lt;p&gt;对每个占位符名字，我们都必须提供一个单独的&lt;code&gt;using&lt;/code&gt;声明。编写这样的声明很烦人，也很容易出错。可以使用另外一种不同形式的&lt;code&gt;using&lt;/code&gt;语句，而不是分别声明每个占位符，如下所示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;using&lt;/span&gt; &lt;span class="n"&gt;namespace&lt;/span&gt; &lt;span class="n"&gt;namespace_name&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这种形式说明希望所有来自&lt;code&gt;namespace_name&lt;/code&gt;的名字都可以在我们的程序中直接使用。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;using&lt;/span&gt; &lt;span class="n"&gt;namespace&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;placeholders&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;使得由&lt;code&gt;placeholders&lt;/code&gt;定义的所有名字都可用。与&lt;code&gt;bind&lt;/code&gt;函数一样，&lt;code&gt;placeholders&lt;/code&gt;命名空间也定义在&lt;code&gt;functional&lt;/code&gt;头文件中。&lt;/p&gt;
&lt;h4&gt;绑定引用参数&lt;/h4&gt;
&lt;p&gt;默认情况下，&lt;code&gt;bind&lt;/code&gt;的哪些不是占位符的参数被拷贝到&lt;code&gt;bind&lt;/code&gt;返回的可调用对象中。但是，与&lt;code&gt;lambda&lt;/code&gt;类似，有时对有些绑定的参数我们希望以引用方式传递，或是要绑定参数的类型无法拷贝。例如，为了替换一个引用方式捕获&lt;code&gt;ostream&lt;/code&gt;的&lt;code&gt;lambda&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bind&lt;/code&gt;拷贝其参数，而我们不能拷贝一个&lt;code&gt;ostream&lt;/code&gt;，如果我们希望传递给&lt;code&gt;bind&lt;/code&gt;一个对象而又不是拷贝它，就必须使用标准库&lt;code&gt;ref&lt;/code&gt;函数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;for_each(words.begin(), words.end(), bind(print, ref(os), _1,&amp;#39; &amp;#39;));
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;函数&lt;code&gt;ref&lt;/code&gt;返回一个对象，包含给定的引用，此对象是可以拷贝的。标准库中还有一个&lt;code&gt;cref&lt;/code&gt;函数，生成一个保存&lt;code&gt;const&lt;/code&gt;引用的类。与&lt;code&gt;bind&lt;/code&gt;一样，函数&lt;code&gt;ref&lt;/code&gt;和&lt;code&gt;cref&lt;/code&gt;也定义在头文件&lt;code&gt;functional&lt;/code&gt;中。&lt;/p&gt;
&lt;h2&gt;再探迭代器&lt;/h2&gt;
&lt;p&gt;除了为每个容器定义的迭代器之外，标准库在头文件iterator中还定义了额外几种迭代器。这些迭代器包括以下几种。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;迭代器&lt;/th&gt;
&lt;th align="left"&gt;意义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;插入迭代器&lt;/td&gt;
&lt;td align="left"&gt;这些迭代器被绑定到一个容器上，可用来向容器插入元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;流迭代器&lt;/td&gt;
&lt;td align="left"&gt;这些迭代器被绑定到输入或输出上，可用来遍历所有关联的&lt;code&gt;IO&lt;/code&gt;流&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;反向迭代器&lt;/td&gt;
&lt;td align="left"&gt;这些迭代器向后而不是向前移动。除了&lt;code&gt;forward_list&lt;/code&gt;之外的标准库容器都有反向迭代器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;移动迭代器&lt;/td&gt;
&lt;td align="left"&gt;这些专用的迭代器不是拷贝其中的元素，而是移动它们&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;插入迭代器&lt;/h3&gt;
&lt;p&gt;插入器是一种迭代器适配器，它接受一个容器，生成一个迭代器，能实现向给定容器添加元素。当我们通过一个迭代器进行赋值时，该迭代器调用容器操作来向给定容器的指定位置插入一个元素。下表列出了这种迭代器支持的操作。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;操作&lt;/th&gt;
&lt;th align="left"&gt;意义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;it = t&lt;/td&gt;
&lt;td align="left"&gt;在 it 指定的当前位置插入值 t。假定 c 是 it 绑定的容器，依赖于插入迭代器的不同种类，此赋值分别调用&lt;code&gt;c.push_back(t)&lt;/code&gt;、&lt;code&gt;c.push_front(t)&lt;/code&gt;或&lt;code&gt;c.insert(t, p)&lt;/code&gt;,其中 p 为传递给&lt;code&gt;inserter&lt;/code&gt;的迭代器位置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;*it, ++it, it++&lt;/td&gt;
&lt;td align="left"&gt;这些操作虽然存在，但不会对 it 做任何事情。每个操作都返回 it&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;插入迭代器有三种类型，差异在于元素插入的位置：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;back_inserter&lt;/code&gt;创建一个使用&lt;code&gt;push_back&lt;/code&gt;的迭代器&lt;/li&gt;
&lt;li&gt;&lt;code&gt;front_inserter&lt;/code&gt;创建一个使用&lt;code&gt;push_front&lt;/code&gt;的迭代器&lt;/li&gt;
&lt;li&gt;&lt;code&gt;inserter&lt;/code&gt;创建一个使用&lt;code&gt;insert&lt;/code&gt;的迭代器。此函数接受三个参数，这个参数必须是一个指向给定容器的迭代器。元素将被插入到给定迭代器所表示的元素之前。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;只有在容器支持&lt;code&gt;push_front&lt;/code&gt;的情况下，我们才可以使用&lt;code&gt;front_inserter&lt;/code&gt;。类似的，只有在容器支持&lt;code&gt;push_back&lt;/code&gt;的情况下，我们才能使用&lt;code&gt;back_inserter&lt;/code&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;理解插入迭代器的工作过程是很重要的：当调用&lt;code&gt;inserter(c,iter)&lt;/code&gt;时，我们得到一个迭代器，接下来使用它时，会将元素插入到 iter 原来所指的位置之前的位置。即，如果 it 是由&lt;code&gt;inserter&lt;/code&gt;生成的迭代器，则下面这样的赋值语句：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;*it = val;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其效果与下面代码一样：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;it = c.insert(it, val); //it 指向新加入的元素
++it; //递增 it 使它指向原来的元素
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;front_inserter&lt;/code&gt;生成的迭代器的行为与&lt;code&gt;inserter&lt;/code&gt;生成的迭代器完全不一样。当我们使用&lt;code&gt;front_inserter&lt;/code&gt;时，元素总是插入到容器第一个元素之前，即使我们传递给&lt;code&gt;inserter&lt;/code&gt;的位置原来指向第一个元素，只要我们在此元素之前插入一个新元素，此元素就不再是容器的首元素了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;list&amp;lt;int&amp;gt; lst = {1, 2, 3, 4};
list&amp;lt;int&amp;gt; lst2, lst3;  //空 list
//拷贝完成之后，lst2 包含4 3 2 1
copy(lst.begin(), lst.end(), front_inserter(lst2));
//拷贝完成之后 lst3 包含1 2 3 4
copy(lst.begin(), lst.end(), inserter(lst3,lst.begin()));
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当调用&lt;code&gt;front_inserter(c)&lt;/code&gt;时，我们得到一个插入迭代器，接下来会调用&lt;code&gt;push_front&lt;/code&gt;。当每个元素被插入到容器 c 中时，它变为 c 的新的首元素。因此，&lt;code&gt;front_inserter&lt;/code&gt;生成的迭代器会将插入的元素序列的顺序颠倒过来，而&lt;code&gt;inserter&lt;/code&gt;和&lt;code&gt;back_inserter&lt;/code&gt;则不会。&lt;/p&gt;
&lt;h3&gt;流迭代器&lt;/h3&gt;
&lt;p&gt;虽然&lt;code&gt;iostream&lt;/code&gt;类型不是容器，但标准库定义了用于这些&lt;code&gt;IO&lt;/code&gt;类型对象的迭代器。&lt;code&gt;istream_iterator&lt;/code&gt;读取输入流，&lt;code&gt;ostream_iterator&lt;/code&gt;向一个输出流写数据。这些迭代器将它们对应的流当作一个特定类型的元素序列来处理。通过使用流迭代器，我们可以用泛型算法从流对象读取数据以及向其写入数据。&lt;/p&gt;
&lt;h4&gt;istream_iterator&lt;/h4&gt;
&lt;p&gt;当创建一个流迭代器时，必须指定迭代器将要读写的对象类型。一个&lt;code&gt;istream_iterator&lt;/code&gt;使用&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;来读取流。因此，&lt;code&gt;istream_iterator&lt;/code&gt;要读取的类型必须定义了输入运算符。当创建一个&lt;code&gt;istream_iterator&lt;/code&gt;时，我们可以将它绑定到一个流。当然，我们还可以默认初始化迭代器，这样就创建了一个可以当作尾后值使用的迭代器。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;istream_iterator&amp;lt;int&amp;gt; int_it(cin); //从 cin 读取 int
istream_iterator&amp;lt;int&amp;gt; int_eof; //尾后迭代器
ifstream in(&amp;quot;afile&amp;quot;);
istream_iterator&amp;lt;string&amp;gt; str_in(in); //从 afile 读取字符串
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;下面是一个用&lt;code&gt;istream_iterator&lt;/code&gt;从标准输入流读取数据，存入一个&lt;code&gt;vector&lt;/code&gt;的例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;istream_iterator&amp;lt;int&amp;gt; in_iter(cin); //从 cin 读取 int
istream_iterator&amp;lt;int&amp;gt; eof;  //istream 尾后迭代器
while(in_iter != eof)
　　//后置递增运算读取流，返回迭代器的旧值
　　//解引用迭代器，获得从流读取的前一个值
　　vec.push_back(*in_iter++);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;此循环从&lt;code&gt;cin&lt;/code&gt;读取&lt;code&gt;int&lt;/code&gt;值，保存在 vec 中。在每个循环步中，循环体代码检查 in_iter 是否等于 eof。eof 被定义为空&lt;code&gt;istream_iterator&lt;/code&gt;,从而可以当作尾后迭代器来使用。对于一个绑定到流的迭代器，一旦其关联的流遇到文件尾或遇到&lt;code&gt;IO&lt;/code&gt;错误，迭代器的值就与尾后迭代器相等。&lt;/p&gt;
&lt;p&gt;我们可以将程序重写为如下形式，这体现了&lt;code&gt;istream_iterator&lt;/code&gt;更有用的地方：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;istream_iterator&amp;lt;int&amp;gt; in_iter(cin), eof; //从 cin 读取 int
vector&amp;lt;int&amp;gt; vec(in_iter,eof);  //从迭代器范围构造 vec
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;本例中我们使用了一对表示范围的迭代器来构造 vec，这两个迭代器是&lt;code&gt;istream_iterator&lt;/code&gt;，这意味着元素范围是通过从关联的流中读取数据获得的。这个构造函数从&lt;code&gt;cin&lt;/code&gt;读取数据，直至遇到文件尾或者遇到一个不是&lt;code&gt;int&lt;/code&gt;的数据为止。从流中读取的数据被用来构造 vec。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;istream_iterator 操作&lt;/th&gt;
&lt;th align="left"&gt;意义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;istream_iterator&lt;T&gt; in(is);&lt;/td&gt;
&lt;td align="left"&gt;in 从输入流 is 读取类型为 T 的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;istream_iterator&lt;T&gt; end;&lt;/td&gt;
&lt;td align="left"&gt;读取类型为 T 的值的 istream_iterator 迭代器，表所尾后位置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;in1 == in2, in1 != in2&lt;/td&gt;
&lt;td align="left"&gt;in1 和 in2 必须读取相同类型。如果它们都是尾后迭代器，或绑定到相同的输入，则两个相等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;*in&lt;/td&gt;
&lt;td align="left"&gt;返回从流中读取数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;in-&amp;gt;mem&lt;/td&gt;
&lt;td align="left"&gt;与&lt;code&gt;(*in).mem&lt;/code&gt;的含义相同&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;++in, in++&lt;/td&gt;
&lt;td align="left"&gt;使用元素类型所定义的&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;运算符从输入流中读取下一个值。与以往一样，前置版本返回一个指向递增后迭代器的引用，后置版本返回旧值&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4&gt;使用算法操作流迭代器&lt;/h4&gt;
&lt;p&gt;由于算法使用迭代器操作来处理数据，而流迭代器又至少支持某种迭代器操作，因此我们至少可以用某些算法来操作流迭代器。下面是一个例子，我们可以用一对&lt;code&gt;istream_iterator&lt;/code&gt;来调用&lt;code&gt;accumulate&lt;/code&gt;，此调用会计算出从标准输入读取的值的和:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;istream_iterator&amp;lt;int&amp;gt; in(cin), eof;
cout &amp;lt;&amp;lt; accumulatre(in, eof, 0) &amp;lt;&amp;lt; endl;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;istream_iterator 允许使用懒惰求值&lt;/h4&gt;
&lt;p&gt;当我们将一个&lt;code&gt;istream_iterator&lt;/code&gt;绑定到一个流时，标准库并不保证迭代器立即从流读取数据。具体实现可以推迟从中读取数据，直到我们使用迭代器时才真正读取。标准库中的实现所保证的是，在我们第一次解引用迭代器之前，从流中读取数据的操作已经完成了。对于大多数程序来说，立即读取还是推迟读取并没有什么差别。但是，如果我们创建了一个&lt;code&gt;istream_iterator&lt;/code&gt;，没有使用就销毁了，或者我们正在从两个不同的对象同步读同一个流，那么何时读取可能就很重要了。&lt;/p&gt;
&lt;h4&gt;ostream_iterator&lt;/h4&gt;
&lt;p&gt;我们可以对任何输出运算符(&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;运算符)的类型定义&lt;code&gt;ostream_iterator&lt;/code&gt;。当创建一个&lt;code&gt;ostream_iterator&lt;/code&gt;时，我们可以提供（可选的）第二参数，它是一个字符串，在输出每个元素后都会打印此字符串。此字符串必须是一个 C 风格字符串（即，一个字符串字面值或者一个指向以空字符结尾的字符数组的指针）。必须将&lt;code&gt;ostream_iterator&lt;/code&gt;绑定到一个指定的流。不允许空的或表示尾后位置的&lt;code&gt;ostream_iterator&lt;/code&gt;。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;ostream_iterator 操作&lt;/th&gt;
&lt;th align="left"&gt;意义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;ostream_iterator&lt;T&gt; out(os);&lt;/td&gt;
&lt;td align="left"&gt;out 将类型为 T 的值写到输出流 os 中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;ostream_iterator&lt;T&gt; out(os,d);&lt;/td&gt;
&lt;td align="left"&gt;out 将类型为T的值写到输出流 os 中，每个值后面都输出一个 d。d 指向一个空字符串结尾的字符数组&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;out = val&lt;/td&gt;
&lt;td align="left"&gt;用 &amp;lt;&amp;lt; 运算符将 val 写入到 out 所绑定的 ostream 中。val 的类型必须与 out 可写的类型兼容&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;*out, ++out, out++&lt;/td&gt;
&lt;td align="left"&gt;这些运算符是存在的，但不对 out 做任何事情。每个运算符都返回 out&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;我们可以使用&lt;code&gt;ostream_iterator&lt;/code&gt;来输出值的序列：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ostream_iterator&amp;lt;int&amp;gt; out_iter(cout,&amp;quot; &amp;quot;);
for(auto e : vec)
　　*out_iter++ = e;   //赋值语句实际上将元素写到 cout
cout &amp;lt;&amp;lt; endl;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;此程序将 vec 中的每个元素写到&lt;code&gt;cout&lt;/code&gt;，每个元素加一个空格，每次向 out_iter 赋值时，写操作就会被提交。&lt;/p&gt;
&lt;p&gt;值得注意的是，当我们向 out_iter 赋值时，可以忽略解引用和递增运算。即，循环可以重写成下面的样子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;for(auto e : vec)
　　out_iter = e;//赋值语句将元素写到 cout
cout &amp;lt;&amp;lt; end;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;运算符&lt;code&gt;*&lt;/code&gt;和&lt;code&gt;++&lt;/code&gt;实际上对&lt;code&gt;ostream_iterator&lt;/code&gt;对象不做任何事情，因此忽略它们对我们的程序没有任何影响。但是，推荐第一种形式。在这种写法中，流迭代器的使用与其他迭代器的使用保存一致。如果想将此循环改为操作其他迭代器类型，修改起来非常容易。而且，对于读者来说，此循环的行为也更为清晰。&lt;/p&gt;
&lt;p&gt;可以通过调用&lt;code&gt;copy&lt;/code&gt;来打印 vec 中的元素，这比编写循环更为简单：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;copy(vec.begin(), vec.end(), out_iter);
cout &amp;lt;&amp;lt; endl;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;反向迭代器&lt;/h3&gt;
&lt;p&gt;反向迭代器就是在容器中从尾元素向首元素反向移动的迭代器。对于反向迭代器，递增（以及递减）操作的含义会颠倒过来。递增一个反向迭代器（++it）会移动到前一个元素；递减一迭代器（--it）会移动到下一个元素。&lt;/p&gt;
&lt;p&gt;除了&lt;code&gt;forward_list&lt;/code&gt;之外，其他容器都支持反向迭代器。我们可以通过调用&lt;code&gt;rbegin&lt;/code&gt;、&lt;code&gt;rcend&lt;/code&gt;、&lt;code&gt;crbegin&lt;/code&gt;和&lt;code&gt;crend&lt;/code&gt;成员函数来获得反向迭代器。这些成员函数返回指向容器尾元素和首元素之前一个位置的迭代器。与普通迭代器一样，反向迭代器也有&lt;code&gt;const&lt;/code&gt;和非&lt;code&gt;const&lt;/code&gt;版本。&lt;/p&gt;
&lt;h4&gt;反向迭代器需要递减运算符&lt;/h4&gt;
&lt;p&gt;我们只能从既支持&lt;code&gt;++&lt;/code&gt;也支持&lt;code&gt;--&lt;/code&gt;的迭代器来定义反向迭代器。毕竟反向迭代器的目的是在序列中反向移动。除了&lt;code&gt;forward_list&lt;/code&gt;之外，标准容器上的其他迭代器都既支持递增运算又支持递减运算。但是，流迭代器不支持递减运算，因为不可能在一个流中反向移动。因此，不可能从一个&lt;code&gt;forward_list&lt;/code&gt;或一个流迭代器创建反向迭代器。&lt;/p&gt;
&lt;h4&gt;反向迭代器与其他迭代器间的关系&lt;/h4&gt;
&lt;p&gt;假定有一个名为 line 的&lt;code&gt;string&lt;/code&gt;，保存着一个逗号分隔的单词列表，我们希望打印 line 中的第一个单词，使用&lt;code&gt;find&lt;/code&gt;可以很容易地完成这一任务：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//在一个逗号分隔的列表中查找一个元素
auto comma = find(line.cbegin(), line.cend(), &amp;#39;,&amp;#39;);
cout &amp;lt;&amp;lt; string(line.cbegin(), comma) &amp;lt;&amp;lt; endl;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果 line 中有逗号，那么 comma 将指向这个逗号；否则，它将等于 line.cend().当我们打印从 line.cbegin() 到 comma 之间的内容时，将打印到逗号为止的序列，或者打印整个&lt;code&gt;string&lt;/code&gt;（如果其中不含逗号的话）。&lt;/p&gt;
&lt;p&gt;如果希望打印最后一个单词，可以改用反向迭代器：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//在一个逗号分隔的列表中查找最后一个元素
auto rcomma = find(line.crbegin(), line.crend(), &amp;#39;,&amp;#39;);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;由于我们将&lt;code&gt;crbegin&lt;/code&gt;和&lt;code&gt;crend&lt;/code&gt;传递给&lt;code&gt;find&lt;/code&gt;，&lt;code&gt;find&lt;/code&gt;将从 line 的最后一个字符开始向前搜索。当&lt;code&gt;find&lt;/code&gt;完成后，如果 line 中有逗号，则 rcomma 指向最后一个逗号——即，它指向反向搜索中找到的第一个逗号。如果 line 中没有逗号，则 rcomma 指向 line.crend()。&lt;/p&gt;
&lt;p&gt;但我们试图打印找到的单词时，看起来下面的代码是显然的方法&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//错误:将逆序输出单词的字符
cout &amp;lt;&amp;lt; string(line.crbegin(), rcomma) &amp;lt;&amp;lt; endl;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;但它会生成错误的输出结果。例如，如果我们的输入是：FIRST,MIDOLE,LAST&lt;/p&gt;
&lt;p&gt;则这条语句会打印：TSAL&lt;/p&gt;
&lt;p&gt;问题所在：我们使用的是反向迭代器，会反向处理&lt;code&gt;string&lt;/code&gt;。因此，上述输出语句从&lt;code&gt;crbegin&lt;/code&gt;开始反向打印 line 中内容。而我们希望按正常顺序打印从 rcomma 开始到 line 末尾间的字符。但是，我们不能直接使用 rcomma。因为它是一个反向迭代器，意味着它会反向朝着&lt;code&gt;string&lt;/code&gt;的开始位置移动。需要做的是，将 rcomma 转换回一个普通迭代器，能在 line 中正向移动。我们通过调用&lt;code&gt;reverse_iterator&lt;/code&gt;的&lt;code&gt;base&lt;/code&gt;成员函数来完成这一转换，此成员函数会返回其对应的普通迭代器：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//正确：得到一个正向迭代器，从逗号开始读取字符直到 line 末尾
cout &amp;lt;&amp;lt; string(rcomma.base(), line.cend()) &amp;lt;&amp;lt; endl;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;rcomma 和 rcomma.base() 指向了不同的元素，line.crbegin() 和 line.cend() 也是如此。这些不同保证了元素范围无论是正向处理还是反向出来都是相同的。从技术上讲，普通迭代器与反向迭代器的关系反映了左闭合区间的特征。关键点在于 [line.crbegin(),rcomma) 和 [rcomma.base(),line.cend()) 指向 line 中相同的元素范围。&lt;/p&gt;
&lt;p&gt;&lt;img alt="反向迭代器和普通迭代器之间的关系" src="https://xutree.github.io/images/c++10-1.jpg"&gt;&lt;/p&gt;
&lt;h2&gt;泛型算法结构&lt;/h2&gt;
&lt;p&gt;任何算法的最基本的特性是它要求其迭代器提供哪些操作。某些算法，如&lt;code&gt;find&lt;/code&gt;，只要求通过迭代器访问元素、递增迭代器以及比较两个迭代器是否相等这些能力。其他一些算法，如&lt;code&gt;sort&lt;/code&gt;，还要求读、写和随机访问元素的能力。算法所要求的迭代器操作可以分为5个迭代器类别，如表所示：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;迭代器类型&lt;/th&gt;
&lt;th align="left"&gt;要求&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;输入迭代器&lt;/td&gt;
&lt;td align="left"&gt;只读，不写；单遍扫描，只能递&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;输出迭代器&lt;/td&gt;
&lt;td align="left"&gt;只写，不读；单遍扫描，只能递&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;前向迭代器&lt;/td&gt;
&lt;td align="left"&gt;可读写；多遍扫描，只能递&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;双向迭代器&lt;/td&gt;
&lt;td align="left"&gt;可读写；多遍扫描，可递增递&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;随机访问迭代器&lt;/td&gt;
&lt;td align="left"&gt;可读写；多遍扫描，支持全部迭代器运&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;5类迭代器&lt;/h3&gt;
&lt;p&gt;类似容器，迭代器也定义了一组公共操作，一些操作所有迭代器都支持，另外一些只有特定类别的迭代器才支持。例如，&lt;code&gt;ostream_iterator&lt;/code&gt;只支持递增、解引用和赋值。&lt;code&gt;vector&lt;/code&gt;、&lt;code&gt;string&lt;/code&gt;和&lt;code&gt;deque&lt;/code&gt;的迭代器除了这些操作外，还支持递减、关系和算术运算。&lt;/p&gt;
&lt;p&gt;迭代器是按它们所提供的操作来分类的，而这种分类形成了一种层次。除了输出迭代器之外，一个高层类别的迭代器支持底层类别迭代器的所有操作。&lt;/p&gt;
&lt;h4&gt;输入迭代器&lt;/h4&gt;
&lt;p&gt;输入迭代器：可以读取序列中的元素。一个输入迭代器必须支持：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用于比较两个迭代器的相等和不相等运算符（==、!=）&lt;/li&gt;
&lt;li&gt;用于推进迭代器的前置和后置递增运算（++）&lt;/li&gt;
&lt;li&gt;用于读取元素的解引用运算符（*）；解引用只会出现在赋值运算符的右侧&lt;/li&gt;
&lt;li&gt;箭头运算符（-&amp;gt;），等价于（*it）.member，即，解引用迭代器，并提取对象的成员&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;输入迭代器只用于顺序访问。对于一个输入迭代器，&lt;code&gt;*it++&lt;/code&gt;保证是有效的，但递增它可能导致所有其他指向流的迭代器失效。其结果就是，不能保证输入迭代器的状态可以保存下来并用来访问元素。因此，输入迭代器只能用于单遍扫描算法。算法&lt;code&gt;find&lt;/code&gt;和&lt;code&gt;accumulate&lt;/code&gt;要求输入迭代器；而&lt;code&gt;istream_iterator&lt;/code&gt;是一种输入迭代器。&lt;/p&gt;
&lt;h4&gt;输出迭代器&lt;/h4&gt;
&lt;p&gt;输出迭代器：可以看做输入迭代器功能上的补集——只写而不读元素。输出迭代器必须支持：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用于推进迭代器的前置和后置递增运算（++）&lt;/li&gt;
&lt;li&gt;解引用运算符（*），只能出现在赋值运算符的左侧（向一个已经解引用的输出迭代器赋值，就是将值写入它所指向的元素）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们只能向一个输出迭代器赋值一次。类似输入迭代器，输出迭代器只能用于单遍扫描算法。用作目的位置的迭代器通常都是输出迭代器。例如，&lt;code&gt;copy&lt;/code&gt;函数的第三个参数就是输出迭代器。&lt;code&gt;ostream_iterator&lt;/code&gt;类型也是输出迭代器。&lt;/p&gt;
&lt;h4&gt;前向迭代器&lt;/h4&gt;
&lt;p&gt;前向迭代器：可以读元素。这类迭代器只能在序列中沿一个方向移动。前向迭代器支持所有输入和输出迭代器的操作，而且可以多次读写同一个元素。因此，我们可以保存前向迭代器的状态，使用前向迭代器的算法可以对序列进行多遍扫描。算法&lt;code&gt;replace&lt;/code&gt;要求前向迭代器，&lt;code&gt;forward_list&lt;/code&gt;上的迭代器就是前向迭代器。&lt;/p&gt;
&lt;h4&gt;双向迭代器&lt;/h4&gt;
&lt;p&gt;双向迭代器：可以正向/反向读写序列中的元素。除了支持所有前向迭代器的操作之外，双向迭代器还支持前置和后置递减运算符（--）。算法&lt;code&gt;reverse&lt;/code&gt;要求双向迭代器，除了&lt;code&gt;forward_list&lt;/code&gt;之外，其他标准库都提供符合双向迭代器要求的迭代器。&lt;/p&gt;
&lt;h4&gt;随机迭代器&lt;/h4&gt;
&lt;p&gt;随机访问迭代器：提供在常量时间内访问序列中的任意元素的能力。此类迭代器支持双向迭代器的所有功能，此外还支持如下的操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用于比较两个迭代器相对位置的关系运算符（&amp;lt;、&amp;lt;=、&amp;gt; 和 &amp;gt;=）&lt;/li&gt;
&lt;li&gt;迭代器和一个整数值的加减运算（+、+=、- 和 -=），计算结果是迭代器在序列中前进（或后退）给定整数个元素后的位置&lt;/li&gt;
&lt;li&gt;用于两个迭代器上的减法运算符（-）得到两个迭代器的距离&lt;/li&gt;
&lt;li&gt;下标运算符 (iter[n])，与 *(iter[n]) 等价&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;算法&lt;code&gt;sort&lt;/code&gt;要求随机访问迭代器，&lt;code&gt;array&lt;/code&gt;、&lt;code&gt;deque&lt;/code&gt;、&lt;code&gt;string&lt;/code&gt;和&lt;code&gt;vector&lt;/code&gt;的迭代器都是随机访问迭代器，用于访问内置数组元素的指针也是。&lt;/p&gt;
&lt;h3&gt;算法形参模式&lt;/h3&gt;
&lt;p&gt;在任何其他算法分类之上，还有一组参数规范。大多数算法具有如下4种形式之一：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;alg(beg, end, other args);
alg(beg, end, dest, other args);
alg(beg, end, beg2, other args);
alg(beg, end, beg2, end2, other args);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中 alg 是算法的名字，beg 和 end 表示算法所操作的输入范围。几乎所有算法都接受一个输入范围，是否有其他参数依赖于要执行的操作。这里列出了常见的一种——dest、beg2 和 end2，都是迭代器参数。顾名思义，如果用到了这些迭代器参数，它们分别承担指定目的位置和第二个范围的角色。除了这些迭代器参数，一些算法还接受额外的、非迭代器的特定参数。&lt;/p&gt;
&lt;h3&gt;算法命名规范&lt;/h3&gt;
&lt;h4&gt;一些算法使用重载形式传递一个谓词&lt;/h4&gt;
&lt;p&gt;接受谓词参数来代替 &amp;lt; 或 == 运算符的算法，以及哪些不接受额外参数的算法，通常都是重载的函数。函数的一个版本用元素类型的运算符来比较元素；另一个版本接受一个额外谓词参数，来代替 &amp;lt; 或 ==。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;unique(beg, end);  //使用 == 运算符比较元素
unique(beg, end, comp); 　　//使用 comp 比较运元素
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;两个调用都重新整理给定序列，将相邻的重复元素删除。第一个调用使用元素类型的 == 运算符来检查重复元素；第二个则调用 comp 来确定两个元素是否相等。由于两个版本的函数在参数个数上不相等，因此具体应该调用那个不会产生歧义。&lt;/p&gt;
&lt;h4&gt;_if 版本的算法&lt;/h4&gt;
&lt;p&gt;接受一个元素值的算法通常有另一个不同名的版本，该版本接受一个谓词代替元素值。接受谓词参数的算法都有附加 _if 前缀：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;find(beg, end, val); //查找输入范围中 val 第一次出现的位置
find_if(beg, end, pred);  //查找第一个令 pred 为真的元素
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这两个算法提供了命名上的差异的版本，而非重载版本，因为两个版本的算法都接受相同数目的参数。因此可能产生重载歧义，虽然很罕见，但为了避免任何可能的歧义，标准库提供不同名字的版本而不是重载。&lt;/p&gt;
&lt;h4&gt;区分拷贝元素的版本和不拷贝的版本&lt;/h4&gt;
&lt;p&gt;默认情况下，重排元素的算法将重排后的元素写回固定的输入序列中。这些算法还提供另一个版本，将元素写到一个指定的输出目的位置。如我们所见，写到额外目的空间的算法都在名字后面附加一个 _copy：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;reverse(beg, end); //反转输入范围中元素的顺序
reverse_copy(beg, end, dest); //将元素按逆序拷贝到 dest
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;一些算法同时提供 _copy 和 _if 版本。这些版本接受一个目的位置迭代器和一个谓词：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//从 v1 中删除奇数元素
remove_if(v1.begin(), v1.end(), [] (int i) { return i % 2; });
//将偶数元素从 v1 拷贝到 v2；v1 不变
remove_copy_if(v1.begin(), v1.end(), back_inserter(v2), [] (int i) { return i % 2; });
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;两个算法都调用了&lt;code&gt;lambda&lt;/code&gt;来确定元素是否为奇数。在第一个调用中，我们从输入序列中将奇数元素删除。在第二个调用中，我们将非奇数（即偶数）元素从输入范围拷贝到 v2 中。&lt;/p&gt;
&lt;h2&gt;特定容器算法&lt;/h2&gt;
&lt;p&gt;与其他容器不同，链表类型&lt;code&gt;list&lt;/code&gt;与&lt;code&gt;forward_list&lt;/code&gt;定义了几个成员函数形式的算法。特别是，它们定义了独有的&lt;code&gt;sort&lt;/code&gt;、&lt;code&gt;merge&lt;/code&gt;、&lt;code&gt;remove&lt;/code&gt;、&lt;code&gt;reverse&lt;/code&gt;和&lt;code&gt;unique&lt;/code&gt;。通用版本的&lt;code&gt;sort&lt;/code&gt;要求随机访问迭代器，因此不能用于&lt;code&gt;list&lt;/code&gt;和&lt;code&gt;forward_list&lt;/code&gt;，因为这两个类型分别提供双向迭代器和前向迭代器。&lt;/p&gt;
&lt;p&gt;链表类型定义的其他算法的通用版本可以用于链表，但代价太高。这些算法需要交换输入序列中的元素。一个链表可以通过改变元素间的链接而不是真正的交换它们的值来传递“交换”元素。因此，这些链表版本的算法的性能比对应的通用版本好很多。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对于&lt;code&gt;list&lt;/code&gt;和&lt;code&gt;forward_list&lt;/code&gt;应该优先使用成员函数版本的算法而不是通用算法。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;list&lt;/code&gt;和&lt;code&gt;forward_list&lt;/code&gt;成员函数版本的算法，这些操作都返回&lt;code&gt;void&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;lst.merge(lst2)、lst.merge(lst2, comp)：将来自 lst2 的元素合并入 lst。lst 和 lst2 都必须是有序的。元素将从 lst2 中删除。在合并之后，lst2 变为空。第一个版本使用 &amp;lt; 运算符；第二个版本使用给定的比较操作&lt;/li&gt;
&lt;li&gt;lst.remove(val)、lst.remove_if(pred)：调用 erase 删除掉与给定值相等（==）或令一元谓词为真的每个元素&lt;/li&gt;
&lt;li&gt;lst.reverse()：反转 lst 中元素的顺序&lt;/li&gt;
&lt;li&gt;lst.sort()、lst.sort(comp)：使用 &amp;lt; 或给定比较操作排序元素&lt;/li&gt;
&lt;li&gt;lst.unique()、lst.unique(pred)：调用 erase 删除同一值的连续拷贝。第一个版本使用 ==；第二个版本使用给定的二元谓词&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;splice 成员&lt;/h3&gt;
&lt;p&gt;链表类型还定义了splice算法。此算法是链表数据结构所特有的，因此不需要通用版本。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;list&lt;/code&gt;和&lt;code&gt;forward_list&lt;/code&gt;的&lt;code&gt;splice&lt;/code&gt;成员函数的参数：&lt;/p&gt;
&lt;p&gt;lst.splice(args)或flst.splice_after(args)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(p,lst2)：p 是一个指向 lst 中元素的迭代器，或一个指向 flst 首前位置的迭代器。函数将 lst2 的所有元素移动到 lst 中 p 之前的位置或是 flst 中 p 之后的位置。将元素从 lst2 中删除。lst2 的类型必须与 lst 或 flst 相同，且不能是同一个链表&lt;/li&gt;
&lt;li&gt;(p,lst2,p2)：p2 是一个指向 lst2 中位置的有效的迭代器。将 p2 指向的元素移动到 lst 中，或将 p2 之后的元素移动到 flst 中。lst2 可以是与 lst 或 flst 相同的链表&lt;/li&gt;
&lt;li&gt;(p,lst2,b,e)：b 和 e 必须表示 lst2 中的合法范围。将给定范围中的元素从 lst2 移动到 lst 或 flst。lst2 与 lst（或 flst）可以是相同的链表，但 p 不能指向给定范围中元素&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;链表特有的操作会改变容器&lt;/h3&gt;
&lt;p&gt;多数链表特有的算法都与其通用版本很相似，但不完全相同。链表特有版本与通用版本间的一个至关重要的区别是链表版本会改变底层的容器。例如，&lt;code&gt;remove&lt;/code&gt;的链表版本会删除指定的元素。&lt;code&gt;unique&lt;/code&gt;的链表版本会删除第二个和后继的重复元素。&lt;/p&gt;
&lt;p&gt;类似的，&lt;code&gt;merge&lt;/code&gt;和&lt;code&gt;splice&lt;/code&gt;会销毁其参数。例如，通用版本的&lt;code&gt;remove&lt;/code&gt;将合并的序列写给一个给定的目的迭代器：两个输入序列是不变的。而链表版本的&lt;code&gt;merge&lt;/code&gt;函数会销毁给定的链表——元素从参数指定的链表中删除，被合并到调用&lt;code&gt;merge&lt;/code&gt;的链表对象中。在&lt;code&gt;merge&lt;/code&gt;之后，来自两个链表中的元素仍然存在，但它们都已在同一个链表中。&lt;/p&gt;</content><category term="C++"></category></entry><entry><title>C++ Primer 第九章 顺序容器</title><link href="https://xutree.github.io/pages/2018/10/16/C++_Primer_Chapter_9/" rel="alternate"></link><published>2018-10-16T22:43:16+08:00</published><updated>2018-10-17T11:12:28+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-16:/pages/2018/10/16/C++_Primer_Chapter_9/</id><summary type="html">&lt;p&gt;一个容器就是一些特定类型对象的集合。顺序容器（sequential container）为程序员提供了控制元素存储和访问顺序的能力。这种顺序不依赖于元素的值，而是与元素加入容器时的位置相对应。&lt;/p&gt;
&lt;h2&gt;顺序容器概述&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;类型&lt;/th&gt;
&lt;th align="left"&gt;简介&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;code&gt;vector&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;可变大小数组。支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;code&gt;deque&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;双端队列。支持快速随机访问。在头尾位置插入或删除速度很快&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;code&gt;list&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;双向链表。只支持双向顺序访问。在任何位置进行插入或删除都很快&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;code&gt;forward_list&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;单向链表。只支持单向顺序访问。在任何位置进行插入或删除都很快&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;code&gt;array&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;固定大小数组。支持快速随机访问。不能添加或删除元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;code&gt;string&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;与&lt;code&gt;vector&lt;/code&gt;相似的容器，专门用于保存字符。随机访问快。在尾部插入或删除快&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;string&lt;/code&gt;和&lt;code&gt;vector&lt;/code&gt;保存在连续的内存空间中，因此由下标计算地址非常快速。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;forward_list&lt;/code&gt;的设计目标是达到与最好的手写的单向链表数据结构相当的性能，因此不提供&lt;code&gt;size&lt;/code&gt;操作，因为保存和计算大小会增加开销。&lt;/p&gt;
&lt;p&gt;通常，&lt;code&gt;vector …&lt;/code&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;一个容器就是一些特定类型对象的集合。顺序容器（sequential container）为程序员提供了控制元素存储和访问顺序的能力。这种顺序不依赖于元素的值，而是与元素加入容器时的位置相对应。&lt;/p&gt;
&lt;h2&gt;顺序容器概述&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;类型&lt;/th&gt;
&lt;th align="left"&gt;简介&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;code&gt;vector&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;可变大小数组。支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;code&gt;deque&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;双端队列。支持快速随机访问。在头尾位置插入或删除速度很快&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;code&gt;list&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;双向链表。只支持双向顺序访问。在任何位置进行插入或删除都很快&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;code&gt;forward_list&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;单向链表。只支持单向顺序访问。在任何位置进行插入或删除都很快&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;code&gt;array&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;固定大小数组。支持快速随机访问。不能添加或删除元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;code&gt;string&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;与&lt;code&gt;vector&lt;/code&gt;相似的容器，专门用于保存字符。随机访问快。在尾部插入或删除快&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;string&lt;/code&gt;和&lt;code&gt;vector&lt;/code&gt;保存在连续的内存空间中，因此由下标计算地址非常快速。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;forward_list&lt;/code&gt;的设计目标是达到与最好的手写的单向链表数据结构相当的性能，因此不提供&lt;code&gt;size&lt;/code&gt;操作，因为保存和计算大小会增加开销。&lt;/p&gt;
&lt;p&gt;通常，&lt;code&gt;vector&lt;/code&gt;是最好的选择。&lt;/p&gt;
&lt;p&gt;每个容器都定义在同名的头文件中，容器均是模板类。&lt;/p&gt;
&lt;h2&gt;容器库概览&lt;/h2&gt;
&lt;h3&gt;类型别名&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;类型别名&lt;/th&gt;
&lt;th align="left"&gt;意义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;code&gt;iterator&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;此容器类型的迭代器类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;code&gt;const_iterator&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;常量迭代器类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;code&gt;size_type&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;无符号整数，足够保存此种容器的最大大小&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;code&gt;difference_type&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;带符号整数，足够保存两个迭代器之间的距离&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;code&gt;value_type&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;元素类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;code&gt;reference&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;元素的左值类型，与&lt;code&gt;value_type&amp;amp;&lt;/code&gt;含义相同&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;code&gt;const_reference&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;常量左值类型&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;构造函数&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;构造函数&lt;/th&gt;
&lt;th align="left"&gt;意义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;C c;&lt;/td&gt;
&lt;td align="left"&gt;默认构造函数，构造空容器。如果 c 是一个&lt;code&gt;array&lt;/code&gt;，则元素按默认方式初始化&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;C c1(c2);&lt;/td&gt;
&lt;td align="left"&gt;构造 c2 的拷贝 c1，必须为相同类型，且保存元素也相同&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;C c1 = c2;&lt;/td&gt;
&lt;td align="left"&gt;同上&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;C c(b, e);&lt;/td&gt;
&lt;td align="left"&gt;构造 c，将迭代器指定的范围内的元素拷贝到 c，类型要相容（&lt;code&gt;array&lt;/code&gt;不支持）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td a_="a," align="left" b_="b," c...&gt;C c&lt;/td&gt;
&lt;td align="left"&gt;列表初始化，类型要相容，遗漏元素值初始化&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td a_="a," align="left" b_="b," c...&gt;C c = &lt;/td&gt;
&lt;td align="left"&gt;同上&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;C seq(n);&lt;/td&gt;
&lt;td align="left"&gt;包含 n 个元素并进行值初始化，是&lt;code&gt;explicit&lt;/code&gt;构造函数（&lt;code&gt;string&lt;/code&gt;不要求explicit）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;C seq(n, t);&lt;/td&gt;
&lt;td align="left"&gt;包含 n 个初始值为 t 的元素&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;只有顺序容器（不包括&lt;code&gt;array&lt;/code&gt;的构造函数才能接受大小参数）。如果元素类型没有默认构造函数，除了大小参数外，还需要显式指定元素初始值。&lt;code&gt;array&lt;/code&gt;支持拷贝和赋值（内置数组不行）。&lt;/p&gt;
&lt;h3&gt;赋值与 swap&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;赋值与 swap&lt;/th&gt;
&lt;th align="left"&gt;意义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;c1 = c2;&lt;/td&gt;
&lt;td align="left"&gt;将 c1 中的元素替换成 c2 中的元素，类型要相同&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td a_="a," align="left" b_="b," c...&gt;c1 = &lt;/td&gt;
&lt;td align="left"&gt;将 c1 中的元素替换成列表中的元素（&lt;code&gt;array&lt;/code&gt;不支持）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;a.swap(b);&lt;/td&gt;
&lt;td align="left"&gt;交换 a 和 b 的元素，类型要相同，此操作通常比拷贝元素快得多&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;swap(a, b);&lt;/td&gt;
&lt;td align="left"&gt;与上面等价&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;seq.assign(b, e)&lt;/td&gt;
&lt;td align="left"&gt;将 seq 中的元素替换为迭代器范围中的元素，迭代器不能指向 seq 的元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;seq.assign(il)&lt;/td&gt;
&lt;td align="left"&gt;用初始化列表替换&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;seq.assign(n, t)&lt;/td&gt;
&lt;td align="left"&gt;用 n 个 t 替换&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;由于右边运算对象的大小可能与左边不同，因此&lt;code&gt;array&lt;/code&gt;不支持&lt;code&gt;assign&lt;/code&gt;，也不运行用花括号包围的值列表赋值。&lt;code&gt;assign&lt;/code&gt;不适用于关联容器。&lt;code&gt;assign&lt;/code&gt;仅要求类型相容。&lt;/p&gt;
&lt;p&gt;赋值相关操作会导致指向左边容器内部的迭代器、引用和指针失效，而&lt;code&gt;swap&lt;/code&gt;操作不会导致失效（&lt;code&gt;array&lt;/code&gt;和&lt;code&gt;string&lt;/code&gt;除外），它们仍指向交换之前的那些元素。&lt;/p&gt;
&lt;p&gt;除&lt;code&gt;array&lt;/code&gt;外，&lt;code&gt;swap&lt;/code&gt;不对任何元素进行拷贝、删除和插入操作，因此可以保证在常数时间完成，它只是交换了两个容器的内部数据结构。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;swap&lt;/code&gt;两个&lt;code&gt;array&lt;/code&gt;会真正交换它们的元素。在操作之后，指针、引用和迭代器所绑定的元素保持不变，但元素值已经和另一个&lt;code&gt;array&lt;/code&gt;中对应元素的值进行了交换。&lt;/p&gt;
&lt;p&gt;统一使用非成员版本的&lt;code&gt;swap&lt;/code&gt;是一个好习惯。&lt;/p&gt;
&lt;h3&gt;容器大小操作&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;大小&lt;/th&gt;
&lt;th align="left"&gt;意义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;c.size();&lt;/td&gt;
&lt;td align="left"&gt;c 中元素的数目，&lt;code&gt;forward_list&lt;/code&gt;不支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;c.max_size();&lt;/td&gt;
&lt;td align="left"&gt;c 可保存的最大元素数目&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;c.empty();&lt;/td&gt;
&lt;td align="left"&gt;判空&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;关系运算符&lt;/th&gt;
&lt;th align="left"&gt;意义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;==、!=&lt;/td&gt;
&lt;td align="left"&gt;所有容器都支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&amp;lt;、&amp;lt;=、&amp;gt;、&amp;gt;=&lt;/td&gt;
&lt;td align="left"&gt;无序关联容器不支持，类型相同，保存元素也要相同&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;添加元素&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;添加元素&lt;/th&gt;
&lt;th align="left"&gt;意义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;c.push_back(t)&lt;/td&gt;
&lt;td align="left"&gt;在尾部创建值为 t 的元素，返回&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;c.emplace_back(args)&lt;/td&gt;
&lt;td align="left"&gt;在尾部用参数构造元素，返回&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;c.push_front(t)&lt;/td&gt;
&lt;td align="left"&gt;在头部创建值为 t 的元素，返回&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;c.emplace_front(t)&lt;/td&gt;
&lt;td align="left"&gt;在头部用参数构造元素，返回&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;c.insert(p, t)&lt;/td&gt;
&lt;td align="left"&gt;在迭代器 p 指向的元素之前创建值为 t 的元素，返回指向新添加元素迭代器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;c.emplace(p, args)&lt;/td&gt;
&lt;td align="left"&gt;在迭代器 p 指向的元素之前构造值为 t 的元素，返回指向新添加元素迭代器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;c.insert(p, b, e)&lt;/td&gt;
&lt;td align="left"&gt;在迭代器 p 指向的元素之前插入迭代器范围指定的元素，返回指向新添加的第一个元素的迭代器，若范围为空，返回 p&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;c.insert(p, n, t)&lt;/td&gt;
&lt;td align="left"&gt;n 个 t&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;c.insert(p, il)&lt;/td&gt;
&lt;td align="left"&gt;列表&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;这些操作会改变容器大小，&lt;code&gt;array&lt;/code&gt;不支持。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;forward_list&lt;/code&gt;有自己版本的 insert 和 emplace。&lt;code&gt;forward_list&lt;/code&gt;不支持 push_back 和 emplace_back。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vector&lt;/code&gt;和&lt;code&gt;string&lt;/code&gt;不支持push_front 和 emplace_front。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;emplace&lt;/code&gt;函数会在容器管理的内存空间中直接创建对象，而&lt;code&gt;push&lt;/code&gt;函数会创建一个局部临时变量，并将其压入容器中。传递给&lt;code&gt;emplace&lt;/code&gt;的参数必须与元素类型的构造函数相匹配。&lt;/p&gt;
&lt;h3&gt;访问元素&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;访问元素&lt;/th&gt;
&lt;th align="left"&gt;意义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;c.back()&lt;/td&gt;
&lt;td align="left"&gt;返回尾元素引用。若 c 为空，行为未定义&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;c.front()&lt;/td&gt;
&lt;td align="left"&gt;返回首元素引用。若 c 为空，行为未定义&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;c[n]&lt;/td&gt;
&lt;td align="left"&gt;返回下标为 n 元素的引用，n 是一个无符号整数。若 n &amp;gt;= c.size()，行为未定义&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;c.at(n)&lt;/td&gt;
&lt;td align="left"&gt;返回下标为 n 元素的引用，若 n 越界，抛出 out_of_range 异常&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;at&lt;/code&gt;和下标操作只适用于&lt;code&gt;string&lt;/code&gt;、&lt;code&gt;vector&lt;/code&gt;、&lt;code&gt;deque&lt;/code&gt;和&lt;code&gt;array&lt;/code&gt;。&lt;code&gt;back&lt;/code&gt;不适用于&lt;code&gt;forward_list&lt;/code&gt;。&lt;/p&gt;
&lt;h3&gt;删除元素&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;删除元素&lt;/th&gt;
&lt;th align="left"&gt;意义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;c.pop_back()&lt;/td&gt;
&lt;td align="left"&gt;删除尾元素。若 c 为空，行为未定义。返回&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;c.pop_front()&lt;/td&gt;
&lt;td align="left"&gt;删除首元素。若 c 为空，行为未定义。返回&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;c.erase(p);&lt;/td&gt;
&lt;td align="left"&gt;删除迭代器所指元素，返回被删除元素之后元素的迭代器，若 p 为尾后迭代器，行为未定义&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;c.erase(b, e);&lt;/td&gt;
&lt;td align="left"&gt;删除迭代器所指元素，返回最后一个被删除元素之后元素的迭代器，若 e 为尾后迭代器，函数返回尾后迭代器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;c.clear();&lt;/td&gt;
&lt;td align="left"&gt;清空，返回&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;这些操作会改变容器大小，&lt;code&gt;array&lt;/code&gt;不支持。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;forward_list&lt;/code&gt;有自己版本的 erase。&lt;code&gt;forward_list&lt;/code&gt;不支持 pop_back。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vector&lt;/code&gt;和&lt;code&gt;string&lt;/code&gt;不支持pop_front。&lt;/p&gt;
&lt;p&gt;删除元素的成员函数并不检查其参数。在删除元素前，程序员必须确保它们是存在的。&lt;/p&gt;
&lt;h3&gt;迭代器&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;迭代器&lt;/th&gt;
&lt;th align="left"&gt;意义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;c.begin(), c.end()&lt;/td&gt;
&lt;td align="left"&gt;首尾迭代器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;c.cbegin(), c.cend()&lt;/td&gt;
&lt;td align="left"&gt;首尾常量迭代器&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;反向容器额外成员&lt;/th&gt;
&lt;th align="left"&gt;意义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;reverse_iterator&lt;/td&gt;
&lt;td align="left"&gt;按逆序寻址元素的迭代器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;const_reverse_iterator&lt;/td&gt;
&lt;td align="left"&gt;按逆序寻址元素的常量迭代器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;c.rbegin(), c.rend()&lt;/td&gt;
&lt;td align="left"&gt;尾首迭代器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;c.crbegin(), c.crend()&lt;/td&gt;
&lt;td align="left"&gt;尾首常量迭代器&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;注：&lt;code&gt;forward_list&lt;/code&gt;不支持&lt;/p&gt;
&lt;h3&gt;特殊的 forward_list 操作&lt;/h3&gt;
&lt;p&gt;为了理解&lt;code&gt;forward_list&lt;/code&gt;为什么有特殊版本的添加和删除操作，考虑当我们从一个单向链表中删除一个元素时会发生什么。当添加或删除一个元素时，删除或添加的元素之前的那个元素的后继会发生变化。为了添加或删除一个元素，我们需要访问其前驱，以便改变前驱改变前驱的链接。但是，&lt;code&gt;forward_list&lt;/code&gt;是单向链表。在一个单向链表中，没有简单的方法来获取一个元素的前驱，出于这个原因，在一个&lt;code&gt;forward_list&lt;/code&gt;中添加或删除元素的操作是通过改变给定元素之后的元素来完成的。这样，我们总是可以访问到被添加或删除元素所影响的元素。&lt;/p&gt;
&lt;p&gt;由于这些操作与其他容器上的操作有实现方式不同，&lt;code&gt;forward_list&lt;/code&gt;并未定义&lt;code&gt;insert&lt;/code&gt;、&lt;code&gt;emplace&lt;/code&gt;和&lt;code&gt;erase&lt;/code&gt;，而是定义了名为&lt;code&gt;insert_after&lt;/code&gt;、&lt;code&gt;emplace_after&lt;/code&gt;和&lt;code&gt;erase_after&lt;/code&gt;的操作。为了支持这些操作，&lt;code&gt;forward_list&lt;/code&gt;也定义了&lt;code&gt;before_begin&lt;/code&gt;,它返回一个首前迭代器。这个迭代器允许我们在链表首元素之前并不存在的元素“之后”添加或删除元素（亦即在链表首元素之前添加删除元素）。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;操作&lt;/th&gt;
&lt;th align="left"&gt;意义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;lst.before_begin()&lt;/td&gt;
&lt;td align="left"&gt;返回指向链表首元素之前并不存在的元素的迭代器，此迭代器不能解引用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;lst.cbefore_begin()&lt;/td&gt;
&lt;td align="left"&gt;cbefore_begin() 返回一个 const_iterator&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;lst.insert_after(p, t)&lt;/td&gt;
&lt;td align="left"&gt;在迭代器 p 之后的位置插入元素 t，若 p 为尾后迭代器，则函数的行为未定义。若范围为空，返回 p&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;lst.insert_after(p, n, t)&lt;/td&gt;
&lt;td align="left"&gt;在迭代器 p 之后的位置插入 n 个 t&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;lst.insert_after(p, b, e)&lt;/td&gt;
&lt;td align="left"&gt;在迭代器 p 之后的位置插入迭代器范围表示的元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;lst.insert_after(p,il)&lt;/td&gt;
&lt;td align="left"&gt;在迭代器 p 之后的位置插入花括号列表&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;emplace_after(p,args)&lt;/td&gt;
&lt;td align="left"&gt;使用 args 在 p 指定的位置之后构造一个元素，返回一个指向这个新元素的迭代器。若 p 为尾后迭代器，则函数的行为未定义&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;lst.erase_after(p)&lt;/td&gt;
&lt;td align="left"&gt;删除 p 指向的位置之后的元素，返回一个指向被删除元素之后元素的迭代器，若不存在这样的元素，则返回尾后迭代器，如果 p 指向 lst 的尾元素或者是一个尾后迭代器，则函数的行为未定义&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;lst.erase_after(b, e)&lt;/td&gt;
&lt;td align="left"&gt;删除从 b 之后直到（但不包含）e 之间的元素&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;改变容器大小&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;操作&lt;/th&gt;
&lt;th align="left"&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;c.resize(n)&lt;/td&gt;
&lt;td align="left"&gt;调整 c 的大小为 n 个元素。若 n &amp;lt; c.size()，多出的元素被丢弃。若必须添加新元素，则新元素采取值初始化&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;c.resize(n, t)&lt;/td&gt;
&lt;td align="left"&gt;调整 c 的大小为 n 个元素。，多出的元素被丢弃。若必须添加新元素，则新元素初始化为 t&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;c.shrink_to_fit()&lt;/td&gt;
&lt;td align="left"&gt;请求将&lt;code&gt;capacity()&lt;/code&gt;减小为与&lt;code&gt;size()&lt;/code&gt;相同，具体的实现可能忽略此请求&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;c.capacity()&lt;/td&gt;
&lt;td align="left"&gt;不重新分配内存的话，c 可以保存多少元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;c.reserve(n)&lt;/td&gt;
&lt;td align="left"&gt;分配至少能容纳 n 个元素的内存空间&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;shrink_to_fit()&lt;/code&gt;只适用于&lt;code&gt;vector&lt;/code&gt;、&lt;code&gt;string&lt;/code&gt;和&lt;code&gt;deque&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;capacity()&lt;/code&gt;和&lt;code&gt;reserve(n)&lt;/code&gt;只适用于&lt;code&gt;vector&lt;/code&gt;和&lt;code&gt;string&lt;/code&gt;。&lt;/p&gt;
&lt;h2&gt;迭代器失效&lt;/h2&gt;
&lt;h3&gt;添加元素&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;vector&lt;/code&gt;或&lt;code&gt;string&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;存储空间重新分配：迭代器、指针、引用均失效&lt;/li&gt;
&lt;li&gt;未重新分配：插入位置之前的有效，之后的失效&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;deque&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;插入首尾之外：均失效&lt;/li&gt;
&lt;li&gt;插入首尾：迭代器失效，指针、引用不失效&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;list&lt;/code&gt;或&lt;code&gt;forward_list&lt;/code&gt;：都有效（包括尾后和首前）&lt;/p&gt;
&lt;h3&gt;删除元素&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;list&lt;/code&gt;或&lt;code&gt;forward_list&lt;/code&gt;：都有效（包括尾后和首前）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;deque&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;删除首尾之外：均失效&lt;/li&gt;
&lt;li&gt;删除首：首前失效，其他有效&lt;/li&gt;
&lt;li&gt;删除尾：尾后失效，其他有效&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;vector&lt;/code&gt;或&lt;code&gt;string&lt;/code&gt;：被删除元素之前的都有效&lt;/p&gt;
&lt;p&gt;当我们删除元素时，尾后迭代器总是会失效（除了删除&lt;code&gt;deque&lt;/code&gt;首元素外），所以不要保存&lt;code&gt;end&lt;/code&gt;返回的迭代器。&lt;/p&gt;
&lt;h2&gt;额外的 string 操作&lt;/h2&gt;
&lt;h3&gt;构造 string 的其他方法&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;方法&lt;/th&gt;
&lt;th align="left"&gt;解释&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;string s(cp, n)&lt;/td&gt;
&lt;td align="left"&gt;s 是 cp 指向的数组中前 n 个字符的拷贝。此数组至少应该包含 n 个字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;string s(s2, pos2)&lt;/td&gt;
&lt;td align="left"&gt;s 是 string s2 从下标 pos2 开始的字符的拷贝。若 pos2 &amp;gt; s2.size()，行为未定义&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;string s(s2, pos2, len2)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;这些构造函数接受一个&lt;code&gt;string&lt;/code&gt;或&lt;code&gt;const char*&lt;/code&gt;参数。从&lt;code&gt;const char*&lt;/code&gt;拷贝时，指针指向的数组必须以空字符结尾，如果还传递了一个计数值，数组就不必以空字符结尾。&lt;/p&gt;
&lt;h3&gt;substr 操作&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;s.substr(pos, n)&lt;/code&gt;返回一个&lt;code&gt;string&lt;/code&gt;，包含 s 中从 pos 开始的 n 个字符的拷贝。pos 的默认值是0，n 的默认值是 s.size()-pos，即拷贝从 pos 开始的所有字符。如果开始位置超出&lt;code&gt;string&lt;/code&gt;的大小，抛出 out_of_range 异常，不管 n 值为多少，最多拷贝到&lt;code&gt;string&lt;/code&gt;的末尾。&lt;/p&gt;
&lt;h3&gt;其他修改 string 的操作&lt;/h3&gt;
&lt;p&gt;&lt;img alt="修改 string 的操作" src="https://xutree.github.io/images/c++9-1.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="repalce 和 insert参数类型" src="https://xutree.github.io/images/c++9-2.jpg"&gt;&lt;/p&gt;
&lt;h3&gt;string 搜索操作&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;string&lt;/code&gt;类提供了6个不同的搜索函数，每个函数有4个重载版本。每个搜索操作都返回&lt;code&gt;string::size_type&lt;/code&gt;值，表示匹配发生的下标。如果搜索失败，则返回&lt;code&gt;string::npos&lt;/code&gt;的&lt;code&gt;static&lt;/code&gt;成员。标准库将&lt;code&gt;string::npos&lt;/code&gt;定义成一个&lt;code&gt;const string::size_type&lt;/code&gt;，并初始化为-1。由于 npos 是一个无符号数，此初始值意味着 npos 等于任何&lt;code&gt;string&lt;/code&gt;最大的可能大小。&lt;/p&gt;
&lt;p&gt;&lt;img alt="string 搜索操作" src="https://xutree.github.io/images/c++9-3.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="string 搜索操作参数" src="https://xutree.github.io/images/c++9-4.jpg"&gt;&lt;/p&gt;
&lt;h3&gt;compare 函数&lt;/h3&gt;
&lt;p&gt;&lt;img alt="compare 函数" src="https://xutree.github.io/images/c++9-5.jpg"&gt;&lt;/p&gt;
&lt;h3&gt;数值转换&lt;/h3&gt;
&lt;p&gt;&lt;img alt="string 数值转换" src="https://xutree.github.io/images/c++9-6.jpg"&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;string s2 = &amp;quot;pi = 3.14&amp;quot;;
d = stod(s2.substr(s2.find_first_of(&amp;quot;+-.0123456789&amp;quot;)));
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;容器适配器&lt;/h2&gt;
&lt;p&gt;适配器（adaptors）是标准库中的一个通用概念，容器、迭代器和函数都有适配器。本质上，一个适配器是一种机制，能使某种事物的行为看起来像另外一种事物一样。一个容器适配器（Container adaptors）接受一种已有的容器类型，使其行为看起来像一种不同的类型。标准库定义了三个序列容器适配器：&lt;code&gt;stack&lt;/code&gt;、&lt;code&gt;queue&lt;/code&gt;和&lt;code&gt;priority_queue&lt;/code&gt;。&lt;/p&gt;
&lt;h3&gt;所以适配器都支持的的操作和类型&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;名称&lt;/th&gt;
&lt;th align="left"&gt;意义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;size_type&lt;/td&gt;
&lt;td align="left"&gt;一种类型，足以保存当前类型的最大对象的大小&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;value_type&lt;/td&gt;
&lt;td align="left"&gt;元素类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;container_type&lt;/td&gt;
&lt;td align="left"&gt;实现适配器的底层容器类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;A a;&lt;/td&gt;
&lt;td align="left"&gt;创建一个名为 a 的空适配器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;A a(c);&lt;/td&gt;
&lt;td align="left"&gt;创建一个名为 a 的适配器，带有容器 c 的一个拷贝&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;关系运算符&lt;/td&gt;
&lt;td align="left"&gt;每个适配器都支持所有关系运算符。这些关系运算符返回底层容器的比较结果&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;a.empty()&lt;/td&gt;
&lt;td align="left"&gt;判空&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;a.size()&lt;/td&gt;
&lt;td align="left"&gt;元素数目&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;swap(a, b)&lt;/td&gt;
&lt;td align="left"&gt;交换，类型要相同，包括底层容器类型也必须相同&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;a.swap(b)&lt;/td&gt;
&lt;td align="left"&gt;同上&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;定义适配器&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;stack&lt;/code&gt;默认基于&lt;code&gt;deque&lt;/code&gt;实现，要求&lt;code&gt;push_back&lt;/code&gt;、&lt;code&gt;pop_back&lt;/code&gt;和&lt;code&gt;back&lt;/code&gt;操作，可使用除&lt;code&gt;array&lt;/code&gt;和&lt;code&gt;forward_list&lt;/code&gt;之外的任何容器构造&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;queue&lt;/code&gt;默认基于&lt;code&gt;deque&lt;/code&gt;实现，要求&lt;code&gt;back&lt;/code&gt;、&lt;code&gt;push_back&lt;/code&gt;、&lt;code&gt;front&lt;/code&gt;、&lt;code&gt;push_front&lt;/code&gt;操作，可使用&lt;code&gt;list&lt;/code&gt;和&lt;code&gt;deque&lt;/code&gt;构造&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;priority_queue&lt;/code&gt;默认基于&lt;code&gt;vector&lt;/code&gt;实现，要求&lt;code&gt;front&lt;/code&gt;、&lt;code&gt;push_back&lt;/code&gt;和&lt;code&gt;pop_back&lt;/code&gt;操作，还需要随机访问能力，可使用&lt;code&gt;vector&lt;/code&gt;和&lt;code&gt;deque&lt;/code&gt;构造&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;两种构造方法：默认构造函数创建一个空对象；接受一个容器的构造函数拷贝该容器来初始化适配器。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//假设 deq 是一个 deque&amp;lt;int&amp;gt;
stack&amp;lt;int&amp;gt; stk(deq);    //从 deq 拷贝元素到 stk
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们可以在创建一个适配器时将一个命名的顺序容器作为第二个类型参数，来重载默认容器类型：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//在 vector 上实现的空栈
stack&amp;lt;string, vector&amp;lt;string&amp;gt;&amp;gt; str_stk;
//在 vector 上实现的空栈，初始化时保存 svec 的拷贝
stack&amp;lt;string, vector&amp;lt;string&amp;gt;&amp;gt; str_stk2（svec);
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;栈适配器&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;stack&lt;/code&gt;类型定义在同名头文件中。下面展示了如何使用：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;stack&amp;lt;int&amp;gt; intStack;  //空栈
//填满栈
for (size_t ix = 0; ix != 10; ++ix)
    intStack.push(ix);  //栈保存0-9十个数
while (!intStack.empty()) { //栈中有值就继续循环
    int value = intStack.top();
    //使用栈顶值的代码
    intStack.pop(); //弹出栈顶元素，继续循环
}
&lt;/pre&gt;&lt;/div&gt;


&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;操作&lt;/th&gt;
&lt;th align="left"&gt;意义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;s.pop()&lt;/td&gt;
&lt;td align="left"&gt;删除栈顶元素，但不返回该元素值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;s.push(item)&lt;/td&gt;
&lt;td align="left"&gt;创建一个新元素压入栈顶，该元素通过拷贝或移动 item 而来&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;s.emplace(args)&lt;/td&gt;
&lt;td align="left"&gt;构造一个新元素压入栈顶，该元素通过 args 构造&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;s.top()&lt;/td&gt;
&lt;td align="left"&gt;返回栈顶元素，但不将元素弹出栈&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;每个容器适配器都基于底层容器类型的操作定义了自己的特殊操作，我们只能使用适配器操作，而不能使用底层容器类型的操作。&lt;/p&gt;
&lt;h3&gt;队列适配器&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;queue&lt;/code&gt;和&lt;code&gt;priority_queue&lt;/code&gt;定义在头文件 queue 中。操作方法如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;操作&lt;/th&gt;
&lt;th align="left"&gt;意义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;q.pop()&lt;/td&gt;
&lt;td align="left"&gt;删除 queue 的首元素或 priority_queue 的最高优先级的元素，但不返回该元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;q.front()&lt;/td&gt;
&lt;td align="left"&gt;返回首元素，但不删除此元素，只适用于 queue&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;q.back()&lt;/td&gt;
&lt;td align="left"&gt;返回尾元素，但不删除此元素，只适用于 queue&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;q.top()&lt;/td&gt;
&lt;td align="left"&gt;返回优先级最高的元素，但不删除该元素，只适用于 priority_queue&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;q.push(item)&lt;/td&gt;
&lt;td align="left"&gt;在 queue 末尾或 priority_queue 中恰当的位置创建一个元素，其值为 item&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;q.emplace(args)&lt;/td&gt;
&lt;td align="left"&gt;在 queue 末尾或 priority_queue 中恰当的位置由 args 参数构造一个元素&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</content><category term="C++"></category></entry><entry><title>数据结构——向量</title><link href="https://xutree.github.io/pages/2018/10/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%90%91%E9%87%8F/" rel="alternate"></link><published>2018-10-10T19:50:46+08:00</published><updated>2018-10-12T23:39:31+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-10:/pages/2018/10/10/数据结构向量/</id><summary type="html">&lt;p&gt;数据结构大致可分为：线性结构、半线性结构和非线性结构。线性结构中最基本的称为序列（sequence），根据其中数据项的逻辑次序与其物理存储地址的对应关系不同，又可分为向量（vector）和列表（list）。&lt;/p&gt;
&lt;h2&gt;从数组到向量&lt;/h2&gt;
&lt;p&gt;数组：集合 S 由 n 个元素组成，且各元素之间具有一个线性次序，则可以将它们存放于起始地址 A，物理位置连续的一段存储空间。记为：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;A[0,n) = { A[0], A[1], ..., A[n-1] }&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;将它们存放于起始地址 A，若每个元素占用 s 个单位的空间，则元素 A[i] 的物理地址为：&lt;code&gt;A + i * s&lt;/code&gt;，所以被称作线性数组。&lt;/p&gt;
&lt;p&gt;向量：&lt;code&gt;V[0,n) = { v[0 …&lt;/code&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;数据结构大致可分为：线性结构、半线性结构和非线性结构。线性结构中最基本的称为序列（sequence），根据其中数据项的逻辑次序与其物理存储地址的对应关系不同，又可分为向量（vector）和列表（list）。&lt;/p&gt;
&lt;h2&gt;从数组到向量&lt;/h2&gt;
&lt;p&gt;数组：集合 S 由 n 个元素组成，且各元素之间具有一个线性次序，则可以将它们存放于起始地址 A，物理位置连续的一段存储空间。记为：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;A[0,n) = { A[0], A[1], ..., A[n-1] }&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;将它们存放于起始地址 A，若每个元素占用 s 个单位的空间，则元素 A[i] 的物理地址为：&lt;code&gt;A + i * s&lt;/code&gt;，所以被称作线性数组。&lt;/p&gt;
&lt;p&gt;向量：&lt;code&gt;V[0,n) = { v[0], v[1], ..., v[n-1] }&lt;/code&gt;是线性数组的一种抽象和泛化，由具有线性次序的一组元素构成的集合，其中的元素由秩区分。各元素秩互异，且均为 [0, n) 内的整数。采用“寻秩访问”。经过抽象，不限定同一向量中元素都属于同一数据类型，故而不保证它们之间可以相互比较大小。&lt;/p&gt;
&lt;h2&gt;接口&lt;/h2&gt;
&lt;p&gt;作为一种抽象数据类型，向量对象应支持如下操作接口：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;操作接口&lt;/th&gt;
&lt;th align="left"&gt;功能&lt;/th&gt;
&lt;th align="left"&gt;适用对象&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;size()&lt;/td&gt;
&lt;td align="left"&gt;元素总数&lt;/td&gt;
&lt;td align="left"&gt;向量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;get(r)&lt;/td&gt;
&lt;td align="left"&gt;获取秩为 r 的元素&lt;/td&gt;
&lt;td align="left"&gt;向量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;put(r, e)&lt;/td&gt;
&lt;td align="left"&gt;用 e 代替秩为 r 的元素&lt;/td&gt;
&lt;td align="left"&gt;向量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;insert(r, e)&lt;/td&gt;
&lt;td align="left"&gt;e 作为秩为 r 的元素插入，原后继元素依次后移&lt;/td&gt;
&lt;td align="left"&gt;向量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;remove(r)&lt;/td&gt;
&lt;td align="left"&gt;删除秩为 r 的元素，返回该元素中原存放的对象&lt;/td&gt;
&lt;td align="left"&gt;向量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;disordered()&lt;/td&gt;
&lt;td align="left"&gt;判断所有元素是否已按非降序排列&lt;/td&gt;
&lt;td align="left"&gt;向量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;sort()&lt;/td&gt;
&lt;td align="left"&gt;非降序排序&lt;/td&gt;
&lt;td align="left"&gt;向量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;find(e)&lt;/td&gt;
&lt;td align="left"&gt;查找等于 e 且秩最大的元素&lt;/td&gt;
&lt;td align="left"&gt;向量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;search(e)&lt;/td&gt;
&lt;td align="left"&gt;查找目标元素 e，返回不大于 e 且秩最大的元素&lt;/td&gt;
&lt;td align="left"&gt;有序向量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;deduplicate()&lt;/td&gt;
&lt;td align="left"&gt;剔除重复元素&lt;/td&gt;
&lt;td align="left"&gt;向量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;uniquify()&lt;/td&gt;
&lt;td align="left"&gt;剔除重复元素&lt;/td&gt;
&lt;td align="left"&gt;有序向量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;traverse()&lt;/td&gt;
&lt;td align="left"&gt;遍历向量并统一处理所有元素，处理方法由函数对象指定&lt;/td&gt;
&lt;td align="left"&gt;向量&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;Vector 模板类&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;typedef int Rank;   //秩
#define DEFAULT_CAPACITY 3  //默认的初始容量（实际应用中可设置为更大）

template &amp;lt;typename T&amp;gt; class Vector {    //向量模板类
protected:
    Rank _size; int _capacity; T* _elem;    //规模、容量、数据区
    void copyFrom(T const* A, Rank lo, Rank hi);    //复制数组区间A[lo,hi)
    void expand();  //空间不足时扩容
    void shrink();  //装填因子过小时压缩
    bool bubble(Rank lo, Rank hi);  //扫描交换
    void bubbleSort()Rank lo, Rank hi); //气泡排序算法
    Rank max(Rank lo, Rank hi); //选取最大元素
    void selectionSort(Rank lo, Rank hi);   //选择排序算法
    void merge(Rank lo, Rank mi, Rank hi);   //归并算法
    void mergeSort(Rank lo, Rank hi);   //归并排序算法
    Rank partition(Rank lo, Rank hi);   //轴点构造算法
    void quickSort(Rank lo, Rank hi);   //快速排序算法
    void heapSort(Rank lo, Rank hi);    //堆排序
public:
//构造函数
     //容量为 c，规模为 s，所有元素初始化为 v，s&amp;lt;=c
    Vector(int c = DEFAULT_CAPACITY, int s = 0, T v = 0)
    { _elem = new T[_capacity = c]; for(_size = 0; _size &amp;lt; s; _elem[_size++] = v);  }
    Vector(T const* A, Rank n) { copyFrom(A, 0, n); }   //数组整体复制
    Vector(T const* A, Rank lo, Rank hi) { copyFrom(A, lo, hi); }   //区间
    Vector(Vector&amp;lt;T&amp;gt; const&amp;amp; V) { copyFrom(V._elem, 0, V._size); }   //向量整体复制
    Vector(Vector&amp;lt;T&amp;gt; const&amp;amp; V, Rank lo, Rank hi) { copyFrom(V._elem, lo, hi); } //区间
//析构函数
~Vector() { delete [] _elem; }  //释放内部空间
//只读访问接口
    Rank size() const { return _size; } //规模
    bool empty() const { return !_size; }   //判空
    int disordered() const; //判断向量是否已排序
    Rank find(T const&amp;amp; e) const { return find(e, 0, _size); }   //无序向量整体查找
    Rank find(T const&amp;amp; e, Rank lo, Rank hi) const;  //无序向量区间查找
    Rank search(T const&amp;amp; e) const   //有序向量整体查找
    { return (0 &amp;gt;= _size) ? -1 : search(e, 0, _size); }
    Rank search(T const&amp;amp; e, Rank lo, Rank hi) const   //有序向量区间查找
//可写访问接口
    T&amp;amp; operator[](Rank r) const;    //重载下标运算符，可以类似于数组形式引用各元素
    Vector&amp;lt;T&amp;gt; &amp;amp; operator=(Vector&amp;lt;T&amp;gt; const&amp;amp;);    //重载赋值运算符，以便直接克隆向量
    T remove(Rank r);   //删除秩为 r 的元素
    int remove(Rank lo, Rank hi);   //删除秩在区间 [lo,hi) 之内的元素
    Rank insert(Rank r, T const&amp;amp; e);    //插入元素
    Rank insert(T const&amp;amp; e) { return insert(_size, e); }    //默认作为尾元素插入
    void sort(Rank lo, Rank hi);    //对 [lo,hi) 排序
    void sort() { sort(0, _size); } //整体排序
    void unsort(Rank lo, Rank hi);    //对 [lo,hi) 置乱
    void unsort() { unsort(0, _size); } //整体置乱
    int deduplicate();  //无序去重
    int uniquify(); //有序去重
//遍历
    void traverse(void (*)(T&amp;amp;));    //遍历（使用函数指针，只读或局部性修改）
    template &amp;lt;typename VST&amp;gt; void traverse(VST&amp;amp;);    //遍历（使用函数对象，可全局性修改）
};//Vector
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;构造与析构&lt;/h2&gt;
&lt;p&gt;约定：向量中秩为 r 的元素，对应于内部数组中的 _elem[r]，其物理地址为：_elem + r&lt;/p&gt;
&lt;h3&gt;默认构造函数&lt;/h3&gt;
&lt;p&gt;整个默认构造过程顺序进行，没有任何迭代，故忽略用于分配数组空间的时间，需要常数时间。&lt;/p&gt;
&lt;h3&gt;基于复制的构造函数&lt;/h3&gt;
&lt;p&gt;在模板的实现中，我们将基于数组或者向量的复制操作（局部或整体的）都转交给如下的&lt;code&gt;copyFrom&lt;/code&gt;函数处理：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;template &amp;lt;typename T&amp;gt; void Vector&amp;lt;T&amp;gt;::copyFrom(T const* A, Rank lo, Rank hi) {
    _elem = new T[_capacity = 2 * (hi -lo) ]; _size = 0; //分配空间，规模清零
    while( lo &amp;lt;hi) //A[lo,hi) 元素逐一复制
        _elem[_size++] = A[lo++];   //
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;需要 &lt;em&gt;O&lt;/em&gt;(_size) 时间。&lt;/p&gt;
&lt;p&gt;需要强调的是，由于向量内部含有动态分配的空间，默认的“=”运算符不足以支持向量之间的直接赋值。故要重建“=”：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;template &amp;lt;typename T&amp;gt; Vector&amp;lt;T&amp;gt;&amp;amp; Vector&amp;lt;T&amp;gt;::operator=(Vector&amp;lt;T&amp;gt; const&amp;amp; V) {
    if( _elem ) delet [] _elem;
    copyFrom(V._elem, 0, V.size());
    return *this;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;析构&lt;/h3&gt;
&lt;p&gt;若不计系统用于空间回收的时间，整个析构过程只需常数时间。&lt;/p&gt;
&lt;h2&gt;动态空间管理&lt;/h2&gt;
&lt;h3&gt;扩容&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;template &amp;lt;typename T&amp;gt; void Vector&amp;lt;T&amp;gt;::expand() {
    if(_size &amp;lt; _capacity) return;   //尚未满员，不必扩容
    if(_capacity &amp;lt; DEFAULT_CAPACITY) _capacity = DEFAULT_CAPACITY;  //不低于最小容量
    T *oldElem = _elem; _elem = new T[_capacity &amp;lt;&amp;lt; 1]; //容量加倍
    for( int i = 0; i &amp;lt; _size; i++)
        _elem[i] = oldElem[i]; //复制原向量内容（T为基本类型，或以重载赋值运算符
    delete [] oldElem;  //释放原空间
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;分摊运行时间为 &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;
&lt;h3&gt;缩容&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;template &amp;lt;typename T&amp;gt; void Vector&amp;lt;T&amp;gt;::shrink() {
    if(_capacity &amp;lt; DEFAULT_CAPACITY &amp;lt;&amp;lt; 1) return;   //不至收缩到DEFAULT_CAPACITY
    if(_size &amp;lt;&amp;lt; 2 &amp;gt; _capacity) return;  //以25%为界
    T *oldElem = _elem; _elem = new T[_capacity &amp;gt;&amp;gt; 1]; //容量减半
    for( int i = 0; i &amp;lt; _size; i++)
        _elem[i] = oldElem[i]; //复制原向量内容（T为基本类型，或以重载赋值运算符
    delete [] oldElem;  //释放原空间
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;就单次扩容或缩容操作而言，所需时间的确会高达 &lt;em&gt;O&lt;/em&gt;(n)，因此在对单次操作的执行速度及其敏感的应用场合以上策略并不适用，其中缩容操作甚至可以完全不予考虑。&lt;/p&gt;
&lt;h2&gt;常规向量&lt;/h2&gt;
&lt;h3&gt;直接引用元素&lt;/h3&gt;
&lt;p&gt;与数组直接通过下标访问元素的形式相比，向量 ADT（abstract data type）所设置的&lt;code&gt;get()&lt;/code&gt;和&lt;code&gt;put()&lt;/code&gt;接口都显得不甚自然。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;template &amp;lt;typename T&amp;gt; T&amp;amp; Vector&amp;lt;T&amp;gt;::operator[](Rank r) const
{ return _elem[r]; }    //assert: 0 &amp;lt;= r &amp;lt; _size
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;置乱器&lt;/h3&gt;
&lt;p&gt;重载后&lt;code&gt;[]&lt;/code&gt;返回的是对数组元素的引用，这就意味着它既可以取代&lt;code&gt;get()&lt;/code&gt;操作（通常作为赋值表达式的右值），也可以取代&lt;code&gt;set()&lt;/code&gt;操作（通常作为左值）。采用这种形式，可以很清晰地实现如下的向量置乱器：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;template &amp;lt;typename T&amp;gt; void permute(Vector&amp;lt;T&amp;gt;&amp;amp; V) {
    for(int i = V.size(); i &amp;gt; 0; i--)
        swap(V[i-1], V[rand() % i]); //V[i-1] 与 V[0,i) 中某一随机元素交换
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;从理论上讲，上述算法可以枚举出同一向量所有可能的排列，而且能够保证生成各种排列的概率均等。&lt;/p&gt;
&lt;p&gt;为便于对各种向量算法的测试与比较，不妨将上述算法封装到向量 ADT 中，并对外提供向量的置乱接口操作：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;template &amp;lt;typename T&amp;gt; void Vector&amp;lt;T&amp;gt;::unsort(Rank lo, Rank hi) {
    T* V = _elem + lo;
    for(Rank i =hi -lo; i &amp;gt; 0; i--)
        swap(V[i-1], V[rand() % i]);
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上述两段代码的细微差异：上面的代码通过重载“[]”，利用秩间接访问&lt;strong&gt;向量&lt;/strong&gt;元素，下面的代码通过下标直接访问内部&lt;strong&gt;数组&lt;/strong&gt;的元素。&lt;/p&gt;
&lt;h3&gt;判等器和比较器&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;template &amp;lt;typename T&amp;gt; static bool lt(T* a, T* b) { return lt(*a, *b); } //less than
template &amp;lt;typename T&amp;gt; static bool lt(T&amp;amp; a, T&amp;amp; b) { return a &amp;lt; b; } //less than
template &amp;lt;typename T&amp;gt; static bool eq(T* a, T* b) { return eq(*a, *b); } //equal
template &amp;lt;typename T&amp;gt; static bool eq(T&amp;amp; a, T&amp;amp; b) { return a == b; } //equal
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在一些复杂的数据结构中，内部元素本身的类型可能就是指向其他对象的指针，从而外部更多关注的，往往是其所指向对象的大小如直接比较指针，则结果毫无意义，故上面的代码分别出了了指针和引用的情况。&lt;/p&gt;
&lt;h3&gt;无序查找&lt;/h3&gt;
&lt;h4&gt;判等器&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;Vector&lt;/code&gt;模板中的&lt;code&gt;find&lt;/code&gt;接口的语义为“查找与数据对象 e 相等的元素”。这暗示向量元素可以通过相互“比对”判断是否相等。这类仅支持比对，但未必支持比较的向量，称为无序向量（unsorted vector）。&lt;/p&gt;
&lt;h4&gt;顺序查找&lt;/h4&gt;
&lt;p&gt;由于&lt;code&gt;find&lt;/code&gt;函数查找相等的最大秩元素，故从后往前比对：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;template &amp;lt;typename T&amp;gt; Rank Vector&amp;lt;T&amp;gt;::find(T const&amp;amp; e, Rank lo, Rank hi) const {
    while( (lo &amp;lt; hi--) &amp;amp;&amp;amp; (e != _elem[hi]) ); //assert: 0 &amp;lt;= lo &amp;lt; hi &amp;lt;= _size
    return hi;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;最坏情况：&lt;em&gt;O&lt;/em&gt;(n)；最好情况：&lt;em&gt;O&lt;/em&gt;(1)。为输入敏感（input sensitive）算法。&lt;/p&gt;
&lt;h3&gt;插入&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//assert: 0 &amp;lt;= r &amp;lt;= size
template &amp;lt;typename T&amp;gt; Rank Vector&amp;lt;T&amp;gt;::insert(Rank r, T const&amp;amp; e) {
    expan(); //如有必要，扩容
    for(int i = _size; i &amp;gt; r; i--) _elem[i] = _elem[i-1];
    _elem[r] = e; _size++; //插入并更新容量
    return r;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意从后往前搬移数据，以防覆盖。复杂度：若插入位置等概论分布，则平均运行时间为&lt;em&gt;O&lt;/em&gt;(_size)=&lt;em&gt;O&lt;/em&gt;(n)。&lt;/p&gt;
&lt;h3&gt;删除&lt;/h3&gt;
&lt;p&gt;应将单元素删除视为区间删除的特例，并基于后者来实现前者。&lt;/p&gt;
&lt;h4&gt;区间删除&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//删除区间[lo, hi)
template &amp;lt;typename T&amp;gt; int Vector&amp;lt;T&amp;gt;::remove(Rank lo, Rank hi) {
    if(lo === hi) return 0;
    while(hi &amp;lt; _size)   _elem[lo++] = _elem[hi++];
    _size = lo;
    shrink();
    return hi - lo; //返回被删除元素个数
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;单元素删除&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;template &amp;lt;typename T&amp;gt; T Vector&amp;lt;T&amp;gt;::remove(Rank r) {
    T e = _elem[r];
    remove(r, r + 1);
    return e;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;被删除元素在向量中的位置越靠后（前）所需时间越短（长），最好为&lt;em&gt;O&lt;/em&gt;(1)，最坏为&lt;em&gt;O&lt;/em&gt;(n)。&lt;/p&gt;
&lt;h3&gt;唯一化&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;template &amp;lt;typename T&amp;gt; int Vector&amp;lt;T&amp;gt;::deduplicate() {
    int oldSize = _size;
    Rank i = 1;
    while(i &amp;lt; _size)
        (find(_elem[i], 0, i) &amp;lt; 0) ? i++ : remove(i);
    return oldSize - _size;
}
&lt;/pre&gt;&lt;/div&gt;</content><category term="数据结构"></category></entry><entry><title>C++ Primer 第八章 IO 库</title><link href="https://xutree.github.io/pages/2018/10/09/C++_Primer_Chapter_8/" rel="alternate"></link><published>2018-10-09T22:19:51+08:00</published><updated>2018-10-09T22:19:51+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-09:/pages/2018/10/09/C++_Primer_Chapter_8/</id><summary type="html">&lt;h2&gt;IO 类&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;iostream&lt;/code&gt;头文件：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;istream&lt;/code&gt;,&lt;code&gt;wistream&lt;/code&gt;,&lt;code&gt;ostream&lt;/code&gt;,&lt;code&gt;wostream&lt;/code&gt;,&lt;code&gt;iostream&lt;/code&gt;,&lt;code&gt;wiostream&lt;/code&gt;类型。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;fstream&lt;/code&gt;头文件：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ifstream&lt;/code&gt;,&lt;code&gt;wifstream&lt;/code&gt;,&lt;code&gt;ofstream&lt;/code&gt;,&lt;code&gt;wofstream&lt;/code&gt;,&lt;code&gt;fstream&lt;/code&gt;,&lt;code&gt;wfstream&lt;/code&gt;类型。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sstream&lt;/code&gt;头文件：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;istringstream&lt;/code&gt;,&lt;code&gt;wistringstream&lt;/code&gt;,&lt;code&gt;ostringstream&lt;/code&gt;,&lt;code&gt;wostringstream&lt;/code&gt;,&lt;code&gt;stringstream&lt;/code&gt;,&lt;code&gt;wstringstream&lt;/code&gt;类型。&lt;/p&gt;
&lt;p&gt;宽字符版本的类型和函数的名字以一个“w”开始。&lt;/p&gt;
&lt;p&gt;IO 对象无拷贝和赋值。进行 IO 操作的函数通常以引用方式传递和返回值。读写一个 IO 对象会改变其状态，因此传递和返回的引用不能是&lt;code&gt;const&lt;/code&gt;的。&lt;/p&gt;
&lt;h3&gt;条件状态&lt;/h3&gt;
&lt;p&gt;下表中 &lt;em&gt;strm&lt;/em&gt; 是一种 IO 类型：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;状态 …&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;/table&gt;</summary><content type="html">&lt;h2&gt;IO 类&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;iostream&lt;/code&gt;头文件：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;istream&lt;/code&gt;,&lt;code&gt;wistream&lt;/code&gt;,&lt;code&gt;ostream&lt;/code&gt;,&lt;code&gt;wostream&lt;/code&gt;,&lt;code&gt;iostream&lt;/code&gt;,&lt;code&gt;wiostream&lt;/code&gt;类型。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;fstream&lt;/code&gt;头文件：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ifstream&lt;/code&gt;,&lt;code&gt;wifstream&lt;/code&gt;,&lt;code&gt;ofstream&lt;/code&gt;,&lt;code&gt;wofstream&lt;/code&gt;,&lt;code&gt;fstream&lt;/code&gt;,&lt;code&gt;wfstream&lt;/code&gt;类型。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sstream&lt;/code&gt;头文件：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;istringstream&lt;/code&gt;,&lt;code&gt;wistringstream&lt;/code&gt;,&lt;code&gt;ostringstream&lt;/code&gt;,&lt;code&gt;wostringstream&lt;/code&gt;,&lt;code&gt;stringstream&lt;/code&gt;,&lt;code&gt;wstringstream&lt;/code&gt;类型。&lt;/p&gt;
&lt;p&gt;宽字符版本的类型和函数的名字以一个“w”开始。&lt;/p&gt;
&lt;p&gt;IO 对象无拷贝和赋值。进行 IO 操作的函数通常以引用方式传递和返回值。读写一个 IO 对象会改变其状态，因此传递和返回的引用不能是&lt;code&gt;const&lt;/code&gt;的。&lt;/p&gt;
&lt;h3&gt;条件状态&lt;/h3&gt;
&lt;p&gt;下表中 &lt;em&gt;strm&lt;/em&gt; 是一种 IO 类型：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;状态&lt;/th&gt;
&lt;th align="left"&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;em&gt;strm&lt;/em&gt;::iostate&lt;/td&gt;
&lt;td align="left"&gt;iostate 是一种机器相关的类型，提供了表达条件状态的完整功能&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;em&gt;strm&lt;/em&gt;::badbit&lt;/td&gt;
&lt;td align="left"&gt;流已崩溃&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;em&gt;strm&lt;/em&gt;::failbit&lt;/td&gt;
&lt;td align="left"&gt;IO 操作失败了&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;em&gt;strm&lt;/em&gt;::eofbit&lt;/td&gt;
&lt;td align="left"&gt;流到达了文件结束&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;em&gt;strm&lt;/em&gt;::goodbit&lt;/td&gt;
&lt;td align="left"&gt;流未处于错误状态，此值保证为0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;s.eof()&lt;/td&gt;
&lt;td align="left"&gt;若流 s 的 eofbit 置位，返回 true&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;s.fail()&lt;/td&gt;
&lt;td align="left"&gt;若流 s 的 failbit 或 badbit 置位，返回 true&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;s.bad()&lt;/td&gt;
&lt;td align="left"&gt;若流 s 的 badbit 置位，返回 true&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;s.good()&lt;/td&gt;
&lt;td align="left"&gt;若流 s 处于有效状态，返回 true&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;s.clear()&lt;/td&gt;
&lt;td align="left"&gt;将流 s 所以状态位复位，将流的状态设为有效，返回 void&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;s.clear(flags)&lt;/td&gt;
&lt;td align="left"&gt;根据 flags 复位，flags 类型为 &lt;em&gt;strm&lt;/em&gt;::iostate，返回 void&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;s.setstate(flags)&lt;/td&gt;
&lt;td align="left"&gt;根据 flags 置位，flags 类型为 &lt;em&gt;strm&lt;/em&gt;::iostate，返回 void&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;s.rdstate()&lt;/td&gt;
&lt;td align="left"&gt;返回流 s 的当前条件状态，返回值类型为 &lt;em&gt;strm&lt;/em&gt;::iostate&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;badbit&lt;/code&gt;表示系统级错误，如不可恢复的读写错误，一旦被置位，流就无法再使用了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;failbit&lt;/code&gt;表示可恢复的错误，例如期望读取数值却读到一个字符等错误。这种问题通常是可以修正的，流还可以继续使用。&lt;/p&gt;
&lt;p&gt;如果到达文件结尾，&lt;code&gt;eofbit&lt;/code&gt;和&lt;code&gt;failbit&lt;/code&gt;都会被置位。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;goodbit&lt;/code&gt;值为0，表示流未发生错误。&lt;/p&gt;
&lt;p&gt;如果&lt;code&gt;badbit&lt;/code&gt;、&lt;code&gt;failbit&lt;/code&gt;和&lt;code&gt;eofbit&lt;/code&gt;任一个被置位，则检测流状态的条件会失败。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;good()&lt;/code&gt;函数在所有错误位均未置位的情况下返回&lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;我们将流当做条件使用的代码等价于&lt;code&gt;!fail()&lt;/code&gt;。&lt;/p&gt;
&lt;h3&gt;管理条件状态&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;// 记住 cin 的当前状态
auto old_state = cin.rdstate(); // 记住 cin 的当前状态
cin.clean();  // 使 cin 有效
process_input(cin); // 使用 cin
cin.setstate(old_state);  // 将 cin 置为原有状态
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;// 复位 failbit 和 badbit，保持其他标志位布标
cin.clear(cin.rdstate() &amp;amp; ~cin.failbit &amp;amp; ~cin.badbit);
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;管理输出缓冲&lt;/h3&gt;
&lt;p&gt;每个输出流都管理一个缓冲区，用来保存程序读写的数据。&lt;/p&gt;
&lt;p&gt;导致缓冲刷新（即，数据真正写到输出设备或文件）的原因有很多：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;程序正常结束，作为&lt;code&gt;main&lt;/code&gt;函数的&lt;code&gt;return&lt;/code&gt;操作的一部分，缓冲刷新被执行&lt;/li&gt;
&lt;li&gt;缓冲区满&lt;/li&gt;
&lt;li&gt;使用操纵符&lt;code&gt;endl&lt;/code&gt;（插入换行）、&lt;code&gt;ends&lt;/code&gt;（插入空字符）、&lt;code&gt;flush&lt;/code&gt;（什么都不插入）显式刷新&lt;/li&gt;
&lt;li&gt;在每个输出操作之后，可以用操纵符&lt;code&gt;unitbuf&lt;/code&gt;设置流的内部状态，来情况缓冲区。默认情况下，对&lt;code&gt;cerr&lt;/code&gt;是设置&lt;code&gt;unitbuf&lt;/code&gt;的，因此&lt;code&gt;cerr&lt;/code&gt;的内容都是立即刷新的&lt;/li&gt;
&lt;li&gt;一个输出流可以关联到另一个流。当读写被关联的流时，关联到的流的缓冲区会被刷新。默认情况下，&lt;code&gt;cin&lt;/code&gt;和&lt;code&gt;cerr&lt;/code&gt;都关联到&lt;code&gt;cout&lt;/code&gt;。因此读&lt;code&gt;cin&lt;/code&gt;或者写&lt;code&gt;cerr&lt;/code&gt;都会导致&lt;code&gt;cout&lt;/code&gt;的缓冲区被刷新&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;unitbuf 操纵符&lt;/h3&gt;
&lt;p&gt;如果想在每次输出操作后都刷新缓冲区，可以使用&lt;code&gt;unitbuf&lt;/code&gt;操纵符。它告诉流在接下来的每次写操作之后都执行一次&lt;code&gt;flush&lt;/code&gt;刷新。&lt;code&gt;nounitbuf&lt;/code&gt;操纵符则重置流，使其恢复使用正常的系统管理的缓冲区刷新机制：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;cout &amp;lt;&amp;lt; unitbuf;    // 所有输出操作后都会立即刷新缓冲区
// 任何输出都会立即刷新，无缓冲
cout &amp;lt;&amp;lt; nounitbuf;    // 回到正常的缓冲方式
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;关联输入和输出流&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;tie()&lt;/code&gt;有两个重载的版本：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不带参数的版本返回指向输出流的指针。如果本对象当前关联到一个输出流，则返回的就是指向这个流的指针，如果对象未关联到流，则返回空指针&lt;/li&gt;
&lt;li&gt;第二个版本接受一个指向&lt;code&gt;ostream&lt;/code&gt;的指针，将自己关联到此&lt;code&gt;ostream&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每个流同时最多关联到一个流，但多个流可以同时关联到同一个&lt;code&gt;ostream&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;文件输入输出&lt;/h2&gt;
&lt;h3&gt;fstream 特有的操作&lt;/h3&gt;
&lt;p&gt;下表中的 &lt;em&gt;fstream&lt;/em&gt; 是头文件 fstream 中定义的一个类型：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;操作&lt;/th&gt;
&lt;th align="left"&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;em&gt;fstream&lt;/em&gt; fstrm;&lt;/td&gt;
&lt;td align="left"&gt;创建一个未绑定的文件流&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;em&gt;fstream&lt;/em&gt; fstrm(s);&lt;/td&gt;
&lt;td align="left"&gt;创建一个 &lt;em&gt;fstream&lt;/em&gt;，并打开名为 s 的文件。s 可以是 string 类型或者指向 C 风格字符串的指针。这些构造函数都是&lt;code&gt;explicit&lt;/code&gt;的。默认的文件模式 mode 依赖于 &lt;em&gt;fstream&lt;/em&gt; 的类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;em&gt;fstream&lt;/em&gt; fstrm(s, mode);&lt;/td&gt;
&lt;td align="left"&gt;按 mode 打开文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;fstrm.open(s)&lt;/td&gt;
&lt;td align="left"&gt;打开名为 s 的文件并与 fstrm 绑定。s 可以是 string 类型或者指向 C 风格字符串的指针。默认的文件模式 mode 依赖于 &lt;em&gt;fstream&lt;/em&gt; 的类型。返回&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;fstrm.close()&lt;/td&gt;
&lt;td align="left"&gt;关闭与 fstrm 绑定的文件。返回&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;fstrm.is_open()&lt;/td&gt;
&lt;td align="left"&gt;返回一个布尔值，指出与 fstrm 关联的文件是否打开成功且尚未关闭&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;如果调用&lt;code&gt;open()&lt;/code&gt;失败，&lt;code&gt;failbit&lt;/code&gt;会被置位，条件会为假：&lt;code&gt;if(open(file))&lt;/code&gt;可用于判定。&lt;/p&gt;
&lt;p&gt;对一个已经打开的文件流调用&lt;code&gt;open()&lt;/code&gt;会失败，并且&lt;code&gt;failbit&lt;/code&gt;会被置位。为了将文件流关联到另一个文件，必须先关闭已经关联的文件。&lt;/p&gt;
&lt;p&gt;当一个&lt;code&gt;fstream&lt;/code&gt;对象被销毁时，&lt;code&gt;close&lt;/code&gt;会自动被调用。&lt;/p&gt;
&lt;h3&gt;文件模式&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;文件模式&lt;/th&gt;
&lt;th align="left"&gt;意义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;in&lt;/td&gt;
&lt;td align="left"&gt;只读&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;out&lt;/td&gt;
&lt;td align="left"&gt;只写（会清空已有数据）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;app&lt;/td&gt;
&lt;td align="left"&gt;每次写操作前均定位到文件末尾&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;ate&lt;/td&gt;
&lt;td align="left"&gt;打开文件后立即定位到文件末尾&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;trunc&lt;/td&gt;
&lt;td align="left"&gt;截断文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;binary&lt;/td&gt;
&lt;td align="left"&gt;以二进制方式进行 IO&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;ifstream&lt;/code&gt;默认&lt;code&gt;in&lt;/code&gt;模式；&lt;code&gt;ofstream&lt;/code&gt;默认&lt;code&gt;out&lt;/code&gt;模式；&lt;code&gt;fstream&lt;/code&gt;默认&lt;code&gt;in&lt;/code&gt;和&lt;code&gt;out&lt;/code&gt;模式打开。&lt;/p&gt;
&lt;h2&gt;string 流&lt;/h2&gt;
&lt;h3&gt;fstream 特有的操作&lt;/h3&gt;
&lt;p&gt;下表中的 &lt;em&gt;sstream&lt;/em&gt; 是头文件 sstream 中定义的一个类型：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;操作&lt;/th&gt;
&lt;th align="left"&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;em&gt;sstream&lt;/em&gt; strm;&lt;/td&gt;
&lt;td align="left"&gt;创建一个未绑定的 stringstream 对象&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;em&gt;sstream&lt;/em&gt; strm(s);&lt;/td&gt;
&lt;td align="left"&gt;strm 是一个 sstream 对象，保存 string s 的一个拷贝。此构造函数时&lt;code&gt;explicit&lt;/code&gt;的&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;strm.str()&lt;/td&gt;
&lt;td align="left"&gt;返回 strm 所保存的 string 的拷贝&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;strm.str(s)&lt;/td&gt;
&lt;td align="left"&gt;将 string s 拷贝到 strm 中，返回 void&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</content><category term="C++"></category></entry><entry><title>C++ Primer 第七章 类</title><link href="https://xutree.github.io/pages/2018/10/09/C++_Primer_Chapter_7/" rel="alternate"></link><published>2018-10-09T20:38:15+08:00</published><updated>2018-10-09T20:38:15+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-09:/pages/2018/10/09/C++_Primer_Chapter_7/</id><summary type="html">&lt;p&gt;类的基本思想是数据抽象和封装。&lt;/p&gt;
&lt;p&gt;数据抽象是一种依赖于接口和实现分离的编程（以及设计）技术。类的接口包括用户可以执行的操作，类的实现包括类的数据成员，负责接口实现的函数体以及定义类所需的各种私有函数。&lt;/p&gt;
&lt;p&gt;封装实现了类的接口和实现的分离。封装后的类隐藏了它的实现细节，类的用户只能使用接口而无法访问实现部分。&lt;/p&gt;
&lt;h2&gt;类的定义&lt;/h2&gt;
&lt;p&gt;定义在类内部的函数时隐式&lt;code&gt;inline&lt;/code&gt;的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;this&lt;/code&gt;是一个常量指针。&lt;/p&gt;
&lt;h3&gt;const 成员函数&lt;/h3&gt;
&lt;p&gt;通过在紧随参数列表之后添加&lt;code&gt;const&lt;/code&gt;，可以定义&lt;code&gt;const&lt;/code&gt;成员函数。&lt;code&gt;const&lt;/code&gt;的作用是修改隐式&lt;code&gt;this&lt;/code&gt;指针的类型。&lt;/p&gt;
&lt;p&gt;默认情况下，&lt;code&gt;this&lt;/code&gt;指针的类型是指向类类型非常量版本的常量指针（顶层常量）。这意味着我们不能把&lt;code&gt;this&lt;/code&gt;绑定到一个常量对象上。&lt;/p&gt;
&lt;p&gt;常量对象，以及常量对象的引用或者指针都只能调用常量成员函数。&lt;/p&gt;
&lt;h3&gt;类作用域和成员函数&lt;/h3&gt;
&lt;p&gt;编译器分两步处理类：首先编译成员的声明，然后才轮到成员函数体（如果有的话）。因此，成员函数体可以随意使用类中的其他成员而无须在意这些成员出现的顺序。&lt;/p&gt;
&lt;p&gt;编译器处理完类中的全部声明后才会处理成员函数的定义。&lt;/p&gt;
&lt;p&gt;这种两阶段的处理方式只适用于成员函数中使用的名字。声明中使用的名字，包括返回类型或者参数列表中使用的名字，都必须在使用前确保可见。如果某个成员的声明使用了类中尚未出现的名字，则编译器将会在定义该类的作用域中继续查找 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;类的基本思想是数据抽象和封装。&lt;/p&gt;
&lt;p&gt;数据抽象是一种依赖于接口和实现分离的编程（以及设计）技术。类的接口包括用户可以执行的操作，类的实现包括类的数据成员，负责接口实现的函数体以及定义类所需的各种私有函数。&lt;/p&gt;
&lt;p&gt;封装实现了类的接口和实现的分离。封装后的类隐藏了它的实现细节，类的用户只能使用接口而无法访问实现部分。&lt;/p&gt;
&lt;h2&gt;类的定义&lt;/h2&gt;
&lt;p&gt;定义在类内部的函数时隐式&lt;code&gt;inline&lt;/code&gt;的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;this&lt;/code&gt;是一个常量指针。&lt;/p&gt;
&lt;h3&gt;const 成员函数&lt;/h3&gt;
&lt;p&gt;通过在紧随参数列表之后添加&lt;code&gt;const&lt;/code&gt;，可以定义&lt;code&gt;const&lt;/code&gt;成员函数。&lt;code&gt;const&lt;/code&gt;的作用是修改隐式&lt;code&gt;this&lt;/code&gt;指针的类型。&lt;/p&gt;
&lt;p&gt;默认情况下，&lt;code&gt;this&lt;/code&gt;指针的类型是指向类类型非常量版本的常量指针（顶层常量）。这意味着我们不能把&lt;code&gt;this&lt;/code&gt;绑定到一个常量对象上。&lt;/p&gt;
&lt;p&gt;常量对象，以及常量对象的引用或者指针都只能调用常量成员函数。&lt;/p&gt;
&lt;h3&gt;类作用域和成员函数&lt;/h3&gt;
&lt;p&gt;编译器分两步处理类：首先编译成员的声明，然后才轮到成员函数体（如果有的话）。因此，成员函数体可以随意使用类中的其他成员而无须在意这些成员出现的顺序。&lt;/p&gt;
&lt;p&gt;编译器处理完类中的全部声明后才会处理成员函数的定义。&lt;/p&gt;
&lt;p&gt;这种两阶段的处理方式只适用于成员函数中使用的名字。声明中使用的名字，包括返回类型或者参数列表中使用的名字，都必须在使用前确保可见。如果某个成员的声明使用了类中尚未出现的名字，则编译器将会在定义该类的作用域中继续查找。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;typedef&lt;/span&gt; &lt;span class="kr"&gt;double&lt;/span&gt; &lt;span class="nx"&gt;Money&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;string&lt;/span&gt; &lt;span class="nx"&gt;bal&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;Account&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="kr"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="nx"&gt;Money&lt;/span&gt; &lt;span class="nx"&gt;balance() {&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;bal&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kr"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="nx"&gt;Money&lt;/span&gt; &lt;span class="nx"&gt;bal&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="c1"&gt;// ...&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当编译器看到 balance 函数的声明语句时，它将在 Account 类的范围内寻找对 Money 的声明。编译器只考虑 Account 中在使用 Money 前出现的声明，因为没找到匹配的成员，所以编译器会接着到 Account 的外层作用域中查找。在上面的例子中，编译器会找到 Money 的&lt;code&gt;typedef&lt;/code&gt;语句，该类型被用作 balance 函数的返回类型及数据成员 bal 的类型。另一方面，balance 函数体在整个类可见后才被处理。因此，该函数的&lt;code&gt;return&lt;/code&gt;语句返回名为 bal 的成员，而非外层作用域的&lt;code&gt;string&lt;/code&gt;对象。&lt;/p&gt;
&lt;h3&gt;构造函数&lt;/h3&gt;
&lt;p&gt;构造函数不能被声明成&lt;code&gt;const&lt;/code&gt;的。&lt;/p&gt;
&lt;p&gt;当我们创建类的一个&lt;code&gt;const&lt;/code&gt;对象时，直到构造函数完成初始化过程，对象才能真正取得其“常量”属性。因此，构造函数在&lt;code&gt;const&lt;/code&gt;对象的构造过程中可以向其写值。&lt;/p&gt;
&lt;p&gt;如果我们的类没有显式定义构造函数，编译器会生成合成的默认构造函数。对于大多数类来说，合成的默认构造函数按照如下规则初始化类的数据成员：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果存在类内的初始值，用它来初始化成员&lt;/li&gt;
&lt;li&gt;否则，执行默认初始化&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 C++ 11中，如果我们需要默认的行为，那么可以通过在参数列表后面写上 &lt;strong&gt;= default&lt;/strong&gt; 来要求编译器生成构造函数。如果 &lt;strong&gt;= default&lt;/strong&gt; 出现在类的内部，则默认构造函数是内联的；如果它出现在外部，则该成员默认情况下不是内联的。&lt;/p&gt;
&lt;h4&gt;构造函数初始值列表&lt;/h4&gt;
&lt;p&gt;构造函数初始值列表：&lt;code&gt;Sales_data(const std::string &amp;amp;s) : bookNo(s) { }&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果成员是&lt;code&gt;const&lt;/code&gt;或者引用的话，必须将其初始化。类似的，当成员属于某种类类型且该类类型没有定义默认构造函数时，也必须将这个成员初始化。&lt;/p&gt;
&lt;p&gt;随着构造函数体一开始执行，初始化就完成了。我们初始化&lt;code&gt;const&lt;/code&gt;或者引用类型的唯一机会就是通过构造函数初始化。&lt;/p&gt;
&lt;p&gt;构造函数初始值列表只说明用于初始化成员的值。成员的初始化顺序与它们在类定义中出现顺序一致。&lt;/p&gt;
&lt;h4&gt;委托构造函数&lt;/h4&gt;
&lt;p&gt;一个委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程，或者说它把它自己的一些（或者全部）职责委托给了其他构造函数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;Sales_data&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="kr"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="c1"&gt;// 非委托构造函数&lt;/span&gt;
    &lt;span class="nx"&gt;Sales_data&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt; &lt;span class="nx"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;unsigned&lt;/span&gt; &lt;span class="nx"&gt;cnt&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kr"&gt;double&lt;/span&gt; &lt;span class="nx"&gt;price&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt;
        &lt;span class="nx"&gt;bookNo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;s&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="nx"&gt;units_sold&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;cnt&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="nx"&gt;revenue&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;cnt&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;price&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="c1"&gt;// 其余构造函数都委托给另外一个构造函数&lt;/span&gt;
    &lt;span class="nx"&gt;Sales_data&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;Sales_data&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="nx"&gt;Sales_data&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt; &lt;span class="nx"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;Sales_data&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="nx"&gt;Sales_data&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;istream&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;is&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;Sales_data() {&lt;/span&gt; &lt;span class="nx"&gt;read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;is&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="c1"&gt;//其他成员&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;受委托的构造函数先执行。&lt;/p&gt;
&lt;h2&gt;访问控制与封装&lt;/h2&gt;
&lt;p&gt;定义在 &lt;strong&gt;public&lt;/strong&gt; 说明符之后的成员在整个程序内可被访问，&lt;strong&gt;public&lt;/strong&gt; 成员定义类的接口。&lt;/p&gt;
&lt;p&gt;定义在 &lt;strong&gt;private&lt;/strong&gt; 说明符之后的成员可以被类的成员函数访问，但是不能被使用该类的代码访问。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;class&lt;/code&gt;和&lt;code&gt;struct&lt;/code&gt;定义类唯一的区别就是默认的访问权限。&lt;/p&gt;
&lt;h3&gt;友元&lt;/h3&gt;
&lt;p&gt;通过友元，类可以允许其他类或者函数访问它的&lt;strong&gt;非公有成员&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果类想把一个函数作为它的友元，只需要增加一条以&lt;code&gt;friend&lt;/code&gt;关键字开始的函数声明即可。友元声明只能出现在类定义的内部，但是在类内出现的具体位置不限。友元不是类的成员也不受它所在区域访问控制级别的约束。&lt;/p&gt;
&lt;p&gt;友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明。如果我们希望类的用户能够调用某个友元函数，那么我们必须在友元声明之外再专门对函数进行一次声明。&lt;/p&gt;
&lt;p&gt;友元关系不存在传递性。&lt;/p&gt;
&lt;p&gt;如果一个类指定了友元类，则友元类的成员函数可以访问此类&lt;strong&gt;包括非公有成员在内的所有成员&lt;/strong&gt;。&lt;/p&gt;
&lt;h2&gt;类的其他特性&lt;/h2&gt;
&lt;h3&gt;定义类型成员&lt;/h3&gt;
&lt;p&gt;类可以自定义某种类型在类中的别名。要注意，用来定义类型的成员必须先定义后使用。&lt;/p&gt;
&lt;h3&gt;可变数据成员&lt;/h3&gt;
&lt;p&gt;有时我们希望能够修改类的某个数据成员，即使是在一个&lt;code&gt;const&lt;/code&gt;成员函数内。通过关键字&lt;code&gt;mutable&lt;/code&gt;可以达到这种效果。一个可变数据成员永远不会是&lt;code&gt;const&lt;/code&gt;，即使它是&lt;code&gt;const&lt;/code&gt;对象的成员。&lt;/p&gt;
&lt;h3&gt;返回 *this 的成员函数&lt;/h3&gt;
&lt;p&gt;一个&lt;code&gt;const&lt;/code&gt;成员函数如果以引用的方式返回*this，那么它的返回类型将是常量引用。&lt;/p&gt;
&lt;p&gt;基于&lt;code&gt;const&lt;/code&gt;的重载：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;Screen&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="kr"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="c1"&gt;// 根据对象是否是 const 重载 display 函数&lt;/span&gt;
    &lt;span class="nx"&gt;Screen&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;display&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;ostream&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;os&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;   &lt;span class="nx"&gt;do_display&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;os&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;Screen&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;display&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;ostream&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;os&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;const&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;   &lt;span class="nx"&gt;do_display&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;os&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kr"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="c1"&gt;// 该函数负责显示 Screen 的内容&lt;/span&gt;
    &lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="nx"&gt;do_display&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;ostream&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;os&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;   &lt;span class="nx"&gt;os&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="nx"&gt;contents&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;类类型&lt;/h3&gt;
&lt;p&gt;声明方法：&lt;code&gt;Sales_data item1;&lt;/code&gt;或&lt;code&gt;class Sales_data item1;&lt;/code&gt;后一种从 C 语言继承而来。&lt;/p&gt;
&lt;p&gt;类的声明：前向声明，在类声明之后定义之前，类是一个不完全类型。&lt;/p&gt;
&lt;p&gt;不完全类型只能在非常有限的情景下使用：定义指向这种类型的引用或指针，也可以声明（但是不能定义）以不完全类型作为参数或者返回类型的函数。&lt;/p&gt;
&lt;p&gt;直到类被定义之后数据成员才可以被声明成这种类类型。然而，当一个类的名字出现后，它被认为是声明过了（但尚未定义），因此允许包含指向它自身类型的引用或者指针（有没有想到链表结构）。&lt;/p&gt;
&lt;h4&gt;隐式的类类型转换&lt;/h4&gt;
&lt;p&gt;如果构造函数只接受一个实参，则它实际上定义了转换为此类类型的隐式转换机制，有时我们把这种构造函数称为转换构造函数。&lt;/p&gt;
&lt;p&gt;只允许一步类类型转换。类类型转换不是总有效。&lt;/p&gt;
&lt;h4&gt;抑制构造函数定义的隐式转换&lt;/h4&gt;
&lt;p&gt;可以通过将构造函数声明为&lt;code&gt;explicit&lt;/code&gt;加以阻止。&lt;/p&gt;
&lt;p&gt;关键字&lt;code&gt;explicit&lt;/code&gt;只对一个实参的构造函数有效。需要多个实参的构造函数不能用于执行隐式转换，所以无须将这些构造函数指定为&lt;code&gt;explicit&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;只能在类内声明构造函数时使用&lt;code&gt;explicit&lt;/code&gt;关键字，在类外部定义时不应重复。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;explicit&lt;/code&gt;构造函数只能用于直接初始化。&lt;/p&gt;
&lt;p&gt;尽管编译器不会将&lt;code&gt;explicit&lt;/code&gt;的构造函数用于隐式转换过程，但是我们可以使用这样的构造函数显式地强制类型转换：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;item.combine(static_cast&amp;lt;Sales_data&amp;gt;(cin));
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;聚合类&lt;/h3&gt;
&lt;p&gt;当一个类满足如下条件时，我们说它是聚合的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有成员都是&lt;code&gt;public&lt;/code&gt;的&lt;/li&gt;
&lt;li&gt;没有定义任何构造函数&lt;/li&gt;
&lt;li&gt;没有类内初始值&lt;/li&gt;
&lt;li&gt;没有基类，也没有虚函数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;struct Data {
    int ival;
    string s;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以使用初始化列表初始化，初始值的顺序必须与声明的顺序一致。如果初始值列表中的元素个数少于类的成员数量，则靠后的成员被值初始化。&lt;/p&gt;
&lt;h3&gt;字面值常量类&lt;/h3&gt;
&lt;p&gt;字面值类型的类可能含有&lt;code&gt;constexpr&lt;/code&gt;函数成员，它们是隐式&lt;code&gt;const&lt;/code&gt;成员函数。&lt;/p&gt;
&lt;p&gt;数据成员都是字面值类型的聚合类是字面值常量类。&lt;/p&gt;
&lt;p&gt;如果一个类不是聚合类，符合以下要求也是一个字面值常量类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据成员都必须是字面值类型&lt;/li&gt;
&lt;li&gt;类必须至少有一个&lt;code&gt;constexpr&lt;/code&gt;构造函数&lt;/li&gt;
&lt;li&gt;如果一个数据成员含有类内初始值，则内置类型成员的初始值必须是一条常量表达式；如果成员属于某种类类型，则初始值必须使用成员自己的&lt;code&gt;constexpr&lt;/code&gt;构造函数&lt;/li&gt;
&lt;li&gt;类必须使用析构函数的默认定义，该成员负责销毁类的定义&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;尽管构造函数不能是&lt;code&gt;const&lt;/code&gt;的，但是字面值常量类的构造函数可以使&lt;code&gt;constexpr&lt;/code&gt;函数。事实上，一个字面值常量类都必须至少提供一个&lt;code&gt;constexpr&lt;/code&gt;构造函数。通过前置关键字&lt;code&gt;constexpr&lt;/code&gt;就可以声明一个&lt;code&gt;constexpr&lt;/code&gt;构造函数。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;constexpr&lt;/code&gt;构造函数可以声明成&lt;code&gt;=default&lt;/code&gt;或者删除函数的形式，否则，&lt;code&gt;constexpr&lt;/code&gt;构造函数就必须既符合构造函数的要求（意味着不能包含返回语句），又符合&lt;code&gt;constexpr&lt;/code&gt;函数的要求（意味着它唯一可执行语句就是返回语句），综合这两点，&lt;code&gt;constexpr&lt;/code&gt;构造函数体一般来说应该是空的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;constexpr&lt;/code&gt;构造函数必须初始化所有数据成员，初始值或者使用&lt;code&gt;constexpr&lt;/code&gt;构造函数，或者是一条常量表达式。&lt;/p&gt;
&lt;h2&gt;类的静态成员&lt;/h2&gt;
&lt;p&gt;类的静态成员存在于任何对象之外，对象中不包含任何与静态数据成员有关的数据。类似的，静态成员函数也不与任何对象绑定在一起，它们不包含&lt;code&gt;this&lt;/code&gt;指针。作为结果，静态成员函数不能声明成&lt;code&gt;const&lt;/code&gt;的，而且我们也不能在静态函数体内使用&lt;code&gt;this&lt;/code&gt;指针。&lt;/p&gt;
&lt;p&gt;成员函数不用通过作用域运算符就能直接使用静态成员。&lt;/p&gt;
&lt;p&gt;当在类的外部定义静态成员时，不能重复&lt;code&gt;static&lt;/code&gt;关键字，该关键字只出现在类内部的声明语句。&lt;/p&gt;
&lt;p&gt;必须在类的外部定义和初始化每个静态成员（一个例外，如果静态成员是字面值类型的&lt;code&gt;constexpr&lt;/code&gt;可以在类内给它提供一个整数类型的常量表达式初始值），一个静态成员只能被初始化一次。&lt;/p&gt;
&lt;p&gt;类似于全局变量，静态数据成员定义在任何函数之外，一直存在于程序的整个生命周期中。&lt;/p&gt;
&lt;p&gt;静态数据成员可以是不完全类型，非静态数据成员只能声明成它所属类的指针或引用。&lt;/p&gt;
&lt;p&gt;静态数据成员可以作为默认实参，非静态数据成员不行，因为它的值本身属于对象的一部分，这么做的结果是无法真正提供一个对象以便从中获得成员的值（类似于循环定义），将引发错误。&lt;/p&gt;</content><category term="C++"></category></entry><entry><title>C++ Primer 第六章 函数</title><link href="https://xutree.github.io/pages/2018/10/09/C++_Primer_Chapter_6/" rel="alternate"></link><published>2018-10-09T15:55:08+08:00</published><updated>2018-10-09T15:55:08+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-09:/pages/2018/10/09/C++_Primer_Chapter_6/</id><summary type="html">&lt;p&gt;函数是一个命名了的代码块。&lt;/p&gt;
&lt;h2&gt;函数基础&lt;/h2&gt;
&lt;p&gt;为了与 C 语言兼容，可以使用关键字&lt;code&gt;void&lt;/code&gt;表示函数没有形参。&lt;/p&gt;
&lt;p&gt;函数的返回值不能是数组或者函数类型，但可以返回指向数组和函数的指针。&lt;/p&gt;
&lt;p&gt;自动对象：只存在于块执行期间的对象。当块的执行结束后，块中创建的自动对象的值就变成未定义的了。&lt;/p&gt;
&lt;p&gt;局部静态对象：在程序执行路径第一次经过对象定义语句时初始化，并且直到程序终止才销毁。如果没有显示初始化，则执行值初始化，内置类型的局部静态变量初始化为0。&lt;/p&gt;
&lt;h2&gt;参数传递&lt;/h2&gt;
&lt;p&gt;值传递和引用传递。&lt;/p&gt;
&lt;p&gt;当某种类型不支持拷贝操作时，函数只能通过引用形参访问该类型的对象。如 IO 类型。&lt;/p&gt;
&lt;h3&gt;const 形参和实参&lt;/h3&gt;
&lt;p&gt;如果函数无须改变引用形参的值，最好将其声明为常量引用。&lt;/p&gt;
&lt;p&gt;此外，使用引用而非常量引用也会极大地限制函数所能接受的实参类型。例如，我们不能把&lt;code&gt;const&lt;/code&gt;对象、字面值或者需要类型转换的对象传递给普通的引用形参，这种绝不像看起来那么简单，它可能造成出人意料的后果。考虑如下函数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nd"&gt;size_type&lt;/span&gt; &lt;span class="nt"&gt;find_char&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;string&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nt"&gt;s&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;char&lt;/span&gt; &lt;span class="nt"&gt;c&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nd"&gt;size_type …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;函数是一个命名了的代码块。&lt;/p&gt;
&lt;h2&gt;函数基础&lt;/h2&gt;
&lt;p&gt;为了与 C 语言兼容，可以使用关键字&lt;code&gt;void&lt;/code&gt;表示函数没有形参。&lt;/p&gt;
&lt;p&gt;函数的返回值不能是数组或者函数类型，但可以返回指向数组和函数的指针。&lt;/p&gt;
&lt;p&gt;自动对象：只存在于块执行期间的对象。当块的执行结束后，块中创建的自动对象的值就变成未定义的了。&lt;/p&gt;
&lt;p&gt;局部静态对象：在程序执行路径第一次经过对象定义语句时初始化，并且直到程序终止才销毁。如果没有显示初始化，则执行值初始化，内置类型的局部静态变量初始化为0。&lt;/p&gt;
&lt;h2&gt;参数传递&lt;/h2&gt;
&lt;p&gt;值传递和引用传递。&lt;/p&gt;
&lt;p&gt;当某种类型不支持拷贝操作时，函数只能通过引用形参访问该类型的对象。如 IO 类型。&lt;/p&gt;
&lt;h3&gt;const 形参和实参&lt;/h3&gt;
&lt;p&gt;如果函数无须改变引用形参的值，最好将其声明为常量引用。&lt;/p&gt;
&lt;p&gt;此外，使用引用而非常量引用也会极大地限制函数所能接受的实参类型。例如，我们不能把&lt;code&gt;const&lt;/code&gt;对象、字面值或者需要类型转换的对象传递给普通的引用形参，这种绝不像看起来那么简单，它可能造成出人意料的后果。考虑如下函数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nd"&gt;size_type&lt;/span&gt; &lt;span class="nt"&gt;find_char&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;string&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nt"&gt;s&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;char&lt;/span&gt; &lt;span class="nt"&gt;c&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nd"&gt;size_type&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nt"&gt;occurs&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;则只能将 find_char 函数用于&lt;code&gt;string&lt;/code&gt;对象。类似下面的调用将在编译时发生错误：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;find_char(&amp;quot;Hello World&amp;quot;, &amp;#39;o&amp;#39;, ctr);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;还有一个更难察觉的问题。假如其它函数（正确的）将它们的形参定义成常量引用，那么上述的 find_char 函数无法在此类函数中正常使用。例如&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;bool&lt;/span&gt; &lt;span class="nt"&gt;is_sentence&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;const&lt;/span&gt; &lt;span class="nt"&gt;string&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nt"&gt;s&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;size_type&lt;/span&gt; &lt;span class="n"&gt;ctr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="err"&gt;return&lt;/span&gt; &lt;span class="err"&gt;find_char(s,&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;.&amp;#39;,&lt;/span&gt; &lt;span class="err"&gt;ctr)&lt;/span&gt; &lt;span class="err"&gt;==&lt;/span&gt; &lt;span class="err"&gt;s.size()&lt;/span&gt; &lt;span class="err"&gt;-&lt;/span&gt; &lt;span class="err"&gt;1&lt;/span&gt; &lt;span class="err"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="err"&gt;ctr&lt;/span&gt; &lt;span class="err"&gt;==&lt;/span&gt; &lt;span class="err"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;正确的修改思路是改正 find_char 函数的形参。如果实在不能修改 find_char，就在 is_sentence 内部定义一个&lt;code&gt;string&lt;/code&gt;类型的变量，令其为 s 的副本，然后把这个对象传递给 find_char。&lt;/p&gt;
&lt;p&gt;用实参初始化形参时，会忽略顶层&lt;code&gt;const&lt;/code&gt;。也就是说，当形参是顶层&lt;code&gt;const&lt;/code&gt;时，传给它常量对象或者非常量对象都是可以的。&lt;/p&gt;
&lt;p&gt;可以使用一个非常量初始化一个底层&lt;code&gt;const&lt;/code&gt;对象，但反过来不行。&lt;/p&gt;
&lt;h3&gt;数组形参&lt;/h3&gt;
&lt;p&gt;数组的两个性质：不允许拷贝数组；使用数组时会将其转换成指针。&lt;/p&gt;
&lt;p&gt;当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针。&lt;/p&gt;
&lt;p&gt;尽管不能以值传递的方式传递数组，但是我们可以把形参写成类似数组的形式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;void print(const int*);
void print(const int[]);
void print(const int[10]);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;尽管表现形式不同，但是上面的三个函数是等价的：每个函数的唯一形参都是&lt;code&gt;const int*&lt;/code&gt;类型的。如果我们传给 print 函数的是一个数组，则实参自动的转换成指向数组首元素的指针，数组的大小对函数的调用没有影响。&lt;/p&gt;
&lt;p&gt;因为数组是以指针的形式传递给函数的，所以一开始函数并不知道数组的确切尺寸，调用者应该为此提供一些额外的信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用标记指定数组长度：让数组本身包含一个结束标记，例如 C 风格字符串&lt;/li&gt;
&lt;li&gt;使用标准库规范，&lt;code&gt;begin()&lt;/code&gt;和&lt;code&gt;end()&lt;/code&gt;函数&lt;/li&gt;
&lt;li&gt;显示传递一个表示数组大小的形参&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当函数不需要对数组元素执行写操作的时候，数组形参应该是指向&lt;code&gt;const&lt;/code&gt;的指针，注意下面的函数只能作用于大小为10的数组&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;void print(int (&amp;amp;arr)[10])
{
        for (auto elem : arr)
                cout &amp;lt;&amp;lt; elem &amp;lt;&amp;lt; endl;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;main：处理命令行选项&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int main(int argc, char *argv[]) { ... }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;第二个形参 argv 是一个数组，它的元素是指向 C 风格字符串的指针；第一个形参 argc 表示数组中字符串的数量。因为第二个形参是数组，所以 main 函数也可以定义成：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int main(int argc, char **argv) { ... }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当实参传给 main 函数之后，argv 的第一个元素指向程序的名字或者一个空字符串，接下来的元素依次传递命令行提供的实参，最后一个指针之后的元素值保证为0。&lt;/p&gt;
&lt;h3&gt;含有可变形参的函数&lt;/h3&gt;
&lt;p&gt;为了编写能够处理不同数量实参的函数，C++11 新标准提供了两种主要的方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果所有实参类型相同，可以传递一个名为&lt;code&gt;initializer_list&lt;/code&gt;的标准库类型&lt;/li&gt;
&lt;li&gt;如果实参的类型不同，可以编写可变参数模板&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++ 还有一种特殊的形参类型（即省略号），可以用它传递可变数量的实参，不过需要注意的是，这种功能一般只用于与 C 函数交互的接口程序&lt;/p&gt;
&lt;h4&gt;initializer_list 形参&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;initializer_list&lt;/code&gt;类型定义在同名的头文件中。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;initializer_list&lt;/code&gt;是一种类型模板，提供的操作如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;initializer_list &amp;lt;T&amp;gt; lst;&lt;/code&gt;默认初始化；T 类型元素的空列表。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;initializer_list &amp;lt;T&amp;gt; lst{a,b,c...};&lt;/code&gt;lst 的元素数量和初始值一样多；lst 的元素是对应初始值的副本；列表中的元素是 const。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;lst2(lst);&lt;/code&gt;拷贝或赋值一个&lt;code&gt;initializer_list&lt;/code&gt;对象不会拷贝列表中的元素；拷贝后，原始列表和副本共享元素。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;lst2 = lst;&lt;/code&gt;等价于&lt;code&gt;lst2(lst)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;lst.size();&lt;/code&gt;列表中的元素数量。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;lst.begin();&lt;/code&gt;返回指向 lst 中首元素的指针。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;lst.end();&lt;/code&gt;返回指向 lst 中尾元素下一位置的指针。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;initializer_list&lt;/code&gt;和&lt;code&gt;vector&lt;/code&gt;一样，也是类型模板，定义&lt;code&gt;initializer_list&lt;/code&gt;对象时，必须说明列表中所含对象的类型。和&lt;code&gt;vector&lt;/code&gt;不一样的是，&lt;code&gt;initializer_list&lt;/code&gt;对象中的元素永远是常量值。&lt;/p&gt;
&lt;p&gt;如果想向&lt;code&gt;initializer_list&lt;/code&gt;形参中传递一个值的序列，则必须把序列放在一对花括号内：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//expected和actual是string对象
if (expected != actual)
        error_msg({&amp;quot;functionX&amp;quot;, expected, actual});
else
        error_msg({&amp;quot;functionX&amp;quot;, &amp;quot;okay&amp;quot;});
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;省略符形参&lt;/h4&gt;
&lt;p&gt;省略符形参是为了便于 C++ 程序访问某些特殊的 C 代码而设置的，这些代码使用了名为 varargs 的 C 标准库功能。通常，省略符形参不应用于其他目的。你的 C 编译器文档会描述如何使用 varargs。&lt;/p&gt;
&lt;p&gt;省略符形参只能出现在形参列表的最后一个位置，无外乎两种形式，在第一种形式中，形参声明后面的逗号是可选的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;void foo(parm_list,...);
void foo(...);
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;返回类型和 return 语句&lt;/h2&gt;
&lt;p&gt;返回&lt;code&gt;void&lt;/code&gt;的函数不要求非得有&lt;code&gt;return&lt;/code&gt;语句，以为这类函数的最后一句会隐式的执行&lt;code&gt;return&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;返回的值用于初始化调用点的一个临时量，该临时量就是函数调用的结果。&lt;/p&gt;
&lt;p&gt;不要返回局部对象的引用或指针。&lt;/p&gt;
&lt;p&gt;调用一个返回引用的函数得到左值，其他返回类型得到右值。&lt;/p&gt;
&lt;p&gt;C++ 11新标准规定，函数可以返回花括号包围的值的列表，类似于其他返回结果，此处的列表也用来对表示函数返回的临时量进行初始化。如果列表为空，临时量执行值初始化。如果函数返回的是内置类型，则花括号包围的列表最多包含一个值，且该值所占空间不应该大于目标类型的空间。如果返回的是类类型，由类本身定义初始值如何使用。&lt;/p&gt;
&lt;p&gt;如果控制语句到达了 main 函数的结尾处而且没有&lt;code&gt;return&lt;/code&gt;语句，编译器会隐式的插入一条返回0的&lt;code&gt;return&lt;/code&gt;语句。&lt;/p&gt;
&lt;p&gt;cstdlib 头文件定义了两个预处理变量表示成功与失败：&lt;code&gt;EXIT_SUCCESS&lt;/code&gt;，&lt;code&gt;EXIT_FAILURE&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;int (*func(int i))[10];&lt;/code&gt;func 是一个函数指针，指向：接受一个&lt;code&gt;int&lt;/code&gt;参数，返回值是包含10个&lt;code&gt;int&lt;/code&gt;数组的地址的函数。也可以利用尾置返回类型（C++ 11）写为：&lt;code&gt;auto func(int i) -&amp;gt; int(*)[10];&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;还有一种情况，如果我们知道函数返回的指针将指向哪个数组，就可以使用&lt;code&gt;decltype&lt;/code&gt;关键字声明返回类型。例如，下面的函数返回一个指针，该指针根据参数i的不同指向两个已知数组中的某一个：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int odd[] = {1, 3, 5, 7, 9};
int even[] = {0, 2, 4, 6, 8};
//返回一个指针，该指针指向含有5个整数的数组
decltype(odd) *arrPtr(int i)
{
        return (i % 2) ? &amp;amp;odd : &amp;amp;even;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;arrPtr 使用关键字&lt;code&gt;decltype&lt;/code&gt;表示它的返回类型是个指针，并且该指针所指的对象与 odd 的类型一致。因为 odd 是数组，所以 arrPtr 返回一个指向含有5个整数的数组的指针。有一个地方需要注意，&lt;code&gt;decltype&lt;/code&gt;并不负责把数组类型转换成对应的指针，所以&lt;code&gt;decltype&lt;/code&gt;的结果是个数组，要想表示 arrPtr 返回指针还必须在函数声明时加一个 * 符号。&lt;/p&gt;
&lt;h2&gt;函数重载&lt;/h2&gt;
&lt;h3&gt;顶层 const&lt;/h3&gt;
&lt;p&gt;顶层&lt;code&gt;const&lt;/code&gt;不影响传入函数的对象。一个用于顶层&lt;code&gt;const&lt;/code&gt;的形参无法和一个没有顶层&lt;code&gt;const&lt;/code&gt;的形参区分开，无法重载：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Record lookup(Phone);
Record lookup(const Phone);
//
Record lookup(Phone*);
Record lookup(Phone* const);
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;底层 const&lt;/h3&gt;
&lt;p&gt;底层&lt;code&gt;const&lt;/code&gt;可以实现重载。当我们传递一个非常量对象或者指向非常量对象的指针时，编译器会优先选用非常量的版本：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Record lookup(Account&amp;amp;);
Record lookup(const Account&amp;amp;);
//
Record lookup(Account*);
Record lookup(const Account*);
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;const_cast和重载&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//函数1
const string &amp;amp;shorterString(const string &amp;amp;s1, const strinf &amp;amp;s2)
{
        return s1.size() &amp;lt;= s2.size() ? s1 : s2;
}
//函数2
string &amp;amp;shorterString(string &amp;amp;s1, string &amp;amp;s2)
{
        auto &amp;amp;r = shorterString(const_cast&amp;lt;const string &amp;amp;&amp;gt;(s1),
                                const_cast&amp;lt;const string&amp;amp;&amp;gt;(s2));
        return const_cast&amp;lt;string&amp;amp;&amp;gt;(r);
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;函数1的参数和返回类型都是&lt;code&gt;const string&lt;/code&gt;的引用。我们当然可以对两个非常量的&lt;code&gt;string&lt;/code&gt;实参调用这个函数，但返回的结果仍然是&lt;code&gt;const string&lt;/code&gt;的引用。&lt;/p&gt;
&lt;h3&gt;作用域与重载&lt;/h3&gt;
&lt;p&gt;编译器首先在当前作用域寻找函数，一旦找到，就会忽略掉外层作用域中的同名实体，剩下的工作就是检查函数调用是否有效了。&lt;/p&gt;
&lt;p&gt;在C++语言中，名字查找发生在类型检查之前。&lt;/p&gt;
&lt;h2&gt;特殊用于语言特性&lt;/h2&gt;
&lt;h3&gt;默认实参&lt;/h3&gt;
&lt;p&gt;一旦一个形参被赋予了默认值，它后面的所有形参都必须有默认值。&lt;/p&gt;
&lt;p&gt;在给定的作用域中，一个形参只能被赋予一次默认实参。&lt;/p&gt;
&lt;p&gt;局部变量不能作为默认实参。&lt;/p&gt;
&lt;p&gt;用作函数实参的名字在函数声明所在的作用域内解析，而这些名字的求值过程发生在函数调用时：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sz wd = 80;
char def = &amp;#39;&amp;#39;;
sz ht();
string screen(sz = ht(), sz = wd, char = def);

void f()
{
    def = &amp;#39;*&amp;#39;;  //改变默认实参的值
    sz wd = 100;    //隐藏了外层定义的wd，但是没有改变默认值
    window = screen();  //调用 screen(ht(), 80, &amp;#39;*&amp;#39;)
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;内联函数&lt;/h3&gt;
&lt;p&gt;以空间换时间。在函数返回类型前面加上关键字&lt;code&gt;inline&lt;/code&gt;。内联说明只是向编译器发出一个请求，编译器可以选择忽略这个请求。&lt;/p&gt;
&lt;h3&gt;constexpr 函数&lt;/h3&gt;
&lt;p&gt;能用于常量表达式的函数。函数的返回类型及所有的形参类型都得是字面值类型。函数体中必须有且只有一条&lt;code&gt;return&lt;/code&gt;语句。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;constexpr int new_sz() { return 42; }
constexpr int foo = new_sz();
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;编译器在程序编译时验证 new_sz 函数的返回类型。执行初始化任务时，编译器把对&lt;code&gt;constexpr&lt;/code&gt;函数的调用替换成其结果值。为了能在编译过程中随时展开，&lt;code&gt;constexpr&lt;/code&gt;函数被隐式指定为内联函数。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;constexpr&lt;/code&gt;函数体内也可以包含其他语句，只要这些语句在运行时不执行任何操作就行，例如，空语句、类型别名及&lt;code&gt;using&lt;/code&gt;声明。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;constexpr&lt;/code&gt;函数不一定返回常量表达式，当把这类函数用在需要常量表达式的上下文中时，会出错。&lt;/p&gt;
&lt;p&gt;把内联函数和&lt;code&gt;constexpr&lt;/code&gt;函数放在头文件内。&lt;/p&gt;
&lt;p&gt;和其它函数不一样，内联函数和&lt;code&gt;constexpr&lt;/code&gt;函数可以在程序中多次定义，但是多个定义必须完全一致。&lt;/p&gt;
&lt;h3&gt;调试帮助&lt;/h3&gt;
&lt;h4&gt;assert 预处理宏&lt;/h4&gt;
&lt;p&gt;所谓预处理宏其实是一个预处理变量，它的行为有点类似于内联函数。&lt;code&gt;assert&lt;/code&gt;宏使用一个表达式作为它的条件：&lt;code&gt;assert(expr);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;首先对 expr 求值，如果表达式为假，&lt;code&gt;assert&lt;/code&gt;输出信息并终止程序的执行。如果表达式为真，&lt;code&gt;assert&lt;/code&gt;什么也不做。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;assert&lt;/code&gt;定义在cassert头文件中，&lt;code&gt;assert&lt;/code&gt;宏常用于检查“不能发生”的条件。&lt;/p&gt;
&lt;h4&gt;NDEBUG 预处理变量&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;assert&lt;/code&gt;的行为依赖于&lt;code&gt;NDEBUG&lt;/code&gt;预处理变量的状态。如果定义了&lt;code&gt;NDEBUG&lt;/code&gt;，&lt;code&gt;assert&lt;/code&gt;什么都不做，默认情况下没有定义&lt;code&gt;NDEBUG&lt;/code&gt;，&lt;code&gt;assert&lt;/code&gt;将执行运行时检查。我们可以使用一个&lt;code&gt;#define&lt;/code&gt;语句定义&lt;code&gt;NDEBUG&lt;/code&gt;，从而关闭调试状态。同时，很多编译器都提供了一个命令行选项使我们可以定义预处理变量：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ CC -D NDEBUG main.C &lt;span class="c1"&gt;#use /D with the Mocrosoft compiler.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;除了使用&lt;code&gt;assert&lt;/code&gt;外，也可以使用&lt;code&gt;NDEBUG&lt;/code&gt;编写自己的条件调试代码。如果&lt;code&gt;NDEBUG&lt;/code&gt;未定义，将执行&lt;code&gt;#ifndef&lt;/code&gt;和&lt;code&gt;#endif&lt;/code&gt;之间的代码；如果定义了&lt;code&gt;NDEBUG&lt;/code&gt;，这些代码将被忽略掉。&lt;/p&gt;
&lt;p&gt;编译器为每个函数都定义了&lt;code&gt;__func__&lt;/code&gt;，它是一个&lt;code&gt;const char&lt;/code&gt;局部静态数组，用于存放函数的名字，除了 C++ 编译器定义的&lt;code&gt;__func__&lt;/code&gt;之外，预处理器还定义了另外4个对于程序调试很有用的名字：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;__FILE__&lt;/code&gt; 存放文件名的字符串字面值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__LINE__&lt;/code&gt; 存放当前行号的整型字面值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__TIME__&lt;/code&gt; 存放文件编译时间的字符串字面值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__DATE__&lt;/code&gt; 存放文件编译日期的字符串字面值&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;函数匹配&lt;/h2&gt;
&lt;p&gt;候选函数：函数匹配的第一步是选定本次调用对应的重载函数集。&lt;/p&gt;
&lt;p&gt;可行函数：形参数量与本次提供的实参数量相等（默认形参可以少于）；每个实参的类型与对应的形参相同，或者可以转换成形参的类型。&lt;/p&gt;
&lt;p&gt;寻找最佳匹配（如果有的话）：该函数每个实参的匹配都不劣于其他可行函数需要的匹配；至少有一个实参的匹配优于其他可行函数提供的匹配。&lt;/p&gt;
&lt;p&gt;如果没找到可行函数：编译器报告无匹配函数的错误；如果最佳匹配不唯一，编译器报告二义性错误。&lt;/p&gt;
&lt;h2&gt;函数指针&lt;/h2&gt;
&lt;p&gt;要声明一个函数指针，只需要用指针替换函数名：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;bool (*pf)(const string &amp;amp;, const string &amp;amp;); //未初始化，pf 两端括号必不可少
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当把函数名作为一个值使用时，该函数自动转换为指针，也就是说取地址符是可选的。同样，我们可以直接用函数指针调用函数，解引用符也是可选的。&lt;/p&gt;
&lt;p&gt;不同类型的函数指针之前不存在转换规则。&lt;/p&gt;
&lt;p&gt;函数指针没有指向任何一个函数：将函数指针赋为0或者 &lt;code&gt;nullptr&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;和数组类似，虽然不能定义函数类型的形参，但是可以定义指向函数的指针。此时，形参看起来是函数，实际上被当成指针使用：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//形参是函数类型，会自动转化为指向函数的指针
void test(bool pf(const string &amp;amp;, const string &amp;amp;));
//等价的定义
void test(bool (*pf)(const string &amp;amp;, const string &amp;amp;));
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果函数返回指向函数的指针，那么必须显示的将返回类型指定为指针。&lt;/p&gt;</content><category term="C++"></category></entry><entry><title>C++ Primer 第五章 语句</title><link href="https://xutree.github.io/pages/2018/10/09/C++_Primer_Chapter_5/" rel="alternate"></link><published>2018-10-09T12:06:33+08:00</published><updated>2018-10-09T12:06:33+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-09:/pages/2018/10/09/C++_Primer_Chapter_5/</id><summary type="html">&lt;h2&gt;空语句&lt;/h2&gt;
&lt;p&gt;使用空语句时应该加上注释，从而令读这段代码的知道该语句是有意省略的。&lt;/p&gt;
&lt;h2&gt;悬垂 else&lt;/h2&gt;
&lt;p&gt;C++ 规定&lt;code&gt;else&lt;/code&gt;与离它最近的尚未匹配的&lt;code&gt;if&lt;/code&gt;匹配。&lt;/p&gt;
&lt;h2&gt;switch 语句&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;switch&lt;/code&gt;语句中的&lt;code&gt;case&lt;/code&gt;标签必须是&lt;strong&gt;整型常量表达式&lt;/strong&gt;或者&lt;strong&gt;可以转换成整型常量表达式的类型&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果某个&lt;code&gt;case&lt;/code&gt;标签匹配成功，将从该标签处开始往后顺序执行所有&lt;code&gt;case&lt;/code&gt;分支，除非程序显示的中断了这一过程，否则直到&lt;code&gt;switch&lt;/code&gt;结尾处才停下来。在大多说情况下，在下一个&lt;code&gt;case&lt;/code&gt;标签之前应该有一条&lt;code&gt;break&lt;/code&gt;语句用于中断。&lt;/p&gt;
&lt;p&gt;标签不应该孤零零的出现，它后面必须跟上一条语句或者另一个&lt;code&gt;case&lt;/code&gt;标签。如果&lt;code&gt;switch&lt;/code&gt;结构以一个空的&lt;code&gt;default&lt;/code&gt;标签作为结束，则该&lt;code&gt;default&lt;/code&gt;标签后面必须跟上一条空语句或一个空块。&lt;/p&gt;
&lt;p&gt;不允许跨过变量的初始化语句直接跳转到该变量作用域内的另一个位置。&lt;/p&gt;
&lt;h2&gt;范围 …&lt;/h2&gt;</summary><content type="html">&lt;h2&gt;空语句&lt;/h2&gt;
&lt;p&gt;使用空语句时应该加上注释，从而令读这段代码的知道该语句是有意省略的。&lt;/p&gt;
&lt;h2&gt;悬垂 else&lt;/h2&gt;
&lt;p&gt;C++ 规定&lt;code&gt;else&lt;/code&gt;与离它最近的尚未匹配的&lt;code&gt;if&lt;/code&gt;匹配。&lt;/p&gt;
&lt;h2&gt;switch 语句&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;switch&lt;/code&gt;语句中的&lt;code&gt;case&lt;/code&gt;标签必须是&lt;strong&gt;整型常量表达式&lt;/strong&gt;或者&lt;strong&gt;可以转换成整型常量表达式的类型&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果某个&lt;code&gt;case&lt;/code&gt;标签匹配成功，将从该标签处开始往后顺序执行所有&lt;code&gt;case&lt;/code&gt;分支，除非程序显示的中断了这一过程，否则直到&lt;code&gt;switch&lt;/code&gt;结尾处才停下来。在大多说情况下，在下一个&lt;code&gt;case&lt;/code&gt;标签之前应该有一条&lt;code&gt;break&lt;/code&gt;语句用于中断。&lt;/p&gt;
&lt;p&gt;标签不应该孤零零的出现，它后面必须跟上一条语句或者另一个&lt;code&gt;case&lt;/code&gt;标签。如果&lt;code&gt;switch&lt;/code&gt;结构以一个空的&lt;code&gt;default&lt;/code&gt;标签作为结束，则该&lt;code&gt;default&lt;/code&gt;标签后面必须跟上一条空语句或一个空块。&lt;/p&gt;
&lt;p&gt;不允许跨过变量的初始化语句直接跳转到该变量作用域内的另一个位置。&lt;/p&gt;
&lt;h2&gt;范围 for&lt;/h2&gt;
&lt;p&gt;在范围&lt;code&gt;for&lt;/code&gt;语句中，预存了&lt;code&gt;end()&lt;/code&gt;的值，一旦程序中添加（删除）元素，&lt;code&gt;end&lt;/code&gt;函数的值就可能变得无效，所以不能通过范围&lt;code&gt;for&lt;/code&gt;语句增加或删除容器的元素。&lt;/p&gt;
&lt;h2&gt;do while 语句&lt;/h2&gt;
&lt;p&gt;应该在括号包围起来的条件后面用一个分号表示语句结束。&lt;/p&gt;
&lt;h2&gt;跳转语句&lt;/h2&gt;
&lt;h3&gt;break 语句&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;break&lt;/code&gt;语句负责终止离它最近的&lt;code&gt;while&lt;/code&gt;、&lt;code&gt;do while&lt;/code&gt;、&lt;code&gt;for&lt;/code&gt;或&lt;code&gt;switch&lt;/code&gt;语句，并从这些语句之后的第一条语句开始继续执行。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;break&lt;/code&gt;语句只能出现在迭代语句或者&lt;code&gt;switch&lt;/code&gt;语句内部（包括嵌套在此类循环里的语句或块的内部）。&lt;code&gt;break&lt;/code&gt;语句的作用范围仅限于最近的循环或者&lt;code&gt;switch&lt;/code&gt;。&lt;/p&gt;
&lt;h3&gt;continue 语句&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;continu&lt;/code&gt;e语句终止最近的循环中的当前迭代并立即开始下一次迭代。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;continue&lt;/code&gt;语句只能出现在&lt;code&gt;for&lt;/code&gt;、&lt;code&gt;while&lt;/code&gt;和&lt;code&gt;do while&lt;/code&gt;的循环的内部，或者嵌套在此类循环里的语句或块的内部。&lt;/p&gt;
&lt;p&gt;和&lt;code&gt;break&lt;/code&gt;语句类似的是，出现在嵌套循环中的&lt;code&gt;continue&lt;/code&gt;语句也仅作用于离它最近的循环。&lt;/p&gt;
&lt;p&gt;和&lt;code&gt;break&lt;/code&gt;语句不同的是，只有当&lt;code&gt;switch&lt;/code&gt;语句嵌套在迭代语句内部时，才能在&lt;code&gt;switch&lt;/code&gt;里使用&lt;code&gt;continue&lt;/code&gt;。&lt;/p&gt;
&lt;h3&gt;goto 语句&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;goto&lt;/code&gt;语句的作用是从&lt;code&gt;goto&lt;/code&gt;语句无条件跳转到同一函数内的另一条语句。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;goto&lt;/code&gt;语句和控制权转向的那条带标签的语句必须位于同一函数之内。&lt;/p&gt;
&lt;h2&gt;异常处理&lt;/h2&gt;
&lt;h3&gt;throw 表达式&lt;/h3&gt;
&lt;p&gt;异常检测部分使用&lt;code&gt;throw&lt;/code&gt;表达式来表示它遇到了无法处理的问题。我们说&lt;code&gt;throw&lt;/code&gt;引发了异常，例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;throw runtime_error(&amp;quot;Data must refer to same ISBN&amp;quot;);
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;try 语句块&lt;/h3&gt;
&lt;p&gt;异常处理部分使用&lt;code&gt;try&lt;/code&gt;语句处理异常。&lt;code&gt;try&lt;/code&gt;语句块以关键字&lt;code&gt;try&lt;/code&gt;开始，并以一个或多个&lt;code&gt;catch&lt;/code&gt;字句结束。&lt;code&gt;try&lt;/code&gt;语句块中代码抛出的异常通常会被某个catch字句处理，这些字句称为异常处理代码。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;try{
    program-statements
} catch (exception-declaration) {
    handler-statements
} catch (exception-declaration) {
    handler-statements
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;跟在&lt;code&gt;try&lt;/code&gt;块之后的是一个或多个&lt;code&gt;catch&lt;/code&gt;子句。&lt;code&gt;catch&lt;/code&gt;子句包括三个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关键字&lt;code&gt;catch&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;括号内一个（可能未命名的）对象的声明（称作异常声明）&lt;/li&gt;
&lt;li&gt;一个块&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;try&lt;/code&gt;语句块中 program-statements 组成程序的正常逻辑，像其他任何块一样，可以有包含声明在内的任意 C++ 语句。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;try&lt;/code&gt;语句块内声明的变量在块外部无法访问，特别是在&lt;code&gt;catch子&lt;/code&gt;句内也无法访问。&lt;/p&gt;
&lt;p&gt;函数在寻找代码处理的过程中退出，如果最终没能找到任何匹配的&lt;code&gt;catch&lt;/code&gt;子句，程序转到名为&lt;code&gt;terminate&lt;/code&gt;的标准库函数。该函数的行为与系统有关，一般情况下，执行该函数将导致程序非正常退出。&lt;/p&gt;
&lt;h3&gt;标准异常&lt;/h3&gt;
&lt;p&gt;C++ 标准库定义了一组类，用于报告标准库函数遇到的问题，这些异常类也可以在用户别写的程序中使用，它们分别定义在4个头文件中：&lt;/p&gt;
&lt;h4&gt;exception 头文件&lt;/h4&gt;
&lt;p&gt;定义了最通用的异常类&lt;code&gt;exception&lt;/code&gt;。它只报告异常的发生，不提供任何异常信息&lt;/p&gt;
&lt;h4&gt;stdexcept 头文件定义了几种常见的异常类&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;异常类&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;exception&lt;/td&gt;
&lt;td&gt;最常见的问题&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;runtime_error&lt;/td&gt;
&lt;td&gt;只有在运行时才能检测出的问题&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;range_error&lt;/td&gt;
&lt;td&gt;运行时错误：生成的结果超出了有意义的值域范围&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;overflow_error&lt;/td&gt;
&lt;td&gt;运行时错误：计算上溢&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;underflow_error&lt;/td&gt;
&lt;td&gt;运行时错误：计算下溢&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;logic_error&lt;/td&gt;
&lt;td&gt;程序逻辑错误&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;domain_error&lt;/td&gt;
&lt;td&gt;逻辑错误：参数对应的结果值不存在&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;invalid_argument&lt;/td&gt;
&lt;td&gt;逻辑错误：无效参数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;length_error&lt;/td&gt;
&lt;td&gt;逻辑错误：试图创建一个超出该类型最大长度的对象&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;out_of_range&lt;/td&gt;
&lt;td&gt;逻辑错误：使用一个超出有效范围的值&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4&gt;new 头文件&lt;/h4&gt;
&lt;p&gt;定义了&lt;code&gt;bad_alloc&lt;/code&gt;异常类型&lt;/p&gt;
&lt;h4&gt;type_info 头文件&lt;/h4&gt;
&lt;p&gt;定义了&lt;code&gt;bad_cast&lt;/code&gt;异常类型&lt;/p&gt;
&lt;p&gt;标准异常库只定义了几种运算，包括创建和拷贝异常类型的对象，以及为异常类型的对象赋值。我们只能以默认初始化的方式初始化&lt;code&gt;exception&lt;/code&gt;、&lt;code&gt;bad_alloc&lt;/code&gt;和&lt;code&gt;bad_cas&lt;/code&gt;t对象，不允许为这些对象提供初始值。&lt;/p&gt;
&lt;p&gt;其他异常类型的行为则刚好相反。应该使用&lt;code&gt;string&lt;/code&gt;对象或者 C 风格字符串初始化这些类型的对象，但是不允许使用默认初始化的方式。当创建此类对象时，必须提供初始值，该初始值含有错误相关的信息。&lt;/p&gt;
&lt;p&gt;异常类型只定义了一个名为&lt;code&gt;what&lt;/code&gt;的成员函数，该函数没有任何参数，返回值是一个指向 C 风格字符串的&lt;code&gt;const char *&lt;/code&gt;。该字符串的目的是提供关于异常的一些文本信息。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;what&lt;/code&gt;函数返回的 C 风格字符串的内容与异常对象的类型有关。如果异常类型只有一个字符串初始值，则&lt;code&gt;what&lt;/code&gt;返回该字符串。对于其他无初始值的异常类型来说，&lt;code&gt;what&lt;/code&gt;返回的内容由编译器决定。&lt;/p&gt;</content><category term="C++"></category></entry><entry><title>C++ Primer 第四章 表达式</title><link href="https://xutree.github.io/pages/2018/10/07/C++_Primer_Chapter_4/" rel="alternate"></link><published>2018-10-07T10:44:38+08:00</published><updated>2018-10-07T11:08:56+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-07:/pages/2018/10/07/C++_Primer_Chapter_4/</id><summary type="html">&lt;p&gt;重载运算符时，其包括运算对象的类型和返回值的类型，都是由该运算符定义的；但是运算对象的个数、运算符的优先级和结合律都是无法改变的。&lt;/p&gt;
&lt;h2&gt;左值和右值&lt;/h2&gt;
&lt;p&gt;当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。&lt;/p&gt;
&lt;p&gt;一个重要的原则：在需要右值的地方可以用左值来代替，但是不能把右值当成左值（也就是位置）使用。当一个左值被当成右值使用时，实际使用的是它的内容（值）。&lt;/p&gt;
&lt;p&gt;要用到左值的运算符：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;赋值运算符需要一个左值作为其左侧运算对象，得到的结果也仍然是一个左值&lt;/li&gt;
&lt;li&gt;取地址符作用于一个左值运算对象，返回一个指向该运算对象的指针，这个指针是一个右值&lt;/li&gt;
&lt;li&gt;内置解引用运算符、下标运算符、迭代器解引用运算符、&lt;code&gt;string&lt;/code&gt;和&lt;code&gt;vector&lt;/code&gt;的下标运算符的求值结果都是左值&lt;/li&gt;
&lt;li&gt;内置类型和迭代器的递增递减运算符作用于左值运算对象&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;求值顺序&lt;/h2&gt;
&lt;p&gt;优先级规定了运算对象的组合方式，但是没有说明运算对象按照什么顺序求值。对于那些没有指定执行顺序的运算符来说，如果表达式指向并修改了同一个对象，将会引发错误并产生未定义的行为。&lt;/p&gt;
&lt;p&gt;例如，下面的输出表达式是未定义的，我们无法推测编译器是先求 ++i 还是先输出：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int i = 0;
cout &amp;lt;&amp;lt; i …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;重载运算符时，其包括运算对象的类型和返回值的类型，都是由该运算符定义的；但是运算对象的个数、运算符的优先级和结合律都是无法改变的。&lt;/p&gt;
&lt;h2&gt;左值和右值&lt;/h2&gt;
&lt;p&gt;当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。&lt;/p&gt;
&lt;p&gt;一个重要的原则：在需要右值的地方可以用左值来代替，但是不能把右值当成左值（也就是位置）使用。当一个左值被当成右值使用时，实际使用的是它的内容（值）。&lt;/p&gt;
&lt;p&gt;要用到左值的运算符：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;赋值运算符需要一个左值作为其左侧运算对象，得到的结果也仍然是一个左值&lt;/li&gt;
&lt;li&gt;取地址符作用于一个左值运算对象，返回一个指向该运算对象的指针，这个指针是一个右值&lt;/li&gt;
&lt;li&gt;内置解引用运算符、下标运算符、迭代器解引用运算符、&lt;code&gt;string&lt;/code&gt;和&lt;code&gt;vector&lt;/code&gt;的下标运算符的求值结果都是左值&lt;/li&gt;
&lt;li&gt;内置类型和迭代器的递增递减运算符作用于左值运算对象&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;求值顺序&lt;/h2&gt;
&lt;p&gt;优先级规定了运算对象的组合方式，但是没有说明运算对象按照什么顺序求值。对于那些没有指定执行顺序的运算符来说，如果表达式指向并修改了同一个对象，将会引发错误并产生未定义的行为。&lt;/p&gt;
&lt;p&gt;例如，下面的输出表达式是未定义的，我们无法推测编译器是先求 ++i 还是先输出：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int i = 0;
cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; ++i &amp;lt;&amp;lt; endl;    //未定义的
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;有4种运算符明确规定了运算对象的求值顺序。&amp;amp;&amp;amp;、||、?:、和逗号（，）运算符。&lt;/p&gt;
&lt;p&gt;对于f()+g()*h()+j()的表达式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优先级规定，g() 的返回值和 h() 的返回值相乘&lt;/li&gt;
&lt;li&gt;结合律规定，f() 的返回值先与 g() 和 h() 的乘积相加，所得结果再与 j() 的返回值相加&lt;/li&gt;
&lt;li&gt;对于这些函数的调用顺序没有明确规定&lt;/li&gt;
&lt;li&gt;如果 f、g、h 和 j 是无关函数，它们既不会改变同一对象的状态也不执行 IO 任务，那么函数的调用顺序不受限制。反之，如果其中某几个函数影响同一对象，则它是一条错误的表达式，将产生未定义的行为&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;算术运算符&lt;/h2&gt;
&lt;p&gt;+(正号)、-(负号)、*(乘)、/(除),%(求余)，+(加)、-(减)&lt;/p&gt;
&lt;p&gt;算术运算符的运算对象和求值结果都是右值。&lt;/p&gt;
&lt;p&gt;一元正号负号运算符对运算对象作用后，返回一个（提升后的）副本：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int i = 1024;
int k = -i;
bool b = true;
bool b2 = -b;   //b2 是 true
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;对大多数运算符来说，布尔类型的运算对象将被提升为&lt;code&gt;int&lt;/code&gt;类型。如上，b 参与运算时被提升成整数值1，对它求负-1，转换为布尔值将其作为 b2 的初始值。&lt;/p&gt;
&lt;p&gt;在除法运算中，如果两个运算对象的符号相同则商为正，否则商为负。C++ 语言的早期版本允许结果为负值的商向上或向下取整，C++11 新标准则规定商一律向0取整（即直接切除小数部分）。&lt;/p&gt;
&lt;h2&gt;逻辑和关系运算符&lt;/h2&gt;
&lt;p&gt;运算对象和求值结果都是右值；短路求值；进行比较运算符时，除非比较的对象是布尔类型，否则不要使用布尔字面值&lt;code&gt;true&lt;/code&gt;和&lt;code&gt;false&lt;/code&gt;作为运算对象&lt;/p&gt;
&lt;h2&gt;赋值运算符&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;赋值运算符的左侧运算对象必须是一个可修改的左值&lt;/li&gt;
&lt;li&gt;赋值运算的结果是它的左侧运算对象，并且是一个左值，结果的类型就是左侧运算对象的类型&lt;/li&gt;
&lt;li&gt;如果赋值运算符的左右两个运算对象类型不同，则右侧运算对象将转换成左侧运算对象的类型&lt;/li&gt;
&lt;li&gt;赋值运算满足右结合律：ival = jval = 0；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;++ 和 -- 运算符&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;前置版本将对象本身作为左值返回，后置版本则将对象原始值的副本作为右值返回&lt;/li&gt;
&lt;li&gt;建议：除非必须，否则不用递增递减算符的后置版本&lt;/li&gt;
&lt;li&gt;后置递增运算符的优先级高于解引用运算符，因此 *pbeg++ 等价于 *(pbeg++)，pbeg++ 把 pbeg 的值加1，然后返回 pbeg 的初始值的副本作为其求值结果&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;成员访问运算符&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;由于解引用运算符的优先级低于逗号运算符，因此要对解引用运算符加括号&lt;/li&gt;
&lt;li&gt;箭头运算符作用于一个指针类型的运算对象，结果是一个左值&lt;/li&gt;
&lt;li&gt;点运算符分成两种情况：如果成员所属的对象是左值，那么结果就是左值；反之，如果成员所属的对象是右值，那么结果是右值&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;条件运算符&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;当条件运算符的两个表达式都是左值或者能转换成同一种左值类型时，运算的结果是左值；否则运算的结果是右值&lt;/li&gt;
&lt;li&gt;条件运算符满足右结合律&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;位运算符&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;位运算符作用于整数类型的运算对象&lt;/li&gt;
&lt;li&gt;关于符号位如何处理没有明确的规定，所以强烈建议仅将位运算符作用于处理无符号类型&lt;/li&gt;
&lt;li&gt;移位运算符&lt;ul&gt;
&lt;li&gt;首先令左侧运算对象的内容按照右侧运算对象的要求移动指定位数，然后将经过移动的（可能还进行了提升）左侧运算对象的拷贝作为求值结果。其中，右侧的运算对象一定不能为负，而且值必须严格小于结果的位数，否则就会产生未定义的行为。移出边界之外的位就被舍弃掉了&lt;/li&gt;
&lt;li&gt;移位运算符满足左结合律&lt;/li&gt;
&lt;li&gt;移位运算符的优先级比算术运算符低，比关系运算符、赋值运算符和条件运算符高&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;sizeof运算符&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;sizeof&lt;/code&gt;运算符返回一条表达式或一个类型名字所占的字节数。&lt;code&gt;sizeof&lt;/code&gt;运算符满足右结合律，其所得的值是一个&lt;code&gt;size_t&lt;/code&gt;类型的常量表达式&lt;/p&gt;
&lt;p&gt;两种形式&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sizeof (type)
sizeof expr
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;sizeof&lt;/code&gt;并不直接计算其运算对象的值。&lt;/p&gt;
&lt;p&gt;对于&lt;code&gt;sizeof *p&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因为&lt;code&gt;sizeof&lt;/code&gt;满足右结合律并且与 * 的运算符的优先级一样，所以表达式按照从右到左的顺序结合，等价于：&lt;code&gt;sizeof (*p)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;其次，因为&lt;code&gt;sizeof&lt;/code&gt;不实际求运算对象的值，所以即使 p 是一个无效（即未初始化）的指针也不会有什么影响&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;sizeof&lt;/code&gt;的运算对象中解引用一个无效的指针仍然是一种安全的行为，因为指针实际上并没有被真正使用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sizeof&lt;/code&gt;运算符的结果部分地依赖于其作用的类型：&lt;ul&gt;
&lt;li&gt;对&lt;code&gt;char&lt;/code&gt;或者类型为&lt;code&gt;char&lt;/code&gt;的表达式执行&lt;code&gt;sizeof&lt;/code&gt;运算，结果得1&lt;/li&gt;
&lt;li&gt;对引用类型执行&lt;code&gt;sizeof&lt;/code&gt;运算得到被引用对象所占空间的大小&lt;/li&gt;
&lt;li&gt;对指针执行&lt;code&gt;sizeof&lt;/code&gt;运算得到指针本身所占空间的大小&lt;/li&gt;
&lt;li&gt;对解引用指针执行&lt;code&gt;sizeof&lt;/code&gt;运算得到指针指向的对象所占空间的大小，指针不需有效&lt;/li&gt;
&lt;li&gt;对数值执行&lt;code&gt;sizeof&lt;/code&gt;运算符得到整个数组所占空间的大小。&lt;code&gt;sizeof&lt;/code&gt;运算不会把数组转换成指针来处理&lt;/li&gt;
&lt;li&gt;对&lt;code&gt;string&lt;/code&gt;对象或者&lt;code&gt;vector&lt;/code&gt;对象执行&lt;code&gt;sizeof&lt;/code&gt;运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。即只取决于里面存放的数据类型，与元素的个数无关，是个编译器相关的值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;逗号运算符&lt;/h2&gt;
&lt;p&gt;首先对左侧的表达式求值，然后将求值结果丢弃掉。逗号表达式真正的结果是右侧表达式的值。如果右侧运算对象是左值，那么最终的求值结果也是左值。&lt;/p&gt;
&lt;h2&gt;类型转换&lt;/h2&gt;
&lt;h3&gt;何时发生隐式类型转换&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;在大多数表达式中，比&lt;code&gt;int&lt;/code&gt;类型小的整数值首先提升为较大的整数类型&lt;/li&gt;
&lt;li&gt;在条件中，非布尔值转换成布尔类型&lt;/li&gt;
&lt;li&gt;初始化过程中，初始值转换成变量的类型；在赋值语句中，右侧运算对象装换成左侧运算对象的类型&lt;/li&gt;
&lt;li&gt;如果算术运算或关系运算的运算对象有多种类型，需要转换成同一种类型&lt;/li&gt;
&lt;li&gt;函数调用时也会发生类型转换&lt;/li&gt;
&lt;li&gt;数组转换成指针（当数组被用作&lt;code&gt;decltype&lt;/code&gt;关键字的参数，或者作为取地址符、&lt;code&gt;sizeof&lt;/code&gt;即&lt;code&gt;typeid&lt;/code&gt;等运算符的运算对象时，上述转换不会发生，如果用一个引用来初始化数组，上述转换也不会发生）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;指针的转换&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;常量整数值0或者字面值&lt;code&gt;nullptr&lt;/code&gt;能转换成任意指针类型&lt;/li&gt;
&lt;li&gt;指向任意非常量的指针能转换成&lt;code&gt;void *&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;指向任意对象的指针能转换成&lt;code&gt;const void *&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;转换成常量：允许将指向非常量类型的指针转换成指向相应的常量类型的指针，对于引用也是这样。相反的转换并不存在，因为它试图删掉底层&lt;code&gt;const&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;类类型定义的转换&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;类类型能定义由编译器自动执行的转换，不过编译器每次只能执行一种类类型的转换，如果同时提出多个转换请求，这些请求将被拒绝&lt;/li&gt;
&lt;li&gt;之前遇到过的类类型转换&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;string s, t = &amp;quot;a value&amp;quot;;    //字符串字面值转换成 string 类型
wile( cin &amp;gt;&amp;gt; s)     //while 的条件部分把 cin 转换成布尔值
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;显示转换&lt;/h3&gt;
&lt;p&gt;虽然有时不得不使用强制类型转换，但这种方法本质上是非常危险的。&lt;/p&gt;
&lt;h3&gt;命名的强制类型转换&lt;/h3&gt;
&lt;p&gt;一个命名的强制类型转换具有如下格式：&lt;code&gt;cast-name&amp;lt;type&amp;gt;(expression);&lt;/code&gt;type 是转换的目标类型。如果 type 是引用类型，则结果是左值；expression 是要转换的值；cast-name 是&lt;code&gt;static_cast&lt;/code&gt;、&lt;code&gt;dynamic_cast&lt;/code&gt;、&lt;code&gt;const_cast&lt;/code&gt;和&lt;code&gt;reinterpret_cast&lt;/code&gt;中的一种。&lt;code&gt;dynamic_cast&lt;/code&gt;支持运行时类型识别。&lt;/p&gt;
&lt;h3&gt;static_cast&lt;/h3&gt;
&lt;p&gt;任何具有明确定义的类型转换，只要不包含底层&lt;code&gt;const&lt;/code&gt;，都可以使用&lt;code&gt;static_cast&lt;/code&gt;。当需要把一个较大的算术类型赋给较小的类型时，&lt;code&gt;static_cast&lt;/code&gt;非常有用。此时，强制类型转换告诉程序的读者和编译器：我们知道并且不在乎潜在的精度损失。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;static_cast&lt;/code&gt;对于编译器无法自动执行的类型转换也非常有用。例如，我们可以使用它找回&lt;code&gt;void *&lt;/code&gt;指针中的值:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;void *p = &amp;amp;d;
double *dp = static_cast&amp;lt;double *&amp;gt;(p);
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;const_cast&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;const_cast&lt;/code&gt;只能改变运算对象的底层&lt;code&gt;const&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;const char *pc;
char *p = const_cast&amp;lt;char*&amp;gt;(pc);//正确，但通过p写值是未定义的行为
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;只有&lt;code&gt;const_cast&lt;/code&gt;能改变表达式的常量属性。&lt;/p&gt;
&lt;h3&gt;reinterpret_cast&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;einterpret_cast&lt;/code&gt;通常为运算对象的位模式提供较低层次上的重新解释。&lt;/p&gt;
&lt;p&gt;假如有以下转换：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int *ip;
char *pc = reinterpret_cast&amp;lt;char*&amp;gt;(ip);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们必须牢记 pc 所指的真实对象是一个 int 而非字符，如果把 pc 当成普通的字符指针使用就可能在运行时发生错误。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;string str(pc);     //可能导致异常的运行时行为
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;reinterpret_cast&lt;/code&gt;本质上依赖于机器。要想安全地使用&lt;code&gt;reinterpret_cast&lt;/code&gt;必须对涉及的类型和编译器实现转换的过程都非常了解。&lt;/p&gt;
&lt;p&gt;强制类型转换干扰了正常的类型检查，因此强烈建议避免使用强制类型转换。&lt;/p&gt;
&lt;h3&gt;旧式的强制类型转换&lt;/h3&gt;
&lt;p&gt;在早期版本的 C++ 语言中，显示地进行强制类型转换包含两种形式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;type (expr);    //函数形式的强制类型转换
(type) expr;    //C 语言风格的强制类型转换
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;根据所设计的类型不同，旧式的强制类型转换分别具有与&lt;code&gt;const_cast&lt;/code&gt;，&lt;code&gt;static_cast&lt;/code&gt;或&lt;code&gt;reinterpret_cast&lt;/code&gt;相似的行为。当我们在某处执行旧式的强制类型转换时，如果换成&lt;code&gt;const_cast&lt;/code&gt;和&lt;code&gt;static_cast&lt;/code&gt;也合法，则其行为与相应的命名转换一致。如果替换后不合法，则旧式强制类型转换执行与&lt;code&gt;reinterpret_cast&lt;/code&gt;类似的功能。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;char *pc = (char*) ip;  //ip是指向整数的指针
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上述代码的效果与&lt;code&gt;reinterpret_cast&lt;/code&gt;一样。&lt;/p&gt;</content><category term="C++"></category></entry><entry><title>C++ Primer 第三章 字符串、向量和数组</title><link href="https://xutree.github.io/pages/2018/10/06/C++_Primer_Chapter_3/" rel="alternate"></link><published>2018-10-06T22:31:16+08:00</published><updated>2018-10-07T10:48:54+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-06:/pages/2018/10/06/C++_Primer_Chapter_3/</id><summary type="html">&lt;p&gt;&lt;code&gt;string&lt;/code&gt;表示可变长的字符数组。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vector&lt;/code&gt;存放的是某种给定类型对象的可变长序列。&lt;/p&gt;
&lt;p&gt;数组和其他内置类型一样，实现与硬件密切相关，在灵活性上稍显不足。&lt;/p&gt;
&lt;p&gt;命名空间&lt;code&gt;using&lt;/code&gt;声明：&lt;code&gt;using namespace::name;&lt;/code&gt;例如：&lt;code&gt;using std::cin;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;头文件不应包含&lt;code&gt;using&lt;/code&gt;声明，防止名字冲突。&lt;/p&gt;
&lt;h2&gt;标准库类型 string&lt;/h2&gt;
&lt;h3&gt;头文件和声明&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="n"&gt;using&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kr"&gt;string&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;定义和初始化&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;string s1;  //默认初始化，空字符串
string s2 = s1; //s2是s1的副本，等价于 s2(s1)
string s3 = &amp;quot;hiya&amp;quot;; //s3是字符串字面值的副本，等价于s3(&amp;quot;hiya&amp;quot;)
string s4(10 …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;&lt;code&gt;string&lt;/code&gt;表示可变长的字符数组。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vector&lt;/code&gt;存放的是某种给定类型对象的可变长序列。&lt;/p&gt;
&lt;p&gt;数组和其他内置类型一样，实现与硬件密切相关，在灵活性上稍显不足。&lt;/p&gt;
&lt;p&gt;命名空间&lt;code&gt;using&lt;/code&gt;声明：&lt;code&gt;using namespace::name;&lt;/code&gt;例如：&lt;code&gt;using std::cin;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;头文件不应包含&lt;code&gt;using&lt;/code&gt;声明，防止名字冲突。&lt;/p&gt;
&lt;h2&gt;标准库类型 string&lt;/h2&gt;
&lt;h3&gt;头文件和声明&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="n"&gt;using&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kr"&gt;string&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;定义和初始化&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;string s1;  //默认初始化，空字符串
string s2 = s1; //s2是s1的副本，等价于 s2(s1)
string s3 = &amp;quot;hiya&amp;quot;; //s3是字符串字面值的副本，等价于s3(&amp;quot;hiya&amp;quot;)
string s4(10, &amp;#39;c&amp;#39;); //s4的内容是cccccccccc
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;string 对象上的操作&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;操作&lt;/th&gt;
&lt;th&gt;意义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;os &amp;lt;&amp;lt; s&lt;/td&gt;
&lt;td&gt;将 s 写到输出流 os 中，返回 os&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;is &amp;gt;&amp;gt; s&lt;/td&gt;
&lt;td&gt;从 is 中读取字符串赋给 s，字符串以空白分隔，返回 is&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;getline(is, s)&lt;/td&gt;
&lt;td&gt;从 is 中读取一行赋给 s，返回 is&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s.empty()&lt;/td&gt;
&lt;td&gt;s 为空返回 true，否则返回 false&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s.size()&lt;/td&gt;
&lt;td&gt;返回 s 中字符的个数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s[n]&lt;/td&gt;
&lt;td&gt;返回 s 中第 n 个字符的引用，位置 n 从0记起&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s1 + s2&lt;/td&gt;
&lt;td&gt;返回连接后的结果&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s1 = s2&lt;/td&gt;
&lt;td&gt;用 s2 的副本代替 s1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s1 == s2&lt;/td&gt;
&lt;td&gt;如果 s1 和 s2 中所含的字符完全一样，则他们相等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s1 != s2&lt;/td&gt;
&lt;td&gt;string 对象的相等性判断对大小写敏感&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;lt;, &amp;lt;=, &amp;gt;, &amp;gt;=&lt;/td&gt;
&lt;td&gt;利用字符在字典里的顺序进行比较，大小写敏感&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;读取未知数量的 string 对象&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int main()
{
    string word;
    while (cin &amp;gt;&amp;gt; word)
        cout &amp;lt;&amp;lt; word &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;直到遇到结束标记或者非法输入才会停止&lt;/p&gt;
&lt;h3&gt;使用 getline 读取一整行&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int main()
{
    string line;
    while (getline(cin,line))
        cout &amp;lt;&amp;lt; line &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;getline&lt;/code&gt;函数的参数是一个输入流和一个&lt;code&gt;string&lt;/code&gt;对象，&lt;code&gt;getline&lt;/code&gt;从给定的输入流中读入内容，直到遇到换行符为止（注意换行符也被读进来了），然后把所读的内容存入&lt;code&gt;string&lt;/code&gt;对象中（注意不存换行符）。如果输入一开始就是换行符，那么所得的结果是个空&lt;code&gt;string&lt;/code&gt;。&lt;/p&gt;
&lt;h3&gt;string::size_type 类型&lt;/h3&gt;
&lt;p&gt;是一个无符号类型的值。如果一个表达式中已经有&lt;code&gt;size&lt;/code&gt;函数就不要再使用&lt;code&gt;int&lt;/code&gt;了，这样可以避免混用&lt;code&gt;int&lt;/code&gt;和&lt;code&gt;unsigned&lt;/code&gt;可能带来的问题。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;string&lt;/code&gt;对象可以和字符字符串字面值相加，只要保证 + 号两侧的运算对象至少有一个&lt;code&gt;string&lt;/code&gt;对象即可。&lt;/p&gt;
&lt;p&gt;由于某些历史原因，也为了和 C 兼容，所以 C++ 中的字符串字面值并不是标准库&lt;code&gt;string&lt;/code&gt;类型。&lt;/p&gt;
&lt;h3&gt;处理 string 对象里的字符&lt;/h3&gt;
&lt;p&gt;包含在&lt;code&gt;cctype&lt;/code&gt;头文件中：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;意义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;isalunm(c)&lt;/td&gt;
&lt;td&gt;当 c 是字母或数字时为真&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;isalpha(c)&lt;/td&gt;
&lt;td&gt;当 c 是字母时为真&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;iscntrl(c)&lt;/td&gt;
&lt;td&gt;当 c 是控制字符时为真&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;isdigit(c)&lt;/td&gt;
&lt;td&gt;当 c 是数字时为真&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;isgraph(c)&lt;/td&gt;
&lt;td&gt;当 c 不是空格但可打印时为真&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;islower(c)&lt;/td&gt;
&lt;td&gt;当 c 是小写字母时为真&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;isprint(c)&lt;/td&gt;
&lt;td&gt;当 c 是可打印字符时为真（即 c 是空格或 c 具有可视形式）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ispunct(c)&lt;/td&gt;
&lt;td&gt;当 c 是标点符号时为真（即 c 不是控制字符、数字、字母、可打印空白中的一种）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;isspace(c)&lt;/td&gt;
&lt;td&gt;当 c 是空白时为真（即 c 是空格、横向制表符、纵向制表符、回车符、换行符、进纸符中的一种）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;isupper(c)&lt;/td&gt;
&lt;td&gt;当 c 是大写字母时为真&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;isxdigit(c)&lt;/td&gt;
&lt;td&gt;当 c 是十六进制数字时为真&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;tolower(c)&lt;/td&gt;
&lt;td&gt;输出 c 的小写&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;toupper(c)&lt;/td&gt;
&lt;td&gt;输出 c 的大写&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;C++ 标准库除了定义 C++ 语言特有的功能外，也兼容了 C 语言的标准库。C 语言的头文件形如 name.h，C++ 则将这些文件命名为 cname。因此&lt;code&gt;cctype&lt;/code&gt;头文件和&lt;code&gt;ctype.h&lt;/code&gt; 头文件的内容是一样的，只不过从命名规范上来讲更符合 C++ 语言的要求。特别地，在名为 cname 的头文件中定义的名字从属于命名空间&lt;code&gt;std&lt;/code&gt;。&lt;/p&gt;
&lt;h3&gt;范围 for&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;for (declaration: expression)
        statement
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;expression 是一个对象，用于表示一个序列；declaration 负责定义一个变量，该变量将被用于访问序列中的基础元素，每次迭代，declaration 部分的变量会被初始化为 expression 部分的下一个元素值。&lt;/p&gt;
&lt;p&gt;使用范围for输出&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;string str(&amp;quot;some string&amp;quot;);
        for (auto c : str)
cout &amp;lt;&amp;lt; c &amp;lt;&amp;lt; endl;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;使用范围for修改&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;string s(&amp;quot;Hello World!&amp;quot;);
for (auto &amp;amp;c : s)
        c = toupper(c);
cout &amp;lt;&amp;lt; s &amp;lt;&amp;lt; endl;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;下标运算符 [ ]&lt;/h3&gt;
&lt;p&gt;[ ]接收的输入参数是&lt;code&gt;string:size_type&lt;/code&gt;类型的值，这个参数表示要访问的字符的位置，返回值是该位置上字符的引用。&lt;code&gt;string&lt;/code&gt;对象的下标必须大于等于0而小于&lt;code&gt;s.size()&lt;/code&gt;。&lt;/p&gt;
&lt;h2&gt;标准库类型 vector&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;vector&lt;/code&gt;表示对象的集合，其中所有对象的类型都相同，也常被称作容器，是一种类模板&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;vector&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="n"&gt;using&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;编译器根据模板创建类或函数的过程称为实例化，对于类模板，我们通过提供一些额外信息来指定模板到底实例化成什么样的类：在模板名字后面跟一对尖括号，在括号内放上信息&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;vector&amp;lt;int&amp;gt; ivec;
vector&amp;lt;Sales_item&amp;gt; Sales_vec;
vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; file;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在早期版本的 C++ 标准中如果&lt;code&gt;vector&lt;/code&gt;的元素还是&lt;code&gt;vector&lt;/code&gt;（或者其他模板类型），则其定义的形式与现在的 C++11 新标准略有不同。过去，必须在外层&lt;code&gt;vector&lt;/code&gt;对象的右尖括号和其元素类型之间添加一个空格，如应写成&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;初始化&lt;/h3&gt;
&lt;p&gt;默认初始化。&lt;/p&gt;
&lt;p&gt;列表初始化。&lt;/p&gt;
&lt;p&gt;值初始化：通常情况下，可以只提供vector对象容纳的元素数量而略去初始值。此时库会创建一个值初始化的元素初值，并把它赋给容器中的所有元素。这个初值由vector对象中元素的类型决定。内置类型：0；类类型：由类默认初始化。&lt;/p&gt;
&lt;h3&gt;添加元素&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;push_back&lt;/code&gt;：负责把一个值当成&lt;code&gt;vector&lt;/code&gt;对象的尾元素压到&lt;code&gt;vector&lt;/code&gt;对象的尾端&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;vector&amp;lt;int&amp;gt; v2;
for (int i = 0; i != 100; ++i)
        v2.push_back(i);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果循环内部包含有向&lt;code&gt;vector&lt;/code&gt;对象添加元素的语句，则不能使用范围&lt;code&gt;for&lt;/code&gt;循环。&lt;/p&gt;
&lt;h3&gt;其他vector操作&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;v.empty()&lt;/td&gt;
&lt;td&gt;如果 v 不含有任何元素，返回真；否则返回假&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;v.size()&lt;/td&gt;
&lt;td&gt;返回 v 中元素的个数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;v.push_back(t)&lt;/td&gt;
&lt;td&gt;向 v 的尾端添加一个值为 t 的元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;v[n]&lt;/td&gt;
&lt;td&gt;返回 v 中第 n 个位置上元素的引用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;v1 = v2&lt;/td&gt;
&lt;td&gt;用 v2 中的元素拷贝替换 v1 中的元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td a，b，c...&gt;v1 = &lt;/td&gt;
&lt;td&gt;用列表中元素的拷贝替换 v1 中的元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;v1 == v2&lt;/td&gt;
&lt;td&gt;v1 和 v2 相等当且仅当它们的元素数量相同且对应位置的元素值都相同&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;v1 != v2&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;lt;,&amp;lt;=,&amp;gt;,&amp;gt;=&lt;/td&gt;
&lt;td&gt;以字典顺序进行比较&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;vector 的 size_type&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;vector&amp;lt;int&amp;gt;::size_type      //正确
vector::size_type           //错误
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;和&lt;code&gt;string&lt;/code&gt;一样，&lt;code&gt;vector&lt;/code&gt;对象的下标也是从0开始计算，&lt;code&gt;vector&lt;/code&gt;对象（以及&lt;code&gt;string&lt;/code&gt;对象）的下标运算符可用于访问已存在的元素，而不能用于添加元素。&lt;/p&gt;
&lt;h2&gt;迭代器&lt;/h2&gt;
&lt;p&gt;所有标准库容器都可以使用迭代器，但只有少数的几种才同时支持下标运算符。&lt;/p&gt;
&lt;p&gt;严格来讲，&lt;code&gt;string&lt;/code&gt;不属于容器类型，但是&lt;code&gt;string&lt;/code&gt;支持很多与容器类型相似的操作。&lt;code&gt;vector&lt;/code&gt;支持下标运算符，这点和&lt;code&gt;string&lt;/code&gt;一样。&lt;/p&gt;
&lt;p&gt;和指针不一样，获取迭代器不是使用取地址符，有迭代器的类型同时拥有返回迭代器的成员。&lt;code&gt;begin&lt;/code&gt;和&lt;code&gt;end&lt;/code&gt;：&lt;code&gt;auto b = v.begin(), e = v.end();&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;end&lt;/code&gt;成员负责返回指向容器“尾元素的下一位置”的迭代器。常被称作尾后迭代器或尾迭代器。&lt;/p&gt;
&lt;p&gt;如果容器为空，则&lt;code&gt;begin&lt;/code&gt;和&lt;code&gt;end&lt;/code&gt;返回的是同一个迭代器，都是尾后迭代器。&lt;/p&gt;
&lt;h3&gt;标准容器迭代器的运算符&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;符号&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;*iter&lt;/td&gt;
&lt;td&gt;返回迭代器 iter 所指元素的引用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;iter-&amp;gt;mem&lt;/td&gt;
&lt;td&gt;解引用 iter 并获取该元素的名为 mem 的成员，等价于(*iter).mem&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;++iter&lt;/td&gt;
&lt;td&gt;令 iter 指向容器中的下一个元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;--iter&lt;/td&gt;
&lt;td&gt;令 iter 指向容器中的上一个元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;iter1 == iter2&lt;/td&gt;
&lt;td&gt;判断两个迭代器是否相等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;iter1 != iter2&lt;/td&gt;
&lt;td&gt;如果指向同一元素或者他们是同一容器的尾后迭代器&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;因为&lt;code&gt;end&lt;/code&gt;返回的迭代器并不实际指向某个元素，所以不能对其进行递增或解引用操作。C++ 程序员习惯性地使用&lt;code&gt;!=&lt;/code&gt;，其原因和他们更愿意使用迭代器而非下标的原因一样：这种编程风格在标准库提供的所有容器上都有效，因为所有标准库容器都定义了&lt;code&gt;==&lt;/code&gt;和&lt;code&gt;!=&lt;/code&gt;。&lt;/p&gt;
&lt;h3&gt;迭代器类型&lt;/h3&gt;
&lt;p&gt;拥有迭代器的标准库类型使用&lt;code&gt;iterator&lt;/code&gt;和&lt;code&gt;const_iterator&lt;/code&gt;来表示迭代器的类型&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nd"&gt;iterator&lt;/span&gt; &lt;span class="nt"&gt;it&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;   &lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="nt"&gt;it&lt;/span&gt; &lt;span class="nt"&gt;能读写&lt;/span&gt; &lt;span class="nt"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nt"&gt;的元素&lt;/span&gt;
&lt;span class="nt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nd"&gt;iterator&lt;/span&gt; &lt;span class="nt"&gt;it2&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;       &lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="nt"&gt;it2&lt;/span&gt; &lt;span class="nt"&gt;能读写&lt;/span&gt; &lt;span class="nt"&gt;string&lt;/span&gt; &lt;span class="nt"&gt;对象中的元素&lt;/span&gt;
&lt;span class="nt"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="nt"&gt;const_iterator&lt;/span&gt; &lt;span class="nt"&gt;it3&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;  &lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="nt"&gt;it3&lt;/span&gt; &lt;span class="nt"&gt;只能读元素&lt;/span&gt;&lt;span class="err"&gt;，&lt;/span&gt;&lt;span class="nt"&gt;不能写元素&lt;/span&gt;
&lt;span class="nt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nd"&gt;const_iterator&lt;/span&gt; &lt;span class="nt"&gt;it4&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;     &lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="nt"&gt;it4&lt;/span&gt; &lt;span class="nt"&gt;只能读字符&lt;/span&gt;&lt;span class="err"&gt;，&lt;/span&gt;&lt;span class="nt"&gt;不能写字符&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;begin&lt;/code&gt;和&lt;code&gt;end&lt;/code&gt;返回的具体类型由对象是否是常量决定，如果对象是常量，&lt;code&gt;begin&lt;/code&gt;和&lt;code&gt;end&lt;/code&gt;返回&lt;code&gt;const_iterator&lt;/code&gt;；如果对象不是常量，返回&lt;code&gt;iterator&lt;/code&gt;。如果对象只需读操作而无需写操作的话最好使用常量类型迭代器。为了专门得到&lt;code&gt;const_iterator&lt;/code&gt;，C++11 标准引入两个新函数：&lt;code&gt;cbegin&lt;/code&gt;和&lt;code&gt;cend&lt;/code&gt;。任何一种可能改变容器容量的操作，都会是迭代器失效。&lt;/p&gt;
&lt;h3&gt;迭代器运算&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;string&lt;/code&gt;和&lt;code&gt;vector&lt;/code&gt;的迭代器提供了更多额外的运算符：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;iter + n&lt;/code&gt;：迭代器加上一个整数值仍得到一个迭代器，迭代器指示的新位置与原来相比向前移动了若干个元素。结果迭代器或者指示容器内的一个元素，或者指示容器尾元素的下一位置。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;iter - n&lt;/code&gt;：迭代器减去一个整数值仍得一个迭代器，迭代器指示的新位置与原来相比向后移动了若干位置。结果迭代器或者指示容器内的一个元素，或者指示容器尾元素的下一位置。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;iter1 - iter2&lt;/code&gt;：两个迭代器相减的结果是它们之间的距离，也就是说，将运算符右侧的迭代器向前移动差值个元素后将得到左侧的迭代器。参与运算的两个迭代器必须指向的是同一容器中的元素或者尾元素的下一位置。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;gt;, &amp;gt;=, &amp;lt;, &amp;lt;=&lt;/code&gt;：迭代器的关系运算符，如果迭代器指向的容器位置在另一个迭代器所指位置之前，则说前者小于后者。&lt;/p&gt;
&lt;h2&gt;数组&lt;/h2&gt;
&lt;p&gt;因为数组的大小固定，因此在对某些特殊的应用来说程序的运行时性能较好，但是相应的也损失了一些灵活性。&lt;/p&gt;
&lt;p&gt;数组的维度必须是一个常量表达式。&lt;/p&gt;
&lt;p&gt;默认情况下数组的元素被默认初始化。&lt;/p&gt;
&lt;p&gt;和内置类型的变量一样，如果在函数内部定义了某种内置类型的数组，那么默认初始化会令数组含有未定义的值。&lt;/p&gt;
&lt;p&gt;定义数组的时候必须指定数组的类型，不允许用auto关键字由初始值的列表推断类型。&lt;/p&gt;
&lt;p&gt;字符数组可以利用字符串字面值初始化，此时注意字符串字面值末尾的空字符，也会被拷贝到字符数组中。&lt;/p&gt;
&lt;p&gt;不允许拷贝和赋值。一些编译器支持数组的赋值，这就是所谓的编译器扩展，但一般来说，最好避免使用非标准特性，因为可能在其他编译器上无法正常工作。&lt;/p&gt;
&lt;p&gt;理解复杂的数组声明：由内向外阅读&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int *ptrs[10];   //ptrs 是含有10个整型指针的数组
int (*Parray)[10] = &amp;amp;arr;   //Parray 是指针，指向一个含有10个整数的数组
int (&amp;amp;arrRef)[10] = arr;    //arrRef 是引用，引用一个含有10个整数的数组
int *(&amp;amp;arry)[10] = ptrs;    //arry 是引用，引用一个含有10个整型指针的数组
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;访问数组元素&lt;/h3&gt;
&lt;p&gt;数组的索引从0开始。&lt;/p&gt;
&lt;p&gt;在使用数组下标的时候，通常将其定义为&lt;code&gt;size_t&lt;/code&gt;类型。&lt;code&gt;size_t&lt;/code&gt;是一种机器相关的无符号类型，它被设计的足够大以便能表示内存中任意对象的大小。&lt;/p&gt;
&lt;p&gt;在 cstddef 头文件中定义了&lt;code&gt;size_t&lt;/code&gt;类型，这个文件是 C 标准库 stddef.h 头文件的 C++ 版本。&lt;/p&gt;
&lt;p&gt;使用数组的时候编译器一般会把它转换成指针。&lt;/p&gt;
&lt;p&gt;通常情况下，使用取地址符来获取指向某个对象的指针，取地址符可以用于任何对象。数组的元素也是对象，对数组使用下标运算符得到该数组指定位置的元素，对数组元素应用取地址符就能得到指向该元素的指针。&lt;/p&gt;
&lt;p&gt;数组还有一个特性：在很多时候用到数组名字的地方，编译器都会自动地将其替换为一个指向数组首元素的指针&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;string *p2 = nums;  //等价于 p2 = &amp;amp;nums[0]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;所以如果使用数组作为一个auto变量的初始值时，推断的类型是指针而非数组&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int ia[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9,};
auto ia2(ia);       // ia2 是一个整型指针，指向 ia 的第一个元素
ia2 = 42;       //错误，ia2 是一个指针，不能用 int 赋值
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当使用&lt;code&gt;decltype&lt;/code&gt;关键字时上述转换不会发生，&lt;code&gt;decltype(ia)&lt;/code&gt;返回的类型是由10个整数构成的数组&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;decltype(ia) ia3 = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
ia3 = p;        //错误，不能用整型指针给数组赋值
ia3[4] = i;     //正确：把 i 的值赋给 ia3 的一个元素
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;为了让指针的使用更简单、更安全，C++11 新标准引入两个名为&lt;code&gt;begin&lt;/code&gt;和&lt;code&gt;end&lt;/code&gt;的函数，不过数组毕竟不是类类型，因此这两个函数不是成员函数。正确的使用形式是将数组作为它们的参数&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int ia[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};
int *beg = begin(ia);
int *last = end(ia);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;begin&lt;/code&gt;函数返回指向 ia 首元素的指针，&lt;code&gt;end&lt;/code&gt;函数返回指向 ia 尾元素下一位置的指针，这两个函数定义在 iterator 头文件中&lt;/p&gt;
&lt;p&gt;两个指针相减结果的类型是一种名为&lt;code&gt;ptrdiff_t&lt;/code&gt;的类型，和&lt;code&gt;size_t&lt;/code&gt;一样，它也是定义在 cstddef 头文件中的机器相关的类型。因为差值可能是负值，所以它是一种带符号类型。&lt;/p&gt;
&lt;p&gt;内置的下标运算符所用的索引值不是无符号类型，这一点和&lt;code&gt;vector&lt;/code&gt;和&lt;code&gt;string&lt;/code&gt;不一样&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int *p = &amp;amp;ia[2];
int k = p[-2];      //k 是 ia[0] 那个元素
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;C 风格字符串&lt;/h3&gt;
&lt;p&gt;按此习惯书写的字符串存放在字符数组中并以空字符结束。&lt;/p&gt;
&lt;p&gt;C 语言标准库提供了一组函数用于操作 C 风格字符串，它们定义在 cstring 头文件中，cstring 是 C 语言头文件 string.h 的 C++ 版本。&lt;/p&gt;
&lt;h3&gt;与旧代码的接口&lt;/h3&gt;
&lt;p&gt;任何出现字符串字面值的地方都可以用空字符结尾的字符数组来代替。不能用string对象直接初始化指向字符的指针，为了完成该功能，string专门提供了一个名为c_str的成员函数&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;char *str = s;      //错误，不能用 string 对象初始化 char*
const char *str = s.c_str();    //正确
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们无法保证 c_str 函数返回的数组一直有效，事实上，如果后续的操作改变了 s 的值就可能让之前返回的数组失去效用&lt;/p&gt;
&lt;p&gt;使用数组初始化&lt;code&gt;vector&lt;/code&gt;对象&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int int_arr[] = {0, 1, 2, 3, 4, 5};
vector&amp;lt;int&amp;gt; ivec(begin(int_arr),end(int_arr));
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;现代的 C++ 程序员应当尽量使用&lt;code&gt;vector&lt;/code&gt;和迭代器，避免使用内置的数组和指针，应该尽量使用&lt;code&gt;string&lt;/code&gt;，避免使用 C 风格的基于数组的字符串。&lt;/p&gt;
&lt;p&gt;多维数组：要使用范围 for 语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型。&lt;/p&gt;
&lt;p&gt;缓冲区溢出：主要原因是试图通过一个越界的索引访问容器内容。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;difference_type&lt;/code&gt;：由&lt;code&gt;string&lt;/code&gt;和&lt;code&gt;vector&lt;/code&gt;定义的一种带符号整数类型，表示两个迭代器之间的距离。&lt;/p&gt;</content><category term="C++"></category></entry><entry><title>C++ Primer 第二章 变量和基本类型</title><link href="https://xutree.github.io/pages/2018/10/06/C++_Primer_Chapter_2/" rel="alternate"></link><published>2018-10-06T22:02:54+08:00</published><updated>2018-10-07T10:48:38+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-06:/pages/2018/10/06/C++_Primer_Chapter_2/</id><summary type="html">&lt;h2&gt;类型&lt;/h2&gt;
&lt;p&gt;下表列出了 C++ 标准规定的数据类型尺寸的最小值，同时允许编译器赋予这些类型更大的尺寸&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;th&gt;最小尺寸&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;bool&lt;/td&gt;
&lt;td&gt;布尔类型&lt;/td&gt;
&lt;td&gt;未定义&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;char&lt;/td&gt;
&lt;td&gt;字符&lt;/td&gt;
&lt;td&gt;8位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;wchar_t&lt;/td&gt;
&lt;td&gt;宽字符&lt;/td&gt;
&lt;td&gt;16位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;char16_t&lt;/td&gt;
&lt;td&gt;Unicode 字符&lt;/td&gt;
&lt;td&gt;16位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;char32_t&lt;/td&gt;
&lt;td&gt;Unicode 字符&lt;/td&gt;
&lt;td&gt;32位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;short&lt;/td&gt;
&lt;td&gt;短整型&lt;/td&gt;
&lt;td&gt;16位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;整型&lt;/td&gt;
&lt;td&gt;16位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;long&lt;/td&gt;
&lt;td&gt;长整型&lt;/td&gt;
&lt;td&gt;32位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;long long&lt;/td&gt;
&lt;td&gt;长整型&lt;/td&gt;
&lt;td&gt;64位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;float&lt;/td&gt;
&lt;td&gt;单精度浮点数&lt;/td&gt;
&lt;td&gt;6位有效数字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;double&lt;/td&gt;
&lt;td&gt;双精度浮点数&lt;/td&gt;
&lt;td&gt;10位有效数字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;long double&lt;/td&gt;
&lt;td&gt;扩展精度浮点数&lt;/td&gt;
&lt;td&gt;10位有效数字&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;一个&lt;code&gt;char …&lt;/code&gt;&lt;/p&gt;</summary><content type="html">&lt;h2&gt;类型&lt;/h2&gt;
&lt;p&gt;下表列出了 C++ 标准规定的数据类型尺寸的最小值，同时允许编译器赋予这些类型更大的尺寸&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;th&gt;最小尺寸&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;bool&lt;/td&gt;
&lt;td&gt;布尔类型&lt;/td&gt;
&lt;td&gt;未定义&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;char&lt;/td&gt;
&lt;td&gt;字符&lt;/td&gt;
&lt;td&gt;8位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;wchar_t&lt;/td&gt;
&lt;td&gt;宽字符&lt;/td&gt;
&lt;td&gt;16位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;char16_t&lt;/td&gt;
&lt;td&gt;Unicode 字符&lt;/td&gt;
&lt;td&gt;16位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;char32_t&lt;/td&gt;
&lt;td&gt;Unicode 字符&lt;/td&gt;
&lt;td&gt;32位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;short&lt;/td&gt;
&lt;td&gt;短整型&lt;/td&gt;
&lt;td&gt;16位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;整型&lt;/td&gt;
&lt;td&gt;16位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;long&lt;/td&gt;
&lt;td&gt;长整型&lt;/td&gt;
&lt;td&gt;32位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;long long&lt;/td&gt;
&lt;td&gt;长整型&lt;/td&gt;
&lt;td&gt;64位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;float&lt;/td&gt;
&lt;td&gt;单精度浮点数&lt;/td&gt;
&lt;td&gt;6位有效数字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;double&lt;/td&gt;
&lt;td&gt;双精度浮点数&lt;/td&gt;
&lt;td&gt;10位有效数字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;long double&lt;/td&gt;
&lt;td&gt;扩展精度浮点数&lt;/td&gt;
&lt;td&gt;10位有效数字&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;一个&lt;code&gt;char&lt;/code&gt;的空间应确保可以存放机器基本字符集中任意字符对应的数字值。也就是说，一个&lt;code&gt;char&lt;/code&gt;的大小和一个机器字节一样。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;wchar_t&lt;/code&gt;类型用于确保可以存放机器最大扩展字符集中的任意一个字符。&lt;/p&gt;
&lt;p&gt;C++ 语言规定，一个&lt;code&gt;int&lt;/code&gt;至少和一个&lt;code&gt;short&lt;/code&gt;一样大，一个&lt;code&gt;long&lt;/code&gt;至少和一个&lt;code&gt;int&lt;/code&gt;一样大，一个&lt;code&gt;long long&lt;/code&gt;至少和一个&lt;code&gt;long&lt;/code&gt;一样大。&lt;/p&gt;
&lt;p&gt;可寻址的最小内存块成称为“字节（byte）”，存储的基本单元称为“字（word）”，它通常有几个字节组成。&lt;/p&gt;
&lt;p&gt;在 C++ 语言中，一个字节至少能容纳机器基本字符串中的字符。大多数机器的字节由8比特构成，字则由32或64比特构成，也就是4字节或8字节。&lt;/p&gt;
&lt;p&gt;C++ 标准指定了一个浮点数有效位数的最小值，然而大多数编译器都实现了更高的精度。通常，&lt;code&gt;float&lt;/code&gt;以1个字（32比特）来表示，&lt;code&gt;double&lt;/code&gt;以2个字（64位）来表示，&lt;code&gt;long double&lt;/code&gt;以3或4个字（96或128比特）来表示。一般来说，&lt;code&gt;float&lt;/code&gt;和&lt;code&gt;double&lt;/code&gt;分别有7和16个有效位；类型&lt;code&gt;long double&lt;/code&gt;则常常被用于有特殊浮点要求的硬件，它的具体实现不同，精度也各不相同。&lt;/p&gt;
&lt;p&gt;类型&lt;code&gt;int&lt;/code&gt;、&lt;code&gt;short&lt;/code&gt;、&lt;code&gt;long&lt;/code&gt;和&lt;code&gt;long long&lt;/code&gt;都是带符号的，通过在这些类型名前添加&lt;code&gt;unsigned&lt;/code&gt;就可以得到无符号类型。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;char&lt;/code&gt;、&lt;code&gt;signed char&lt;/code&gt;和&lt;code&gt;unsigned char&lt;/code&gt;，&lt;code&gt;char&lt;/code&gt;是否等于&lt;code&gt;signed char&lt;/code&gt;由编译器决定。&lt;/p&gt;
&lt;p&gt;C++ 标准并没有规定带符号类型应如何表示，但是约定了在表示范围内正值和负值的量应该平衡。因此，8比特的&lt;code&gt;signed char&lt;/code&gt;理论上可以表示-127至127区间内的值，大多数现代计算机将实际的表示范围定为-128至127。&lt;/p&gt;
&lt;h2&gt;如何选择类型&lt;/h2&gt;
&lt;p&gt;明知数值不可能为负数，选用无符号类型。&lt;/p&gt;
&lt;p&gt;如果数值超过了&lt;code&gt;int&lt;/code&gt;的表示范围，选用&lt;code&gt;long long&lt;/code&gt;，因为&lt;code&gt;long&lt;/code&gt;一般和&lt;code&gt;int&lt;/code&gt;有一样的尺寸。&lt;/p&gt;
&lt;p&gt;算术表达式中不要使用&lt;code&gt;bool&lt;/code&gt;或&lt;code&gt;char&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;执行浮点数运算选用&lt;code&gt;double&lt;/code&gt;。因为&lt;code&gt;float&lt;/code&gt;通常精度不够而且计算代价相差无几。&lt;code&gt;long double&lt;/code&gt;提供的精度一般情况下是没有必要的而且计算代价大。&lt;/p&gt;
&lt;h2&gt;类型转换&lt;/h2&gt;
&lt;p&gt;非布尔 -&amp;gt; 布尔：0 -&amp;gt; &lt;code&gt;false&lt;/code&gt;，其他 -&amp;gt; &lt;code&gt;ture&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;布尔 -&amp;gt; 非布尔：&lt;code&gt;false&lt;/code&gt;-&amp;gt; 0，&lt;code&gt;ture&lt;/code&gt; -&amp;gt; 1。&lt;/p&gt;
&lt;p&gt;浮点 -&amp;gt; 整型：仅保留小数点前。&lt;/p&gt;
&lt;p&gt;整型 -&amp;gt; 浮点：小数部分记为0，如果该整数所占的空间超过浮点类型的容量，精度可能损失。&lt;/p&gt;
&lt;p&gt;当我们赋给无符号类型一个超过它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。&lt;/p&gt;
&lt;p&gt;当我们赋给带符号类型一个超出它表示范围的值时，结果是未定义的。此时，程序可能继续工作、可能崩溃，也可能生成垃圾数据。&lt;/p&gt;
&lt;p&gt;当一个算术表达式中既有无符号数又有&lt;code&gt;int&lt;/code&gt;值时，那个&lt;code&gt;int&lt;/code&gt;会转换成无符号数。把&lt;code&gt;int&lt;/code&gt;转换成无符号数的过程和把&lt;code&gt;int&lt;/code&gt;赋值给无符号变量一样。&lt;/p&gt;
&lt;p&gt;当从一个无符号数中减去一个值时，我们必须确保结果不是负值，否则实际结果会是取模后的值。&lt;/p&gt;
&lt;h2&gt;字面值常量&lt;/h2&gt;
&lt;p&gt;整型和浮点型字面值。&lt;/p&gt;
&lt;p&gt;字符和字符串字面值：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;‘a’ 和“a”，字符串字面值最后补’\0’&lt;/li&gt;
&lt;li&gt;如果两个字符串字面值位置紧邻且仅由空格、缩进和换行分隔，则它们是一个整体&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;布尔字面值：&lt;code&gt;true&lt;/code&gt;、&lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;指针字面值：&lt;code&gt;nullptr&lt;/code&gt;。&lt;/p&gt;
&lt;h2&gt;指定字面值的类型&lt;/h2&gt;
&lt;p&gt;字符和字符串字面值&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;前缀&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;u&lt;/td&gt;
&lt;td&gt;char16_t&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;U&lt;/td&gt;
&lt;td&gt;char32_t&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;L&lt;/td&gt;
&lt;td&gt;wchar_t&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;u8&lt;/td&gt;
&lt;td&gt;char&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;整型字面值&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;后缀&lt;/th&gt;
&lt;th&gt;最小匹配类型&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;u 或 U&lt;/td&gt;
&lt;td&gt;unsigned&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;l 或 L&lt;/td&gt;
&lt;td&gt;long&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ll 或 LL&lt;/td&gt;
&lt;td&gt;long long&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;浮点型字面值&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;后缀&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;f 或 F&lt;/td&gt;
&lt;td&gt;float&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;l 或 L&lt;/td&gt;
&lt;td&gt;long double&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;列表初始化&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;int units_sold{0}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;列表初始化的重要特点：如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将报错。&lt;/p&gt;
&lt;h2&gt;默认初始化&lt;/h2&gt;
&lt;p&gt;内置类型变量&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定义于任何函数之外，初始化为0&lt;/li&gt;
&lt;li&gt;定义于函数体内的局部静态变量，初始化为0&lt;/li&gt;
&lt;li&gt;定义于函数体内的非局部静态变量，不被初始化，试图拷贝或以其他方式访问此类值将引发错误&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每个类各自决定其初始化对象的方式。&lt;/p&gt;
&lt;h2&gt;分离式编译&lt;/h2&gt;
&lt;p&gt;将程序分割为若干个文件，每个文件可被独立编译&lt;/p&gt;
&lt;h2&gt;声明&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;extern int i;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;extern&lt;/code&gt;语句如果包含初始值就不再是声明，而变成定义了：&lt;code&gt;extern int i = 0;&lt;/code&gt;在函数体内部，试图初始化一个由&lt;code&gt;extern&lt;/code&gt;关键字标记的变量将引发错误。&lt;/p&gt;
&lt;p&gt;静态类型语言：在编译阶段执行类型检查&lt;/p&gt;
&lt;h2&gt;C++ 标识符&lt;/h2&gt;
&lt;p&gt;字母、数字、下划线，必须以字母或下划线开头，长度无限制，大小写敏感。&lt;/p&gt;
&lt;p&gt;C++ 为标准库保留了一些名字&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自定义标识符中不能连续出现两个下划线&lt;/li&gt;
&lt;li&gt;不能以下划线紧接大写字母开头&lt;/li&gt;
&lt;li&gt;定义在函数体外的函数不能以下划线开头&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;作用域操作符 ::&lt;/h2&gt;
&lt;p&gt;若左侧为空，则指代全局作用域&lt;/p&gt;
&lt;h2&gt;复合类型&lt;/h2&gt;
&lt;h3&gt;引用&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;int &amp;amp;b = a;&lt;/code&gt;b指向a。&lt;/p&gt;
&lt;p&gt;引用必须初始化。&lt;/p&gt;
&lt;p&gt;引用本身不是一个对象，不能定义引用的引用。&lt;/p&gt;
&lt;p&gt;引用必须绑定到对象上，不能绑定到字面值或者某个表达式的计算结果上。&lt;/p&gt;
&lt;p&gt;除了两种例外，所有引用的类型都要和它所绑定的对象严格匹配：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可&lt;/li&gt;
&lt;li&gt;允许将基类的引用绑定到派生类上&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;指针&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;int *b = &amp;amp;a;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;指针是一个对象。&lt;/p&gt;
&lt;p&gt;在块作用域内定义的指针如果未初始化，将拥有一个不确定的值。&lt;/p&gt;
&lt;p&gt;除了两种例外，所有指针的类型都要和它所指向的对象严格匹配：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;允许一个指向常量的指针指向一个非常量对象&lt;/li&gt;
&lt;li&gt;允许将基类的指针绑定到派生类上&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;试图拷贝或以其他方式访问无效指针的值将引起错误，编译器不负责检查此类错误。&lt;/p&gt;
&lt;p&gt;任何非零的指针对应的条件值都是true。&lt;/p&gt;
&lt;p&gt;合法指针可以比较大小：== 或 !=。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;void *&lt;/code&gt;是一个特殊的指针类型，可用于存放任意对象的地址，只支持有限的操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;拿它和别的指针比较&lt;/li&gt;
&lt;li&gt;作为函数的输入或输出&lt;/li&gt;
&lt;li&gt;赋给另外一个&lt;code&gt;void *&lt;/code&gt;指针&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;理解复合类型的声明&lt;/h2&gt;
&lt;p&gt;变量的定义包括一个基本数据类型和一组声明符。&lt;/p&gt;
&lt;p&gt;一条定义语句可能定义出不同类型的变量：&lt;code&gt;int i = 1024, *p = &amp;amp;i, &amp;amp;r =i;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;面对一条比较复杂的指针或者引用的声明语句时，从右往左阅读有助于弄清楚它的真实含义，例如：&lt;code&gt;int \*&amp;amp;r;&lt;/code&gt;首先 r 是一个引用，其次 r 是一个指针的引用，再次 r 是一个指向整型指针的引用。&lt;/p&gt;
&lt;h2&gt;const 限定符&lt;/h2&gt;
&lt;p&gt;因为&lt;code&gt;const&lt;/code&gt;对象一旦创建就无法改变其值，所以必须初始化。&lt;/p&gt;
&lt;p&gt;当用一个对象去初始化另外一个对象，它们是不是&lt;code&gt;const&lt;/code&gt;都无关紧要，常量的特性仅仅在执行改变其值的操作时才会发挥作用。&lt;/p&gt;
&lt;p&gt;默认情况下，&lt;code&gt;const&lt;/code&gt;对象仅在文件内有效。&lt;/p&gt;
&lt;p&gt;如果想在多个文件之间共享&lt;code&gt;const&lt;/code&gt;对象，必须在变量的定义之前添加&lt;code&gt;extern&lt;/code&gt;关键字。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;const&lt;/code&gt;的引用，常量引用的初始化：初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。尤其，允许为一个常量引用绑定非常量的对象、字面值甚至是一个表达式。实际上是通过绑定到一个临时量对象上实现的。&lt;/p&gt;
&lt;p&gt;对&lt;code&gt;const&lt;/code&gt;的引用可能引用一个并非&lt;code&gt;const&lt;/code&gt;的对象，常量引用仅对引用可参与的操作做了限制，对于引用的对象本身是不是常量未做限制。&lt;/p&gt;
&lt;h2&gt;指针和 const&lt;/h2&gt;
&lt;h3&gt;指向常量的指针&lt;/h3&gt;
&lt;p&gt;允许一个指向常量的指针指向一个非常量对象。&lt;/p&gt;
&lt;p&gt;仅对指向常量的指针可参与的操作做了限制，对于指向的对象本身是不是常量未做限制。&lt;/p&gt;
&lt;h3&gt;const 指针&lt;/h3&gt;
&lt;p&gt;指针是对象，可以把指针本身定为常量。&lt;/p&gt;
&lt;p&gt;常量指针必须初始化，一经初始化就不能再改变。&lt;/p&gt;
&lt;p&gt;把*放在&lt;code&gt;const&lt;/code&gt;关键字之前说明指针是一个常量。&lt;/p&gt;
&lt;h3&gt;顶层和底层 const&lt;/h3&gt;
&lt;p&gt;顶层&lt;code&gt;const&lt;/code&gt;：指针本身是个常量。&lt;/p&gt;
&lt;p&gt;底层&lt;code&gt;const&lt;/code&gt;：指针所值的对象是一个常量。&lt;/p&gt;
&lt;p&gt;更一般的，顶层&lt;code&gt;const&lt;/code&gt;可以表示任意的对象是常量，这一点对任意数据类型都适用。底层&lt;code&gt;const&lt;/code&gt;则与指针和引用等复合类型的基本类型部分有关。&lt;/p&gt;
&lt;p&gt;执行对象的拷贝操作时，顶层&lt;code&gt;const&lt;/code&gt;不受影响；拷入和拷出的对象必须具有相同的底层&lt;code&gt;const&lt;/code&gt;资格，或者两个对象的数据类型必须能够转换。一般来说，非常量可以转换成常量，反之不行。&lt;/p&gt;
&lt;h3&gt;constexpr 和常量表达式&lt;/h3&gt;
&lt;p&gt;常量表达式：值不会改变并且在编译过程就能得到计算结果的表达式。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;constexpr&lt;/code&gt;变量：由编译器来验证变量的值是否是一个常量表达式，声明为&lt;code&gt;constexpr&lt;/code&gt;的变量一定是一个常量，并且必须用常量表达式初始化。&lt;/p&gt;
&lt;p&gt;字面值类型：算术类型、引用、指针、字面值常量类、枚举。&lt;/p&gt;
&lt;p&gt;声明&lt;code&gt;constexpr&lt;/code&gt;用到的类型为字面值类型。&lt;/p&gt;
&lt;p&gt;一个&lt;code&gt;constexpr&lt;/code&gt;指针的初始值必须是&lt;code&gt;nullptr&lt;/code&gt;或者0，或者是存储于某个固定地址中的对象：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函数体内定义的变量一般并非存放在固定地址中，&lt;code&gt;constexpr&lt;/code&gt;指针不能指向这样的变量（局部静态对象除外）&lt;/li&gt;
&lt;li&gt;定义于所有函数体之外的对象地址固定不变，能用来初始化&lt;code&gt;constexpr&lt;/code&gt;指针&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在&lt;code&gt;constexpr&lt;/code&gt;声明中如果定义了一个指针，限定符&lt;code&gt;constexpr&lt;/code&gt;仅对指针有效，与指针所指的对象无关。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;constexpr&lt;/code&gt;把它所定义的对象置为顶层&lt;code&gt;const&lt;/code&gt;。&lt;/p&gt;
&lt;h2&gt;处理类型&lt;/h2&gt;
&lt;h3&gt;类型别名&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;typedef double wages;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;using SI = Sales_item;&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;auto 类型说明符&lt;/h3&gt;
&lt;p&gt;让编译器自己去分析表达式所属的类型。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;auto&lt;/code&gt;也能在一条语句中声明多个变量。因为一条声明语句只能有一个基本数据类型，所以该语句中所有变量的基本数据类型都必须一样。&lt;/p&gt;
&lt;p&gt;当引用被用作初始化&lt;code&gt;auto&lt;/code&gt;变量时，编译器以引用所引用对象的类型作为&lt;code&gt;auto&lt;/code&gt;的类型。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;auto&lt;/code&gt;一般会忽略顶层&lt;code&gt;const&lt;/code&gt;，同时底层&lt;code&gt;const&lt;/code&gt;会保留下来。&lt;/p&gt;
&lt;p&gt;如果希望推断出的&lt;code&gt;auto&lt;/code&gt;类型是一个顶层&lt;code&gt;const&lt;/code&gt;，需要明确指出。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;auto&lt;/code&gt;引用&lt;code&gt;auto &amp;amp;b = a;&lt;/code&gt;初始值 a 的顶层&lt;code&gt;const&lt;/code&gt;会保留。&lt;/p&gt;
&lt;h3&gt;decltype 类型指示符&lt;/h3&gt;
&lt;p&gt;选择并返回操作数的数据类型，编译器分析表达式得到它的类型，却不实际计算表达式的值，编译器并不实际调用f。&lt;/p&gt;
&lt;p&gt;如果&lt;code&gt;decltype&lt;/code&gt;使用的表达式是一个变量，则&lt;code&gt;decltype&lt;/code&gt;返回该变量的类型（包括顶层&lt;code&gt;const&lt;/code&gt;和引用在内），需要指出的是，引用从来都作为其所指对象的同义词出现，只有在&lt;code&gt;decltype&lt;/code&gt;处是一个例外。&lt;/p&gt;
&lt;p&gt;如果&lt;code&gt;decltype&lt;/code&gt;使用的表达式不是一个变量，则&lt;code&gt;decltype&lt;/code&gt;返回该表达式的结果对应的类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因为 r 是一个引用，&lt;code&gt;decltype(r)&lt;/code&gt;的结果是引用类型，如果想让结果类型是 r 所指的类型，可以把 r 作为表达式的一部分，显然这个表达式的结果是一个具体的值而非一个引用&lt;/li&gt;
&lt;li&gt;如果表达式的内容是解引用操作，则&lt;code&gt;decltype&lt;/code&gt;将得到引用类型&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果&lt;code&gt;decltype&lt;/code&gt;使用的表达式是一个变量：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不加括号，得到该变量的类型&lt;/li&gt;
&lt;li&gt;加括号，得到引用类型&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;自定义数据结构：结构体和类&lt;/h2&gt;
&lt;p&gt;记得定义末尾的分号。可以类内初始化。&lt;/p&gt;
&lt;h2&gt;头文件保护符&lt;/h2&gt;
&lt;p&gt;头文件保护符依赖于预处理变量。&lt;/p&gt;
&lt;p&gt;预处理变量由两个状态：已定义和未定义。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;#define&lt;/code&gt;指令把一个名字设定为预处理变量。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;#ifdef&lt;/code&gt;当且仅当变量已定义时为真。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;#ifndef&lt;/code&gt;当且仅当变量未定义时为真。&lt;/p&gt;
&lt;p&gt;一旦检查结果为真，则执行后续操作直到遇到&lt;code&gt;#endif&lt;/code&gt;指令为止&lt;/p&gt;</content><category term="C++"></category></entry><entry><title>C++ Primer 第一章 开始</title><link href="https://xutree.github.io/pages/2018/10/05/C++_Primer_Chapter_1/" rel="alternate"></link><published>2018-10-05T23:11:35+08:00</published><updated>2018-10-07T10:48:26+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-05:/pages/2018/10/05/C++_Primer_Chapter_1/</id><summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;code&gt;g++ -std=c++14  -Wall -o test test.cpp&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iostream&lt;/code&gt; &lt;code&gt;cin&lt;/code&gt; &lt;code&gt;cout&lt;/code&gt; &lt;code&gt;cerr&lt;/code&gt; &lt;code&gt;clog&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;运算符返回其左侧的运算对象&lt;/li&gt;
&lt;li&gt;写入&lt;code&gt;endl&lt;/code&gt;的效果是结束当前行，并将与设备关联的缓冲区中的内容刷到设备中。缓冲刷新操作可以保证到目前为止程序所产生的所有输出都真正写入到输出流中，而不是仅停留在内存中等待写入流&lt;/li&gt;
&lt;li&gt;小心程序崩溃，输出可能还留在缓冲区的情况，利用&lt;code&gt;endl&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;标准库定义的所有名字都在命名空间&lt;code&gt;std&lt;/code&gt;中&lt;/li&gt;
&lt;li&gt;当我们使用一个&lt;code&gt;istream&lt;/code&gt;对象作为条件时，其效果是检测流的状态。流有效，即流未遇到错误，那么检测成功。当遇到文件结束符（end of file），或遇到一个无效输入时，&lt;code&gt;istream&lt;/code&gt;对象的状态会变为无效。无效的&lt;code&gt;istream&lt;/code&gt;对象会使条件为假&lt;/li&gt;
&lt;li&gt;文件结束符：Windows 先Ctrl + Z，后Enter …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;ul&gt;
&lt;li&gt;&lt;code&gt;g++ -std=c++14  -Wall -o test test.cpp&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iostream&lt;/code&gt; &lt;code&gt;cin&lt;/code&gt; &lt;code&gt;cout&lt;/code&gt; &lt;code&gt;cerr&lt;/code&gt; &lt;code&gt;clog&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;运算符返回其左侧的运算对象&lt;/li&gt;
&lt;li&gt;写入&lt;code&gt;endl&lt;/code&gt;的效果是结束当前行，并将与设备关联的缓冲区中的内容刷到设备中。缓冲刷新操作可以保证到目前为止程序所产生的所有输出都真正写入到输出流中，而不是仅停留在内存中等待写入流&lt;/li&gt;
&lt;li&gt;小心程序崩溃，输出可能还留在缓冲区的情况，利用&lt;code&gt;endl&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;标准库定义的所有名字都在命名空间&lt;code&gt;std&lt;/code&gt;中&lt;/li&gt;
&lt;li&gt;当我们使用一个&lt;code&gt;istream&lt;/code&gt;对象作为条件时，其效果是检测流的状态。流有效，即流未遇到错误，那么检测成功。当遇到文件结束符（end of file），或遇到一个无效输入时，&lt;code&gt;istream&lt;/code&gt;对象的状态会变为无效。无效的&lt;code&gt;istream&lt;/code&gt;对象会使条件为假&lt;/li&gt;
&lt;li&gt;文件结束符：Windows 先Ctrl + Z，后Enter 或 Return；UNIX：Ctrl +D&lt;/li&gt;
&lt;li&gt;标准库文件通常不带后缀。编译器一般不关心头文件名的形式，但有的IDE对此有特定要求&lt;/li&gt;
&lt;li&gt;头文件包含：标准库头文件 &amp;lt;&amp;gt;     非标准库头文件 ""&lt;/li&gt;
&lt;li&gt;文件重定向：从文件读入\&amp;lt;infile，输出到文件&gt;outfile&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cerr&lt;/code&gt;(无缓冲标准错误) 没有缓冲，发送给它的内容立即被输出&lt;/li&gt;
&lt;li&gt;&lt;code&gt;clog&lt;/code&gt;(缓冲标准错误)  有缓冲，缓冲区满时输出&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cout&lt;/code&gt;标准输出&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cout&lt;/code&gt;是在终端显示器输出，&lt;code&gt;cout&lt;/code&gt;流在内存中对应开辟了一个缓冲区，用来存放流中的数据，当向&lt;code&gt;cout&lt;/code&gt;流插入一个&lt;code&gt;endl&lt;/code&gt;，不论缓冲区是否满了，都立即输出流中所有数据，然后插入一个换行符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cerr&lt;/code&gt;流对象是标准错误流，指定为和显示器关联，和&lt;code&gt;cout&lt;/code&gt;作用差不多，有点不同就是&lt;code&gt;cout&lt;/code&gt;通常是传到显示器输出，但可以被重定向输出到文件，而&lt;code&gt;cerr&lt;/code&gt;流中的信息只能在显示器输出&lt;/li&gt;
&lt;li&gt;&lt;code&gt;clog&lt;/code&gt;流也是标准错误流，作用和&lt;code&gt;cerr&lt;/code&gt;一样，区别在于&lt;code&gt;cerr&lt;/code&gt;不经过缓冲区，直接向显示器输出信息，而&lt;code&gt;clog&lt;/code&gt;中的信息存放在缓冲区，缓冲区满或者遇到&lt;code&gt;endl&lt;/code&gt;时才输出&lt;/li&gt;
&lt;li&gt;对于为什么有&lt;code&gt;cerr&lt;/code&gt;和&lt;code&gt;clog&lt;/code&gt;？比如，你的程序遇到调用栈用完了的威胁（无限，没有出口的递归。你说，你到什么地方借内存，存放你的错误信息？所以有了&lt;code&gt;cerr&lt;/code&gt;。其目的，就是在你最需要它的紧急情况下，还能得到输出功能的支持&lt;/li&gt;
&lt;li&gt;缓冲区的目的，就是减少刷屏的次数——比如，你的程序输出圣经中的一篇文章。不带缓冲的话，就会每写一个字母，就输出一个字母，然后刷屏。有了缓冲，你将看到若干句子“同时”就出现在了屏幕上（由内存翻新到显存，然后刷新屏幕）&lt;/li&gt;
&lt;/ul&gt;</content><category term="C++"></category></entry></feed>