<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>You Know Nothing - 读书笔记</title><link href="https://xutree.github.io/" rel="alternate"></link><link href="https://xutree.github.io/feeds/du-shu-bi-ji.atom.xml" rel="self"></link><id>https://xutree.github.io/</id><updated>2018-10-06T22:25:35+08:00</updated><entry><title>【读书笔记】C++ Primer 第二章</title><link href="https://xutree.github.io/pages/2018/10/06/C++_Primer_Chapter_2/" rel="alternate"></link><published>2018-10-06T22:02:54+08:00</published><updated>2018-10-06T22:25:35+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-06:/pages/2018/10/06/C++_Primer_Chapter_2/</id><summary type="html">&lt;ul&gt;
&lt;li&gt;下表列出了 C++ 标准规定的数据类型尺寸的最小值，同时允许编译器赋予这些类型更大的尺寸&lt;ul&gt;
&lt;li&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;th&gt;最小尺寸&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;bool&lt;/td&gt;
&lt;td&gt;布尔类型&lt;/td&gt;
&lt;td&gt;未定义&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;char&lt;/td&gt;
&lt;td&gt;字符&lt;/td&gt;
&lt;td&gt;8位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;wchar_t&lt;/td&gt;
&lt;td&gt;宽字符&lt;/td&gt;
&lt;td&gt;16位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;char16_t&lt;/td&gt;
&lt;td&gt;Unicode 字符&lt;/td&gt;
&lt;td&gt;16位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;char32_t&lt;/td&gt;
&lt;td&gt;Unicode 字符&lt;/td&gt;
&lt;td&gt;32位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;short&lt;/td&gt;
&lt;td&gt;短整型&lt;/td&gt;
&lt;td&gt;16位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;整型&lt;/td&gt;
&lt;td&gt;16位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;long&lt;/td&gt;
&lt;td&gt;长整型&lt;/td&gt;
&lt;td&gt;32位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;long long&lt;/td&gt;
&lt;td&gt;长整型&lt;/td&gt;
&lt;td&gt;64位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;float&lt;/td&gt;
&lt;td&gt;单精度浮点数&lt;/td&gt;
&lt;td&gt;6位有效数字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;double&lt;/td&gt;
&lt;td&gt;双精度浮点数&lt;/td&gt;
&lt;td&gt;10位有效数字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;long double&lt;/td&gt;
&lt;td&gt;扩展精度浮点数&lt;/td&gt;
&lt;td&gt;10位有效数字&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;一个&lt;code&gt;char&lt;/code&gt;的空间应确保可以存放机器基本字符集中任意字符对应的数字值 …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;ul&gt;
&lt;li&gt;下表列出了 C++ 标准规定的数据类型尺寸的最小值，同时允许编译器赋予这些类型更大的尺寸&lt;ul&gt;
&lt;li&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;th&gt;最小尺寸&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;bool&lt;/td&gt;
&lt;td&gt;布尔类型&lt;/td&gt;
&lt;td&gt;未定义&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;char&lt;/td&gt;
&lt;td&gt;字符&lt;/td&gt;
&lt;td&gt;8位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;wchar_t&lt;/td&gt;
&lt;td&gt;宽字符&lt;/td&gt;
&lt;td&gt;16位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;char16_t&lt;/td&gt;
&lt;td&gt;Unicode 字符&lt;/td&gt;
&lt;td&gt;16位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;char32_t&lt;/td&gt;
&lt;td&gt;Unicode 字符&lt;/td&gt;
&lt;td&gt;32位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;short&lt;/td&gt;
&lt;td&gt;短整型&lt;/td&gt;
&lt;td&gt;16位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;整型&lt;/td&gt;
&lt;td&gt;16位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;long&lt;/td&gt;
&lt;td&gt;长整型&lt;/td&gt;
&lt;td&gt;32位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;long long&lt;/td&gt;
&lt;td&gt;长整型&lt;/td&gt;
&lt;td&gt;64位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;float&lt;/td&gt;
&lt;td&gt;单精度浮点数&lt;/td&gt;
&lt;td&gt;6位有效数字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;double&lt;/td&gt;
&lt;td&gt;双精度浮点数&lt;/td&gt;
&lt;td&gt;10位有效数字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;long double&lt;/td&gt;
&lt;td&gt;扩展精度浮点数&lt;/td&gt;
&lt;td&gt;10位有效数字&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;一个&lt;code&gt;char&lt;/code&gt;的空间应确保可以存放机器基本字符集中任意字符对应的数字值。也就是说，一个&lt;code&gt;char&lt;/code&gt;的大小和一个机器字节一样&lt;/li&gt;
&lt;li&gt;&lt;code&gt;wchar_t&lt;/code&gt;类型用于确保可以存放机器最大扩展字符集中的任意一个字符&lt;/li&gt;
&lt;li&gt;C++ 语言规定，一个&lt;code&gt;int&lt;/code&gt;至少和一个&lt;code&gt;short&lt;/code&gt;一样大，一个&lt;code&gt;long&lt;/code&gt;至少和一个&lt;code&gt;int&lt;/code&gt;一样大，一个&lt;code&gt;long long&lt;/code&gt;至少和一个&lt;code&gt;long&lt;/code&gt;一样大&lt;/li&gt;
&lt;li&gt;可寻址的最小内存块成称为“字节（byte）”，存储的基本单元称为“字（word）”，它通常有几个字节组成&lt;/li&gt;
&lt;li&gt;在 C++ 语言中，一个字节至少能容纳机器基本字符串中的字符&lt;/li&gt;
&lt;li&gt;大多数机器的字节由8比特构成，字则由32或64比特构成，也就是4字节或8字节&lt;/li&gt;
&lt;li&gt;C++ 标准指定了一个浮点数有效位数的最小值，然而大多数编译器都实现了更高的精度。通常，&lt;code&gt;float&lt;/code&gt;以1个字（32比特）来表示，&lt;code&gt;double&lt;/code&gt;以2个字（64位）来表示，&lt;code&gt;long double&lt;/code&gt;以3或4个字（96或128比特）来表示&lt;/li&gt;
&lt;li&gt;一般来说，&lt;code&gt;float&lt;/code&gt;和&lt;code&gt;double&lt;/code&gt;分别有7和16个有效位；类型&lt;code&gt;long double&lt;/code&gt;则常常被用于有特殊浮点要求的硬件，它的具体实现不同，精度也各不相同&lt;/li&gt;
&lt;li&gt;类型&lt;code&gt;int&lt;/code&gt;、&lt;code&gt;short&lt;/code&gt;、&lt;code&gt;long&lt;/code&gt;和&lt;code&gt;long long&lt;/code&gt;都是带符号的，通过在这些类型名前添加&lt;code&gt;unsigned&lt;/code&gt;就可以得到无符号类型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;char&lt;/code&gt;、&lt;code&gt;signed char&lt;/code&gt;和&lt;code&gt;unsigned char&lt;/code&gt;，&lt;code&gt;char&lt;/code&gt;是否等于&lt;code&gt;signed char&lt;/code&gt;由编译器决定&lt;/li&gt;
&lt;li&gt;C++ 标准并没有规定带符号类型应如何表示，但是约定了在表示范围内正值和负值的量应该平衡。因此，8比特的&lt;code&gt;signed char&lt;/code&gt;理论上可以表示-127至127区间内的值，大多数现代计算机将实际的表示范围定为-128至127&lt;/li&gt;
&lt;li&gt;如何选择类型&lt;ul&gt;
&lt;li&gt;明知数值不可能为负数，选用无符号类型&lt;/li&gt;
&lt;li&gt;如果数值超过了&lt;code&gt;int&lt;/code&gt;的表示范围，选用&lt;code&gt;long long&lt;/code&gt;，因为&lt;code&gt;long&lt;/code&gt;一般和&lt;code&gt;int&lt;/code&gt;有一样的尺寸&lt;/li&gt;
&lt;li&gt;算术表达式中不要使用&lt;code&gt;bool&lt;/code&gt;或&lt;code&gt;char&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;执行浮点数运算选用&lt;code&gt;double&lt;/code&gt;。因为&lt;code&gt;float&lt;/code&gt;通常精度不够而且计算代价相差无几。&lt;code&gt;long double&lt;/code&gt;提供的精度一般情况下是没有必要的而且计算代价大&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;类型转换&lt;ul&gt;
&lt;li&gt;非布尔 -&amp;gt; 布尔：0 -&amp;gt; &lt;code&gt;false&lt;/code&gt;，其他 -&amp;gt; &lt;code&gt;ture&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;布尔 -&amp;gt; 非布尔：&lt;code&gt;false&lt;/code&gt;-&amp;gt; 0，&lt;code&gt;ture&lt;/code&gt; -&amp;gt; 1&lt;/li&gt;
&lt;li&gt;浮点 -&amp;gt; 整型：仅保留小数点前&lt;/li&gt;
&lt;li&gt;整型 -&amp;gt; 浮点：小数部分记为0，如果该整数所占的空间超过浮点类型的容量，精度可能损失&lt;/li&gt;
&lt;li&gt;当我们赋给无符号类型一个超过它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数&lt;/li&gt;
&lt;li&gt;当我们赋给带符号类型一个超出它表示范围的值时，结果是未定义的。此时，程序可能继续工作、可能崩溃，也可能生成垃圾数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;当一个算术表达式中既有无符号数又有&lt;code&gt;int&lt;/code&gt;值时，那个&lt;code&gt;int&lt;/code&gt;会转换成无符号数。把&lt;code&gt;int&lt;/code&gt;转换成无符号数的过程和把&lt;code&gt;int&lt;/code&gt;赋值给无符号变量一样&lt;/li&gt;
&lt;li&gt;当从一个无符号数中减去一个值时，我们必须确保结果不是负值，否则实际结果会是取模后的值&lt;/li&gt;
&lt;li&gt;字面值常量&lt;ul&gt;
&lt;li&gt;整型和浮点型字面值&lt;/li&gt;
&lt;li&gt;字符和字符串字面值&lt;ul&gt;
&lt;li&gt;‘a’ 和“a”，字符串字面值最后补’\0’&lt;/li&gt;
&lt;li&gt;如果两个字符串字面值位置紧邻且仅由空格、缩进和换行分隔，则它们是一个整体&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;布尔字面值：&lt;code&gt;true&lt;/code&gt;、&lt;code&gt;false&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;指针字面值：&lt;code&gt;nullptr&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;指定字面值的类型&lt;ul&gt;
&lt;li&gt;字符和字符串字面值&lt;ul&gt;
&lt;li&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;前缀&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;u&lt;/td&gt;
&lt;td&gt;char16_t&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;U&lt;/td&gt;
&lt;td&gt;char32_t&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;L&lt;/td&gt;
&lt;td&gt;wchar_t&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;u8&lt;/td&gt;
&lt;td&gt;char&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;整型字面值&lt;ul&gt;
&lt;li&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;后缀&lt;/th&gt;
&lt;th&gt;最小匹配类型&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;u或U&lt;/td&gt;
&lt;td&gt;unsigned&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;l或L&lt;/td&gt;
&lt;td&gt;long&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ll或LL&lt;/td&gt;
&lt;td&gt;long long&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;浮点型字面值&lt;ul&gt;
&lt;li&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;后缀&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;f或F&lt;/td&gt;
&lt;td&gt;float&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;l或L&lt;/td&gt;
&lt;td&gt;long double&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;列表初始化： &lt;code&gt;int units_sold{0}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;列表初始化的重要特点：如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将报错&lt;/li&gt;
&lt;li&gt;默认初始化&lt;ul&gt;
&lt;li&gt;内置类型变量&lt;ul&gt;
&lt;li&gt;定义于任何函数之外，初始化为0&lt;/li&gt;
&lt;li&gt;定义于函数体内的局部静态变量，初始化为0&lt;/li&gt;
&lt;li&gt;定义于函数体内的非局部静态变量，不被初始化，试图拷贝或以其他方式访问此类值将引发错误&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;每个类各自决定其初始化对象的方式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;分离式编译：将程序分割为若干个文件，每个文件可被独立编译&lt;/li&gt;
&lt;li&gt;声明：&lt;code&gt;extern int i;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;extern语句如果包含初始值就不再是声明，而变成定义了：&lt;code&gt;extern int i = 0;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在函数体内部，试图初始化一个由&lt;code&gt;extern&lt;/code&gt;关键字标记的变量将引发错误&lt;/li&gt;
&lt;li&gt;静态类型语言：在编译阶段执行类型检查&lt;/li&gt;
&lt;li&gt;C++ 标识符：字母、数字、下划线，必须以字母或下划线开头，长度无限制，大小写敏感&lt;/li&gt;
&lt;li&gt;C++ 为标准库保留了一些名字&lt;ul&gt;
&lt;li&gt;自定义标识符中不能连续出现两个下划线&lt;/li&gt;
&lt;li&gt;不能以下划线紧接大写字母开头&lt;/li&gt;
&lt;li&gt;定义在函数体外的函数不能以下划线开头&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;作用域操作符 ::，若左侧为空，则指代全局作用域&lt;/li&gt;
&lt;li&gt;复合类型：&lt;ul&gt;
&lt;li&gt;引用&lt;ul&gt;
&lt;li&gt;&lt;code&gt;int &amp;amp;b = a;&lt;/code&gt;b指向a&lt;/li&gt;
&lt;li&gt;引用必须初始化&lt;/li&gt;
&lt;li&gt;引用本身不是一个对象，不能定义引用的引用&lt;/li&gt;
&lt;li&gt;引用必须绑定到对象上，不能绑定到字面值或者某个表达式的计算结果上&lt;/li&gt;
&lt;li&gt;除了两种例外，所有引用的类型都要和它所绑定的对象严格匹配&lt;ul&gt;
&lt;li&gt;初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可&lt;/li&gt;
&lt;li&gt;允许将基类的引用绑定到派生类上&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;指针&lt;ul&gt;
&lt;li&gt;&lt;code&gt;int *b = &amp;amp;a;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;指针是一个对象&lt;/li&gt;
&lt;li&gt;在块作用域内定义的指针如果未初始化，将拥有一个不确定的值&lt;/li&gt;
&lt;li&gt;除了两种例外，所有指针的类型都要和它所指向的对象严格匹配&lt;ul&gt;
&lt;li&gt;允许一个指向常量的指针指向一个非常量对象&lt;/li&gt;
&lt;li&gt;允许将基类的指针绑定到派生类上&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;试图拷贝或以其他方式访问无效指针的值将引起错误，编译器不负责检查此类错误&lt;/li&gt;
&lt;li&gt;任何非零的指针对应的条件值都是true&lt;/li&gt;
&lt;li&gt;合法指针可以比较大小：== 或 !=&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void *&lt;/code&gt;是一个特殊的指针类型，可用于存放任意对象的地址&lt;ul&gt;
&lt;li&gt;拿它和别的指针比较&lt;/li&gt;
&lt;li&gt;作为函数的输入或输出&lt;/li&gt;
&lt;li&gt;赋给另外一个&lt;code&gt;void *&lt;/code&gt;指针&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;理解复合类型的声明&lt;ul&gt;
&lt;li&gt;变量的定义包括一个基本数据类型和一组声明符&lt;/li&gt;
&lt;li&gt;一条定义语句可能定义出不同类型的变量：&lt;code&gt;int i = 1024, *p = &amp;amp;i, &amp;amp;r =i;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;面对一条比较复杂的指针或者引用的声明语句时，从右往左阅读有助于弄清楚它的真实含义，例如：&lt;code&gt;int \*&amp;amp;r;&lt;/code&gt;首先 r 是一个引用，其次 r 是一个指针的引用，再次 r 是一个指向整型指针的引用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const&lt;/code&gt;限定符&lt;ul&gt;
&lt;li&gt;因为&lt;code&gt;const&lt;/code&gt;对象一旦创建就无法改变其值，所以必须初始化&lt;/li&gt;
&lt;li&gt;当用一个对象去初始化另外一个对象，它们是不是&lt;code&gt;const&lt;/code&gt;都无关紧要，常量的特性仅仅在执行改变其值的操作时才会发挥作用&lt;/li&gt;
&lt;li&gt;默认情况下，&lt;code&gt;const&lt;/code&gt;对象仅在文件内有效&lt;/li&gt;
&lt;li&gt;如果想在多个文件之间共享&lt;code&gt;const&lt;/code&gt;对象，必须在变量的定义之前添加&lt;code&gt;extern&lt;/code&gt;关键字&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const&lt;/code&gt;的引用（常量引用）&lt;/li&gt;
&lt;li&gt;常量引用的初始化：初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。尤其，允许为一个常量引用绑定非常量的对象、字面值甚至是一个表达式。实际上是通过绑定到一个临时量对象上实现的&lt;/li&gt;
&lt;li&gt;对&lt;code&gt;const&lt;/code&gt;的引用可能引用一个并非&lt;code&gt;const&lt;/code&gt;的对象，常量引用仅对引用可参与的操作做了限制，对于引用的对象本身是不是常量未做限制&lt;/li&gt;
&lt;li&gt;指针和&lt;code&gt;const&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;指向常量的指针&lt;ul&gt;
&lt;li&gt;允许一个指向常量的指针指向一个非常量对象&lt;/li&gt;
&lt;li&gt;仅对指向常量的指针可参与的操作做了限制，对于指向的对象本身是不是常量未做限制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;const&lt;/code&gt;指针&lt;ul&gt;
&lt;li&gt;指针是对象，可以把指针本身定为常量&lt;/li&gt;
&lt;li&gt;常量指针必须初始化，一经初始化就不能再改变&lt;/li&gt;
&lt;li&gt;把*放在&lt;code&gt;const&lt;/code&gt;关键字之前说明指针是一个常量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;顶层和底层&lt;code&gt;const&lt;/code&gt;&lt;ul&gt;
&lt;li&gt;顶层&lt;code&gt;const&lt;/code&gt;：指针本身是个常量&lt;/li&gt;
&lt;li&gt;底层&lt;code&gt;const&lt;/code&gt;：指针所值的对象是一个常量&lt;/li&gt;
&lt;li&gt;更一般的，顶层&lt;code&gt;const&lt;/code&gt;可以表示任意的对象是常量，这一点对任意数据类型都适用。底层&lt;code&gt;const&lt;/code&gt;则与指针和引用等复合类型的基本类型部分有关&lt;/li&gt;
&lt;li&gt;执行对象的拷贝操作时&lt;ul&gt;
&lt;li&gt;顶层&lt;code&gt;const&lt;/code&gt;不受影响&lt;/li&gt;
&lt;li&gt;拷入和拷出的对象必须具有相同的底层&lt;code&gt;const&lt;/code&gt;资格，或者两个对象的数据类型必须能够转换。一般来说，非常量可以转换成常量，反之不行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;constexpr&lt;/code&gt;和常量表达式&lt;ul&gt;
&lt;li&gt;常量表达式：值不会改变并且在编译过程就能得到计算结果的表达式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;constexpr&lt;/code&gt;变量：由编译器来验证变量的值是否是一个常量表达式，声明为&lt;code&gt;constexpr&lt;/code&gt;的变量一定是一个常量，并且必须用常量表达式初始化&lt;/li&gt;
&lt;li&gt;字面值类型：算术类型、引用、指针、字面值常量类、枚举&lt;/li&gt;
&lt;li&gt;声明&lt;code&gt;constexpr&lt;/code&gt;用到的类型为字面值类型&lt;/li&gt;
&lt;li&gt;一个&lt;code&gt;constexpr&lt;/code&gt;指针的初始值必须是&lt;code&gt;nullptr&lt;/code&gt;或者0，或者是存储于某个固定地址中的对象&lt;ul&gt;
&lt;li&gt;函数体内定义的变量一般并非存放在固定地址中，&lt;code&gt;constexpr&lt;/code&gt;指针不能指向这样的变量（局部静态对象除外）&lt;/li&gt;
&lt;li&gt;定义于所有函数体之外的对象地址固定不变，能用来初始化&lt;code&gt;constexpr&lt;/code&gt;指针&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;constexpr&lt;/code&gt;声明中如果定义了一个指针，限定符&lt;code&gt;constexpr&lt;/code&gt;仅对指针有效，与指针所指的对象无关&lt;/li&gt;
&lt;li&gt;&lt;code&gt;constexpr&lt;/code&gt;把它所定义的对象置为顶层&lt;code&gt;const&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;处理类型&lt;ul&gt;
&lt;li&gt;类型别名&lt;ul&gt;
&lt;li&gt;&lt;code&gt;typedef double wages;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;using SI = Sales_item;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;下面两条声明语句的基本数据类型都是&lt;code&gt;const pstring&lt;/code&gt;，&lt;code&gt;const&lt;/code&gt;是对给定类型的修饰，&lt;code&gt;pstring&lt;/code&gt;实际上是指向&lt;code&gt;char&lt;/code&gt;的指针，所以&lt;code&gt;const pstring&lt;/code&gt;是指向&lt;code&gt;char&lt;/code&gt;的常量指针&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;auto&lt;/code&gt;类型说明符&lt;ul&gt;
&lt;li&gt;让编译器自己去分析表达式所属的类型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;auto&lt;/code&gt;也能在一条语句中声明多个变量。因为一条声明语句只能有一个基本数据类型，所以该语句中所有变量的基本数据类型都必须一样&lt;/li&gt;
&lt;li&gt;当引用被用作初始化&lt;code&gt;auto&lt;/code&gt;变量时，编译器以引用所引用对象的类型作为&lt;code&gt;auto&lt;/code&gt;的类型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;auto&lt;/code&gt;一般会忽略顶层&lt;code&gt;const&lt;/code&gt;，同时底层&lt;code&gt;const&lt;/code&gt;会保留下来&lt;/li&gt;
&lt;li&gt;如果希望推断出的&lt;code&gt;auto&lt;/code&gt;类型是一个顶层&lt;code&gt;const&lt;/code&gt;，需要明确指出&lt;/li&gt;
&lt;li&gt;&lt;code&gt;auto&lt;/code&gt;引用&lt;code&gt;auto &amp;amp;b = a;&lt;/code&gt;初始值 a 的顶层&lt;code&gt;const&lt;/code&gt;会保留&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;decltype&lt;/code&gt;类型指示符&lt;ul&gt;
&lt;li&gt;选择并返回操作数的数据类型，编译器分析表达式得到它的类型，却不实际计算表达式的值，编译器并不实际调用f&lt;/li&gt;
&lt;li&gt;如果&lt;code&gt;decltype&lt;/code&gt;使用的表达式是一个变量，则&lt;code&gt;decltype&lt;/code&gt;返回该变量的类型（包括顶层&lt;code&gt;const&lt;/code&gt;和引用在内），需要指出的是，引用从来都作为其所指对象的同义词出现，只有在&lt;code&gt;decltype&lt;/code&gt;处是一个例外&lt;/li&gt;
&lt;li&gt;如果&lt;code&gt;decltype&lt;/code&gt;使用的表达式不是一个变量，则&lt;code&gt;decltype&lt;/code&gt;返回该表达式的结果对应的类型&lt;ul&gt;
&lt;li&gt;因为 r 是一个引用，&lt;code&gt;decltype(r)&lt;/code&gt;的结果是引用类型，如果想让结果类型是 r 所指的类型，可以把 r 作为表达式的一部分，显然这个表达式的结果是一个具体的值而非一个引用&lt;/li&gt;
&lt;li&gt;如果表达式的内容是解引用操作，则&lt;code&gt;decltype&lt;/code&gt;将得到引用类型&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果&lt;code&gt;decltype&lt;/code&gt;使用的表达式是一个变量&lt;ul&gt;
&lt;li&gt;不加括号，得到该变量的类型&lt;/li&gt;
&lt;li&gt;加括号，得到引用类型&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;自定义数据结构&lt;ul&gt;
&lt;li&gt;结构体&lt;/li&gt;
&lt;li&gt;类&lt;/li&gt;
&lt;li&gt;记得定义末尾的分号；&lt;/li&gt;
&lt;li&gt;可以类内初始化&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;头文件保护符&lt;ul&gt;
&lt;li&gt;头文件保护符依赖于预处理变量&lt;/li&gt;
&lt;li&gt;预处理变量由两个状态：已定义和未定义&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#define&lt;/code&gt;指令把一个名字设定为预处理变量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#ifdef&lt;/code&gt;当且仅当变量已定义时为真&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#ifndef&lt;/code&gt;当且仅当变量未定义时为真&lt;/li&gt;
&lt;li&gt;一旦检查结果为真，则执行后续操作直到遇到&lt;code&gt;#endif&lt;/code&gt;指令为止&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;</content><category term="C++"></category></entry><entry><title>【读书笔记】C++ Primer 第一章</title><link href="https://xutree.github.io/pages/2018/10/05/C++_Primer_Chapter_1/" rel="alternate"></link><published>2018-10-05T23:11:35+08:00</published><updated>2018-10-06T22:02:49+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-05:/pages/2018/10/05/C++_Primer_Chapter_1/</id><summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;code&gt;main&lt;/code&gt;函数的返回类型必须为&lt;code&gt;int&lt;/code&gt;，返回值0表示成功，非0的含义由系统定义，通常用来指出错误类型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;g++ -std=c++14  -Wall -o test test.cpp&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iostream&lt;/code&gt; &lt;code&gt;cin&lt;/code&gt; &lt;code&gt;cout&lt;/code&gt; &lt;code&gt;cerr&lt;/code&gt; &lt;code&gt;clog&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;运算符返回其左侧的运算对象&lt;/li&gt;
&lt;li&gt;写入&lt;code&gt;endl&lt;/code&gt;的效果是结束当前行，并将与设备关联的缓冲区中的内容刷到设备中。缓冲刷新操作可以保证到目前为止程序所产生的所有输出都真正写入到输出流中，而不是仅停留在内存中等待写入流&lt;/li&gt;
&lt;li&gt;小心程序崩溃，输出可能还留在缓冲区的情况，利用&lt;code&gt;endl&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;标准库定义的所有名字都在命名空间&lt;code&gt;std&lt;/code&gt;中&lt;/li&gt;
&lt;li&gt;当我们使用一个&lt;code&gt;istream&lt;/code&gt;对象作为条件时，其效果是检测流的状态。流有效，即流未遇到错误，那么检测成功。当遇到文件结束符（end of file），或遇到一个无效输入时，&lt;code&gt;istream&lt;/code&gt;对象的状态会变为无效。无效的&lt;code&gt;istream …&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;ul&gt;
&lt;li&gt;&lt;code&gt;main&lt;/code&gt;函数的返回类型必须为&lt;code&gt;int&lt;/code&gt;，返回值0表示成功，非0的含义由系统定义，通常用来指出错误类型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;g++ -std=c++14  -Wall -o test test.cpp&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iostream&lt;/code&gt; &lt;code&gt;cin&lt;/code&gt; &lt;code&gt;cout&lt;/code&gt; &lt;code&gt;cerr&lt;/code&gt; &lt;code&gt;clog&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;运算符返回其左侧的运算对象&lt;/li&gt;
&lt;li&gt;写入&lt;code&gt;endl&lt;/code&gt;的效果是结束当前行，并将与设备关联的缓冲区中的内容刷到设备中。缓冲刷新操作可以保证到目前为止程序所产生的所有输出都真正写入到输出流中，而不是仅停留在内存中等待写入流&lt;/li&gt;
&lt;li&gt;小心程序崩溃，输出可能还留在缓冲区的情况，利用&lt;code&gt;endl&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;标准库定义的所有名字都在命名空间&lt;code&gt;std&lt;/code&gt;中&lt;/li&gt;
&lt;li&gt;当我们使用一个&lt;code&gt;istream&lt;/code&gt;对象作为条件时，其效果是检测流的状态。流有效，即流未遇到错误，那么检测成功。当遇到文件结束符（end of file），或遇到一个无效输入时，&lt;code&gt;istream&lt;/code&gt;对象的状态会变为无效。无效的&lt;code&gt;istream&lt;/code&gt;对象会使条件为假&lt;/li&gt;
&lt;li&gt;文件结束符：Windows 先Ctrl + Z，后Enter 或 Return；UNIX：Ctrl +D&lt;/li&gt;
&lt;li&gt;标准库文件通常不带后缀。编译器一般不关心头文件名的形式，但有的IDE对此有特定要求&lt;/li&gt;
&lt;li&gt;头文件包含：标准库头文件 &amp;lt;&amp;gt;     非标准库头文件 ""&lt;/li&gt;
&lt;li&gt;文件重定向：从文件读入\&amp;lt;infile，输出到文件&gt;outfile&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;C++里关于&lt;code&gt;cerr&lt;/code&gt;, &lt;code&gt;clog&lt;/code&gt;, &lt;code&gt;cout&lt;/code&gt;三者的区别:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cerr&lt;/code&gt;(无缓冲标准错误) 没有缓冲，发送给它的内容立即被输出&lt;/li&gt;
&lt;li&gt;&lt;code&gt;clog&lt;/code&gt;(缓冲标准错误)  有缓冲，缓冲区满时输出&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cout&lt;/code&gt;标准输出&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cout&lt;/code&gt;是在终端显示器输出，&lt;code&gt;cout&lt;/code&gt;流在内存中对应开辟了一个缓冲区，用来存放流中的数据，当向&lt;code&gt;cout&lt;/code&gt;流插入一个&lt;code&gt;endl&lt;/code&gt;，不论缓冲区是否满了，都立即输出流中所有数据，然后插入一个换行符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cerr&lt;/code&gt;流对象是标准错误流，指定为和显示器关联，和&lt;code&gt;cout&lt;/code&gt;作用差不多，有点不同就是&lt;code&gt;cout&lt;/code&gt;通常是传到显示器输出，但可以被重定向输出到文件，而&lt;code&gt;cerr&lt;/code&gt;流中的信息只能在显示器输出&lt;/li&gt;
&lt;li&gt;&lt;code&gt;clog&lt;/code&gt;流也是标准错误流，作用和&lt;code&gt;cerr&lt;/code&gt;一样，区别在于&lt;code&gt;cerr&lt;/code&gt;不经过缓冲区，直接向显示器输出信息，而&lt;code&gt;clog&lt;/code&gt;中的信息存放在缓冲区，缓冲区满或者遇到&lt;code&gt;endl&lt;/code&gt;时才输出&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于为什么有&lt;code&gt;cerr&lt;/code&gt;和&lt;code&gt;clog&lt;/code&gt;？比如，你的程序遇到调用栈用完了的威胁（无限，没有出口的递归。你说，你到什么地方借内存，存放你的错误信息？所以有了&lt;code&gt;cerr&lt;/code&gt;。其目的，就是在你最需要它的紧急情况下，还能得到输出功能的支持&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;缓冲区的目的，就是减少刷屏的次数——比如，你的程序输出圣经中的一篇文章。不带缓冲的话，就会每写一个字母，就输出一个字母，然后刷屏。有了缓冲，你将看到若干句子“同时”就出现在了屏幕上（由内存翻新到显存，然后刷新屏幕）&lt;/li&gt;
&lt;/ul&gt;</content><category term="C++"></category></entry></feed>