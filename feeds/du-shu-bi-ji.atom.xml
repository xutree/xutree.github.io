<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>You Know Nothing - 读书笔记</title><link href="https://xutree.github.io/" rel="alternate"></link><link href="https://xutree.github.io/feeds/du-shu-bi-ji.atom.xml" rel="self"></link><id>https://xutree.github.io/</id><updated>2018-10-20T17:35:11+08:00</updated><entry><title>C++ Primer 第十三章 拷贝控制</title><link href="https://xutree.github.io/pages/2018/10/20/C++_Primer_Chapter_13/" rel="alternate"></link><published>2018-10-20T16:41:10+08:00</published><updated>2018-10-20T17:35:11+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-20:/pages/2018/10/20/C++_Primer_Chapter_13/</id><summary type="html">&lt;p&gt;当定义一个类时，我们显示地或隐式地指定在此类型的对象拷贝、移动、赋值和销毁时做什么。一个类通过定义五种特殊的成员函数来控制这些操作，包括：拷贝构造函数（copy constructor）、拷贝赋值运算符（copy-assignment operator）、移动构造函数（move constructor）、移动赋值运算符（move-assignment operator）和析构函数（destructor）。&lt;/p&gt;
&lt;p&gt;拷贝和移动构造函数定义了当用同类型的另一个对象初始化本对象时做什么。&lt;/p&gt;
&lt;p&gt;拷贝和移动赋值运算符定义了将一个对象赋予同类型的另一个对象时做什么。&lt;/p&gt;
&lt;p&gt;析构函数定义了当此类型对象销毁时做什么。&lt;/p&gt;
&lt;p&gt;我们称这些操作为拷贝控制操作（copy control）。&lt;/p&gt;
&lt;h2&gt;拷贝、赋值和销毁&lt;/h2&gt;
&lt;h3&gt;拷贝构造函数&lt;/h3&gt;
&lt;p&gt;如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;Foo&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="kr"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="nx"&gt;Foo&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  &lt;span class="c1"&gt;//默认构造函数&lt;/span&gt;
    &lt;span class="nx"&gt;Foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;Foo&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;    &lt;span class="c1"&gt;//拷贝构造函数&lt;/span&gt;
    &lt;span class="c1"&gt;//...&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;拷贝构造函数的第一个参数必须是一个引用类型，虽然我们可以定义一个接受非&lt;code&gt;const&lt;/code&gt;引用的拷贝构造函数，但此参数几乎总是一个&lt;code&gt;const&lt;/code&gt;引用。拷贝构造函数在几种情况下都会被隐式地使用。因此 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;当定义一个类时，我们显示地或隐式地指定在此类型的对象拷贝、移动、赋值和销毁时做什么。一个类通过定义五种特殊的成员函数来控制这些操作，包括：拷贝构造函数（copy constructor）、拷贝赋值运算符（copy-assignment operator）、移动构造函数（move constructor）、移动赋值运算符（move-assignment operator）和析构函数（destructor）。&lt;/p&gt;
&lt;p&gt;拷贝和移动构造函数定义了当用同类型的另一个对象初始化本对象时做什么。&lt;/p&gt;
&lt;p&gt;拷贝和移动赋值运算符定义了将一个对象赋予同类型的另一个对象时做什么。&lt;/p&gt;
&lt;p&gt;析构函数定义了当此类型对象销毁时做什么。&lt;/p&gt;
&lt;p&gt;我们称这些操作为拷贝控制操作（copy control）。&lt;/p&gt;
&lt;h2&gt;拷贝、赋值和销毁&lt;/h2&gt;
&lt;h3&gt;拷贝构造函数&lt;/h3&gt;
&lt;p&gt;如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;Foo&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="kr"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="nx"&gt;Foo&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  &lt;span class="c1"&gt;//默认构造函数&lt;/span&gt;
    &lt;span class="nx"&gt;Foo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;Foo&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;    &lt;span class="c1"&gt;//拷贝构造函数&lt;/span&gt;
    &lt;span class="c1"&gt;//...&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;拷贝构造函数的第一个参数必须是一个引用类型，虽然我们可以定义一个接受非&lt;code&gt;const&lt;/code&gt;引用的拷贝构造函数，但此参数几乎总是一个&lt;code&gt;const&lt;/code&gt;引用。拷贝构造函数在几种情况下都会被隐式地使用。因此，拷贝构造函数通常不应该是&lt;code&gt;explicit&lt;/code&gt;的。&lt;/p&gt;
&lt;h4&gt;合成拷贝构造函数（synthesized copy constructor）&lt;/h4&gt;
&lt;p&gt;如果我们没有为一个类定义拷贝构造函数，编译器会为我们定义一个。与合成默认构造函数不同，即使我们定义了其他构造函数，编译器也会为我们合成一个拷贝构造函数。&lt;/p&gt;
&lt;p&gt;每个成员的类型决定了它如何拷贝：对类类型成员，会使用其拷贝构造函数来拷贝；内置类型的成员则直接拷贝。Sales_data 类的合成拷贝构造函数等价于：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;Slaes_data&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="kr"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="c1"&gt;//其他成员和构造函数的定义，如前&lt;/span&gt;
    &lt;span class="c1"&gt;//与合成的拷贝构造函数等价的拷贝构造函数的声明&lt;/span&gt;
    &lt;span class="nx"&gt;Sales_data&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;Sales_data&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="kr"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt; &lt;span class="nx"&gt;bookNo&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="nx"&gt;units_sold&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kr"&gt;double&lt;/span&gt; &lt;span class="nx"&gt;revenue&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="c1"&gt;//与 Sales_data 的合成的拷贝构造函数等价&lt;/span&gt;
&lt;span class="nx"&gt;Sales_data&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;Sales_data&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;Sales_data&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;orig&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="nx"&gt;bookNo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;orig&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;bookNo&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;    &lt;span class="c1"&gt;//使用string的拷贝构造函数&lt;/span&gt;
    &lt;span class="nx"&gt;units_sold&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;orig&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;units_sold&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="err"&gt;，&lt;/span&gt;    &lt;span class="c1"&gt;//拷贝orig.units_sold&lt;/span&gt;
    &lt;span class="nx"&gt;revenue&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;orig&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;revenue&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;   &lt;span class="c1"&gt;//拷贝orig.revenue&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="c1"&gt;//空函数体&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;拷贝初始化（copy initialization）&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;string dots(10,&amp;#39;.&amp;#39;);    //直接初始化
string s(dots);     //直接初始化
string s2 = dots;   //拷贝初始化
string null_book = &amp;quot;9-999-99999-9&amp;quot;; //拷贝初始化
string nines = string(100, &amp;#39;9&amp;#39;);    //拷贝初始化
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当使用直接初始化时，我们实际上是要求编译器使用普通的函数匹配来选择与我们提供的实参最匹配的构造函数。当我们使用拷贝初始化时，我们要求编译器将右侧运算对象拷贝到正在创建的对象中，如果需要的话还要进行类型转换。&lt;/p&gt;
&lt;p&gt;拷贝初始化通常通过拷贝构造函数来完成，但是，如果一个类有一个移动构造函数，则拷贝初始化有时会使用移动构造函数而非拷贝构造函数来完成。&lt;/p&gt;
&lt;p&gt;拷贝初始化不仅在外面用=定义变量时会发生，在下列情况下也会发生：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将一个对象作为实参传递给一个非引用类型的形参&lt;/li&gt;
&lt;li&gt;从一个返回类型为非引用类型的函数返回一个对象&lt;/li&gt;
&lt;li&gt;用花括号列表初始化一个数组中的元素或一个聚合类中的成员&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;某些类类型还会对它们所分配的对象使用拷贝初始化。例如，当我们初始化标准库容器或是调用其&lt;code&gt;insert&lt;/code&gt;或&lt;code&gt;push&lt;/code&gt;成员时，容器会对其元素进行拷贝初始化。与之相对，用&lt;code&gt;emplace&lt;/code&gt;成员创建的元素都进行直接初始化。&lt;/p&gt;
&lt;h4&gt;参数和返回值&lt;/h4&gt;
&lt;p&gt;在函数调用过程中，具有非引用类型的参数要进行拷贝初始化。&lt;/p&gt;
&lt;p&gt;拷贝构造函数被用来初始化非引用类类型参数，这一特性解释了为什么拷贝构造函数自己的参数必须是引用类型。如果其参数不是引用类型，则调用永远也不会成功——为了调用拷贝构造函数，我们必须拷贝它的实参，但为了拷贝实参，我们又需要调用拷贝构造函数，如此无限循环。&lt;/p&gt;
&lt;h4&gt;拷贝初始化的限制&lt;/h4&gt;
&lt;p&gt;如前所述，如果我们使用的初始化值要求通过一个&lt;code&gt;explicit&lt;/code&gt;的构造函数来进行类型转换，那么使用拷贝初始化还是直接初始化就不是无关紧要的了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;vector&amp;lt;int&amp;gt; v1(10); //正确，直接初始化
vector&amp;lt;int&amp;gt; v2 = 10;    //错误：接受大小参数的构造函数是 explicit 的
void f(vector&amp;lt;int&amp;gt;);    //f 的参数进行拷贝初始化
f(10);  //错误：不能用一个 explicit 的构造函数拷贝一个实参
f(vector&amp;lt;int&amp;gt;(10)); //正确：从一个 int 直接构造一个临时的 vector
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;编译器可以绕过拷贝构造函数&lt;/h4&gt;
&lt;p&gt;在拷贝初始化的过程中，编译器可以（但不是必须）跳过拷贝/移动构造函数，直接创建对象。即，编译器允许将下面的代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;string null_book = &amp;quot;9-999-99999-9&amp;quot;; //拷贝初始化
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;改写为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;string null_book(&amp;quot;9-999-99999-9&amp;quot;);  //编译器略过了拷贝构造函数
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;但是，即使编译器略过拷贝/移动构造函数，但在这个程序点上，拷贝/移动构造函数必须是存在并且是可访问的（例如，不能是 private 的）。&lt;/p&gt;
&lt;h3&gt;拷贝赋值运算符&lt;/h3&gt;
&lt;p&gt;与控制其对象如何初始化一样，类也可以控制其对象如何赋值：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Sales_data trans, accum;
trans = accum;    //使用 Sales_data 的拷贝赋值运算符
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;重载赋值运算符&lt;/h4&gt;
&lt;p&gt;重载运算符本质上是函数，其名字由&lt;code&gt;operator&lt;/code&gt;关键字后接表示要定义的运算符的符号组成。因此，赋值运算符就是一个名为&lt;code&gt;operator=&lt;/code&gt;的函数。&lt;/p&gt;
&lt;p&gt;某些运算符，包括赋值运算符，必须定义为成员函数。如果一个运算符是一个成员函数，其左侧运算对象就绑定到隐式的&lt;code&gt;this&lt;/code&gt;参数。对于一个二元运算符，例如赋值运算符，其右侧运算对象作为显式参数传递。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;//拷贝赋值运算符接受一个与其所在类相同类型的参数&lt;/span&gt;
&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;Foo&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="kr"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="nx"&gt;Foo&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;Foo&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;//赋值运算符&lt;/span&gt;
    &lt;span class="c1"&gt;//...&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;为了与内置类型的赋值保持一致，赋值运算符通常返回一个指向其左侧运算对象的引用。&lt;/p&gt;
&lt;h4&gt;合成拷贝赋值运算符&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//等价于合成拷贝赋值运算符
Sales_data&amp;amp; Sales_data::operator=(const Sales_data &amp;amp;rhs)
{
    bookNo = rhs.bookNo；    //调用 string::operator=
    units_sold = rhs.units_sold;    //使用内置的 int 赋值
    revenue = rhs.revenue;  //使用内置的 double 赋值
    return *this;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;析构函数&lt;/h3&gt;
&lt;p&gt;析构函数执行与构造函数相反的操作：构造函数初始化对象的非&lt;code&gt;static&lt;/code&gt;数据成员，还可能做一些其他工作；析构函数释放对象使用的资源，并销毁对象的非&lt;code&gt;static&lt;/code&gt;数据成员。&lt;/p&gt;
&lt;p&gt;析构函数是类的一个成员函数，名字由波浪号接类名构成，没有返回值，也不接受参数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;Foo&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="kr"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="nx"&gt;Foo&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;//析构函数&lt;/span&gt;
    &lt;span class="c1"&gt;//...&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;由于析构函数不接受参数，因此它不能被重载。对一个给定类，只会有唯一一个析构函数。&lt;/p&gt;
&lt;p&gt;在一个析构函数中，首先执行函数体，然后销毁成员。成员按初始化顺序的逆序销毁。&lt;/p&gt;
&lt;p&gt;在一个析构函数中，不存在类似构造函数中初始化列表的东西来控制成员如何销毁，析构部分是隐式的。&lt;strong&gt;成员销毁时发生什么完全依赖于成员的类型。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;销毁类类型成员需要执行成员自己的析构函数。内置类型没有析构函数，因此销毁内置类型成员什么也不需要做。所以：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;隐式销毁一个内置指针类型的成员不会&lt;code&gt;delete&lt;/code&gt;它所指向的对象&lt;/li&gt;
&lt;li&gt;当指向一个对象的引用或指针离开作用域时，析构函数不会执行&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;{ //新作用域
    //p 和 p2 指向动态分配的内存
    Sales_data *p = new Sales_data; //p 是一个内置指针
    auto p2 = make_shared&amp;lt;Sales_data&amp;gt;();    //p2 是一个 shared_ptr
    Sales_data item(*p);    //拷贝构造函数将 p 拷贝到 item 中
    vector&amp;lt;Sales_data&amp;gt; vec; //局部变量
    vec.push_back(*p2); //拷贝 p2 指向的对象
    delete p;   //对 p 指向的对象进行析构函数
} //退出局部作用域；对 item、p2 和 vec 调用析构函数
  //销毁 p2 会递减其引用计数；如果引用计数为0，对象被释放
  //销毁 vec 会销毁它的元素
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;什么时候会调用析构函数&lt;/h4&gt;
&lt;p&gt;无论何时一个对象被销毁，就会自动调用其析构函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;变量在离开作用域时被销毁&lt;/li&gt;
&lt;li&gt;当一个对象被销毁时，其成员被销毁&lt;/li&gt;
&lt;li&gt;容器（无论是标准库容器还是数组）被销毁时，其元素被销毁&lt;/li&gt;
&lt;li&gt;对于动态分配的对象，当对指向它的指针应用&lt;code&gt;delete&lt;/code&gt;运算符时被销毁&lt;/li&gt;
&lt;li&gt;对于临时对象，当创建它的完整表达式结束时被销毁&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;合成析构函数（synthesized destructor）&lt;/h4&gt;
&lt;p&gt;当一个类未定义自己的析构函数时，编译器会为他定义一个合成析构函数。例如，下面的代码等价于 Sales_data 的合成析构函数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;Sales_data&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="kr"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="c1"&gt;//成员会被自动销毁，除此之外不需要做其他事情&lt;/span&gt;
    &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="nx"&gt;Sales_data() {&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="c1"&gt;//其他成员的定义，如前&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在（空）析构函数体执行完毕后，成员会被自动销毁。特别的，&lt;code&gt;string&lt;/code&gt;的析构函数会被调用，它将释放 bookNo 成员所用的内存。认识到析构函数本身并不直接销毁成员是非常重要的。成员是在析构函数体之后隐含的析构阶段中被销毁的。在整个对象销毁过程中，析构函数体是作为成员销毁步骤之外的另一部分而进行的。&lt;/p&gt;
&lt;h3&gt;三/五法则&lt;/h3&gt;
&lt;p&gt;如前所述，有三个基本操作可以控制类的拷贝操作：拷贝构造函数、拷贝赋值运算符和析构函数。而且，在新标准下，一个类还可以定义一个移动构造函数和一个移动赋值运算符。&lt;/p&gt;
&lt;h4&gt;需要析构函数的类也需要拷贝和赋值操作&lt;/h4&gt;
&lt;p&gt;当我们决定一个类是否要定义它自己版本的拷贝控制成员时，一个基本的原则是首先确定这个类是否需要一个析构函数。如果这个类需要一个自定义析构函数，我几乎可以肯定它也需要自定义拷贝构造函数和自定义拷贝赋值运算符。&lt;/p&gt;
&lt;p&gt;如果类在构造函数中分配动态内存。合成析构函数不会&lt;code&gt;delete&lt;/code&gt;一个指针数据成员。因此，此类需要定义一个析构函数来释放构造函数分配的内存。&lt;/p&gt;
&lt;h4&gt;需要拷贝操作的类也需要赋值操作，反之亦然&lt;/h4&gt;
&lt;p&gt;虽然很多类需要定义所有(或是不需要定义任何)拷贝控制成员，但某些类所要完成的工作，只需要拷贝或赋值操作，不需要析构函数。第二个基本原则：如果一个类需要一个拷贝构造函数，几乎可以肯定它也需要一个拷贝赋值运算符。反之亦然。&lt;/p&gt;
&lt;h3&gt;使用 =default&lt;/h3&gt;
&lt;p&gt;我们可以通过将拷贝控制成员定义为=default来显示地要求编译器生成合成的版本：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;Sales_data&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="kr"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="c1"&gt;//拷贝控制成员；使用default&lt;/span&gt;
    &lt;span class="nx"&gt;Sales_data&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nx"&gt;Sales_data&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;Sales_data&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nx"&gt;Sales_data&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="nx"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;Sales_data&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="nx"&gt;Sales_data&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="c1"&gt;//其他成员的定义，如前&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="nx"&gt;Sales_data&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="nx"&gt;Sales_data&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;Sales_data&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当我们在类内使用&lt;code&gt;=default&lt;/code&gt;修饰成员的声明时，合成的函数将隐式地声明为内联的。如果我们不希望合成的成员是内联函数，应该只对成员的类外定义使用&lt;code&gt;=default&lt;/code&gt;，就像对拷贝赋值运算符所做的那样。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们只能对具有合成版本的成员函数使用&lt;code&gt;=default&lt;/code&gt;(即，默认构造函数或拷贝控制成员)。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;阻止拷贝&lt;/h3&gt;
&lt;p&gt;大多数类应该定义默认构造函数、拷贝构造函数和拷贝赋值运算符，无论是隐式地还是显示地。&lt;/p&gt;
&lt;p&gt;但是，在某些情况下，定义类时必须采用某种机制阻止拷贝或赋值。例如，&lt;code&gt;iostream&lt;/code&gt;类阻止了拷贝，以避免多个对象写入或读取相同的 IO 缓冲。&lt;/p&gt;
&lt;p&gt;为了阻止拷贝，看起来可能应该不定义拷贝控制成员。但是，这种策略是无效的：如果我们的类未定义这些操作，编译器为它生成合成的版本。&lt;/p&gt;
&lt;h4&gt;定义删除的函数&lt;/h4&gt;
&lt;p&gt;在新标准下，我们可以通过将拷贝构造函数和拷贝赋值运算符定义为删除的函数（deleted function）来阻止拷贝。删除的函数是这样一种函数：我们虽然声明了它们但不能以任何方式使用它们：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;struct NoCopy{
    NoCopy() = default; //使用合成的默认构造函数
    NoCopy(const NoCopy&amp;amp;) = delete; //阻止拷贝
    NoCopy &amp;amp;operator=(const NoCopy&amp;amp;) = delete;  //阻止赋值
    ~NoCopy() = delete; //使用合成的析构函数
    //其他成员
};
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;&lt;code&gt;=delete&lt;/code&gt;通知编译器（以及我们代码的读者），我们不希望定义这些成员&lt;/li&gt;
&lt;li&gt;与&lt;code&gt;=default&lt;/code&gt;不同，&lt;code&gt;=delete&lt;/code&gt;必须出现在函数第一次声明的时候&lt;/li&gt;
&lt;li&gt;与&lt;code&gt;=default&lt;/code&gt;的另一不同之处是，我们可以对任何函数指定&lt;code&gt;=delete&lt;/code&gt;（我们只能对编译器可以合成的默认构造函数或拷贝控制成员使用&lt;code&gt;=default&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;析构函数不能是删除的成员&lt;/h4&gt;
&lt;p&gt;值得注意的是，我们不能删除析构函数。如果析构函数被删除，就无法销毁此类型的的对象了。对于析构函数已删除的类型，不能定义该类型的变量或释放指向该类型动态分配对象的指针，但是可以动态分配这种类型的对象（然而动态分配后不能释放）。&lt;/p&gt;
&lt;h4&gt;合成的拷贝控制成员可能是删除的&lt;/h4&gt;
&lt;p&gt;如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数将被定义为删除的。&lt;/p&gt;
&lt;h4&gt;private 拷贝控制&lt;/h4&gt;
&lt;p&gt;在新标准发布之前，类是通过将其拷贝构造函数和拷贝赋值运算符声明为&lt;code&gt;private&lt;/code&gt;的来阻止拷贝：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;PrivateCopy&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;//无访问说明符；接下来的成员默认为 private 的&lt;/span&gt;
    &lt;span class="c1"&gt;//拷贝控制成员是 private 的，因此普通用户代码无法访问&lt;/span&gt;
    &lt;span class="nx"&gt;PrivateCopy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;PrivateCopy&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="nx"&gt;PrivateCopy&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;PrivateCopy&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="c1"&gt;//其他成员&lt;/span&gt;
&lt;span class="kr"&gt;public&lt;/span&gt;&lt;span class="err"&gt;：&lt;/span&gt;
    &lt;span class="nx"&gt;PrivateCopy&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;default&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;//使用合成的默认构造函数&lt;/span&gt;
    &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="nx"&gt;PrivateCopy&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;//用户可以定义此类型的对象，但无法拷贝它们&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;为了阻止友元和成员函数进行拷贝，我们将这些拷贝控制成员声明为&lt;code&gt;private&lt;/code&gt;的，但并不定义它们。声明但不定义一个成员函数是合法的(除了在继承中需要覆盖基类的情况)。&lt;/p&gt;
&lt;p&gt;通过声明（但不定义）&lt;code&gt;private&lt;/code&gt;的拷贝构造函数，我们可以预先阻止任何拷贝该类对象的企图：试图拷贝对象的用户代码将在编译阶段被标记为错误；成员函数或友元函数的拷贝操作将会导致链接时错误。&lt;/p&gt;
&lt;p&gt;建议：希望阻止拷贝的类应该使用&lt;code&gt;=delete&lt;/code&gt;来定义它们自己的拷贝构造函数和拷贝赋值运算符，而不应该将它们声明为&lt;code&gt;private&lt;/code&gt;的。&lt;/p&gt;
&lt;h2&gt;拷贝控制和资源管理&lt;/h2&gt;
&lt;p&gt;为了定义这些成员，我们首先必须确定此类型对象的拷贝语义。一般来说，有两种选择：可以定义拷贝操作，使类的行为看起来像一个值或者像一个指针。&lt;/p&gt;
&lt;p&gt;类的行为像一个值，意味着它应该也有自己的状态。当我们拷贝一个像值的对象时，副本和原对象是完全独立的。改变副本不会对原对象有任何影响，反之亦然；&lt;/p&gt;
&lt;p&gt;行为像指针的类则共享状态。当我们拷贝一个这种类的对象时，副本和原对象使用相同的底层数据。改变副本也会改变原对象，反之亦然。&lt;/p&gt;
&lt;h3&gt;行为像值的类&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;HasPtr&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="kr"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="nx"&gt;HasPtr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;s&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="nx"&gt;ps&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)),&lt;/span&gt;
            &lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="c1"&gt;//ps 指向的 string，每个 HasPtr 对象都有自己的拷贝&lt;/span&gt;
    &lt;span class="nx"&gt;HasPtr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;HasPtr&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;p&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
            &lt;span class="nx"&gt;ps&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;p&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;ps&lt;/span&gt;&lt;span class="p"&gt;)),&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;p&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
    &lt;span class="nx"&gt;HasPtr&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="nx"&gt;operator&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;HasPtr&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="nx"&gt;HasPtr() {&lt;/span&gt;&lt;span class="k"&gt;delete&lt;/span&gt; &lt;span class="nx"&gt;ps&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;
&lt;span class="kr"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;ps&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;类值拷贝赋值运算符赋值运算符通常组合了析构函数和构造函数的操作：类似析构函数，赋值操作会销毁左侧运算对象的资源；类似拷贝构造函数，赋值操作会从右侧运算对象拷贝数据。&lt;/p&gt;
&lt;p&gt;本例中，通过先拷贝右侧运算对象，我们可以处理自赋值情况，并能保证异常发生时代码也是安全的。在完成拷贝后，我们释放左侧运算对象的资源，并更新指针指向新分配的&lt;code&gt;string&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;HasPtr&amp;amp; HasPtr::operator=(const HasPtr&amp;amp;rhs)
{
    auto newp = new string(*rhs.ps);    //拷贝底层 string，注意成员选择优先级大于解引用，故等价于*(rhs.ps)
    delete ps;  //释放旧内存
    ps = newp;  //从右侧运算对象拷贝数据到本对象
    i = rhs.i;
    return *this;   //返回本对象
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当你编写赋值运算符时，有两点需要记住：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果将一个对象赋予它自身，赋值运算符必须能正确工作&lt;/li&gt;
&lt;li&gt;大多数赋值运算符组合了析构函数和拷贝构造函数的工作&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当你编写一个赋值运算符时，一个好的模式是先将右侧运算对象拷贝到一个局部临时对象中。当拷贝完成后，销毁左侧运算对象的现有成员就是安全的了。一旦左侧运算对象的资源被销毁，就只剩下将数据从临时对象拷贝到左侧运算对象的成员中了。&lt;/p&gt;
&lt;p&gt;为了说明防范自赋值操作的重要性，看下面一个错误的例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//这样编写赋值运算符是错误的！
HasPtr&amp;amp; HasPtr::operator=(const HasPtr &amp;amp;rhs)
{
    delete ps;  //释放对象指向的 string
    //如果 rhs 和 *this 是同一个对象，我们就将从已释放的内存中拷贝数据！
    ps = new string(*(rhs.ps));
    i = rhs.i;
    return *this;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果 rhs 和本对象是同一个对象，&lt;code&gt;delete ps&lt;/code&gt;会释放&lt;code&gt;*this&lt;/code&gt;和 rhs 指向的&lt;code&gt;string&lt;/code&gt;。接下来，当我们在&lt;code&gt;new&lt;/code&gt;表达式中试图拷贝&lt;code&gt;*(rhs.ps)&lt;/code&gt;时，就会访问一个指向无效内存的指针，其行为和结果是未定义的。&lt;/p&gt;
&lt;h3&gt;定义行为像指针的类&lt;/h3&gt;
&lt;p&gt;对于行为类似指针的类，我们需要为其定义拷贝构造函数和拷贝赋值运算符，来拷贝指针成员本身而不是它指向的&lt;code&gt;string&lt;/code&gt;。我们的类仍然需要自己的析构函数来释放接受&lt;code&gt;string&lt;/code&gt;参数的构造函数分配的内存。但是，析构函数不能单方面地释放关联的&lt;code&gt;string&lt;/code&gt;，只有当最后一个指向&lt;code&gt;string&lt;/code&gt;的对象销毁时，才可以释放&lt;code&gt;string&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;令一个类展现类似指针的行为最好的方法是使用&lt;code&gt;shared_ptr&lt;/code&gt;来管理类中的资源。如果我们希望直接管理资源，可以使用引用计数（reference count）。下面我们不使用&lt;code&gt;shared_ptr&lt;/code&gt;而是使用引用计数来实现行为像指针的类。&lt;/p&gt;
&lt;h4&gt;引用计数&lt;/h4&gt;
&lt;p&gt;引用计数的工作方式如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;除了初始化对象之外，每个构造函数(拷贝构造函数除外)都要创建一个引用计数，用来记录有多少对象共享正在创建的对象共享状态，当创建一个对象时，引用计数为1，因为此时只有一个对象共享&lt;/li&gt;
&lt;li&gt;拷贝构造函数不分配新得引用计数器，拷贝给定对象的数据成员，包括引用计数器，拷贝构造函数递增共享的计数器，表示给定对象更的状态又被一个新用户所共享&lt;/li&gt;
&lt;li&gt;拷贝赋值运算符递减左侧运算对象的引用计数器，递增右侧对象的引用计数器，如果左侧对象的引用计数器为0，则销毁左侧对象&lt;/li&gt;
&lt;li&gt;析构函数判断引用计数是否为0，如果为0，则销毁左侧对象&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;引用计数的实现：我们假设有下面的情况：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;HasPtr h1;
HasPtr h2(h1);
HasPtr h3(h1);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;HasPtr 是一个行为像指针的类，新创建的 h1的引用计数为1，创建 h2，用 h1 初始化 h2，会递增 h1 的引用计数值，此时 h2 保存了 h1 中的引用计数，在创建 h3 的时候，递增了 h1 的引用计数值，而且我们必须做的是要更新 h2 中的引用计数值，此时无法更新 h2 中的引用计数值。因此，我们需要将引用计数保存在动态内存中，这样原对象和其他副本对象都会指向相同的计数器，这样就可以自动更新引用计数在每个共享对象中的状态。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;HasPtr&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="kr"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="c1"&gt;//构造函数分配新的 string 和新的计数器，将计数器置为1&lt;/span&gt;
    &lt;span class="nx"&gt;HasPtr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="nx"&gt;s&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;ps&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)),&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="nx"&gt;use&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;size_t&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
    &lt;span class="c1"&gt;//拷贝构造函数拷贝所以三个数据成员，并递增计数器&lt;/span&gt;
    &lt;span class="nx"&gt;HasPtr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;HasPtr&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;p&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt;  &lt;span class="nx"&gt;ps&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;p&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;ps&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;p&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="nx"&gt;use&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;p&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;use&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="o"&gt;++*&lt;/span&gt;&lt;span class="nx"&gt;use&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="nx"&gt;HasPtr&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="nx"&gt;operator&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;HasPtr&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="nx"&gt;HasPtr&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="kr"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;ps&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kr"&gt;int&lt;/span&gt; &lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;size_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;use&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 引用计数&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="nx"&gt;HasPtr&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;HasPtr&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="nx"&gt;operator&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;HasPtr&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="nx"&gt;has&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="o"&gt;++*&lt;/span&gt;&lt;span class="nx"&gt;has&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;use&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;//递增右侧运算对象的引用计数&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="o"&gt;--*&lt;/span&gt;&lt;span class="nx"&gt;use&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="c1"&gt;//然后递减本对象的引用计数&lt;/span&gt;
        &lt;span class="k"&gt;delete&lt;/span&gt; &lt;span class="nx"&gt;ps&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;delete&lt;/span&gt; &lt;span class="nx"&gt;use&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="nx"&gt;ps&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;has&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;ps&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nx"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;has&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nx"&gt;use&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;has&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;use&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="nx"&gt;HasPtr&lt;/span&gt;&lt;span class="o"&gt;::~&lt;/span&gt;&lt;span class="nx"&gt;HasPtr() {&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;--*&lt;/span&gt;&lt;span class="nx"&gt;use&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;delete&lt;/span&gt; &lt;span class="nx"&gt;ps&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;delete&lt;/span&gt; &lt;span class="nx"&gt;use&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;交换操作&lt;/h2&gt;
&lt;p&gt;通常，管理资源的类除了定义拷贝控制成员之外，还会定义交换操作的函数&lt;code&gt;swap&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果一个类定义了自己的&lt;code&gt;swap&lt;/code&gt;，那么算法将使用类自定义版本，否则，将使用标准库定义的&lt;code&gt;swap&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;理论上来说，我们的&lt;code&gt;swap&lt;/code&gt;函数应该是这样的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//交换两个类值 HasPtr 对象的代码可能像下面这样：
HasPtr temp = v1;   //创建 v1 的值的一个临时副本
v1 = v2;    //将 v2 的值赋予 v1
v2 = temp;  //将保存的 v1 的值赋予 v2
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样的代码将 v1 中&lt;code&gt;string&lt;/code&gt;拷贝了两次，但是这样做是没有必要的，我们希望&lt;code&gt;swap&lt;/code&gt;交换指针，而不是分配&lt;code&gt;string&lt;/code&gt;的副本：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;string *temp = v1.ps;   //为 v1.ps 中的指针创建一个副本
v1.ps = v2.ps;  //将 v2.ps 中的指针赋予 v1.ps1
v2.ps = temp;   //将保存的 v1.ps 中原来的指针赋予 v2.ps
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;编写我们自己的 swap 函数&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;HasPtr&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;friend&lt;/span&gt; &lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="nx"&gt;swap&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;HasPtr&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;HasPtr&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="c1"&gt;//其他成员定义&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="nx"&gt;inline&lt;/span&gt; &lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="nx"&gt;swap&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;HasPtr&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;lhs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;HasPtr&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;using&lt;/span&gt; &lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nx"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;lhs&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;ps&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;ps&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   &lt;span class="c1"&gt;//交换指针，而不是string数据&lt;/span&gt;
    &lt;span class="nx"&gt;swap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;lhs&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;rhs&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;i&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;//交换 int 成员&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们首先将&lt;code&gt;swap&lt;/code&gt;定义为&lt;code&gt;friend&lt;/code&gt;以便能访问 HasPtr 的（private的）数据成员。由于&lt;code&gt;swap&lt;/code&gt;的存在就是为了优化代码，我们将其声明为&lt;code&gt;inline&lt;/code&gt;函数。&lt;/p&gt;
&lt;p&gt;与拷贝控制成员不同，&lt;code&gt;swap&lt;/code&gt;并不是必要的。但是，对于分配了资源的类，定义&lt;code&gt;swap&lt;/code&gt;可能是一种很重要的优化手段。&lt;/p&gt;
&lt;h3&gt;swap 函数应该调用 swap，而不是 std::swap&lt;/h3&gt;
&lt;p&gt;在&lt;code&gt;swap&lt;/code&gt;函数中，使用了&lt;code&gt;using std::swap&lt;/code&gt;，如果这个类有自己的&lt;code&gt;swap&lt;/code&gt;函数，匹配程度会高于标准库&lt;code&gt;swap&lt;/code&gt;，会优先使用类自己的&lt;code&gt;swap&lt;/code&gt;，如果没有，则使用标准库的&lt;code&gt;swap&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;swap&lt;/code&gt;里交换类的指针和&lt;code&gt;int&lt;/code&gt;成员，并不会发生递归循环，HasPtr 的数据成员是内置类型的，这时候会调用标准库版本的&lt;code&gt;swap&lt;/code&gt;。&lt;/p&gt;
&lt;h3&gt;在赋值运算符中使用 swap&lt;/h3&gt;
&lt;p&gt;定义&lt;code&gt;swap&lt;/code&gt;的类通常用&lt;code&gt;swap&lt;/code&gt;来定义它们的赋值运算符。这些运算符使用了一种名为拷贝并交换（copy and swap）的技术。这种技术将左侧运算对象与右侧运算对象的一个副本进行交换：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//注意 rhs 是按值传递的，意味着 HasPtr 的拷贝构造函数将
//右侧运算对象中的 string 拷贝到 rhs
HasPtr&amp;amp; HasPtr::operator=(HasPtr rhs)
{
    //交换左侧运算对象和局部变量 rhs 的内容
    swap(*this, rhs);   //rhs 现在指向本对象曾经使用的内存
    return *this;   //rhs 被销毁，从而 delete 了 rhs 中的指针
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在进行 HasPtr 类的赋值运算中，先将右侧对象拷贝到拷贝赋值运算符函数里，然后交换左侧对象的指针和右侧对象的指针，交换后，右侧对象赋值给了左侧对象，左侧对象相应的&lt;code&gt;string&lt;/code&gt;指针也指向了右侧对象副本的对应成员，而右侧对象的&lt;code&gt;string&lt;/code&gt;指针则指向了左侧对象的相应成员。在这个函数结束后，右侧对象的副本被销毁，于是原来左侧对象的资源被释放，而左侧对象现在保存的是右侧对象的成员。&lt;/p&gt;
&lt;p&gt;拷贝并交换的操作，和之前的拷贝赋值运算符的实现原理是相同的， 在改变左侧对象之前拷贝右侧对象。保证了这样的操作异常的安全。&lt;/p&gt;
&lt;h2&gt;对象移动&lt;/h2&gt;
&lt;p&gt;待续...&lt;/p&gt;</content><category term="C++"></category></entry><entry><title>C++ Primer 第十二章 动态内存</title><link href="https://xutree.github.io/pages/2018/10/17/C++_Primer_Chapter_12/" rel="alternate"></link><published>2018-10-17T22:25:02+08:00</published><updated>2018-10-20T14:50:55+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-17:/pages/2018/10/17/C++_Primer_Chapter_12/</id><summary type="html">&lt;p&gt;一个由 C/C++ 编译的程序占用的内存分为以下几个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;栈区（stack）：由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈&lt;/li&gt;
&lt;li&gt;堆区（heap）：一般由程序员分配释放，若程序员不释放，程序结束时可能由 OS 回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表&lt;/li&gt;
&lt;li&gt;全局区（静态区）（static）：全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量、未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放&lt;/li&gt;
&lt;li&gt;文字常量区：常量字符串就是放在这里的。程序结束后由系统释放&lt;/li&gt;
&lt;li&gt;程序代码区：存放函数体的二进制代码&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;动态内存与智能指针&lt;/h2&gt;
&lt;p&gt;在 C++ 中，动态内存的管理是通过一对运算符来完成的：&lt;code&gt;new&lt;/code&gt;，在动态内存中为对象分配空间并返回一个指向该对象的指针，我们可以选择对对象进行初始化；&lt;code&gt;delete&lt;/code&gt;，接受一个动态指针，销毁该对象，并释放与之关联的内存。&lt;/p&gt;
&lt;p&gt;为了更容易地使用动态内存，新的标准提供了两种智能指针(smart pointer)类型来管理动态对象。&lt;code&gt;shared_ptr …&lt;/code&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;一个由 C/C++ 编译的程序占用的内存分为以下几个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;栈区（stack）：由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈&lt;/li&gt;
&lt;li&gt;堆区（heap）：一般由程序员分配释放，若程序员不释放，程序结束时可能由 OS 回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表&lt;/li&gt;
&lt;li&gt;全局区（静态区）（static）：全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量、未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放&lt;/li&gt;
&lt;li&gt;文字常量区：常量字符串就是放在这里的。程序结束后由系统释放&lt;/li&gt;
&lt;li&gt;程序代码区：存放函数体的二进制代码&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;动态内存与智能指针&lt;/h2&gt;
&lt;p&gt;在 C++ 中，动态内存的管理是通过一对运算符来完成的：&lt;code&gt;new&lt;/code&gt;，在动态内存中为对象分配空间并返回一个指向该对象的指针，我们可以选择对对象进行初始化；&lt;code&gt;delete&lt;/code&gt;，接受一个动态指针，销毁该对象，并释放与之关联的内存。&lt;/p&gt;
&lt;p&gt;为了更容易地使用动态内存，新的标准提供了两种智能指针(smart pointer)类型来管理动态对象。&lt;code&gt;shared_ptr&lt;/code&gt;允许多个指针指向同一个对象；&lt;code&gt;unique_ptr&lt;/code&gt;则“独占”所指向的对象。标准库还定义了一个名为&lt;code&gt;weak_ptr&lt;/code&gt;的伴随类，指向&lt;code&gt;shared_ptr&lt;/code&gt;所管理的对象。这三种类型都定义在&lt;code&gt;memory&lt;/code&gt;头文件中。&lt;/p&gt;
&lt;h3&gt;shared_ptr 类&lt;/h3&gt;
&lt;p&gt;类似&lt;code&gt;vector&lt;/code&gt;智能指针也是模板：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;shared_ptr&amp;lt;string&amp;gt; p1;  //shared_ptr，可以指向 string
shared_ptr&amp;lt;list&amp;lt;int&amp;gt;&amp;gt; p2;   //shared_ptr,可以指向 int 的 list
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当我们创建&lt;code&gt;shared_ptr&lt;/code&gt;时，可以传递一个（可选的）指向删除器函数的参数。&lt;/p&gt;
&lt;p&gt;智能指针操作：&lt;/p&gt;
&lt;p&gt;&lt;img alt="智能指针操作" src="https://xutree.github.io/images/c++12-1.jpg"&gt;&lt;/p&gt;
&lt;h4&gt;make_shared 函数&lt;/h4&gt;
&lt;p&gt;最安全的分配和使用动态内存的方法是调用一个名为&lt;code&gt;make_shared&lt;/code&gt;的标准库函数。此函数在动态内存中分配一个对象并初始化它，返回指向此对象的&lt;code&gt;shared_ptr&lt;/code&gt;。与智能指针一样，&lt;code&gt;make_shared&lt;/code&gt;也定义在&lt;code&gt;memory&lt;/code&gt;头文件中。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//指向一个值为42的 int 的 shared_ptr
shared_ptr&amp;lt;int&amp;gt; p3 = make_shared&amp;lt;int&amp;gt;(42);
//p4 指向一个值为”999999999”的 string
shared_ptr&amp;lt;string&amp;gt; p4 = make_shared&amp;lt;string&amp;gt;(10,&amp;#39;9&amp;#39;);
//p5 指向一个值初始化的 int，即，值为0
shared_ptr&amp;lt;int&amp;gt; p5 = make_shared&amp;lt;int&amp;gt;();
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;类似顺序容器的&lt;code&gt;emplace&lt;/code&gt;成员，&lt;code&gt;make_shared&lt;/code&gt;用其参数来构造给定类型的对象。例如，调用&lt;code&gt;make_shared&amp;lt;string&amp;gt;&lt;/code&gt;时传递的参数必须与&lt;code&gt;string&lt;/code&gt;的某个构造函数相匹配。&lt;/p&gt;
&lt;p&gt;当然，我们通常用&lt;code&gt;auto&lt;/code&gt;定义一个对象来保存&lt;code&gt;make_shared&lt;/code&gt;的结果，这种方式简单：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//p6 指向一个动态分配的空 vector&amp;lt;string&amp;gt;
auto p6 = make_shared&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt;();
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;shared_ptr 的拷贝和赋值&lt;/h4&gt;
&lt;p&gt;当进行拷贝或赋值操作时，每个&lt;code&gt;shared_ptr&lt;/code&gt;都会记录有多少个其他&lt;code&gt;shared_ptr&lt;/code&gt;指向相同的对象。&lt;/p&gt;
&lt;p&gt;我们可以认为每个&lt;code&gt;shared_ptr&lt;/code&gt;都有一个关联的计数器，通常称其为引用计数(reference count)。无论何时我们拷贝一个&lt;code&gt;shared_ptr&lt;/code&gt;，计数器都会递增；当我们给&lt;code&gt;shared_ptr&lt;/code&gt;赋予一个新值或是&lt;code&gt;shared_ptr&lt;/code&gt;被销毁时，计算器就会递减。
一旦一个&lt;code&gt;shared_ptr&lt;/code&gt;的计数器变为0，它就会自动释放自己所管理的对象。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;auto r = make_shared&amp;lt;int&amp;gt;(42);  //r 指向的 int 只有一个引用者
r = q;  //给 r 赋值，令它指向另一个地址
    //递增 q 指向的对象的引用计数
    //递减 r 原来指向对象的引用计数
    //r 原来指向的对象已没有引用者，会自动释放
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;shared_ptr&lt;/code&gt;自动销毁所管理的对象，还会自动释放相关联的内存。&lt;/p&gt;
&lt;p&gt;如果你将&lt;code&gt;shared_ptr&lt;/code&gt;存放于一个容器中，而后不再需要全部元素，要记得使用&lt;code&gt;erase&lt;/code&gt;删除不需要的那些元素，否则&lt;code&gt;shared_ptr&lt;/code&gt;在无用之后会仍然保留。&lt;/p&gt;
&lt;h3&gt;直接管理内存&lt;/h3&gt;
&lt;p&gt;C++ 语言定义了两个运算符来分配和释放动态内存。运算符&lt;code&gt;new&lt;/code&gt;分配内存，&lt;code&gt;delete&lt;/code&gt;释放&lt;code&gt;new&lt;/code&gt;分配的内存。相对于智能指针，使用这两个运算符管理内存非常容易出错。&lt;/p&gt;
&lt;h4&gt;使用 new 动态分配和初始化对象&lt;/h4&gt;
&lt;p&gt;在自由空间分配的内存是无名的，因此&lt;code&gt;new&lt;/code&gt;无法为其分配的对象命名，而是返回一个指向该对象的指针：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int *pi = new int;    //pi 指向一个动态分配的、未初始化的无名对象
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;默认情况下，动态分配的对象是默认初始化的，这意味着内置类型或组合类型的对象的值将是未定义的，而类类型对象将用默认构造函数进行初始化：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;string *ps = new string;    //初始化为空 string
int *pi = new int;  //pi 指向一个未初始化的 int

//可以使用直接初始化方式来初始化一个动态分配的对象
int *pi = new int(1024);    //pi 指向的对象的值为1024
string *ps = new string(10,&amp;#39;9&amp;#39;);    //*ps 为“999999999”
//vector 有10个元素，值依次从0到9
vector&amp;lt;int&amp;gt; *pv = new vector&amp;lt;int&amp;gt;{0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;也可以对动态分配的对象进行值初始化，只需在类型名之后跟一对空括号即可：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;string *ps1 = new string;   //默认初始化为空 string
string *ps = new string();  //值初始化为空 string
int *pi1 = new int;     //默认初始化；*pi1 的值未定义
int *pi2 = new int();       //值初始化为0；*pi2 为0
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果我们提供了一个括号包围的初始化器，就可以用&lt;code&gt;auto&lt;/code&gt;从此初始化器推断我们想要分配的对象的类型。但是由于编译器要用初始化器类型来推断分配的类型，只有当括号中仅有单一初始化器时才可以使用&lt;code&gt;auto&lt;/code&gt;（这也意味着不能用&lt;code&gt;auto&lt;/code&gt;动态分配数组）。&lt;/p&gt;
&lt;h4&gt;动态分配的 const 对象&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//分配并初始化一个 const int
const int *pci = new const int(1024);
//分配并默认初始化一个 const 的空 string
const string *pcs =new const string;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;类似其他任何&lt;code&gt;const&lt;/code&gt;对象，一个动态分配的&lt;code&gt;const&lt;/code&gt;对象必须进行初始化。对于一个定义了默认构造函数的类类型，其&lt;code&gt;const&lt;/code&gt;动态对象可以隐式初始化，而其他类型的对象就必须显式初始化。由于分配的对象是&lt;code&gt;const&lt;/code&gt;的，&lt;code&gt;new&lt;/code&gt;返回的指针是一个指向&lt;code&gt;const&lt;/code&gt;的指针。&lt;/p&gt;
&lt;h4&gt;内存耗尽&lt;/h4&gt;
&lt;p&gt;默认情况下，如果&lt;code&gt;new&lt;/code&gt;不能分配所要求的内存空间，它会抛出一个类型为&lt;code&gt;bad_alloc&lt;/code&gt;的异常。我们可以改变使用&lt;code&gt;new&lt;/code&gt;的方式来阻止它抛出异常：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//若果分配失败，new返回一个空指针
int *p1 = new int;  //如果分配失败，new 抛出std::bad_alloc
int *p2 = new (nothrow) int;    //如果分配失败，new 返回一个空指针
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们称这种形式的&lt;code&gt;new&lt;/code&gt;为定位&lt;code&gt;new&lt;/code&gt;，&lt;code&gt;bad_alloc&lt;/code&gt;和&lt;code&gt;nothrow&lt;/code&gt;都定义在&lt;code&gt;new&lt;/code&gt;头文件中。&lt;/p&gt;
&lt;h4&gt;释放动态内存&lt;/h4&gt;
&lt;p&gt;为了防止内存耗尽，在动态内存使用完毕后，必须将其归还给系统。我们通过&lt;code&gt;delete&lt;/code&gt;表达式(delete expression)来将动态内存归还给系统。&lt;/p&gt;
&lt;p&gt;与&lt;code&gt;new&lt;/code&gt;类似，&lt;code&gt;delete&lt;/code&gt;表达式也执行两个动作：销毁给定的指针指向的对象；释放对应的内存。在&lt;code&gt;delete&lt;/code&gt;之后，指针就变成了人们所说的空悬指针，即指向一块曾经保存数据对象但现在已经无效的内存的指针。如果需要保留指针，可以在&lt;code&gt;delete&lt;/code&gt;之后将&lt;code&gt;nullptr&lt;/code&gt;赋予指针。&lt;/p&gt;
&lt;h4&gt;使用 new 和 delete 管理动态内存存在的三个常见问题&lt;/h4&gt;
&lt;p&gt;忘记&lt;code&gt;delete&lt;/code&gt;内存。忘记释放动态内存会导致人们常说的“内存泄露”问题，因为这种内存永远不可能归还给自由空间了。查找内存泄露错误是非常困难的。&lt;/p&gt;
&lt;p&gt;使用已经释放掉的对象。通过在释放内存后将指针置为空，有时可以检测出这种错误。&lt;/p&gt;
&lt;p&gt;同一块内存释放两次。当两个指针指向相同的动态分配对象时，可能发生这种错误。&lt;/p&gt;
&lt;h3&gt;shared_ptr 和 new 结合使用&lt;/h3&gt;
&lt;p&gt;如前所述，如果我们不初始化一个智能指针，他就会被初始化为一个空指针。如下表所示，我们还可以用&lt;code&gt;new&lt;/code&gt;返回的指针来初始化智能指针：&lt;/p&gt;
&lt;p&gt;&lt;img alt="智能指针其他操作" src="https://xutree.github.io/images/c++12-2.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="智能指针其他操作" src="https://xutree.github.io/images/c++12-3.jpg"&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;shared_ptr&amp;lt;double&amp;gt; p1;  //shared_ptr 可以指向一个 double
shared_ptr&amp;lt;int&amp;gt; p2(new int (42));   //p2 指向一个值为42的 int
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;接受指针参数的智能指针构造函数是&lt;code&gt;explicit&lt;/code&gt;的。因此，我们不能将一个内置指针隐式转换为一个智能指针，必须使用直接初始化形式来初始化一个智能指针：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;shared_ptr&amp;lt;int&amp;gt; p1 = new int(1024); //错误：必须使用直接初始化形式
shared_ptr&amp;lt;int&amp;gt; p2(new int (1024)); //正确：使用了直接初始化
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;出于相同的原因，一个返回&lt;code&gt;shared_ptr&lt;/code&gt;的函数不能在其返回语句中隐式转换一个普通指针：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;shared_ptr&amp;lt;int&amp;gt; clone(int p){
    return new int(p);  //错误：隐式转换为 shared_ptr&amp;lt;int&amp;gt;
}
//我们必须将 shared_ptr 显式绑定到一个想要返回的指针上：
shared_ptr&amp;lt;int&amp;gt; clone(int p){
    //正确：显式地用 int* 创建 shared_ptr&amp;lt;int&amp;gt;
    return shared_ptr&amp;lt;int&amp;gt;(new int(p));
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;默认情况下，一个用来初始化智能指针的普通指针必须指向动态内存，因为智能指针默认使用&lt;code&gt;delete&lt;/code&gt;释放它所关联的对象。&lt;/p&gt;
&lt;p&gt;不要混合使用普通指针和智能指针：&lt;/p&gt;
&lt;p&gt;&lt;img alt="不要混合使用普通指针和智能指针" src="https://xutree.github.io/images/c++12-4.jpg"&gt;&lt;/p&gt;
&lt;p&gt;也不要使用get初始化另一个智能指针或为智能指针赋值：&lt;/p&gt;
&lt;p&gt;&lt;img alt="不要使用get初始化另一个智能指针或为智能指针赋值" src="https://xutree.github.io/images/c++12-5.jpg"&gt;&lt;/p&gt;
&lt;h3&gt;unique_ptr 指针&lt;/h3&gt;
&lt;p&gt;一个&lt;code&gt;unique_ptr&lt;/code&gt;“拥有”它所指向的对象。与&lt;code&gt;shared_ptr&lt;/code&gt;不同，某个时刻只能有一个&lt;code&gt;unique_ptr&lt;/code&gt;指向一个给定对象。&lt;/p&gt;
&lt;p&gt;与&lt;code&gt;shared_ptr&lt;/code&gt;不同，没有类似&lt;code&gt;make_shared&lt;/code&gt;的标准库函数返回一个&lt;code&gt;unique_ptr&lt;/code&gt;。当我们定义一个&lt;code&gt;unique_ptr&lt;/code&gt;时，需要将其绑定到一个&lt;code&gt;new&lt;/code&gt;返回的指针上。类似&lt;code&gt;shared_ptr&lt;/code&gt;，初始化&lt;code&gt;unique_ptr&lt;/code&gt;必须采用直接初始化形式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;unique_ptr&amp;lt;double&amp;gt; p1;  //可以指向一个 double 的 unique_ptr
unique_ptr&amp;lt;int&amp;gt; p2(new int(42));    //p2 指向一个值为42的 int
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;由于一个&lt;code&gt;unique_ptr&lt;/code&gt;拥有它指向的对象，因此&lt;code&gt;unique_ptr&lt;/code&gt;不支持普通的拷贝或赋值操作：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;unique_ptr&amp;lt;string&amp;gt; p1(new string(&amp;quot;Stegosaurus&amp;quot;);
unique_ptr&amp;lt;string&amp;gt; p2(p1);  //错误：unique_ptr 不支持拷贝
unique_ptr&amp;lt;string&amp;gt; p3;
p3 = p2;    //错误：unique_ptr 不支持赋值
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;unique_ptr&lt;/code&gt;特有的操作：&lt;/p&gt;
&lt;p&gt;&lt;img alt="unique_ptr特有的操作" src="https://xutree.github.io/images/c++12-6.jpg"&gt;&lt;/p&gt;
&lt;p&gt;虽然我不能拷贝或赋值&lt;code&gt;unique_ptr&lt;/code&gt;，但可以通过调用&lt;code&gt;release&lt;/code&gt;或&lt;code&gt;reset&lt;/code&gt;将指针的所有权从一个（非&lt;code&gt;const&lt;/code&gt;）&lt;code&gt;unique_ptr&lt;/code&gt;转移给另一个&lt;code&gt;unique&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//将所有权从 p1（指向 string Stegosaurus）转移给 p2
unique_ptr&amp;lt;string&amp;gt; p2(p1.release());    //release 将 p1 置为空
unique_ptr&amp;lt;string&amp;gt; p3(new string(&amp;quot;Trex&amp;quot;));
//将所有权从 p3 转移给 p2
p2.reset(p3.release()); //reset 释放了 p2 原来指向的内存
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;调用&lt;code&gt;release&lt;/code&gt;会切断&lt;code&gt;unique_ptr&lt;/code&gt;和它原来管理的对象间的联系。&lt;code&gt;release&lt;/code&gt;返回的指针通常被用来初始化另一个智能指针或给另一个智能指针赋值。&lt;/p&gt;
&lt;h4&gt;传递 unique_ptr 参数和返回 unique_ptr&lt;/h4&gt;
&lt;p&gt;不能拷贝&lt;code&gt;unique_ptr&lt;/code&gt;的规则有一个例外：我们可以拷贝或赋值一个将要被销毁的&lt;code&gt;unique_ptr&lt;/code&gt;。最常见的例子是从函数返回一个&lt;code&gt;unique_ptr&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;unique_ptr&amp;lt;int&amp;gt; clone(int p){
    //正确：从int*创建一个unique_ptr&amp;lt;int&amp;gt;
    return unique_ptr&amp;lt;int&amp;gt;(new int(p));
}
//还可以返回一个局部对象的拷贝
unique_ptr&amp;lt;int&amp;gt; clone(int p){
    unique_ptr&amp;lt;int&amp;gt; ret(new int(p));
    //...
    return ret;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;对于两段代码，编译器都知道要返回的对象将要销毁。在此情况下，编译器执行一种特殊的“拷贝”。&lt;/p&gt;
&lt;h4&gt;向 unique_ptr 传递删除器&lt;/h4&gt;
&lt;p&gt;类似&lt;code&gt;shared_ptr&lt;/code&gt;，&lt;code&gt;unique_ptr&lt;/code&gt;默认情况下用&lt;code&gt;delete&lt;/code&gt;释放它指向的对象。与&lt;code&gt;shared_ptr&lt;/code&gt;一样，我们可以重载一个&lt;code&gt;unique_ptr&lt;/code&gt;中默认的删除器。与重载关联容器的比较操作类似，我们必须在尖括号中&lt;code&gt;unique_ptr&lt;/code&gt;指向类型之后提供删除器类型。在创建或&lt;code&gt;reset&lt;/code&gt;一个这种&lt;code&gt;unique_ptr&lt;/code&gt;类型对象时，必须提供一个指定类型的可调用对象（删除器）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//p指向一个类型为 objT 的对象，并使用一个类型为 delT 的对象释放 objT 对象
//它会调用一个名为 fcn 的 delT 类型对象
unique_ptr&amp;lt;objT, delT&amp;gt; p(new objT,fcn);

//作为一个更具体的例子，我们将重写连接程序，用 unique_ptr 代替 shared_ptr
void f(destination &amp;amp;d /*其他需要的参数*/)
{
    connection c = connect(&amp;amp;d); //打开连接
    //当 p 被销毁时，连接将会关闭
    unique_ptr&amp;lt;connection, decltype(end_connection)*&amp;gt;
        p(&amp;amp;c, end_connection);
    //使用连接
    //当 f 退出时，connection 会被正确关闭
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;weak_ptr&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;weak_ptr&lt;/code&gt;是一种不控制所指向对象生存期的智能指针，它指向由一个&lt;code&gt;shared_ptr&lt;/code&gt;管理的对象。将一个&lt;code&gt;weak_ptr&lt;/code&gt;绑定到一个&lt;code&gt;shared_ptr&lt;/code&gt;不会改变&lt;code&gt;shared_ptr&lt;/code&gt;的引用计数。&lt;/p&gt;
&lt;p&gt;一旦最后一个指向对象的&lt;code&gt;shared_ptr&lt;/code&gt;被销毁，对象就会被释放，即使有&lt;code&gt;weak_ptr&lt;/code&gt;指向对象。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;weak_ptr&lt;/code&gt;操作：&lt;/p&gt;
&lt;p&gt;&lt;img alt="weak_ptr操作" src="https://xutree.github.io/images/c++12-7.jpg"&gt;&lt;/p&gt;
&lt;p&gt;当创建一个&lt;code&gt;weak_ptr&lt;/code&gt;时，要用一个&lt;code&gt;shared_ptr&lt;/code&gt;来初始化它：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;auto p = make_shared&amp;lt;int&amp;gt;(42);
weak_ptr&amp;lt;int&amp;gt; wp(p);    //wp 弱共享 p；p 的引用计数未改变
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;由于对象可能不存在，我们不能使用&lt;code&gt;weak_ptr&lt;/code&gt;直接访问对象，而必须调用&lt;code&gt;lock&lt;/code&gt;。此函数检查&lt;code&gt;weak_ptr&lt;/code&gt;指向的对象是否存在。&lt;/p&gt;
&lt;h2&gt;动态数组&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;new&lt;/code&gt;和&lt;code&gt;delete&lt;/code&gt;运算符一次分配/释放一个对象，但某些应用需要一次为很多对象分配内存的功能。为了支持这种需求，C++ 语言和标准库提供了两种一次分配一个对象数组的方法。C++ 语言定义了一种&lt;code&gt;new&lt;/code&gt;表达式，可以分配并初始化一个对象数组。
标准库中包含一个名为&lt;code&gt;allocator&lt;/code&gt;的类，允许我们将分配和初始化分离。使用&lt;code&gt;allocator&lt;/code&gt;通常会提供更好的性能和更灵活的内存管理能力。&lt;/p&gt;
&lt;p&gt;大多数应用应该使用标准库容器而不是动态分配的数组。使用容器更为简单、更不容易出现内存管理错误并且可能有更好的性能。&lt;/p&gt;
&lt;h3&gt;new 和数组&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//调用 get_size 确定分配多少个 int
int *pia = new int[get_size];   //pia 指向第一个 int
//方括号中的大小必须是整型，但不必是常量
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;typedef int arrT[42];   //arrT 表示42个 int 的数组类型
int *p = new arrT;  //
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;分配一个数组会得到一个元素类型的指针&lt;/h4&gt;
&lt;p&gt;虽然我们通常称&lt;code&gt;new T[]&lt;/code&gt;分配的内存为“动态数组”，但这种叫法某种程度上有些误导。当用&lt;code&gt;new&lt;/code&gt;分配一个数组时，我们并未得到一个数组类型的对象，而是得到一个数组元素类型的指针。&lt;/p&gt;
&lt;p&gt;由于分配的内存并不是一个数组类型，因此不能对动态数组调用&lt;code&gt;begin&lt;/code&gt;和&lt;code&gt;end&lt;/code&gt;。这些函数使用数组维度来返回指向首元素和尾元素的指针。处于相同的原因，也不能用范围&lt;code&gt;for&lt;/code&gt;语句来处理（所谓的）动态数组中的元素。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;要记住我们所说的动态数组并不是数组类型，这是很重要的。&lt;/strong&gt;&lt;/p&gt;
&lt;h4&gt;初始化动态分配对象的数组&lt;/h4&gt;
&lt;p&gt;默认情况下，&lt;code&gt;new&lt;/code&gt;分配的对象，不管是单个分配的还是数组中的，都是默认初始化的。可以对数组中的元素进行值初始化，方法是在大小之后跟一对空括号。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int *pia = new int[10]; //10个未初始化的 int
int *pia2 = new int[10]();  //10个值初始化为0的 int
string *psa = new string[10];   //10个空 string
string *psa2 = new string[10]();    //10个空 string
//在新标准中，我们还提供一个元素初始化器的花括号列表：
//10个 int 分别用列表中对应的初始化器初始化
int *pia3 = new int[10] {0,1,2,3,4,5,6,7,8,9};
//10个 string，前4个用给定的初始化器初始化，剩余的进行值初始化
string *psa3 = new string[10]{&amp;quot;a&amp;quot;, &amp;quot;an&amp;quot;, &amp;quot;the&amp;quot;, string(3,&amp;#39;x&amp;#39;)};
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果初始化器数目大于元素数目，则&lt;code&gt;new&lt;/code&gt;表达式失败，不会分配任何内存，并抛出&lt;code&gt;bad_array_new_length&lt;/code&gt;的异常，类似于&lt;code&gt;bad_alloc&lt;/code&gt;，此类型定义在头文件&lt;code&gt;new&lt;/code&gt;中。&lt;/p&gt;
&lt;h4&gt;动态分配一个空数组是合法的&lt;/h4&gt;
&lt;p&gt;我们在使用&lt;code&gt;new&lt;/code&gt;分配一个动态数组时，可以指定分配数组的大小为0，这样做是合法的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;char *pc = new char(0);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;此时&lt;code&gt;new&lt;/code&gt;返回一个与其他&lt;code&gt;new&lt;/code&gt;表达式返回类型都不同的指针类型， 该指针不能解引用，就像一个数组的尾后迭代器一样。&lt;/p&gt;
&lt;h4&gt;释放动态数组&lt;/h4&gt;
&lt;p&gt;为了释放动态数组，我们使用一种特殊形式的&lt;code&gt;delete&lt;/code&gt;——在指针前加上一个空括号对：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;delete p;    //p 必须指向一个动态分配的对象或为空
delete [] pa;  //pa 必须指向一个动态分配的数组或为空
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;第二条语句销毁 pa 指向的数组中的元素，并释放对应的内存。数组中的元素按逆序销毁，即，最后一个元素首先被销毁，然后是倒数第二个，以此类推。&lt;/p&gt;
&lt;p&gt;当我们释放一个动态数组时，空方括号是必须的，它指示编译器此指针指向一个对象数组的第一个元素。 &lt;code&gt;delete&lt;/code&gt;一个动态数组时未添加空方括号或&lt;code&gt;delete&lt;/code&gt;一个普通指针时添加了空方括号，其行为都是未定义的。&lt;/p&gt;
&lt;p&gt;前面我们讲到， 可以使用&lt;code&gt;typedef&lt;/code&gt;来给动态数组起一个别名，这样在&lt;code&gt;new&lt;/code&gt;一个动态数组时就不必添加方括号&lt;code&gt;[]&lt;/code&gt;，即使这样，我们在释放一个动态数组时，仍然需要添加方括号&lt;code&gt;[]&lt;/code&gt;，因为它本质上还是一个动态数组。&lt;/p&gt;
&lt;h4&gt;智能指针和动态数组&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;unique_ptr&lt;/code&gt;智能指针有个可以管理&lt;code&gt;new&lt;/code&gt;分配的动态数组的版本，为了使用一个&lt;code&gt;unique_ptr&lt;/code&gt;来管理动态数组，需要在对象类型后加一个空方括号&lt;code&gt;[]&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;unique_ptr&amp;lt;int[]&amp;gt; up(new int[10]());
up.release(); // 自动调用 delete [] 销毁其指针
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当一个&lt;code&gt;unique_ptr&lt;/code&gt;指向一个数组时，我们不能使用点和箭头成员运算符，毕竟，&lt;code&gt;unique_ptr&lt;/code&gt;指向的是一个数组而不是单个对象。不过，我们可以使用下表运算符来访问数组中的元素：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;for (size_t i = 0; i &amp;lt; 10; ++i)
    up[i] = i;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;shared_ptr&lt;/code&gt;不支持动态数组，如果希望使用&lt;code&gt;shared_ptr&lt;/code&gt;管理一个动态数组，我们需要提供自己的删除器：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;shared_ptr&amp;lt;int&amp;gt; sp(new int[10], [](int* p){ delete [] p; });
sp.reset();
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们在这个例子中使用&lt;code&gt;lambda&lt;/code&gt;做为&lt;code&gt;shared_ptr&lt;/code&gt;的删除器，如果我们不提供删除器，这样的行为是未定义的，因为默认情况下&lt;code&gt;shared_ptr&lt;/code&gt;使用&lt;code&gt;delete&lt;/code&gt;来释放内存，使用&lt;code&gt;delete&lt;/code&gt;来释放一个动态数组的定位是未定义的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;shared_ptr&lt;/code&gt;不支持动态数组这一特性会影响我们访问数组中的元素：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;for (size_t i = 0; i != 10; ++i)
    *(sp.get() + i) = i;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;shared_ptr&lt;/code&gt;没有定义下标运算符，而且智能指针不支持指针算术运算。因此，为了访问数组中的元素，我们必须用&lt;code&gt;get&lt;/code&gt;成员函数获取一个内置指针，然后使用该内置指针来访问数租元素。&lt;/p&gt;
&lt;h3&gt;allocator 类&lt;/h3&gt;
&lt;p&gt;标准库&lt;code&gt;allocator&lt;/code&gt;类定义在头文件&lt;code&gt;memory&lt;/code&gt;中。它帮助我们将内存分配和构造分离开来，它分配的内存是原始的、未构造的。&lt;/p&gt;
&lt;p&gt;类似&lt;code&gt;vector&lt;/code&gt;，&lt;code&gt;allocator&lt;/code&gt;也是一个模板类，我们在定义一个&lt;code&gt;allocator&lt;/code&gt;类类型的时候需要制定它要分配内存的类型，它会根据给定的对象类型来确定恰当的内存大小和对齐位置：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;allocator&amp;lt;string&amp;gt; alloc;
auto const p = alloc.allocate(n); // 分配 n 个未初始化的 string
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;allocator&lt;/code&gt;类及其算法：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;操作&lt;/th&gt;
&lt;th align="left"&gt;意义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;allocator&lt;T&gt; a&lt;/td&gt;
&lt;td align="left"&gt;定义了一个名为 a 的 allocator 对象，可以为类型为 T 的对象分配内存&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;a.allocate(n)&lt;/td&gt;
&lt;td align="left"&gt;分配一段原始的、未构造的内存，保存 n 个类型为 T 的对象&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;a.deallocate(p, n)&lt;/td&gt;
&lt;td align="left"&gt;释放从 T* 指针 p 中地址开始的内存，这块内存保存了 n 个类型为 T 的对象；p 必须是一个先前由 allocate 成员函数返回的指针，且 n 必须是创建时候的大小，在调用 deallocate 之前，用户必须对每个在在这块内存中创建的对象调用 destroy 函数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;a.construct(p, args)&lt;/td&gt;
&lt;td align="left"&gt;p 必须是一个类型为 T* 的指针，指向一块原始内存，args 被传递给类型为 T 的构造函数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;a.destroy(p)&lt;/td&gt;
&lt;td align="left"&gt;p 为 T* 类型的指针，此算法对 p 执行析构函数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4&gt;allocator 分配未构造的内存&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;auto q = p; //q 指向最后构造的元素之后的位置
alloc.construct(q++);   //*q 为空字符串
alloc.construct(q++, 10, &amp;#39;c&amp;#39;);  //*q 为cccccccccc
alloc.construct(q++, &amp;quot;hi&amp;quot;); //*q 为hi
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;为了使用&lt;code&gt;allocate&lt;/code&gt;返回的内存，我们必须用&lt;code&gt;construct&lt;/code&gt;构造对象。使用未构造的内存，其行为是未定义的。&lt;/p&gt;
&lt;p&gt;当我们用完对象后，必须对每个构造的元素调用&lt;code&gt;destroy&lt;/code&gt;来销毁它们。函数&lt;code&gt;destroy&lt;/code&gt;接受一个指针，对指向的对象执行析构函数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;while(q != p)
    alloc.destroy(--q); //释放我们真正构造的 string
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;一旦元素被销毁后，就可以重新使用这部分内存来保存其他&lt;code&gt;string&lt;/code&gt;，也可以将其归还给系统。释放内存通过调用&lt;code&gt;deallocate&lt;/code&gt;来完成：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;alloc.deallocate(p, n);
//传递给 deallocate 的指针不能为空，它必须指向由 allocate 分配的内存
//传递给 deallcoate 的大小参数必须与调用 allocate 分配内存时提供的大小参数具有一样的值
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们只能对真正构造了的元素进行&lt;code&gt;destroy&lt;/code&gt;操作。&lt;/p&gt;
&lt;h4&gt;拷贝和填充为初始化内存的算法&lt;/h4&gt;
&lt;p&gt;标准库为&lt;code&gt;allocator&lt;/code&gt;类定义了两个伴随算法，可以在未初始化内存中创建对象：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;操作&lt;/th&gt;
&lt;th align="left"&gt;意义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;uninitialized_copy(b, e, b2)&lt;/td&gt;
&lt;td align="left"&gt;从迭代器 b 和 e 指出的输入范围中拷贝元素到迭代器 b2 指定的未构造的原始内存中，b2 指向的内存必须足够大，能容下输入序列中的元素的拷贝&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;uninitialized_copy_n(b, n, b2)&lt;/td&gt;
&lt;td align="left"&gt;从迭代器 b 指向的元素开始，拷贝 n 个元素到 b2 开始的原始内存中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;uninitialized_fill(b, e, t)&lt;/td&gt;
&lt;td align="left"&gt;在迭代器 b 和 e 指定的原始内存范围中创建对象，值均为 t 的拷贝&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;uninitialized_fill_n(b, n, t)&lt;/td&gt;
&lt;td align="left"&gt;从迭代器 b 指向的原始内存地址开始创建 n 个对象，b 必须指向足够大的未构造的原始内存，能容纳给定数量的对象&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;这些函数在给定目的位置创建元素，而不是由系统分配内存给他们。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;vector&amp;lt;int&amp;gt; vec{0, 1, 2, 3, 4, 5};
auto p = alloc.allocate(vec.size() * 2);
auto q = uninitialized_copy(vec.begin(), vec.end(), p);
uninitialize_fill_n(q, vec.size(), 42);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;uninitialized_copy&lt;/code&gt;在给定位置构造元素，函数返回递增后的目的位置迭代器。因此，一个&lt;code&gt;uninitialized_copy&lt;/code&gt;调用会返回一个指针，指向 最后一个构造的元素之后的位置。&lt;/p&gt;</content><category term="C++"></category></entry><entry><title>C++ Primer 第十一章 关联容器</title><link href="https://xutree.github.io/pages/2018/10/17/C++_Primer_Chapter_11/" rel="alternate"></link><published>2018-10-17T21:12:37+08:00</published><updated>2018-10-17T21:12:37+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-17:/pages/2018/10/17/C++_Primer_Chapter_11/</id><summary type="html">&lt;p&gt;关联容器和顺序容器有着根本的不同：关联容器中的元素是按关键字来保存和访问的。与之相对，顺序容器中的元素是按它们在容器中的位置来顺序保存和访问的。&lt;/p&gt;
&lt;p&gt;关联容器支持高效的关键字查找和访问。两个主要的关联容器（associative-container）类型是 &lt;strong&gt;map&lt;/strong&gt; 和 &lt;strong&gt;set&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;map&lt;/code&gt;中的元素是一些关键字-值（key-value）对：关键字起到索引的作用，值则表示与索引相关联的数据。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;set&lt;/code&gt;中每个元素只包含一个关键字，&lt;code&gt;set&lt;/code&gt;支持高效的关键字查询操作。&lt;/p&gt;
&lt;p&gt;类型&lt;code&gt;map&lt;/code&gt;和&lt;code&gt;multimap&lt;/code&gt;定义在头文件&lt;code&gt;map&lt;/code&gt;中；&lt;code&gt;set&lt;/code&gt;和&lt;code&gt;multiset&lt;/code&gt;定义在头文件&lt;code&gt;set&lt;/code&gt;中；无序容器则定义在头文件&lt;code&gt;unordered_map&lt;/code&gt;和&lt;code&gt;unordered_set&lt;/code&gt;中。无序容器使用哈希函数来组织元素。&lt;/p&gt;
&lt;p&gt;关联容器类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;按关键字有序保存元素&lt;ul&gt;
&lt;li&gt;map：关联数组，保存关键字-值对&lt;/li&gt;
&lt;li&gt;set：关键字即值，即只保存关键字的容器&lt;/li&gt;
&lt;li&gt;multimap：关键字可重复的 …&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;关联容器和顺序容器有着根本的不同：关联容器中的元素是按关键字来保存和访问的。与之相对，顺序容器中的元素是按它们在容器中的位置来顺序保存和访问的。&lt;/p&gt;
&lt;p&gt;关联容器支持高效的关键字查找和访问。两个主要的关联容器（associative-container）类型是 &lt;strong&gt;map&lt;/strong&gt; 和 &lt;strong&gt;set&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;map&lt;/code&gt;中的元素是一些关键字-值（key-value）对：关键字起到索引的作用，值则表示与索引相关联的数据。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;set&lt;/code&gt;中每个元素只包含一个关键字，&lt;code&gt;set&lt;/code&gt;支持高效的关键字查询操作。&lt;/p&gt;
&lt;p&gt;类型&lt;code&gt;map&lt;/code&gt;和&lt;code&gt;multimap&lt;/code&gt;定义在头文件&lt;code&gt;map&lt;/code&gt;中；&lt;code&gt;set&lt;/code&gt;和&lt;code&gt;multiset&lt;/code&gt;定义在头文件&lt;code&gt;set&lt;/code&gt;中；无序容器则定义在头文件&lt;code&gt;unordered_map&lt;/code&gt;和&lt;code&gt;unordered_set&lt;/code&gt;中。无序容器使用哈希函数来组织元素。&lt;/p&gt;
&lt;p&gt;关联容器类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;按关键字有序保存元素&lt;ul&gt;
&lt;li&gt;map：关联数组，保存关键字-值对&lt;/li&gt;
&lt;li&gt;set：关键字即值，即只保存关键字的容器&lt;/li&gt;
&lt;li&gt;multimap：关键字可重复的 map&lt;/li&gt;
&lt;li&gt;multiset：关键字可重复的 set&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;无序集合&lt;ul&gt;
&lt;li&gt;unordered_map：用哈希函数组织的 map&lt;/li&gt;
&lt;li&gt;unordered_set：用哈希函数组织的 set&lt;/li&gt;
&lt;li&gt;unordered_multimap：哈希组织的 map，关键字可重复出现&lt;/li&gt;
&lt;li&gt;unordered_multiset：哈希组织的 set，关键字可重复出现&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;关联容器概述&lt;/h2&gt;
&lt;p&gt;关联容器（有序和无序的）都支持如下的普通容器操作：&lt;/p&gt;
&lt;p&gt;&lt;img alt="普通容器操作" src="https://xutree.github.io/images/c++11-1.jpg"&gt;&lt;/p&gt;
&lt;p&gt;关联容器不支持顺序容器位置相关的操作，例如&lt;code&gt;push_front&lt;/code&gt;或&lt;code&gt;push_back&lt;/code&gt;，关联容器也不支持构造函数或插入操作这些接受一个元素值和一个数量值的操作。&lt;/p&gt;
&lt;p&gt;关联容器的迭代器都是双向的。&lt;/p&gt;
&lt;h3&gt;定义关联容器&lt;/h3&gt;
&lt;p&gt;每个关联容器都定义一个默认构造函数，它创建一个指定类型的空容器。我们可以将关联容器初始化为另一个同类型容器的拷贝，或者从一个值范围来初始化关联容器，只要这些值可以转换为容器所需类型就行。在新标准下，我们也可以对关联容器进行值初始化，与往常一样，初始化器必须能够转换为容器中元素的类型：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;map&amp;lt;string, size_t&amp;gt; word_count; //空容器
//列表初始化
set&amp;lt;string&amp;gt; exclude = {&amp;quot;the&amp;quot;, &amp;quot;but&amp;quot;, &amp;quot;and&amp;quot;};
//两个元素，列表初始化
map&amp;lt;string, string&amp;gt; authors = { {&amp;quot;Joyce&amp;quot;, &amp;quot;James&amp;quot;}, {&amp;quot;Austen&amp;quot;, &amp;quot;Jane&amp;quot;}  };
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;关键字类型的要求&lt;/h3&gt;
&lt;h4&gt;有序容器&lt;/h4&gt;
&lt;p&gt;关键字类型必须定义元素比较的方法，默认情况下，标准库使用关键字类型的&lt;code&gt;&amp;lt;&lt;/code&gt;运算符来比较两个关键字。&lt;/p&gt;
&lt;h4&gt;无序容器&lt;/h4&gt;
&lt;p&gt;默认情况下，无序容器使用关键字类型的&lt;code&gt;==&lt;/code&gt;运算符来比较元素，它们还使用一个&lt;code&gt;hash&amp;lt;key_type&amp;gt;&lt;/code&gt;类型的对象来生成每个元素的哈希值。标准库为内置类型（包括指针）提供了&lt;code&gt;hash&lt;/code&gt;模板。还为一些标准库类型，包括&lt;code&gt;string&lt;/code&gt;和智能指针类型定义了&lt;code&gt;hash&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;因此，我们可以直接定义关键字是内置类型（包括指针类型）、&lt;code&gt;string&lt;/code&gt;还有智能指针类型的无序容器。&lt;/p&gt;
&lt;p&gt;但是，我们不能直接定义关键字类型为自定义类类型的无序容器。我们必须提供自己的&lt;code&gt;hash&lt;/code&gt;模板版本。&lt;/p&gt;
&lt;h4&gt;使用关键字类型的比较函数&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;multiset&amp;lt;Sales_data, decltype(compareIsbn)*&amp;gt; bookstore(compareIsbn);
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;用尖括号指出要定义哪种类型的容器，自定义的操作类型必须在尖括号中紧跟着元素类型给出&lt;/li&gt;
&lt;li&gt;比较操作的类型应该是一种函数指针类型&lt;/li&gt;
&lt;li&gt;在尖括号中的类型仅仅是一个类型而已，当我们创建一个容器（对象）时，才会以构造函数参数的形式提供真正的比较操作（其类型必须与尖括号中指定的类型吻合）&lt;/li&gt;
&lt;li&gt;当使用&lt;code&gt;decltype&lt;/code&gt;来获得一个函数指针类型时，必须加上一个“*”来指出我们需要一个函数指针类型&lt;/li&gt;
&lt;li&gt;用于初始化 bookstore 对象的参数也可以写作&lt;code&gt;&amp;amp;compareIsbn&lt;/code&gt;，因为函数名会自动转换为函数指针&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;pair 类型&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;pair&lt;/code&gt;标准库类型定义在头文件&lt;code&gt;utility&lt;/code&gt;中。一个&lt;code&gt;pair&lt;/code&gt;保存两个数据成员。&lt;code&gt;pair&lt;/code&gt;是一个用来生成特定类型的模板。&lt;code&gt;pair&lt;/code&gt;的默认构造函数对数据成员进行值初始化。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pair&lt;/code&gt;的成员是&lt;code&gt;public&lt;/code&gt;的，两个成员为&lt;code&gt;first&lt;/code&gt;和&lt;code&gt;second&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;标准库定义的&lt;code&gt;pair&lt;/code&gt;操作：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;操作&lt;/th&gt;
&lt;th align="left"&gt;意义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;pair&lt;T1, T2&gt; p;&lt;/td&gt;
&lt;td align="left"&gt;p 是一个 pair，两个类型分布为 T1 和 T2 的成员都进行值初始化&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;pair&lt;T1, T2&gt; p(v1, v2);&lt;/td&gt;
&lt;td align="left"&gt;用 v1 和 v2 初始化&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left" v1_="v1," v2&gt;pair&lt;T1, T2&gt; p = &lt;/td&gt;
&lt;td align="left"&gt;同上&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;make_pair(v1, v2)&lt;/td&gt;
&lt;td align="left"&gt;返回一个用 v1 和 v2 初始化的 pair，pair 的类型由 v1 和 v2 推断而来&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;p.first, p.second&lt;/td&gt;
&lt;td align="left"&gt;成员&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;p1 &lt;em&gt;relop&lt;/em&gt; p2&lt;/td&gt;
&lt;td align="left"&gt;关系运算符按字典顺序定义。关系运算利用元素的 &amp;lt; 运算符实现&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;p1 == p2, p1 != p2&lt;/td&gt;
&lt;td align="left"&gt;相等性判定利用元素的 == 运算符实现&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4&gt;创建返回 pair 对象的函数&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;pair&amp;lt;string, int&amp;gt; process(vector&amp;lt;string&amp;gt; &amp;amp;v)
{
    //处理 v
    if (!v.empty())
        //列表初始化
        return {v.back(), v.back().size()};
    else
        //隐式构造返回值
        return pair&amp;lt;string, int&amp;gt;();
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;关联容器操作&lt;/h2&gt;
&lt;p&gt;关联容器额外定义了一些类型别名：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;别名&lt;/th&gt;
&lt;th align="left"&gt;意义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;key_type&lt;/td&gt;
&lt;td align="left"&gt;此容器类型的关键字类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;mapped_type&lt;/td&gt;
&lt;td align="left"&gt;每个关键字关联的类型，只适用于&lt;code&gt;map&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;value_type&lt;/td&gt;
&lt;td align="left"&gt;对于&lt;code&gt;set&lt;/code&gt;，与 key_type 相同，对于&lt;code&gt;map&lt;/code&gt;，为 pair&lt;const key_type, mapped_type&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;由于我们不能改变一个元素的关键字，因此这些&lt;code&gt;pair&lt;/code&gt;的关键字部分是&lt;code&gt;const&lt;/code&gt;的。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;set&amp;lt;string&amp;gt;::value_type v1; //v1 是一个 string
set&amp;lt;string&amp;gt;::key_type v2;   //v2 是一个 string
map&amp;lt;string, int&amp;gt;::value_type v3;    //v3 是一个 pair&amp;lt;const string, int&amp;gt;
map&amp;lt;string, int&amp;gt;::key_type v4;  //v4 是一个 string
map&amp;lt;string, int&amp;gt;::mapped_type v5;   //v5 是一个 int
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;关联容器迭代器&lt;/h3&gt;
&lt;p&gt;当解引用一个关联容器迭代器时，我们会得到一个类型为容器的 value_type 的值的引用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对&lt;code&gt;map&lt;/code&gt;而言，得到&lt;code&gt;pair&lt;/code&gt;类型，其 first 成员保存&lt;code&gt;const&lt;/code&gt;关键字，second 成员保存值&lt;/li&gt;
&lt;li&gt;对&lt;code&gt;set&lt;/code&gt;而言，迭代器也是&lt;code&gt;const&lt;/code&gt;的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当使用一个迭代器遍历一个&lt;code&gt;map&lt;/code&gt;、&lt;code&gt;multimap&lt;/code&gt;、&lt;code&gt;set&lt;/code&gt;、&lt;code&gt;multiset&lt;/code&gt;时，迭代器按关键字升序遍历元素。&lt;/p&gt;
&lt;p&gt;我们通常不对关联容器使用泛型算法。在实际编程中，如果我们真的要对一个关联容器使用算法，要么将它作为一个源序列，要么将它作为一个目的位置。&lt;/p&gt;
&lt;h3&gt;添加元素&lt;/h3&gt;
&lt;p&gt;&lt;img alt="添加元素" src="https://xutree.github.io/images/c++11-2.jpg"&gt;&lt;/p&gt;
&lt;p&gt;返回值：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不包含重复关键字的容器：返回一个&lt;code&gt;pair&lt;/code&gt;，first 成员是一个迭代器，指向具有给定关键字的元素，second 成员是一个&lt;code&gt;bool&lt;/code&gt;值，关键字不存在，为&lt;code&gt;true&lt;/code&gt;，否则为&lt;code&gt;false&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;包含重复关键字的容器：返回一个指向新元素的迭代器&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;删除元素&lt;/h3&gt;
&lt;p&gt;&lt;img alt="删除元素" src="https://xutree.github.io/images/c++11-3.jpg"&gt;&lt;/p&gt;
&lt;h3&gt;map 下标操作&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;操作&lt;/th&gt;
&lt;th align="left"&gt;意义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;c[k]&lt;/td&gt;
&lt;td align="left"&gt;返回关键字为 k 的元素；如果 k 不在 c 中，添加一个关键字为 k 的元素，对其进行值初始化&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;c.at(k)&lt;/td&gt;
&lt;td align="left"&gt;访问关键字为 k 的元素，带参数检查；若 k 不在 c 中，抛出 out_of_range 异常&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;由于下标运算可能插入一个新元素，我们只可以对非&lt;code&gt;const&lt;/code&gt;的&lt;code&gt;map&lt;/code&gt;使用下标操作。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;map&lt;/code&gt;下标操作与其他下标操作不同的地方：对&lt;code&gt;map&lt;/code&gt;进行下标操作时，会得到一个 mapped_type 对象；但当解引用一个&lt;code&gt;map&lt;/code&gt;迭代器时，得到一个 value_type 对象。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;map&lt;/code&gt;下标操作与其他下标操作相同的地方：返回一个左值，可读也可写。&lt;/p&gt;
&lt;h3&gt;访问元素&lt;/h3&gt;
&lt;p&gt;&lt;img alt="访问元素" src="https://xutree.github.io/images/c++11-4.jpg"&gt;&lt;/p&gt;
&lt;p&gt;lower_bound 和 upper_bound 不适用于无序容器。&lt;/p&gt;
&lt;p&gt;下标和 at 操作只适用于非&lt;code&gt;const&lt;/code&gt;的&lt;code&gt;map&lt;/code&gt;和&lt;code&gt;unordered_map&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;对&lt;code&gt;map&lt;/code&gt;使用 find 代替下标操作，以防添加不存在元素。&lt;/p&gt;
&lt;h2&gt;无序容器&lt;/h2&gt;
&lt;p&gt;新标准定义了4个无序关联容器（unordered associative container）。这些容器不是使用比较运算符来组织元素，而是使用一个哈希函数和关键字类型的 == 运算符。&lt;/p&gt;
&lt;p&gt;除了哈希管理操作之外，无序容器还提供了与有序容器相同的操作。&lt;/p&gt;
&lt;h3&gt;管理桶&lt;/h3&gt;
&lt;p&gt;无序容器在存储上组织为一组桶，每个桶保存零个或多个元素。&lt;/p&gt;
&lt;p&gt;无序容器使用一个哈希函数将元素映射到桶。&lt;/p&gt;
&lt;p&gt;为了访问一个元素，容器首先计算元素的哈希值，它指出应该搜索哪个桶。&lt;/p&gt;
&lt;p&gt;容器将具有一个特定哈希值的所有元素都保存在相同的桶中。&lt;/p&gt;
&lt;p&gt;如果容器允许重复关键字，所有具有相同关键字的元素也都会在同一个桶中。&lt;/p&gt;
&lt;p&gt;无序容器的性能依赖于哈希函数的质量和桶的数量和大小。&lt;/p&gt;
&lt;p&gt;对于相同的参数，哈希函数必须总是产生相同的结果。&lt;/p&gt;
&lt;p&gt;理想情况下，哈希函数还能将每个特定的值映射到唯一的桶。但是将不同关键字的元素映射到相同的桶也是允许的。&lt;/p&gt;
&lt;p&gt;当一个桶保存多个元素时，需要顺序搜索这些元素来查找我们想要的那个。计算一个元素的哈希值和在桶中搜索通常都是很快的操作。但是如果一个桶保存了很多元素，那么查找一个特定元素就需要大量比较操作。&lt;/p&gt;
&lt;p&gt;无序容器提供了一组管理桶的函数：&lt;/p&gt;
&lt;p&gt;&lt;img alt="桶管理操作" src="https://xutree.github.io/images/c++11-5.jpg"&gt;&lt;/p&gt;
&lt;h3&gt;无序容器对关键字类型的要求&lt;/h3&gt;
&lt;p&gt;&lt;img alt="无序容器" src="https://xutree.github.io/images/c++11-6.jpg"&gt;&lt;/p&gt;</content><category term="C++"></category></entry><entry><title>C++ Primer 第十章 泛型算法</title><link href="https://xutree.github.io/pages/2018/10/17/C++_Primer_Chapter_10/" rel="alternate"></link><published>2018-10-17T16:10:44+08:00</published><updated>2018-10-17T17:10:03+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-17:/pages/2018/10/17/C++_Primer_Chapter_10/</id><summary type="html">&lt;p&gt;顺序容器只定义了很少的操作：在多数情况下，我们可以添加和删除元素。访问首尾元素、确定容器是否为空以及获得指向首元素或尾元素之后位置的迭代器。&lt;/p&gt;
&lt;p&gt;如果我们想要做：查找特定元素、替换或删除一个特定值、重排元素顺序等。标准库并未给每个容器都定义成员函数来实现这些操作，而是定义了一组泛型算法：称它们为“算法”，是因为它们实现了一些经典算法的公共接口，如排序和搜索；称它们是“泛型的”，是因为它们可用于不同类型的元素和多种容器类型（不仅包括标准库类型，如&lt;code&gt;vector&lt;/code&gt;或&lt;code&gt;list&lt;/code&gt;，还包括内置的数组类型）。&lt;/p&gt;
&lt;h2&gt;概述&lt;/h2&gt;
&lt;p&gt;大多数算法都定义在头文件&lt;code&gt;algorithm&lt;/code&gt;中。标准库还在头文件&lt;code&gt;numeric&lt;/code&gt;中定义了一组数值泛型算法。&lt;/p&gt;
&lt;p&gt;一般情况下，这些算法并不直接操作容器，而是遍历由两个迭代器指定的一个元素范围来进行操作。通常情况下，算法遍历范围，对其中每个元素进行一些处理。&lt;/p&gt;
&lt;p&gt;迭代器令算法不依赖于容器，但算法依赖于元素类型的操作。虽然迭代器的使用令算法不依赖于容器类型。但大多数算法都使用了一个(或多个)元素类型上的操作。例如，&lt;code&gt;find&lt;/code&gt;用元素的&lt;code&gt;==&lt;/code&gt;运算符完成每个元素与给定值的比较。其他算法可能要求元素类型支持&lt;code&gt;&amp;lt;&lt;/code&gt;运算符。不过 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;顺序容器只定义了很少的操作：在多数情况下，我们可以添加和删除元素。访问首尾元素、确定容器是否为空以及获得指向首元素或尾元素之后位置的迭代器。&lt;/p&gt;
&lt;p&gt;如果我们想要做：查找特定元素、替换或删除一个特定值、重排元素顺序等。标准库并未给每个容器都定义成员函数来实现这些操作，而是定义了一组泛型算法：称它们为“算法”，是因为它们实现了一些经典算法的公共接口，如排序和搜索；称它们是“泛型的”，是因为它们可用于不同类型的元素和多种容器类型（不仅包括标准库类型，如&lt;code&gt;vector&lt;/code&gt;或&lt;code&gt;list&lt;/code&gt;，还包括内置的数组类型）。&lt;/p&gt;
&lt;h2&gt;概述&lt;/h2&gt;
&lt;p&gt;大多数算法都定义在头文件&lt;code&gt;algorithm&lt;/code&gt;中。标准库还在头文件&lt;code&gt;numeric&lt;/code&gt;中定义了一组数值泛型算法。&lt;/p&gt;
&lt;p&gt;一般情况下，这些算法并不直接操作容器，而是遍历由两个迭代器指定的一个元素范围来进行操作。通常情况下，算法遍历范围，对其中每个元素进行一些处理。&lt;/p&gt;
&lt;p&gt;迭代器令算法不依赖于容器，但算法依赖于元素类型的操作。虽然迭代器的使用令算法不依赖于容器类型。但大多数算法都使用了一个(或多个)元素类型上的操作。例如，&lt;code&gt;find&lt;/code&gt;用元素的&lt;code&gt;==&lt;/code&gt;运算符完成每个元素与给定值的比较。其他算法可能要求元素类型支持&lt;code&gt;&amp;lt;&lt;/code&gt;运算符。不过，我们将会看到，大多数算法提供了一种方法，允许我们使用自定义的操作来代替默认的运算符。&lt;/p&gt;
&lt;p&gt;泛型算法本身不会执行容器的操作，它们只会运行与迭代器之上，执行迭代器的操作。泛型算法运行于迭代器之上而不会执行容器操作的特性带来了一个令人惊讶但非常必要的编程假定：算法永远不会改变底层容器的大小。算法可能改变容器中保存的元素的值，也可能在容器内移动元素，但永远不会直接添加或删除元素。&lt;/p&gt;
&lt;h2&gt;初识泛型算法&lt;/h2&gt;
&lt;p&gt;除了少数例外，标准库算法都对一个范围内的元素进行操作。我们将此元素范围称为“输入范围”。接受输入范围的算法总是使用前两个参数来表示此范围，两个参数分别是指想要处理的第一个元素和尾元素之后位置的迭代器。&lt;/p&gt;
&lt;h3&gt;只读算法&lt;/h3&gt;
&lt;p&gt;一些算法只会读取其输入范围内的元素，而从不改变元素。&lt;code&gt;find&lt;/code&gt;就是这样一种算法。&lt;/p&gt;
&lt;h4&gt;accumulate&lt;/h4&gt;
&lt;p&gt;另一个只读算法是&lt;code&gt;accumulate&lt;/code&gt;，它定义在头文件&lt;code&gt;numeric&lt;/code&gt;中。&lt;code&gt;accumulate&lt;/code&gt;函数接受三个参数，前两个指出了需要求和的元素的范围，第三个参赛是和的初值。假定 vec 是一个整数序列，则：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//对 vec 中元素的求和，和的初值是0
int sum = accumulate(vec.cbegin(), vec.cend(), 0);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这条语句将 sum 设置为 vec 中元素的和，和的初值被设置为0.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;accumulate&lt;/code&gt;的第三个参数的类型决定了函数中使用哪个加法运算符以及返回值的类型。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;accumulate&lt;/code&gt;将第三个参数作为求和起点，这蕴含着一个编程假定：将元素类型加到和的类型上的操作必须是可行的。即，序列中元素的类型必须与第三个参数匹配，或者能够转换为第三个参数的类型。&lt;/p&gt;
&lt;p&gt;下面是另一个例子，由于&lt;code&gt;string&lt;/code&gt;定义了&lt;code&gt;+&lt;/code&gt;运算符，所有我们可以通过调用&lt;code&gt;accumulate&lt;/code&gt;来将&lt;code&gt;vector&lt;/code&gt;中所有&lt;code&gt;string&lt;/code&gt;元素连接起来：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;string sum = accumulate(v.cbegin(), v.cend(), string(&amp;quot;&amp;quot;));
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;此调用将 v 中每个元素连接到一个&lt;code&gt;string&lt;/code&gt;上，该&lt;code&gt;string&lt;/code&gt;初始时是空串。注意，我们通过第三个参数显式地创建了一个&lt;code&gt;string&lt;/code&gt;。将空串当做一个字符串字面值传递给第三个参数是不可以的，会导致一个编译错误：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//错误：const char*上没有定义+运算符
string sum = accumulate(v.cbegin(), v.cend(), &amp;quot;&amp;quot;);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;原因在于，如果我们传递了一个字符串字面值，用于保存和的对象的类型将是&lt;code&gt;const char*&lt;/code&gt;。如前所述，此类型决定了使用哪个&lt;code&gt;+&lt;/code&gt;运算符。由于&lt;code&gt;const char*&lt;/code&gt;并没有+运算符，此调用将产生编译错误。&lt;/p&gt;
&lt;p&gt;操作两个序列的算法&lt;/p&gt;
&lt;h4&gt;equal&lt;/h4&gt;
&lt;p&gt;另一个只读算法是&lt;code&gt;equal&lt;/code&gt;，用于确定两个序列是否保存相同的值，它将第一个序列中的每个元素与第二个序列中的对应元素进行比较。如果所有对应元素都相等，则返回&lt;code&gt;true&lt;/code&gt;，否则返回&lt;code&gt;false&lt;/code&gt;。此算法接受三个迭代器：前两个表示第一个序列中的元素的范围，第三个表示第二个序列的首元素：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//roster2 中的元素数目应该至少与 roster1 一样多
equal(roster1.cbegin(), roster1.cend(), roster2.cbegin());
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;由于&lt;code&gt;equal&lt;/code&gt;利用迭代器完成操作，因此我们可以通过调用&lt;code&gt;equal&lt;/code&gt;来比较两个不同类型的容器中的元素。而且，元素类型也不必一样，只要我们能用&lt;code&gt;==&lt;/code&gt;来比较两个元素类型即可。例如，在此例中，roster1 可以是&lt;code&gt;vector&amp;lt;string&amp;gt;&lt;/code&gt;,而 roster2 是&lt;code&gt;list&amp;lt;const char*&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;但是，&lt;code&gt;equal&lt;/code&gt;基于一个非常重要的假设：它假定第二个序列至少与第一个序列一样长。此算法要处理第一个序列中的每个元素，它假定每个元素在第二个序列中都有一个与之对应的元素。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那些只接受一个单一迭代器来表示第二个序列的算法，都假定第二个序列至少与第一个序列一样长。确保算法不会试图访问第二个序列中不存在的元素是程序员的责任。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;写容器元素的算法&lt;/h3&gt;
&lt;p&gt;一些算法将新值赋予序列中的元素。当我们使用这类算法时，必须注意确保序列原大小至少不小于我们要求算法写入的元素数目。记住，算法不会执行容器操作，因此它们自身不可能改变容器的大小。&lt;/p&gt;
&lt;p&gt;一些算法会自己向输入范围写入元素，这些算法本质上并不危险，它们最多写入与给定序列一样多的元素。&lt;/p&gt;
&lt;p&gt;例如，算法&lt;code&gt;fill&lt;/code&gt;接受一对迭代器表示一个范围，还接受一个值作为第三个参数。&lt;code&gt;fill&lt;/code&gt;将给定的这个值赋予输入序列中的每个元素：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;fill(vec.begin(), vec.end(), 0); //将每个元素重置为0
//将容器的一个子序列设置为10
fill(vec.begin(), vec.begin()+vec.size()/2, 10);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;由于&lt;code&gt;fill&lt;/code&gt;向给定输入序列中写入数据，因此，只要我们传递一个有效的输入序列，写入操作就是安全的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;算法不检查写操作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一些算法接受一个迭代器来指出一个单独的目的位置。这些算法将新值赋予一个序列中的元素，该序列从目的位置迭代器指向的元素开始。例如，函数&lt;code&gt;fill_n&lt;/code&gt;接受一个单迭代器、一个计数值和一个值。它将给定值赋予迭代器指向的元素开始的指定个元素。我们可以用&lt;code&gt;fill_n&lt;/code&gt;将一个新值赋予&lt;code&gt;vector&lt;/code&gt;中的元素：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;vector&amp;lt;int&amp;gt; vec;  //空vector
//使用vec，赋予它不同值
fill_n(vec.begin(), vec.size(), 0);  //将所有元素重置为0
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;函数&lt;code&gt;fill_n&lt;/code&gt;假定写入指定个元素是安全的。即，如下形式的调用：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;fill_n(dest, n, val)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;函数&lt;code&gt;fill_n&lt;/code&gt;假定 dest 指向一个元素，而 dest 开始的序列至少包含 n 个元素。&lt;/p&gt;
&lt;p&gt;一个初学者非常容易犯的错误是在一个空容器上调用&lt;code&gt;fill_n&lt;/code&gt;（或类似的写元素的算法）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;vector&amp;lt;int&amp;gt; vec;  //空向量
//灾难：修改vec中10个（不存在）元素
fill_n(vec.begin(), 10, 0);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个调用是一场灾难，我们指定了要写入10个元素，但 vec 中并没有元素——它是空的，这条语句的结果是未定义的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;向目的迭代器写入数据的算法假定目的位置是足够大，能容纳要写入的元素。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;介绍 back_inserter&lt;/h3&gt;
&lt;p&gt;一种保证算法有足够元素空间来容纳输出数据的方法是使用插入迭代器。插入迭代器是一种向容器中添加元素的迭代器。通常情况下，当我们通过一个迭代器向容器元素赋值时，值被赋予迭代器指向的元素。而当我们通过一个插入迭代器赋值时，一个赋值号右侧值相等的元素被添加到容器中。&lt;/p&gt;
&lt;p&gt;为了展示如何用算法向容器中写入数据，我们现在将使用&lt;code&gt;back_inserter&lt;/code&gt;，它是定义在头文件&lt;code&gt;iterator&lt;/code&gt;中的一个函数。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;back_inserter&lt;/code&gt;接受一个&lt;strong&gt;指向容器的引用&lt;/strong&gt;，返回一个与该容器绑定的插入迭代器。当我们通过此迭代器赋值时，赋值运算符会调用&lt;code&gt;push_back&lt;/code&gt;将一个具有给定值的元素&lt;strong&gt;添加&lt;/strong&gt;到容器中：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;vector&amp;lt;int&amp;gt; vec;   //空容器
auto it = back_inserter(vec); //通过它赋值会将元素添加到vec中
*it = 42;//vec现在有一个元素，值为42
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们常常使用&lt;code&gt;back_inserter&lt;/code&gt;来创建一个迭代器，作为算法的目的位置来使用。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;vector&amp;lt;int&amp;gt; vec;  //空向量
//正确：back_inserter 创建一个插入迭代器，可以用来向 vec 添加元素
fill_n(back_inserter(vec), 10, 0);  //添加10个元素到 vec
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在每步迭代中，&lt;code&gt;fill_n&lt;/code&gt;向给定容器序列的一个元素赋值。由于我们传递的参数是&lt;code&gt;back_inserter&lt;/code&gt;返回的迭代器，因此每次赋值都会在 vec 上调用&lt;code&gt;push_back&lt;/code&gt;。最终，这条&lt;code&gt;fill_n&lt;/code&gt;调用语句向 vec 的末尾添加了10个元素，每个元素的值都是0.&lt;/p&gt;
&lt;h3&gt;拷贝算法&lt;/h3&gt;
&lt;p&gt;拷贝算法是另一个向目的位置迭代器指向的输出序列中的元素写入数据的算法。此算法接受三个迭代器，前两个表示一个输入范围，第三个表示目的序列的起始位置。此算法将输入范围中的元素拷贝到目的序列中。传递给&lt;code&gt;copy&lt;/code&gt;的目的序列至少要包含与输入序列一样多的元素，这一点很重要。&lt;/p&gt;
&lt;p&gt;我们可以用&lt;code&gt;copy&lt;/code&gt;实现内置数组的拷贝，如下面代码所示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int a[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
int a2[sizeof(a1) / sizeof(*a1)];
auto ret = copy(begin(a1), end(a1), a2); //把a1的内容拷贝到a2
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;copy&lt;/code&gt;返回的是其目的位置迭代器（递增后）的值。即，ret 恰好指向拷贝到 a2 的尾元素之后的位置。&lt;/p&gt;
&lt;p&gt;多个算法都提供所谓的“拷贝”版本。这些算法计算新元素的值，但不会将它们放置在输入序列的末尾，而是创建以新序列保存这些结果。&lt;/p&gt;
&lt;p&gt;例如，&lt;code&gt;replace&lt;/code&gt;算法读入一个序列，并将其中所有等于给定值的元素都改为另一个值。此算法接受4个参数：前两个是迭代器，表示输入序列，后两个一个是要搜索的值，另一个是新值。它将所有等于第一个值的元素替换为第二个值：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//将所有值为0的元素改为42
replace(ilist.begin(), ilist.end(), 0, 42);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;此调用将序列中所有0都替换为42,。如果我们希望保留原序列不变，可以调用&lt;code&gt;replace_copy&lt;/code&gt;。此算法接受额外第三个迭代器参数，指出调整后序列的保存位置：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//使用back_inserter按需要增长目标序列
replace_copy(ilist.begin(), ilist.end(), back_inserter(ivec), 0, 42);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;此调用后，ilis 并未改变，ivec 包含 ilist 的一份拷贝，不过原来在 ilist 中值为0的元素在 ivec 中都变为42。&lt;/p&gt;
&lt;h3&gt;重排容器元素的算法&lt;/h3&gt;
&lt;h4&gt;sort&lt;/h4&gt;
&lt;p&gt;某些算法会重排容器中元素的顺序，一个明显的例子是&lt;code&gt;sort&lt;/code&gt;。调用&lt;code&gt;sort&lt;/code&gt;会重排输入序列中的元素，使之有序，它是利用元素类型的&lt;code&gt;&amp;lt;&lt;/code&gt;运算符来实现排序的。&lt;/p&gt;
&lt;h4&gt;unique&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;unique&lt;/code&gt;算法重排输入序列，将相邻的重复项“消除”，并返回一个指向不重复范围末尾的迭代器。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;unique&lt;/code&gt;并不真正的删除任何元素，它只是覆盖相邻的重复元素，使得不重复元素出现在序列开始部分，&lt;code&gt;unique&lt;/code&gt;返回的迭代器指向最后一个不重复元素之后的位置。此位置之后的元素仍然存在，但我们不知道它们的值是什么。&lt;/p&gt;
&lt;p&gt;标准库算法对迭代器而不是容器进行操作。因此，算法不能（直接）添加或删除元素。为了真正删除无用元素，我们必须使用容器操作，例如&lt;code&gt;erase&lt;/code&gt;。&lt;/p&gt;
&lt;h2&gt;定制操作&lt;/h2&gt;
&lt;p&gt;很多算法都会比较输入序列中的元素。默认情况下，这类算法使用元素类型的&lt;code&gt;&amp;lt;&lt;/code&gt;或&lt;code&gt;==&lt;/code&gt;运算符完成比较。标准库还为这些算法定义了额外的版本，允许我们提供自己定义的操作来代替默认运算符。&lt;/p&gt;
&lt;p&gt;例如，&lt;code&gt;sort&lt;/code&gt;算法默认使用元素类型的&lt;code&gt;&amp;lt;&lt;/code&gt;运算符。但可能我们希望的排序顺序与&lt;code&gt;&amp;lt;&lt;/code&gt;所定义的顺序不同，或是我们的序列可能保存的是未定义&lt;code&gt;&amp;lt;&lt;/code&gt;运算符的元素类型。在这两种情况下，都需要重载&lt;code&gt;sort&lt;/code&gt;的默认行为。&lt;/p&gt;
&lt;h3&gt;向算法传递函数&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;sort&lt;/code&gt;的第二个版本是重载过的，它接受三个参数，此参数是一个&lt;strong&gt;谓词&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;谓词是一个可调用的表达式，其返回结果是一个能用作条件的值。标准库算法所使用的谓词分为两类：一元谓词（unary predicate 意味着它们只接受单一参数）和二元谓词（binary predicate 意味着它们接受两个参数）。接受谓词参数的算法对输入序列中的元素调用谓词。因此，元素类型必须能转换为谓词的参数类型。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//比较函数，用来比较长度排序单词
bool isShorter(const string &amp;amp;s1, const string &amp;amp;s2)
{
　　return s1.size() &amp;lt; s2.size();
}
//按长度由短至长排序words
sort(words.begin(), words.end(), isShorter);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;stable_sort&lt;/code&gt;算法：这种稳定排序算法维持相等元素的原有顺序。&lt;/p&gt;
&lt;h3&gt;lambda 表达式&lt;/h3&gt;
&lt;p&gt;根据算法接受一元谓词还是二元谓词，我们传递给算法的谓词必须严格接受一个或两个参数。但是，有时我们希望进行的操作需要更多参数，超出了算法对谓词的限制。这时候我们可以利用&lt;code&gt;lambda&lt;/code&gt;表达式。&lt;/p&gt;
&lt;p&gt;我们可以向一个算法传递任何类别的可调用对象。对于一个对象或一个表达式，如果可以对其使用调用运算符，则称它为可调用的。即，如果 e 是一个可调用的表达式，则我们可以编写代码 e(args),其中 args 是一个逗号分隔的一个或多个参数的列表。&lt;/p&gt;
&lt;p&gt;到目前为止，我们使用过的仅有的两种可调用对象是函数和函数指针。还有其他两种可调用对象：重载了函数调用运算符的类，以及&lt;code&gt;lambda&lt;/code&gt;表达式。&lt;/p&gt;
&lt;p&gt;一个&lt;code&gt;lambda&lt;/code&gt;表达式表示一个可调用的代码单元。我们可以将其理解为一个未命名的内联函数。与任何函数类似，一个&lt;code&gt;lambda&lt;/code&gt;具有一个返回返回类型、一个参数列表和一个函数体。但与函数不同，&lt;code&gt;lambda&lt;/code&gt;可能定义在函数内部。一个&lt;code&gt;lambda&lt;/code&gt;表达式具有如下形式&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;capture&lt;/span&gt; &lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parameter&lt;/span&gt; &lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;function&lt;/span&gt; &lt;span class="n"&gt;body&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中，&lt;code&gt;capture list&lt;/code&gt;(捕获列表)是一个&lt;code&gt;lambda&lt;/code&gt;所在函数中定义的局部变量列表（通常为空）；&lt;code&gt;return type&lt;/code&gt;、&lt;code&gt;parameter list&lt;/code&gt;和&lt;code&gt;function body&lt;/code&gt;与任何普通函数一样，分别表示返回类型、参数列表和函数体。但是，与普通函数不同，&lt;code&gt;lambda&lt;/code&gt;必须使用尾置返回来指定返回类型。&lt;/p&gt;
&lt;p&gt;我们可以忽略参数列表和返回类型，但必须永远包含捕获列表和函数体：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;auto f = [] { return 42; };
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;此例中，我们定义了一个可调用对象，它不接受参数，返回42.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;lambda&lt;/code&gt;的调用方式与普通函数的调用方式相同，都是使用调用运算符：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;cout &amp;lt;&amp;lt; f() &amp;lt;&amp;lt; endl; //打印42
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在&lt;code&gt;lambda&lt;/code&gt;中忽略括号和参数列表等价于指定一个空参数列表。在此例中，当调用 f 时，函数参数列表是空的。如果忽略返回类型，则返回类型从返回的表达式的类型推断而来。否则，返回类型为&lt;code&gt;void&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果&lt;code&gt;lambda&lt;/code&gt;的函数体包含任何单一&lt;code&gt;return&lt;/code&gt;语句之外的语句，且未指定返回类型，则返回&lt;code&gt;void&lt;/code&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;h4&gt;向 lambda 传递参数&lt;/h4&gt;
&lt;p&gt;与普通函数调用类似，调用一个&lt;code&gt;lambda&lt;/code&gt;时给定的实参类型被用来初始化&lt;code&gt;lambda&lt;/code&gt;的形参。通常，实参和形参的类型必须匹配，但与普通函数不同，&lt;code&gt;lambda&lt;/code&gt;不能有默认参数。因此，一个&lt;code&gt;lambda&lt;/code&gt;调用的实参数目永远与形参数目相等。一旦形参初始化完毕，就可以执行函数体了。&lt;/p&gt;
&lt;p&gt;作为一个带参数的&lt;code&gt;lambda&lt;/code&gt;的例子，我们可以编写一个与 isShorter 函数完成相同功能的&lt;code&gt;lambda&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;[] (const string &amp;amp;s1, const string &amp;amp;s2)
{ return s1.size() &amp;lt; s2.size(); }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;空捕获列表表明此&lt;code&gt;lambda&lt;/code&gt;不使用它所在函数中的任何局部变量。&lt;code&gt;lambda&lt;/code&gt;的参数与 isShorter 的参数类似，是&lt;code&gt;const string&lt;/code&gt;的引用。&lt;code&gt;lambda&lt;/code&gt;的函数体也与 isShorter 类型，比较两个参数的&lt;code&gt;size()&lt;/code&gt;，并根据两者的相对大小返回一个布尔值。&lt;/p&gt;
&lt;p&gt;如下所示，可以使用此&lt;code&gt;lambda&lt;/code&gt;来调用&lt;code&gt;stable_sort&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;stable_sort(words.begin(), words.end(), [] (const string &amp;amp;s1, const string &amp;amp;s2) { return s1.size()&amp;lt;s2.size(); });
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当&lt;code&gt;stable_sort&lt;/code&gt;需要比较两个元素时，它就会调用给定的这个&lt;code&gt;lambda&lt;/code&gt;表达式。&lt;/p&gt;
&lt;h4&gt;使用捕获列表&lt;/h4&gt;
&lt;p&gt;编写一个可以传递给&lt;code&gt;find_if&lt;/code&gt;的可调用表达式。我们希望这个表达式能将输入序列中每个&lt;code&gt;string&lt;/code&gt;的长度与 biggies 函数中的 sz 参数的值进行比较。&lt;/p&gt;
&lt;p&gt;虽然一个&lt;code&gt;lambda&lt;/code&gt;可以出现在一个函数中，使用其局部变量，但它只能使用那些明确指明的变量。一个&lt;code&gt;lambda&lt;/code&gt;通过将局部变量包含在其捕获列表中指出将会使用这些变量。捕获列表指引&lt;code&gt;lambda&lt;/code&gt;在其内部包含访问局部变量所需的信息。&lt;/p&gt;
&lt;p&gt;在本例中，我们的&lt;code&gt;lambda&lt;/code&gt;会捕获 sz，并只有单一的&lt;code&gt;string&lt;/code&gt;参数。其函数体会将&lt;code&gt;string&lt;/code&gt;的大小与捕获的 sz 的值进行比较：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;[sz] (const string &amp;amp;s) { return s.size() &amp;gt;= sz; };
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;lambda&lt;/code&gt;以一对&lt;code&gt;[]&lt;/code&gt;开始，我们可以在其中提供一个以逗号分隔的名字列表，这些名字都是它所在函数中定义的。&lt;/p&gt;
&lt;p&gt;如果我们给&lt;code&gt;lambda&lt;/code&gt;提供了一个空捕获列表，则代码会编译错误：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//错误：sz未捕获
[] (const string &amp;amp;s) { return s.size() &amp;gt;= sz; };
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;一个&lt;code&gt;lambda&lt;/code&gt;只有在其捕获列表中捕获一个所在函数中的局部变量，才能在函数体中使用该变量。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个&lt;code&gt;lambda&lt;/code&gt;可以直接使用定义在当前函数之外的名字。捕获列表只用于局部非&lt;code&gt;static&lt;/code&gt;变量，&lt;code&gt;lambda&lt;/code&gt;可以直接使用局部&lt;code&gt;static&lt;/code&gt;变量和在它所在函数之外声明的名字。&lt;/p&gt;
&lt;h4&gt;lambda 捕获和返回&lt;/h4&gt;
&lt;p&gt;当定义一个&lt;code&gt;lambda&lt;/code&gt;时，编译器生成一个与&lt;code&gt;lambda&lt;/code&gt;对应的新的（未命名的）类类型。当向一个函数传递一个&lt;code&gt;lambda&lt;/code&gt;时，同时定义了一个新类型和该类型的一个对象；传递的参数就是此编译器生成的类类型的未命名对象。类似的，当使用&lt;code&gt;auto&lt;/code&gt;定义一个用&lt;code&gt;lambda&lt;/code&gt;初始化的变量时，定义了一个从&lt;code&gt;lambda&lt;/code&gt;生成的类型的对象。&lt;/p&gt;
&lt;p&gt;默认情况下，从&lt;code&gt;lambda&lt;/code&gt;生成的类都包含一个对应该&lt;code&gt;lambda&lt;/code&gt;所捕获的变量的数据成员类似任何普通类的数据成员，&lt;code&gt;lambda&lt;/code&gt;的数据成员也在&lt;code&gt;lambda&lt;/code&gt;对象创建时被初始化。&lt;/p&gt;
&lt;h4&gt;值捕获&lt;/h4&gt;
&lt;p&gt;类似参数传递，变量的捕获方式也可以是值或引用。到目前为止，我们的&lt;code&gt;lambda&lt;/code&gt;采用值捕获的方式。与传值参数类似，采用值捕获的前提是变量可以拷贝。与参数不同，被捕获的变量的值是在&lt;code&gt;lambda&lt;/code&gt;创建时拷贝，而不是调用时拷贝：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;void fcn1()
{
　　size_t v1 = 42;  //局部变量
　　//将 v1 拷贝到名为 f 的可调用对象
　　auto f = [v1] { return v1; };
　　v1 = 0;
　　auto j = f(); //j 为42；f 保存了我们创建它时 v1 的拷贝
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;由于被捕获变量的值是在&lt;code&gt;lambda&lt;/code&gt;创建时拷贝，因此随后对其修改不会影响到&lt;code&gt;lambda&lt;/code&gt;内对应的值。&lt;/p&gt;
&lt;h4&gt;引用捕获&lt;/h4&gt;
&lt;p&gt;我们定义&lt;code&gt;lambda&lt;/code&gt;时可以采用引用方式捕获变量。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;void fcn2()
{
　　size_t v1 = 42;
　　//对象 f2 包含 v1 的引用
　　auto f2 = [&amp;amp;v1] { return v1; };
　　v1 = 0;
　　auto j = f2();  //j 为0；f2 保存 v1 的引用，而非拷贝
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;一个以引用方式捕获的变量与其他任何类型的引用的行为类似。当我们在&lt;code&gt;lambda&lt;/code&gt;函数体内使用此变量时，实际上使用的是引用所绑定的对象。引用捕获与返回引用有着相同的问题和限制。如果我们采用引用方式捕获一个变量，就必须确保被引用的对象在&lt;code&gt;lambda&lt;/code&gt;执行的时候是存在的。&lt;code&gt;lambda&lt;/code&gt;捕获的都是局部变量，这些变量在函数结束后就不复存在了。如果&lt;code&gt;lambda&lt;/code&gt;可能在函数结束后执行，捕获的引用指向的局部变量已经消失。&lt;/p&gt;
&lt;p&gt;我们不能拷贝&lt;code&gt;ostream&lt;/code&gt;对象，因此捕获&lt;code&gt;os&lt;/code&gt;的唯一方式就是捕获其引用（或指向&lt;code&gt;os&lt;/code&gt;的指针）。&lt;/p&gt;
&lt;p&gt;我们也可以从一个函数返回&lt;code&gt;lambda&lt;/code&gt;，函数可以直接返回一个可调用对象，或者返回一个类对象，该类含有可调用对象的数据成员。如果函数返回一个&lt;code&gt;lambda&lt;/code&gt;，则与函数不能返回一个局部变量的引用类似，此&lt;code&gt;lambda&lt;/code&gt;也不能包含引用捕获。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当以引用方式捕获一个变量时，必须保证在&lt;code&gt;lambda&lt;/code&gt;执行时变量是存在的。&lt;/strong&gt;&lt;/p&gt;
&lt;h4&gt;隐式捕获&lt;/h4&gt;
&lt;p&gt;除了显式列出我们希望使用的来自所在函数的变量外，还可以让编译器根据&lt;code&gt;lambda&lt;/code&gt;体中的代码来推断我们要使用哪些变量。为了指示编译器推断捕获列表，应在捕获列表中写一个&lt;code&gt;&amp;amp;&lt;/code&gt;或&lt;code&gt;=&lt;/code&gt;。&lt;code&gt;&amp;amp;&lt;/code&gt;告诉编译器采用捕获引用方式，&lt;code&gt;=&lt;/code&gt;则采用值捕获。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//sz为隐式捕获，值捕获方式
wc=find_if(words.begin(),words.end(),
　　[=] (const string &amp;amp;s) { return s.size()&amp;gt;=sz; });
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果我们希望对一部分变量采用值捕获，对其它变量采用引用捕获，可以混合使用隐式捕获和显式捕获：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;void biggies(vector&amp;lt;string&amp;gt; &amp;amp;words, vector&amp;lt;string&amp;gt;::size_type sz, ostream &amp;amp;os=cout, char c=&amp;#39; &amp;#39;)
{

　　//os 隐式捕获，引用捕获方式；c 显式捕获，值捕获方式
　　for_each(words.begin(), words.end(), [&amp;amp;, c] (const string &amp;amp;s) { os &amp;lt;&amp;lt; s &amp;lt;&amp;lt;c; });
　　//os 显式捕获，引用捕获方式；c 隐式捕获，值捕获方式
　　for_each(words.begin(), words.end(),[=, &amp;amp;os] (const string &amp;amp;s) { os &amp;lt;&amp;lt; s &amp;lt;&amp;lt;c; });
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当我们混合使用隐式捕获和显式捕获时，捕获列表中的第一个元素必须是一个&lt;code&gt;&amp;amp;&lt;/code&gt;或&lt;code&gt;=&lt;/code&gt;，此符号指定了默认捕获方式为引用或值。&lt;/p&gt;
&lt;p&gt;当混合使用隐式捕获和显式捕获时，显式捕获的变量必须使用与隐式捕获不同的方式。即，如果隐式捕获是引用方式（使用了&lt;code&gt;&amp;amp;&lt;/code&gt;），则显示捕获命名变量必须采用值方式，因此不能在其名字前使用&lt;code&gt;&amp;amp;&lt;/code&gt;。类似的，如果隐式捕获采用的是值方式（使用了&lt;code&gt;=&lt;/code&gt;），则显式捕获命名变量必须采用引用方式，即，在名字前使用&lt;code&gt;&amp;amp;&lt;/code&gt;。&lt;/p&gt;
&lt;h4&gt;可变 lambda&lt;/h4&gt;
&lt;p&gt;默认情况下，对于一个值被拷贝的变量，&lt;code&gt;lambda&lt;/code&gt;不会改变其值。如果我们希望能改变一个捕获的变量的值，就必须在参数列表首加上关键字&lt;code&gt;mutable&lt;/code&gt;。因此，可变&lt;code&gt;lambda&lt;/code&gt;能省略参数列表：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;void fcn3()
{
　　size_t v1 = 42; //局部变量
　　//f 可以改变它所捕获的变量的值
　　auto f = [v1] () mutable { return ++v1; };
　　v1=0;
　　auto j = f(); //j为43
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;一个引用捕获的变量是否（如往常一样）可以修改依赖于此引用指向的是一个&lt;code&gt;const&lt;/code&gt;类型还是一个非&lt;code&gt;const&lt;/code&gt;类型：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;void fcn4()
{
　　size_t v1 = 42;  //局部变量
　　//v1 是一个非 const 变量的引用
　　//可以通过 f2 中的引用来改变它

　　auto f2 = [&amp;amp;v1] { return ++v1; };
　　v1=0;
　　auto j = f2(); //j为1
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;指定 lambda 返回类型&lt;/h4&gt;
&lt;p&gt;默认情况下，如果一个&lt;code&gt;lambda&lt;/code&gt;体包含&lt;code&gt;return&lt;/code&gt;之外的任何语句，则编译器假定此&lt;code&gt;lambda&lt;/code&gt;返回&lt;code&gt;void&lt;/code&gt;。与其它返回&lt;code&gt;void&lt;/code&gt;的函数类型类似，被推断返回&lt;code&gt;void&lt;/code&gt;的&lt;code&gt;lambda&lt;/code&gt;不能返回值。&lt;/p&gt;
&lt;p&gt;当我们需要为一个&lt;code&gt;lambda&lt;/code&gt;定义返回类型时，必须使用尾置返回类型。&lt;/p&gt;
&lt;h3&gt;参数绑定&lt;/h3&gt;
&lt;p&gt;对于那种只有一两个地方使用的简单操作，&lt;code&gt;lambda&lt;/code&gt;表达式是最有用的。如果我们需要在很多地方使用相同的操作，通常应该定义一个函数，而不是多次编写相同的&lt;code&gt;lambda&lt;/code&gt;表达式。类似的，如果一个操作需要很多语句才能完成，通常使用函数更好。&lt;/p&gt;
&lt;p&gt;但是，对于捕获局部变量的&lt;code&gt;lambda&lt;/code&gt;，用函数来替换它就不是那么容易了。例如，我们用在&lt;code&gt;find_if&lt;/code&gt;调用中的&lt;code&gt;lambda&lt;/code&gt;比较一个&lt;code&gt;string&lt;/code&gt;和一个给定大小。我们可以很容易地编写一个完成同样工作的函数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;bool check_size(const string &amp;amp;s, string::size_type sz)
{
　　return s.size() &amp;gt;= sz;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;但是，我们不能用这个函数作为&lt;code&gt;find_if&lt;/code&gt;的一个参数。&lt;code&gt;find_if&lt;/code&gt;接受一个一元谓词，因此传递给&lt;code&gt;find_if&lt;/code&gt;的可调用对象必须接受单一参数。为了用 check_size 函数来代替&lt;code&gt;lambda&lt;/code&gt;，必须解决如何向 sz 形参传递一个参数的问题。&lt;/p&gt;
&lt;h4&gt;标准库 bind 函数&lt;/h4&gt;
&lt;p&gt;我们可以解决向 check_size 传递一个长度参数的问题，方法是使用一个新的名为&lt;code&gt;bind&lt;/code&gt;的标准库函数，它定义在头文件&lt;code&gt;functional&lt;/code&gt;中。可以将&lt;code&gt;bind&lt;/code&gt;函数看作一个通用的函数适配器，它接受一个可调用对象，生成一个新的可调用对象来“适应”原对象的参数列表。&lt;/p&gt;
&lt;p&gt;调用bind的一般形式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;auto newCallable = bind(callable, arg_list);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中，newCallable 本身是一个可调用对象，arg_list 是一个逗号分隔的参数列表，对应给定的 callable 的参数。即，当我们调用 newCallable 时，newCallable 会调用 callable，并传递给它 arg_list 中的参数。&lt;/p&gt;
&lt;p&gt;arg_list 中的参数可能包含形如 &lt;code&gt;_n&lt;/code&gt; 的名字，其中 n 是一个整数。这些参数是“占位符”，表示 newCallable 的参数，它们占据了传递给 newCallable 的参数的“位置”。数值n表示生成的可调用对象中参数的位置：&lt;code&gt;_1&lt;/code&gt;为newCallable的第一个参数，&lt;code&gt;_2&lt;/code&gt;为第二个参数，以此类推。&lt;/p&gt;
&lt;h4&gt;绑定 check_size 的 sz 参数&lt;/h4&gt;
&lt;p&gt;作为一个简单的例子，我们将使用&lt;code&gt;bind&lt;/code&gt;生成一个调用 check_size 的对象，如下所示，它用一个定值作为其大小参数来调用 check_size:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//check6 是一个可调用对象，接受一个 string 类型的参数
//并用此 string 和值6来调用 check_size
auto check6 = bind(check_size, _1, 6);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;此&lt;code&gt;bind&lt;/code&gt;调用只有一个占位符，表示 check6 只接受单一参数。占位符出现在 arg_list 的第一个位置，表示 check6 的此参数对应 check_size 的第一个参数。此参数是一个&lt;code&gt;const string&amp;amp;&lt;/code&gt;。因此，调用 check6 必须传递给它一个&lt;code&gt;string&lt;/code&gt;类型的参数，check6 会将此参数传递给 check_size。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;string s = &amp;quot;hello&amp;quot;;
bool b1 = check6(s); //check6(s) 会调用 check_size(s, 6)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;使用&lt;code&gt;bind&lt;/code&gt;，我们可以将原来基于&lt;code&gt;lambda&lt;/code&gt;的&lt;code&gt;find_if&lt;/code&gt;调用：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;auto wc = find_if(words.begin(), words.end(), [sz] (const string &amp;amp;s)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;替换为如下使用 check_size 的版本：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;auto wc = find_if(words.begin(), words.end(), bind(check_size, _1, sz));
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;此&lt;code&gt;bind&lt;/code&gt;调用生成一个可调用对象，将 check_size 的第二个参数绑定到 sz 的值。&lt;/p&gt;
&lt;h4&gt;placeholders&lt;/h4&gt;
&lt;p&gt;名字&lt;code&gt;_n&lt;/code&gt;都定义在一个名为&lt;code&gt;placeholders&lt;/code&gt;的命名空间中，而这个命名空间本身定义在&lt;code&gt;std&lt;/code&gt;命名空间中。为了使用这些名字，两个命名空间都要写上。例如，&lt;code&gt;_1&lt;/code&gt;对应的&lt;code&gt;using&lt;/code&gt;声明为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;using&lt;/span&gt; &lt;span class="nt"&gt;std&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nd"&gt;placeholders&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nd"&gt;_1&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;此声明说明我们要使用的名字&lt;code&gt;_1&lt;/code&gt;定义在命名空间&lt;code&gt;placeholders&lt;/code&gt;中，而此命名空间又定义在命名空间&lt;code&gt;std&lt;/code&gt;中。&lt;/p&gt;
&lt;p&gt;对每个占位符名字，我们都必须提供一个单独的&lt;code&gt;using&lt;/code&gt;声明。编写这样的声明很烦人，也很容易出错。可以使用另外一种不同形式的&lt;code&gt;using&lt;/code&gt;语句，而不是分别声明每个占位符，如下所示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;using&lt;/span&gt; &lt;span class="n"&gt;namespace&lt;/span&gt; &lt;span class="n"&gt;namespace_name&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这种形式说明希望所有来自&lt;code&gt;namespace_name&lt;/code&gt;的名字都可以在我们的程序中直接使用。例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;using&lt;/span&gt; &lt;span class="n"&gt;namespace&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;placeholders&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;使得由&lt;code&gt;placeholders&lt;/code&gt;定义的所有名字都可用。与&lt;code&gt;bind&lt;/code&gt;函数一样，&lt;code&gt;placeholders&lt;/code&gt;命名空间也定义在&lt;code&gt;functional&lt;/code&gt;头文件中。&lt;/p&gt;
&lt;h4&gt;绑定引用参数&lt;/h4&gt;
&lt;p&gt;默认情况下，&lt;code&gt;bind&lt;/code&gt;的哪些不是占位符的参数被拷贝到&lt;code&gt;bind&lt;/code&gt;返回的可调用对象中。但是，与&lt;code&gt;lambda&lt;/code&gt;类似，有时对有些绑定的参数我们希望以引用方式传递，或是要绑定参数的类型无法拷贝。例如，为了替换一个引用方式捕获&lt;code&gt;ostream&lt;/code&gt;的&lt;code&gt;lambda&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bind&lt;/code&gt;拷贝其参数，而我们不能拷贝一个&lt;code&gt;ostream&lt;/code&gt;，如果我们希望传递给&lt;code&gt;bind&lt;/code&gt;一个对象而又不是拷贝它，就必须使用标准库&lt;code&gt;ref&lt;/code&gt;函数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;for_each(words.begin(), words.end(), bind(print, ref(os), _1,&amp;#39; &amp;#39;));
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;函数&lt;code&gt;ref&lt;/code&gt;返回一个对象，包含给定的引用，此对象是可以拷贝的。标准库中还有一个&lt;code&gt;cref&lt;/code&gt;函数，生成一个保存&lt;code&gt;const&lt;/code&gt;引用的类。与&lt;code&gt;bind&lt;/code&gt;一样，函数&lt;code&gt;ref&lt;/code&gt;和&lt;code&gt;cref&lt;/code&gt;也定义在头文件&lt;code&gt;functional&lt;/code&gt;中。&lt;/p&gt;
&lt;h2&gt;再探迭代器&lt;/h2&gt;
&lt;p&gt;除了为每个容器定义的迭代器之外，标准库在头文件iterator中还定义了额外几种迭代器。这些迭代器包括以下几种。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;迭代器&lt;/th&gt;
&lt;th align="left"&gt;意义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;插入迭代器&lt;/td&gt;
&lt;td align="left"&gt;这些迭代器被绑定到一个容器上，可用来向容器插入元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;流迭代器&lt;/td&gt;
&lt;td align="left"&gt;这些迭代器被绑定到输入或输出上，可用来遍历所有关联的&lt;code&gt;IO&lt;/code&gt;流&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;反向迭代器&lt;/td&gt;
&lt;td align="left"&gt;这些迭代器向后而不是向前移动。除了&lt;code&gt;forward_list&lt;/code&gt;之外的标准库容器都有反向迭代器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;移动迭代器&lt;/td&gt;
&lt;td align="left"&gt;这些专用的迭代器不是拷贝其中的元素，而是移动它们&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;插入迭代器&lt;/h3&gt;
&lt;p&gt;插入器是一种迭代器适配器，它接受一个容器，生成一个迭代器，能实现向给定容器添加元素。当我们通过一个迭代器进行赋值时，该迭代器调用容器操作来向给定容器的指定位置插入一个元素。下表列出了这种迭代器支持的操作。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;操作&lt;/th&gt;
&lt;th align="left"&gt;意义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;it = t&lt;/td&gt;
&lt;td align="left"&gt;在 it 指定的当前位置插入值 t。假定 c 是 it 绑定的容器，依赖于插入迭代器的不同种类，此赋值分别调用&lt;code&gt;c.push_back(t)&lt;/code&gt;、&lt;code&gt;c.push_front(t)&lt;/code&gt;或&lt;code&gt;c.insert(t, p)&lt;/code&gt;,其中 p 为传递给&lt;code&gt;inserter&lt;/code&gt;的迭代器位置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;*it, ++it, it++&lt;/td&gt;
&lt;td align="left"&gt;这些操作虽然存在，但不会对 it 做任何事情。每个操作都返回 it&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;插入迭代器有三种类型，差异在于元素插入的位置：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;back_inserter&lt;/code&gt;创建一个使用&lt;code&gt;push_back&lt;/code&gt;的迭代器&lt;/li&gt;
&lt;li&gt;&lt;code&gt;front_inserter&lt;/code&gt;创建一个使用&lt;code&gt;push_front&lt;/code&gt;的迭代器&lt;/li&gt;
&lt;li&gt;&lt;code&gt;inserter&lt;/code&gt;创建一个使用&lt;code&gt;insert&lt;/code&gt;的迭代器。此函数接受三个参数，这个参数必须是一个指向给定容器的迭代器。元素将被插入到给定迭代器所表示的元素之前。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;只有在容器支持&lt;code&gt;push_front&lt;/code&gt;的情况下，我们才可以使用&lt;code&gt;front_inserter&lt;/code&gt;。类似的，只有在容器支持&lt;code&gt;push_back&lt;/code&gt;的情况下，我们才能使用&lt;code&gt;back_inserter&lt;/code&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;理解插入迭代器的工作过程是很重要的：当调用&lt;code&gt;inserter(c,iter)&lt;/code&gt;时，我们得到一个迭代器，接下来使用它时，会将元素插入到 iter 原来所指的位置之前的位置。即，如果 it 是由&lt;code&gt;inserter&lt;/code&gt;生成的迭代器，则下面这样的赋值语句：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;*it = val;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其效果与下面代码一样：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;it = c.insert(it, val); //it 指向新加入的元素
++it; //递增 it 使它指向原来的元素
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;front_inserter&lt;/code&gt;生成的迭代器的行为与&lt;code&gt;inserter&lt;/code&gt;生成的迭代器完全不一样。当我们使用&lt;code&gt;front_inserter&lt;/code&gt;时，元素总是插入到容器第一个元素之前，即使我们传递给&lt;code&gt;inserter&lt;/code&gt;的位置原来指向第一个元素，只要我们在此元素之前插入一个新元素，此元素就不再是容器的首元素了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;list&amp;lt;int&amp;gt; lst = {1, 2, 3, 4};
list&amp;lt;int&amp;gt; lst2, lst3;  //空 list
//拷贝完成之后，lst2 包含4 3 2 1
copy(lst.begin(), lst.end(), front_inserter(lst2));
//拷贝完成之后 lst3 包含1 2 3 4
copy(lst.begin(), lst.end(), inserter(lst3,lst.begin()));
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当调用&lt;code&gt;front_inserter(c)&lt;/code&gt;时，我们得到一个插入迭代器，接下来会调用&lt;code&gt;push_front&lt;/code&gt;。当每个元素被插入到容器 c 中时，它变为 c 的新的首元素。因此，&lt;code&gt;front_inserter&lt;/code&gt;生成的迭代器会将插入的元素序列的顺序颠倒过来，而&lt;code&gt;inserter&lt;/code&gt;和&lt;code&gt;back_inserter&lt;/code&gt;则不会。&lt;/p&gt;
&lt;h3&gt;流迭代器&lt;/h3&gt;
&lt;p&gt;虽然&lt;code&gt;iostream&lt;/code&gt;类型不是容器，但标准库定义了用于这些&lt;code&gt;IO&lt;/code&gt;类型对象的迭代器。&lt;code&gt;istream_iterator&lt;/code&gt;读取输入流，&lt;code&gt;ostream_iterator&lt;/code&gt;向一个输出流写数据。这些迭代器将它们对应的流当作一个特定类型的元素序列来处理。通过使用流迭代器，我们可以用泛型算法从流对象读取数据以及向其写入数据。&lt;/p&gt;
&lt;h4&gt;istream_iterator&lt;/h4&gt;
&lt;p&gt;当创建一个流迭代器时，必须指定迭代器将要读写的对象类型。一个&lt;code&gt;istream_iterator&lt;/code&gt;使用&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;来读取流。因此，&lt;code&gt;istream_iterator&lt;/code&gt;要读取的类型必须定义了输入运算符。当创建一个&lt;code&gt;istream_iterator&lt;/code&gt;时，我们可以将它绑定到一个流。当然，我们还可以默认初始化迭代器，这样就创建了一个可以当作尾后值使用的迭代器。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;istream_iterator&amp;lt;int&amp;gt; int_it(cin); //从 cin 读取 int
istream_iterator&amp;lt;int&amp;gt; int_eof; //尾后迭代器
ifstream in(&amp;quot;afile&amp;quot;);
istream_iterator&amp;lt;string&amp;gt; str_in(in); //从 afile 读取字符串
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;下面是一个用&lt;code&gt;istream_iterator&lt;/code&gt;从标准输入流读取数据，存入一个&lt;code&gt;vector&lt;/code&gt;的例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;istream_iterator&amp;lt;int&amp;gt; in_iter(cin); //从 cin 读取 int
istream_iterator&amp;lt;int&amp;gt; eof;  //istream 尾后迭代器
while(in_iter != eof)
　　//后置递增运算读取流，返回迭代器的旧值
　　//解引用迭代器，获得从流读取的前一个值
　　vec.push_back(*in_iter++);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;此循环从&lt;code&gt;cin&lt;/code&gt;读取&lt;code&gt;int&lt;/code&gt;值，保存在 vec 中。在每个循环步中，循环体代码检查 in_iter 是否等于 eof。eof 被定义为空&lt;code&gt;istream_iterator&lt;/code&gt;,从而可以当作尾后迭代器来使用。对于一个绑定到流的迭代器，一旦其关联的流遇到文件尾或遇到&lt;code&gt;IO&lt;/code&gt;错误，迭代器的值就与尾后迭代器相等。&lt;/p&gt;
&lt;p&gt;我们可以将程序重写为如下形式，这体现了&lt;code&gt;istream_iterator&lt;/code&gt;更有用的地方：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;istream_iterator&amp;lt;int&amp;gt; in_iter(cin), eof; //从 cin 读取 int
vector&amp;lt;int&amp;gt; vec(in_iter,eof);  //从迭代器范围构造 vec
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;本例中我们使用了一对表示范围的迭代器来构造 vec，这两个迭代器是&lt;code&gt;istream_iterator&lt;/code&gt;，这意味着元素范围是通过从关联的流中读取数据获得的。这个构造函数从&lt;code&gt;cin&lt;/code&gt;读取数据，直至遇到文件尾或者遇到一个不是&lt;code&gt;int&lt;/code&gt;的数据为止。从流中读取的数据被用来构造 vec。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;istream_iterator 操作&lt;/th&gt;
&lt;th align="left"&gt;意义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;istream_iterator&lt;T&gt; in(is);&lt;/td&gt;
&lt;td align="left"&gt;in 从输入流 is 读取类型为 T 的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;istream_iterator&lt;T&gt; end;&lt;/td&gt;
&lt;td align="left"&gt;读取类型为 T 的值的 istream_iterator 迭代器，表所尾后位置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;in1 == in2, in1 != in2&lt;/td&gt;
&lt;td align="left"&gt;in1 和 in2 必须读取相同类型。如果它们都是尾后迭代器，或绑定到相同的输入，则两个相等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;*in&lt;/td&gt;
&lt;td align="left"&gt;返回从流中读取数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;in-&amp;gt;mem&lt;/td&gt;
&lt;td align="left"&gt;与&lt;code&gt;(*in).mem&lt;/code&gt;的含义相同&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;++in, in++&lt;/td&gt;
&lt;td align="left"&gt;使用元素类型所定义的&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;运算符从输入流中读取下一个值。与以往一样，前置版本返回一个指向递增后迭代器的引用，后置版本返回旧值&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4&gt;使用算法操作流迭代器&lt;/h4&gt;
&lt;p&gt;由于算法使用迭代器操作来处理数据，而流迭代器又至少支持某种迭代器操作，因此我们至少可以用某些算法来操作流迭代器。下面是一个例子，我们可以用一对&lt;code&gt;istream_iterator&lt;/code&gt;来调用&lt;code&gt;accumulate&lt;/code&gt;，此调用会计算出从标准输入读取的值的和:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;istream_iterator&amp;lt;int&amp;gt; in(cin), eof;
cout &amp;lt;&amp;lt; accumulatre(in, eof, 0) &amp;lt;&amp;lt; endl;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;istream_iterator 允许使用懒惰求值&lt;/h4&gt;
&lt;p&gt;当我们将一个&lt;code&gt;istream_iterator&lt;/code&gt;绑定到一个流时，标准库并不保证迭代器立即从流读取数据。具体实现可以推迟从中读取数据，直到我们使用迭代器时才真正读取。标准库中的实现所保证的是，在我们第一次解引用迭代器之前，从流中读取数据的操作已经完成了。对于大多数程序来说，立即读取还是推迟读取并没有什么差别。但是，如果我们创建了一个&lt;code&gt;istream_iterator&lt;/code&gt;，没有使用就销毁了，或者我们正在从两个不同的对象同步读同一个流，那么何时读取可能就很重要了。&lt;/p&gt;
&lt;h4&gt;ostream_iterator&lt;/h4&gt;
&lt;p&gt;我们可以对任何输出运算符(&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;运算符)的类型定义&lt;code&gt;ostream_iterator&lt;/code&gt;。当创建一个&lt;code&gt;ostream_iterator&lt;/code&gt;时，我们可以提供（可选的）第二参数，它是一个字符串，在输出每个元素后都会打印此字符串。此字符串必须是一个 C 风格字符串（即，一个字符串字面值或者一个指向以空字符结尾的字符数组的指针）。必须将&lt;code&gt;ostream_iterator&lt;/code&gt;绑定到一个指定的流。不允许空的或表示尾后位置的&lt;code&gt;ostream_iterator&lt;/code&gt;。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;ostream_iterator 操作&lt;/th&gt;
&lt;th align="left"&gt;意义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;ostream_iterator&lt;T&gt; out(os);&lt;/td&gt;
&lt;td align="left"&gt;out 将类型为 T 的值写到输出流 os 中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;ostream_iterator&lt;T&gt; out(os,d);&lt;/td&gt;
&lt;td align="left"&gt;out 将类型为T的值写到输出流 os 中，每个值后面都输出一个 d。d 指向一个空字符串结尾的字符数组&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;out = val&lt;/td&gt;
&lt;td align="left"&gt;用 &amp;lt;&amp;lt; 运算符将 val 写入到 out 所绑定的 ostream 中。val 的类型必须与 out 可写的类型兼容&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;*out, ++out, out++&lt;/td&gt;
&lt;td align="left"&gt;这些运算符是存在的，但不对 out 做任何事情。每个运算符都返回 out&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;我们可以使用&lt;code&gt;ostream_iterator&lt;/code&gt;来输出值的序列：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;ostream_iterator&amp;lt;int&amp;gt; out_iter(cout,&amp;quot; &amp;quot;);
for(auto e : vec)
　　*out_iter++ = e;   //赋值语句实际上将元素写到 cout
cout &amp;lt;&amp;lt; endl;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;此程序将 vec 中的每个元素写到&lt;code&gt;cout&lt;/code&gt;，每个元素加一个空格，每次向 out_iter 赋值时，写操作就会被提交。&lt;/p&gt;
&lt;p&gt;值得注意的是，当我们向 out_iter 赋值时，可以忽略解引用和递增运算。即，循环可以重写成下面的样子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;for(auto e : vec)
　　out_iter = e;//赋值语句将元素写到 cout
cout &amp;lt;&amp;lt; end;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;运算符&lt;code&gt;*&lt;/code&gt;和&lt;code&gt;++&lt;/code&gt;实际上对&lt;code&gt;ostream_iterator&lt;/code&gt;对象不做任何事情，因此忽略它们对我们的程序没有任何影响。但是，推荐第一种形式。在这种写法中，流迭代器的使用与其他迭代器的使用保存一致。如果想将此循环改为操作其他迭代器类型，修改起来非常容易。而且，对于读者来说，此循环的行为也更为清晰。&lt;/p&gt;
&lt;p&gt;可以通过调用&lt;code&gt;copy&lt;/code&gt;来打印 vec 中的元素，这比编写循环更为简单：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;copy(vec.begin(), vec.end(), out_iter);
cout &amp;lt;&amp;lt; endl;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;反向迭代器&lt;/h3&gt;
&lt;p&gt;反向迭代器就是在容器中从尾元素向首元素反向移动的迭代器。对于反向迭代器，递增（以及递减）操作的含义会颠倒过来。递增一个反向迭代器（++it）会移动到前一个元素；递减一迭代器（--it）会移动到下一个元素。&lt;/p&gt;
&lt;p&gt;除了&lt;code&gt;forward_list&lt;/code&gt;之外，其他容器都支持反向迭代器。我们可以通过调用&lt;code&gt;rbegin&lt;/code&gt;、&lt;code&gt;rcend&lt;/code&gt;、&lt;code&gt;crbegin&lt;/code&gt;和&lt;code&gt;crend&lt;/code&gt;成员函数来获得反向迭代器。这些成员函数返回指向容器尾元素和首元素之前一个位置的迭代器。与普通迭代器一样，反向迭代器也有&lt;code&gt;const&lt;/code&gt;和非&lt;code&gt;const&lt;/code&gt;版本。&lt;/p&gt;
&lt;h4&gt;反向迭代器需要递减运算符&lt;/h4&gt;
&lt;p&gt;我们只能从既支持&lt;code&gt;++&lt;/code&gt;也支持&lt;code&gt;--&lt;/code&gt;的迭代器来定义反向迭代器。毕竟反向迭代器的目的是在序列中反向移动。除了&lt;code&gt;forward_list&lt;/code&gt;之外，标准容器上的其他迭代器都既支持递增运算又支持递减运算。但是，流迭代器不支持递减运算，因为不可能在一个流中反向移动。因此，不可能从一个&lt;code&gt;forward_list&lt;/code&gt;或一个流迭代器创建反向迭代器。&lt;/p&gt;
&lt;h4&gt;反向迭代器与其他迭代器间的关系&lt;/h4&gt;
&lt;p&gt;假定有一个名为 line 的&lt;code&gt;string&lt;/code&gt;，保存着一个逗号分隔的单词列表，我们希望打印 line 中的第一个单词，使用&lt;code&gt;find&lt;/code&gt;可以很容易地完成这一任务：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//在一个逗号分隔的列表中查找一个元素
auto comma = find(line.cbegin(), line.cend(), &amp;#39;,&amp;#39;);
cout &amp;lt;&amp;lt; string(line.cbegin(), comma) &amp;lt;&amp;lt; endl;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果 line 中有逗号，那么 comma 将指向这个逗号；否则，它将等于 line.cend().当我们打印从 line.cbegin() 到 comma 之间的内容时，将打印到逗号为止的序列，或者打印整个&lt;code&gt;string&lt;/code&gt;（如果其中不含逗号的话）。&lt;/p&gt;
&lt;p&gt;如果希望打印最后一个单词，可以改用反向迭代器：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//在一个逗号分隔的列表中查找最后一个元素
auto rcomma = find(line.crbegin(), line.crend(), &amp;#39;,&amp;#39;);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;由于我们将&lt;code&gt;crbegin&lt;/code&gt;和&lt;code&gt;crend&lt;/code&gt;传递给&lt;code&gt;find&lt;/code&gt;，&lt;code&gt;find&lt;/code&gt;将从 line 的最后一个字符开始向前搜索。当&lt;code&gt;find&lt;/code&gt;完成后，如果 line 中有逗号，则 rcomma 指向最后一个逗号——即，它指向反向搜索中找到的第一个逗号。如果 line 中没有逗号，则 rcomma 指向 line.crend()。&lt;/p&gt;
&lt;p&gt;但我们试图打印找到的单词时，看起来下面的代码是显然的方法&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//错误:将逆序输出单词的字符
cout &amp;lt;&amp;lt; string(line.crbegin(), rcomma) &amp;lt;&amp;lt; endl;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;但它会生成错误的输出结果。例如，如果我们的输入是：FIRST,MIDOLE,LAST&lt;/p&gt;
&lt;p&gt;则这条语句会打印：TSAL&lt;/p&gt;
&lt;p&gt;问题所在：我们使用的是反向迭代器，会反向处理&lt;code&gt;string&lt;/code&gt;。因此，上述输出语句从&lt;code&gt;crbegin&lt;/code&gt;开始反向打印 line 中内容。而我们希望按正常顺序打印从 rcomma 开始到 line 末尾间的字符。但是，我们不能直接使用 rcomma。因为它是一个反向迭代器，意味着它会反向朝着&lt;code&gt;string&lt;/code&gt;的开始位置移动。需要做的是，将 rcomma 转换回一个普通迭代器，能在 line 中正向移动。我们通过调用&lt;code&gt;reverse_iterator&lt;/code&gt;的&lt;code&gt;base&lt;/code&gt;成员函数来完成这一转换，此成员函数会返回其对应的普通迭代器：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//正确：得到一个正向迭代器，从逗号开始读取字符直到 line 末尾
cout &amp;lt;&amp;lt; string(rcomma.base(), line.cend()) &amp;lt;&amp;lt; endl;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;rcomma 和 rcomma.base() 指向了不同的元素，line.crbegin() 和 line.cend() 也是如此。这些不同保证了元素范围无论是正向处理还是反向出来都是相同的。从技术上讲，普通迭代器与反向迭代器的关系反映了左闭合区间的特征。关键点在于 [line.crbegin(),rcomma) 和 [rcomma.base(),line.cend()) 指向 line 中相同的元素范围。&lt;/p&gt;
&lt;p&gt;&lt;img alt="反向迭代器和普通迭代器之间的关系" src="https://xutree.github.io/images/c++10-1.jpg"&gt;&lt;/p&gt;
&lt;h2&gt;泛型算法结构&lt;/h2&gt;
&lt;p&gt;任何算法的最基本的特性是它要求其迭代器提供哪些操作。某些算法，如&lt;code&gt;find&lt;/code&gt;，只要求通过迭代器访问元素、递增迭代器以及比较两个迭代器是否相等这些能力。其他一些算法，如&lt;code&gt;sort&lt;/code&gt;，还要求读、写和随机访问元素的能力。算法所要求的迭代器操作可以分为5个迭代器类别，如表所示：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;迭代器类型&lt;/th&gt;
&lt;th align="left"&gt;要求&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;输入迭代器&lt;/td&gt;
&lt;td align="left"&gt;只读，不写；单遍扫描，只能递&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;输出迭代器&lt;/td&gt;
&lt;td align="left"&gt;只写，不读；单遍扫描，只能递&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;前向迭代器&lt;/td&gt;
&lt;td align="left"&gt;可读写；多遍扫描，只能递&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;双向迭代器&lt;/td&gt;
&lt;td align="left"&gt;可读写；多遍扫描，可递增递&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;随机访问迭代器&lt;/td&gt;
&lt;td align="left"&gt;可读写；多遍扫描，支持全部迭代器运&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;5类迭代器&lt;/h3&gt;
&lt;p&gt;类似容器，迭代器也定义了一组公共操作，一些操作所有迭代器都支持，另外一些只有特定类别的迭代器才支持。例如，&lt;code&gt;ostream_iterator&lt;/code&gt;只支持递增、解引用和赋值。&lt;code&gt;vector&lt;/code&gt;、&lt;code&gt;string&lt;/code&gt;和&lt;code&gt;deque&lt;/code&gt;的迭代器除了这些操作外，还支持递减、关系和算术运算。&lt;/p&gt;
&lt;p&gt;迭代器是按它们所提供的操作来分类的，而这种分类形成了一种层次。除了输出迭代器之外，一个高层类别的迭代器支持底层类别迭代器的所有操作。&lt;/p&gt;
&lt;h4&gt;输入迭代器&lt;/h4&gt;
&lt;p&gt;输入迭代器：可以读取序列中的元素。一个输入迭代器必须支持：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用于比较两个迭代器的相等和不相等运算符（==、!=）&lt;/li&gt;
&lt;li&gt;用于推进迭代器的前置和后置递增运算（++）&lt;/li&gt;
&lt;li&gt;用于读取元素的解引用运算符（*）；解引用只会出现在赋值运算符的右侧&lt;/li&gt;
&lt;li&gt;箭头运算符（-&amp;gt;），等价于（*it）.member，即，解引用迭代器，并提取对象的成员&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;输入迭代器只用于顺序访问。对于一个输入迭代器，&lt;code&gt;*it++&lt;/code&gt;保证是有效的，但递增它可能导致所有其他指向流的迭代器失效。其结果就是，不能保证输入迭代器的状态可以保存下来并用来访问元素。因此，输入迭代器只能用于单遍扫描算法。算法&lt;code&gt;find&lt;/code&gt;和&lt;code&gt;accumulate&lt;/code&gt;要求输入迭代器；而&lt;code&gt;istream_iterator&lt;/code&gt;是一种输入迭代器。&lt;/p&gt;
&lt;h4&gt;输出迭代器&lt;/h4&gt;
&lt;p&gt;输出迭代器：可以看做输入迭代器功能上的补集——只写而不读元素。输出迭代器必须支持：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用于推进迭代器的前置和后置递增运算（++）&lt;/li&gt;
&lt;li&gt;解引用运算符（*），只能出现在赋值运算符的左侧（向一个已经解引用的输出迭代器赋值，就是将值写入它所指向的元素）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们只能向一个输出迭代器赋值一次。类似输入迭代器，输出迭代器只能用于单遍扫描算法。用作目的位置的迭代器通常都是输出迭代器。例如，&lt;code&gt;copy&lt;/code&gt;函数的第三个参数就是输出迭代器。&lt;code&gt;ostream_iterator&lt;/code&gt;类型也是输出迭代器。&lt;/p&gt;
&lt;h4&gt;前向迭代器&lt;/h4&gt;
&lt;p&gt;前向迭代器：可以读元素。这类迭代器只能在序列中沿一个方向移动。前向迭代器支持所有输入和输出迭代器的操作，而且可以多次读写同一个元素。因此，我们可以保存前向迭代器的状态，使用前向迭代器的算法可以对序列进行多遍扫描。算法&lt;code&gt;replace&lt;/code&gt;要求前向迭代器，&lt;code&gt;forward_list&lt;/code&gt;上的迭代器就是前向迭代器。&lt;/p&gt;
&lt;h4&gt;双向迭代器&lt;/h4&gt;
&lt;p&gt;双向迭代器：可以正向/反向读写序列中的元素。除了支持所有前向迭代器的操作之外，双向迭代器还支持前置和后置递减运算符（--）。算法&lt;code&gt;reverse&lt;/code&gt;要求双向迭代器，除了&lt;code&gt;forward_list&lt;/code&gt;之外，其他标准库都提供符合双向迭代器要求的迭代器。&lt;/p&gt;
&lt;h4&gt;随机迭代器&lt;/h4&gt;
&lt;p&gt;随机访问迭代器：提供在常量时间内访问序列中的任意元素的能力。此类迭代器支持双向迭代器的所有功能，此外还支持如下的操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用于比较两个迭代器相对位置的关系运算符（&amp;lt;、&amp;lt;=、&amp;gt; 和 &amp;gt;=）&lt;/li&gt;
&lt;li&gt;迭代器和一个整数值的加减运算（+、+=、- 和 -=），计算结果是迭代器在序列中前进（或后退）给定整数个元素后的位置&lt;/li&gt;
&lt;li&gt;用于两个迭代器上的减法运算符（-）得到两个迭代器的距离&lt;/li&gt;
&lt;li&gt;下标运算符 (iter[n])，与 *(iter[n]) 等价&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;算法&lt;code&gt;sort&lt;/code&gt;要求随机访问迭代器，&lt;code&gt;array&lt;/code&gt;、&lt;code&gt;deque&lt;/code&gt;、&lt;code&gt;string&lt;/code&gt;和&lt;code&gt;vector&lt;/code&gt;的迭代器都是随机访问迭代器，用于访问内置数组元素的指针也是。&lt;/p&gt;
&lt;h3&gt;算法形参模式&lt;/h3&gt;
&lt;p&gt;在任何其他算法分类之上，还有一组参数规范。大多数算法具有如下4种形式之一：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;alg(beg, end, other args);
alg(beg, end, dest, other args);
alg(beg, end, beg2, other args);
alg(beg, end, beg2, end2, other args);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中 alg 是算法的名字，beg 和 end 表示算法所操作的输入范围。几乎所有算法都接受一个输入范围，是否有其他参数依赖于要执行的操作。这里列出了常见的一种——dest、beg2 和 end2，都是迭代器参数。顾名思义，如果用到了这些迭代器参数，它们分别承担指定目的位置和第二个范围的角色。除了这些迭代器参数，一些算法还接受额外的、非迭代器的特定参数。&lt;/p&gt;
&lt;h3&gt;算法命名规范&lt;/h3&gt;
&lt;h4&gt;一些算法使用重载形式传递一个谓词&lt;/h4&gt;
&lt;p&gt;接受谓词参数来代替 &amp;lt; 或 == 运算符的算法，以及哪些不接受额外参数的算法，通常都是重载的函数。函数的一个版本用元素类型的运算符来比较元素；另一个版本接受一个额外谓词参数，来代替 &amp;lt; 或 ==。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;unique(beg, end);  //使用 == 运算符比较元素
unique(beg, end, comp); 　　//使用 comp 比较运元素
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;两个调用都重新整理给定序列，将相邻的重复元素删除。第一个调用使用元素类型的 == 运算符来检查重复元素；第二个则调用 comp 来确定两个元素是否相等。由于两个版本的函数在参数个数上不相等，因此具体应该调用那个不会产生歧义。&lt;/p&gt;
&lt;h4&gt;_if 版本的算法&lt;/h4&gt;
&lt;p&gt;接受一个元素值的算法通常有另一个不同名的版本，该版本接受一个谓词代替元素值。接受谓词参数的算法都有附加 _if 前缀：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;find(beg, end, val); //查找输入范围中 val 第一次出现的位置
find_if(beg, end, pred);  //查找第一个令 pred 为真的元素
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这两个算法提供了命名上的差异的版本，而非重载版本，因为两个版本的算法都接受相同数目的参数。因此可能产生重载歧义，虽然很罕见，但为了避免任何可能的歧义，标准库提供不同名字的版本而不是重载。&lt;/p&gt;
&lt;h4&gt;区分拷贝元素的版本和不拷贝的版本&lt;/h4&gt;
&lt;p&gt;默认情况下，重排元素的算法将重排后的元素写回固定的输入序列中。这些算法还提供另一个版本，将元素写到一个指定的输出目的位置。如我们所见，写到额外目的空间的算法都在名字后面附加一个 _copy：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;reverse(beg, end); //反转输入范围中元素的顺序
reverse_copy(beg, end, dest); //将元素按逆序拷贝到 dest
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;一些算法同时提供 _copy 和 _if 版本。这些版本接受一个目的位置迭代器和一个谓词：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//从 v1 中删除奇数元素
remove_if(v1.begin(), v1.end(), [] (int i) { return i % 2; });
//将偶数元素从 v1 拷贝到 v2；v1 不变
remove_copy_if(v1.begin(), v1.end(), back_inserter(v2), [] (int i) { return i % 2; });
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;两个算法都调用了&lt;code&gt;lambda&lt;/code&gt;来确定元素是否为奇数。在第一个调用中，我们从输入序列中将奇数元素删除。在第二个调用中，我们将非奇数（即偶数）元素从输入范围拷贝到 v2 中。&lt;/p&gt;
&lt;h2&gt;特定容器算法&lt;/h2&gt;
&lt;p&gt;与其他容器不同，链表类型&lt;code&gt;list&lt;/code&gt;与&lt;code&gt;forward_list&lt;/code&gt;定义了几个成员函数形式的算法。特别是，它们定义了独有的&lt;code&gt;sort&lt;/code&gt;、&lt;code&gt;merge&lt;/code&gt;、&lt;code&gt;remove&lt;/code&gt;、&lt;code&gt;reverse&lt;/code&gt;和&lt;code&gt;unique&lt;/code&gt;。通用版本的&lt;code&gt;sort&lt;/code&gt;要求随机访问迭代器，因此不能用于&lt;code&gt;list&lt;/code&gt;和&lt;code&gt;forward_list&lt;/code&gt;，因为这两个类型分别提供双向迭代器和前向迭代器。&lt;/p&gt;
&lt;p&gt;链表类型定义的其他算法的通用版本可以用于链表，但代价太高。这些算法需要交换输入序列中的元素。一个链表可以通过改变元素间的链接而不是真正的交换它们的值来传递“交换”元素。因此，这些链表版本的算法的性能比对应的通用版本好很多。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对于&lt;code&gt;list&lt;/code&gt;和&lt;code&gt;forward_list&lt;/code&gt;应该优先使用成员函数版本的算法而不是通用算法。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;list&lt;/code&gt;和&lt;code&gt;forward_list&lt;/code&gt;成员函数版本的算法，这些操作都返回&lt;code&gt;void&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;lst.merge(lst2)、lst.merge(lst2, comp)：将来自 lst2 的元素合并入 lst。lst 和 lst2 都必须是有序的。元素将从 lst2 中删除。在合并之后，lst2 变为空。第一个版本使用 &amp;lt; 运算符；第二个版本使用给定的比较操作&lt;/li&gt;
&lt;li&gt;lst.remove(val)、lst.remove_if(pred)：调用 erase 删除掉与给定值相等（==）或令一元谓词为真的每个元素&lt;/li&gt;
&lt;li&gt;lst.reverse()：反转 lst 中元素的顺序&lt;/li&gt;
&lt;li&gt;lst.sort()、lst.sort(comp)：使用 &amp;lt; 或给定比较操作排序元素&lt;/li&gt;
&lt;li&gt;lst.unique()、lst.unique(pred)：调用 erase 删除同一值的连续拷贝。第一个版本使用 ==；第二个版本使用给定的二元谓词&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;splice 成员&lt;/h3&gt;
&lt;p&gt;链表类型还定义了splice算法。此算法是链表数据结构所特有的，因此不需要通用版本。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;list&lt;/code&gt;和&lt;code&gt;forward_list&lt;/code&gt;的&lt;code&gt;splice&lt;/code&gt;成员函数的参数：&lt;/p&gt;
&lt;p&gt;lst.splice(args)或flst.splice_after(args)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(p,lst2)：p 是一个指向 lst 中元素的迭代器，或一个指向 flst 首前位置的迭代器。函数将 lst2 的所有元素移动到 lst 中 p 之前的位置或是 flst 中 p 之后的位置。将元素从 lst2 中删除。lst2 的类型必须与 lst 或 flst 相同，且不能是同一个链表&lt;/li&gt;
&lt;li&gt;(p,lst2,p2)：p2 是一个指向 lst2 中位置的有效的迭代器。将 p2 指向的元素移动到 lst 中，或将 p2 之后的元素移动到 flst 中。lst2 可以是与 lst 或 flst 相同的链表&lt;/li&gt;
&lt;li&gt;(p,lst2,b,e)：b 和 e 必须表示 lst2 中的合法范围。将给定范围中的元素从 lst2 移动到 lst 或 flst。lst2 与 lst（或 flst）可以是相同的链表，但 p 不能指向给定范围中元素&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;链表特有的操作会改变容器&lt;/h3&gt;
&lt;p&gt;多数链表特有的算法都与其通用版本很相似，但不完全相同。链表特有版本与通用版本间的一个至关重要的区别是链表版本会改变底层的容器。例如，&lt;code&gt;remove&lt;/code&gt;的链表版本会删除指定的元素。&lt;code&gt;unique&lt;/code&gt;的链表版本会删除第二个和后继的重复元素。&lt;/p&gt;
&lt;p&gt;类似的，&lt;code&gt;merge&lt;/code&gt;和&lt;code&gt;splice&lt;/code&gt;会销毁其参数。例如，通用版本的&lt;code&gt;remove&lt;/code&gt;将合并的序列写给一个给定的目的迭代器：两个输入序列是不变的。而链表版本的&lt;code&gt;merge&lt;/code&gt;函数会销毁给定的链表——元素从参数指定的链表中删除，被合并到调用&lt;code&gt;merge&lt;/code&gt;的链表对象中。在&lt;code&gt;merge&lt;/code&gt;之后，来自两个链表中的元素仍然存在，但它们都已在同一个链表中。&lt;/p&gt;</content><category term="C++"></category></entry><entry><title>C++ Primer 第九章 顺序容器</title><link href="https://xutree.github.io/pages/2018/10/16/C++_Primer_Chapter_9/" rel="alternate"></link><published>2018-10-16T22:43:16+08:00</published><updated>2018-10-17T11:12:28+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-16:/pages/2018/10/16/C++_Primer_Chapter_9/</id><summary type="html">&lt;p&gt;一个容器就是一些特定类型对象的集合。顺序容器（sequential container）为程序员提供了控制元素存储和访问顺序的能力。这种顺序不依赖于元素的值，而是与元素加入容器时的位置相对应。&lt;/p&gt;
&lt;h2&gt;顺序容器概述&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;类型&lt;/th&gt;
&lt;th align="left"&gt;简介&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;code&gt;vector&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;可变大小数组。支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;code&gt;deque&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;双端队列。支持快速随机访问。在头尾位置插入或删除速度很快&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;code&gt;list&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;双向链表。只支持双向顺序访问。在任何位置进行插入或删除都很快&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;code&gt;forward_list&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;单向链表。只支持单向顺序访问。在任何位置进行插入或删除都很快&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;code&gt;array&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;固定大小数组。支持快速随机访问。不能添加或删除元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;code&gt;string&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;与&lt;code&gt;vector&lt;/code&gt;相似的容器，专门用于保存字符。随机访问快。在尾部插入或删除快&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;string&lt;/code&gt;和&lt;code&gt;vector&lt;/code&gt;保存在连续的内存空间中，因此由下标计算地址非常快速。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;forward_list&lt;/code&gt;的设计目标是达到与最好的手写的单向链表数据结构相当的性能，因此不提供&lt;code&gt;size&lt;/code&gt;操作，因为保存和计算大小会增加开销。&lt;/p&gt;
&lt;p&gt;通常，&lt;code&gt;vector …&lt;/code&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;一个容器就是一些特定类型对象的集合。顺序容器（sequential container）为程序员提供了控制元素存储和访问顺序的能力。这种顺序不依赖于元素的值，而是与元素加入容器时的位置相对应。&lt;/p&gt;
&lt;h2&gt;顺序容器概述&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;类型&lt;/th&gt;
&lt;th align="left"&gt;简介&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;code&gt;vector&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;可变大小数组。支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;code&gt;deque&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;双端队列。支持快速随机访问。在头尾位置插入或删除速度很快&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;code&gt;list&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;双向链表。只支持双向顺序访问。在任何位置进行插入或删除都很快&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;code&gt;forward_list&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;单向链表。只支持单向顺序访问。在任何位置进行插入或删除都很快&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;code&gt;array&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;固定大小数组。支持快速随机访问。不能添加或删除元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;code&gt;string&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;与&lt;code&gt;vector&lt;/code&gt;相似的容器，专门用于保存字符。随机访问快。在尾部插入或删除快&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;string&lt;/code&gt;和&lt;code&gt;vector&lt;/code&gt;保存在连续的内存空间中，因此由下标计算地址非常快速。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;forward_list&lt;/code&gt;的设计目标是达到与最好的手写的单向链表数据结构相当的性能，因此不提供&lt;code&gt;size&lt;/code&gt;操作，因为保存和计算大小会增加开销。&lt;/p&gt;
&lt;p&gt;通常，&lt;code&gt;vector&lt;/code&gt;是最好的选择。&lt;/p&gt;
&lt;p&gt;每个容器都定义在同名的头文件中，容器均是模板类。&lt;/p&gt;
&lt;h2&gt;容器库概览&lt;/h2&gt;
&lt;h3&gt;类型别名&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;类型别名&lt;/th&gt;
&lt;th align="left"&gt;意义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;code&gt;iterator&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;此容器类型的迭代器类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;code&gt;const_iterator&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;常量迭代器类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;code&gt;size_type&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;无符号整数，足够保存此种容器的最大大小&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;code&gt;difference_type&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;带符号整数，足够保存两个迭代器之间的距离&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;code&gt;value_type&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;元素类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;code&gt;reference&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;元素的左值类型，与&lt;code&gt;value_type&amp;amp;&lt;/code&gt;含义相同&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;code&gt;const_reference&lt;/code&gt;&lt;/td&gt;
&lt;td align="left"&gt;常量左值类型&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;构造函数&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;构造函数&lt;/th&gt;
&lt;th align="left"&gt;意义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;C c;&lt;/td&gt;
&lt;td align="left"&gt;默认构造函数，构造空容器。如果 c 是一个&lt;code&gt;array&lt;/code&gt;，则元素按默认方式初始化&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;C c1(c2);&lt;/td&gt;
&lt;td align="left"&gt;构造 c2 的拷贝 c1，必须为相同类型，且保存元素也相同&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;C c1 = c2;&lt;/td&gt;
&lt;td align="left"&gt;同上&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;C c(b, e);&lt;/td&gt;
&lt;td align="left"&gt;构造 c，将迭代器指定的范围内的元素拷贝到 c，类型要相容（&lt;code&gt;array&lt;/code&gt;不支持）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td a_="a," align="left" b_="b," c...&gt;C c&lt;/td&gt;
&lt;td align="left"&gt;列表初始化，类型要相容，遗漏元素值初始化&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td a_="a," align="left" b_="b," c...&gt;C c = &lt;/td&gt;
&lt;td align="left"&gt;同上&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;C seq(n);&lt;/td&gt;
&lt;td align="left"&gt;包含 n 个元素并进行值初始化，是&lt;code&gt;explicit&lt;/code&gt;构造函数（&lt;code&gt;string&lt;/code&gt;不要求explicit）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;C seq(n, t);&lt;/td&gt;
&lt;td align="left"&gt;包含 n 个初始值为 t 的元素&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;只有顺序容器（不包括&lt;code&gt;array&lt;/code&gt;的构造函数才能接受大小参数）。如果元素类型没有默认构造函数，除了大小参数外，还需要显式指定元素初始值。&lt;code&gt;array&lt;/code&gt;支持拷贝和赋值（内置数组不行）。&lt;/p&gt;
&lt;h3&gt;赋值与 swap&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;赋值与 swap&lt;/th&gt;
&lt;th align="left"&gt;意义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;c1 = c2;&lt;/td&gt;
&lt;td align="left"&gt;将 c1 中的元素替换成 c2 中的元素，类型要相同&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td a_="a," align="left" b_="b," c...&gt;c1 = &lt;/td&gt;
&lt;td align="left"&gt;将 c1 中的元素替换成列表中的元素（&lt;code&gt;array&lt;/code&gt;不支持）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;a.swap(b);&lt;/td&gt;
&lt;td align="left"&gt;交换 a 和 b 的元素，类型要相同，此操作通常比拷贝元素快得多&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;swap(a, b);&lt;/td&gt;
&lt;td align="left"&gt;与上面等价&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;seq.assign(b, e)&lt;/td&gt;
&lt;td align="left"&gt;将 seq 中的元素替换为迭代器范围中的元素，迭代器不能指向 seq 的元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;seq.assign(il)&lt;/td&gt;
&lt;td align="left"&gt;用初始化列表替换&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;seq.assign(n, t)&lt;/td&gt;
&lt;td align="left"&gt;用 n 个 t 替换&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;由于右边运算对象的大小可能与左边不同，因此&lt;code&gt;array&lt;/code&gt;不支持&lt;code&gt;assign&lt;/code&gt;，也不运行用花括号包围的值列表赋值。&lt;code&gt;assign&lt;/code&gt;不适用于关联容器。&lt;code&gt;assign&lt;/code&gt;仅要求类型相容。&lt;/p&gt;
&lt;p&gt;赋值相关操作会导致指向左边容器内部的迭代器、引用和指针失效，而&lt;code&gt;swap&lt;/code&gt;操作不会导致失效（&lt;code&gt;array&lt;/code&gt;和&lt;code&gt;string&lt;/code&gt;除外），它们仍指向交换之前的那些元素。&lt;/p&gt;
&lt;p&gt;除&lt;code&gt;array&lt;/code&gt;外，&lt;code&gt;swap&lt;/code&gt;不对任何元素进行拷贝、删除和插入操作，因此可以保证在常数时间完成，它只是交换了两个容器的内部数据结构。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;swap&lt;/code&gt;两个&lt;code&gt;array&lt;/code&gt;会真正交换它们的元素。在操作之后，指针、引用和迭代器所绑定的元素保持不变，但元素值已经和另一个&lt;code&gt;array&lt;/code&gt;中对应元素的值进行了交换。&lt;/p&gt;
&lt;p&gt;统一使用非成员版本的&lt;code&gt;swap&lt;/code&gt;是一个好习惯。&lt;/p&gt;
&lt;h3&gt;容器大小操作&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;大小&lt;/th&gt;
&lt;th align="left"&gt;意义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;c.size();&lt;/td&gt;
&lt;td align="left"&gt;c 中元素的数目，&lt;code&gt;forward_list&lt;/code&gt;不支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;c.max_size();&lt;/td&gt;
&lt;td align="left"&gt;c 可保存的最大元素数目&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;c.empty();&lt;/td&gt;
&lt;td align="left"&gt;判空&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;关系运算符&lt;/th&gt;
&lt;th align="left"&gt;意义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;==、!=&lt;/td&gt;
&lt;td align="left"&gt;所有容器都支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&amp;lt;、&amp;lt;=、&amp;gt;、&amp;gt;=&lt;/td&gt;
&lt;td align="left"&gt;无序关联容器不支持，类型相同，保存元素也要相同&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;添加元素&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;添加元素&lt;/th&gt;
&lt;th align="left"&gt;意义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;c.push_back(t)&lt;/td&gt;
&lt;td align="left"&gt;在尾部创建值为 t 的元素，返回&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;c.emplace_back(args)&lt;/td&gt;
&lt;td align="left"&gt;在尾部用参数构造元素，返回&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;c.push_front(t)&lt;/td&gt;
&lt;td align="left"&gt;在头部创建值为 t 的元素，返回&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;c.emplace_front(t)&lt;/td&gt;
&lt;td align="left"&gt;在头部用参数构造元素，返回&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;c.insert(p, t)&lt;/td&gt;
&lt;td align="left"&gt;在迭代器 p 指向的元素之前创建值为 t 的元素，返回指向新添加元素迭代器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;c.emplace(p, args)&lt;/td&gt;
&lt;td align="left"&gt;在迭代器 p 指向的元素之前构造值为 t 的元素，返回指向新添加元素迭代器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;c.insert(p, b, e)&lt;/td&gt;
&lt;td align="left"&gt;在迭代器 p 指向的元素之前插入迭代器范围指定的元素，返回指向新添加的第一个元素的迭代器，若范围为空，返回 p&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;c.insert(p, n, t)&lt;/td&gt;
&lt;td align="left"&gt;n 个 t&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;c.insert(p, il)&lt;/td&gt;
&lt;td align="left"&gt;列表&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;这些操作会改变容器大小，&lt;code&gt;array&lt;/code&gt;不支持。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;forward_list&lt;/code&gt;有自己版本的 insert 和 emplace。&lt;code&gt;forward_list&lt;/code&gt;不支持 push_back 和 emplace_back。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vector&lt;/code&gt;和&lt;code&gt;string&lt;/code&gt;不支持push_front 和 emplace_front。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;emplace&lt;/code&gt;函数会在容器管理的内存空间中直接创建对象，而&lt;code&gt;push&lt;/code&gt;函数会创建一个局部临时变量，并将其压入容器中。传递给&lt;code&gt;emplace&lt;/code&gt;的参数必须与元素类型的构造函数相匹配。&lt;/p&gt;
&lt;h3&gt;访问元素&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;访问元素&lt;/th&gt;
&lt;th align="left"&gt;意义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;c.back()&lt;/td&gt;
&lt;td align="left"&gt;返回尾元素引用。若 c 为空，行为未定义&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;c.front()&lt;/td&gt;
&lt;td align="left"&gt;返回首元素引用。若 c 为空，行为未定义&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;c[n]&lt;/td&gt;
&lt;td align="left"&gt;返回下标为 n 元素的引用，n 是一个无符号整数。若 n &amp;gt;= c.size()，行为未定义&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;c.at(n)&lt;/td&gt;
&lt;td align="left"&gt;返回下标为 n 元素的引用，若 n 越界，抛出 out_of_range 异常&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;at&lt;/code&gt;和下标操作只适用于&lt;code&gt;string&lt;/code&gt;、&lt;code&gt;vector&lt;/code&gt;、&lt;code&gt;deque&lt;/code&gt;和&lt;code&gt;array&lt;/code&gt;。&lt;code&gt;back&lt;/code&gt;不适用于&lt;code&gt;forward_list&lt;/code&gt;。&lt;/p&gt;
&lt;h3&gt;删除元素&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;删除元素&lt;/th&gt;
&lt;th align="left"&gt;意义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;c.pop_back()&lt;/td&gt;
&lt;td align="left"&gt;删除尾元素。若 c 为空，行为未定义。返回&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;c.pop_front()&lt;/td&gt;
&lt;td align="left"&gt;删除首元素。若 c 为空，行为未定义。返回&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;c.erase(p);&lt;/td&gt;
&lt;td align="left"&gt;删除迭代器所指元素，返回被删除元素之后元素的迭代器，若 p 为尾后迭代器，行为未定义&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;c.erase(b, e);&lt;/td&gt;
&lt;td align="left"&gt;删除迭代器所指元素，返回最后一个被删除元素之后元素的迭代器，若 e 为尾后迭代器，函数返回尾后迭代器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;c.clear();&lt;/td&gt;
&lt;td align="left"&gt;清空，返回&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;这些操作会改变容器大小，&lt;code&gt;array&lt;/code&gt;不支持。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;forward_list&lt;/code&gt;有自己版本的 erase。&lt;code&gt;forward_list&lt;/code&gt;不支持 pop_back。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vector&lt;/code&gt;和&lt;code&gt;string&lt;/code&gt;不支持pop_front。&lt;/p&gt;
&lt;p&gt;删除元素的成员函数并不检查其参数。在删除元素前，程序员必须确保它们是存在的。&lt;/p&gt;
&lt;h3&gt;迭代器&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;迭代器&lt;/th&gt;
&lt;th align="left"&gt;意义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;c.begin(), c.end()&lt;/td&gt;
&lt;td align="left"&gt;首尾迭代器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;c.cbegin(), c.cend()&lt;/td&gt;
&lt;td align="left"&gt;首尾常量迭代器&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;反向容器额外成员&lt;/th&gt;
&lt;th align="left"&gt;意义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;reverse_iterator&lt;/td&gt;
&lt;td align="left"&gt;按逆序寻址元素的迭代器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;const_reverse_iterator&lt;/td&gt;
&lt;td align="left"&gt;按逆序寻址元素的常量迭代器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;c.rbegin(), c.rend()&lt;/td&gt;
&lt;td align="left"&gt;尾首迭代器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;c.crbegin(), c.crend()&lt;/td&gt;
&lt;td align="left"&gt;尾首常量迭代器&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;注：&lt;code&gt;forward_list&lt;/code&gt;不支持&lt;/p&gt;
&lt;h3&gt;特殊的 forward_list 操作&lt;/h3&gt;
&lt;p&gt;为了理解&lt;code&gt;forward_list&lt;/code&gt;为什么有特殊版本的添加和删除操作，考虑当我们从一个单向链表中删除一个元素时会发生什么。当添加或删除一个元素时，删除或添加的元素之前的那个元素的后继会发生变化。为了添加或删除一个元素，我们需要访问其前驱，以便改变前驱改变前驱的链接。但是，&lt;code&gt;forward_list&lt;/code&gt;是单向链表。在一个单向链表中，没有简单的方法来获取一个元素的前驱，出于这个原因，在一个&lt;code&gt;forward_list&lt;/code&gt;中添加或删除元素的操作是通过改变给定元素之后的元素来完成的。这样，我们总是可以访问到被添加或删除元素所影响的元素。&lt;/p&gt;
&lt;p&gt;由于这些操作与其他容器上的操作有实现方式不同，&lt;code&gt;forward_list&lt;/code&gt;并未定义&lt;code&gt;insert&lt;/code&gt;、&lt;code&gt;emplace&lt;/code&gt;和&lt;code&gt;erase&lt;/code&gt;，而是定义了名为&lt;code&gt;insert_after&lt;/code&gt;、&lt;code&gt;emplace_after&lt;/code&gt;和&lt;code&gt;erase_after&lt;/code&gt;的操作。为了支持这些操作，&lt;code&gt;forward_list&lt;/code&gt;也定义了&lt;code&gt;before_begin&lt;/code&gt;,它返回一个首前迭代器。这个迭代器允许我们在链表首元素之前并不存在的元素“之后”添加或删除元素（亦即在链表首元素之前添加删除元素）。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;操作&lt;/th&gt;
&lt;th align="left"&gt;意义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;lst.before_begin()&lt;/td&gt;
&lt;td align="left"&gt;返回指向链表首元素之前并不存在的元素的迭代器，此迭代器不能解引用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;lst.cbefore_begin()&lt;/td&gt;
&lt;td align="left"&gt;cbefore_begin() 返回一个 const_iterator&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;lst.insert_after(p, t)&lt;/td&gt;
&lt;td align="left"&gt;在迭代器 p 之后的位置插入元素 t，若 p 为尾后迭代器，则函数的行为未定义。若范围为空，返回 p&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;lst.insert_after(p, n, t)&lt;/td&gt;
&lt;td align="left"&gt;在迭代器 p 之后的位置插入 n 个 t&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;lst.insert_after(p, b, e)&lt;/td&gt;
&lt;td align="left"&gt;在迭代器 p 之后的位置插入迭代器范围表示的元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;lst.insert_after(p,il)&lt;/td&gt;
&lt;td align="left"&gt;在迭代器 p 之后的位置插入花括号列表&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;emplace_after(p,args)&lt;/td&gt;
&lt;td align="left"&gt;使用 args 在 p 指定的位置之后构造一个元素，返回一个指向这个新元素的迭代器。若 p 为尾后迭代器，则函数的行为未定义&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;lst.erase_after(p)&lt;/td&gt;
&lt;td align="left"&gt;删除 p 指向的位置之后的元素，返回一个指向被删除元素之后元素的迭代器，若不存在这样的元素，则返回尾后迭代器，如果 p 指向 lst 的尾元素或者是一个尾后迭代器，则函数的行为未定义&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;lst.erase_after(b, e)&lt;/td&gt;
&lt;td align="left"&gt;删除从 b 之后直到（但不包含）e 之间的元素&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;改变容器大小&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;操作&lt;/th&gt;
&lt;th align="left"&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;c.resize(n)&lt;/td&gt;
&lt;td align="left"&gt;调整 c 的大小为 n 个元素。若 n &amp;lt; c.size()，多出的元素被丢弃。若必须添加新元素，则新元素采取值初始化&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;c.resize(n, t)&lt;/td&gt;
&lt;td align="left"&gt;调整 c 的大小为 n 个元素。，多出的元素被丢弃。若必须添加新元素，则新元素初始化为 t&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;c.shrink_to_fit()&lt;/td&gt;
&lt;td align="left"&gt;请求将&lt;code&gt;capacity()&lt;/code&gt;减小为与&lt;code&gt;size()&lt;/code&gt;相同，具体的实现可能忽略此请求&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;c.capacity()&lt;/td&gt;
&lt;td align="left"&gt;不重新分配内存的话，c 可以保存多少元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;c.reserve(n)&lt;/td&gt;
&lt;td align="left"&gt;分配至少能容纳 n 个元素的内存空间&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;shrink_to_fit()&lt;/code&gt;只适用于&lt;code&gt;vector&lt;/code&gt;、&lt;code&gt;string&lt;/code&gt;和&lt;code&gt;deque&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;capacity()&lt;/code&gt;和&lt;code&gt;reserve(n)&lt;/code&gt;只适用于&lt;code&gt;vector&lt;/code&gt;和&lt;code&gt;string&lt;/code&gt;。&lt;/p&gt;
&lt;h2&gt;迭代器失效&lt;/h2&gt;
&lt;h3&gt;添加元素&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;vector&lt;/code&gt;或&lt;code&gt;string&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;存储空间重新分配：迭代器、指针、引用均失效&lt;/li&gt;
&lt;li&gt;未重新分配：插入位置之前的有效，之后的失效&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;deque&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;插入首尾之外：均失效&lt;/li&gt;
&lt;li&gt;插入首尾：迭代器失效，指针、引用不失效&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;list&lt;/code&gt;或&lt;code&gt;forward_list&lt;/code&gt;：都有效（包括尾后和首前）&lt;/p&gt;
&lt;h3&gt;删除元素&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;list&lt;/code&gt;或&lt;code&gt;forward_list&lt;/code&gt;：都有效（包括尾后和首前）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;deque&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;删除首尾之外：均失效&lt;/li&gt;
&lt;li&gt;删除首：首前失效，其他有效&lt;/li&gt;
&lt;li&gt;删除尾：尾后失效，其他有效&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;vector&lt;/code&gt;或&lt;code&gt;string&lt;/code&gt;：被删除元素之前的都有效&lt;/p&gt;
&lt;p&gt;当我们删除元素时，尾后迭代器总是会失效（除了删除&lt;code&gt;deque&lt;/code&gt;首元素外），所以不要保存&lt;code&gt;end&lt;/code&gt;返回的迭代器。&lt;/p&gt;
&lt;h2&gt;额外的 string 操作&lt;/h2&gt;
&lt;h3&gt;构造 string 的其他方法&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;方法&lt;/th&gt;
&lt;th align="left"&gt;解释&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;string s(cp, n)&lt;/td&gt;
&lt;td align="left"&gt;s 是 cp 指向的数组中前 n 个字符的拷贝。此数组至少应该包含 n 个字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;string s(s2, pos2)&lt;/td&gt;
&lt;td align="left"&gt;s 是 string s2 从下标 pos2 开始的字符的拷贝。若 pos2 &amp;gt; s2.size()，行为未定义&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;/td&gt;
&lt;td align="left"&gt;string s(s2, pos2, len2)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;这些构造函数接受一个&lt;code&gt;string&lt;/code&gt;或&lt;code&gt;const char*&lt;/code&gt;参数。从&lt;code&gt;const char*&lt;/code&gt;拷贝时，指针指向的数组必须以空字符结尾，如果还传递了一个计数值，数组就不必以空字符结尾。&lt;/p&gt;
&lt;h3&gt;substr 操作&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;s.substr(pos, n)&lt;/code&gt;返回一个&lt;code&gt;string&lt;/code&gt;，包含 s 中从 pos 开始的 n 个字符的拷贝。pos 的默认值是0，n 的默认值是 s.size()-pos，即拷贝从 pos 开始的所有字符。如果开始位置超出&lt;code&gt;string&lt;/code&gt;的大小，抛出 out_of_range 异常，不管 n 值为多少，最多拷贝到&lt;code&gt;string&lt;/code&gt;的末尾。&lt;/p&gt;
&lt;h3&gt;其他修改 string 的操作&lt;/h3&gt;
&lt;p&gt;&lt;img alt="修改 string 的操作" src="https://xutree.github.io/images/c++9-1.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="repalce 和 insert参数类型" src="https://xutree.github.io/images/c++9-2.jpg"&gt;&lt;/p&gt;
&lt;h3&gt;string 搜索操作&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;string&lt;/code&gt;类提供了6个不同的搜索函数，每个函数有4个重载版本。每个搜索操作都返回&lt;code&gt;string::size_type&lt;/code&gt;值，表示匹配发生的下标。如果搜索失败，则返回&lt;code&gt;string::npos&lt;/code&gt;的&lt;code&gt;static&lt;/code&gt;成员。标准库将&lt;code&gt;string::npos&lt;/code&gt;定义成一个&lt;code&gt;const string::size_type&lt;/code&gt;，并初始化为-1。由于 npos 是一个无符号数，此初始值意味着 npos 等于任何&lt;code&gt;string&lt;/code&gt;最大的可能大小。&lt;/p&gt;
&lt;p&gt;&lt;img alt="string 搜索操作" src="https://xutree.github.io/images/c++9-3.jpg"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="string 搜索操作参数" src="https://xutree.github.io/images/c++9-4.jpg"&gt;&lt;/p&gt;
&lt;h3&gt;compare 函数&lt;/h3&gt;
&lt;p&gt;&lt;img alt="compare 函数" src="https://xutree.github.io/images/c++9-5.jpg"&gt;&lt;/p&gt;
&lt;h3&gt;数值转换&lt;/h3&gt;
&lt;p&gt;&lt;img alt="string 数值转换" src="https://xutree.github.io/images/c++9-6.jpg"&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;string s2 = &amp;quot;pi = 3.14&amp;quot;;
d = stod(s2.substr(s2.find_first_of(&amp;quot;+-.0123456789&amp;quot;)));
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;容器适配器&lt;/h2&gt;
&lt;p&gt;适配器（adaptors）是标准库中的一个通用概念，容器、迭代器和函数都有适配器。本质上，一个适配器是一种机制，能使某种事物的行为看起来像另外一种事物一样。一个容器适配器（Container adaptors）接受一种已有的容器类型，使其行为看起来像一种不同的类型。标准库定义了三个序列容器适配器：&lt;code&gt;stack&lt;/code&gt;、&lt;code&gt;queue&lt;/code&gt;和&lt;code&gt;priority_queue&lt;/code&gt;。&lt;/p&gt;
&lt;h3&gt;所以适配器都支持的的操作和类型&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;名称&lt;/th&gt;
&lt;th align="left"&gt;意义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;size_type&lt;/td&gt;
&lt;td align="left"&gt;一种类型，足以保存当前类型的最大对象的大小&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;value_type&lt;/td&gt;
&lt;td align="left"&gt;元素类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;container_type&lt;/td&gt;
&lt;td align="left"&gt;实现适配器的底层容器类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;A a;&lt;/td&gt;
&lt;td align="left"&gt;创建一个名为 a 的空适配器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;A a(c);&lt;/td&gt;
&lt;td align="left"&gt;创建一个名为 a 的适配器，带有容器 c 的一个拷贝&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;关系运算符&lt;/td&gt;
&lt;td align="left"&gt;每个适配器都支持所有关系运算符。这些关系运算符返回底层容器的比较结果&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;a.empty()&lt;/td&gt;
&lt;td align="left"&gt;判空&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;a.size()&lt;/td&gt;
&lt;td align="left"&gt;元素数目&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;swap(a, b)&lt;/td&gt;
&lt;td align="left"&gt;交换，类型要相同，包括底层容器类型也必须相同&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;a.swap(b)&lt;/td&gt;
&lt;td align="left"&gt;同上&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;定义适配器&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;stack&lt;/code&gt;默认基于&lt;code&gt;deque&lt;/code&gt;实现，要求&lt;code&gt;push_back&lt;/code&gt;、&lt;code&gt;pop_back&lt;/code&gt;和&lt;code&gt;back&lt;/code&gt;操作，可使用除&lt;code&gt;array&lt;/code&gt;和&lt;code&gt;forward_list&lt;/code&gt;之外的任何容器构造&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;queue&lt;/code&gt;默认基于&lt;code&gt;deque&lt;/code&gt;实现，要求&lt;code&gt;back&lt;/code&gt;、&lt;code&gt;push_back&lt;/code&gt;、&lt;code&gt;front&lt;/code&gt;、&lt;code&gt;push_front&lt;/code&gt;操作，可使用&lt;code&gt;list&lt;/code&gt;和&lt;code&gt;deque&lt;/code&gt;构造&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;priority_queue&lt;/code&gt;默认基于&lt;code&gt;vector&lt;/code&gt;实现，要求&lt;code&gt;front&lt;/code&gt;、&lt;code&gt;push_back&lt;/code&gt;和&lt;code&gt;pop_back&lt;/code&gt;操作，还需要随机访问能力，可使用&lt;code&gt;vector&lt;/code&gt;和&lt;code&gt;deque&lt;/code&gt;构造&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;两种构造方法：默认构造函数创建一个空对象；接受一个容器的构造函数拷贝该容器来初始化适配器。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//假设 deq 是一个 deque&amp;lt;int&amp;gt;
stack&amp;lt;int&amp;gt; stk(deq);    //从 deq 拷贝元素到 stk
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们可以在创建一个适配器时将一个命名的顺序容器作为第二个类型参数，来重载默认容器类型：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//在 vector 上实现的空栈
stack&amp;lt;string, vector&amp;lt;string&amp;gt;&amp;gt; str_stk;
//在 vector 上实现的空栈，初始化时保存 svec 的拷贝
stack&amp;lt;string, vector&amp;lt;string&amp;gt;&amp;gt; str_stk2（svec);
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;栈适配器&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;stack&lt;/code&gt;类型定义在同名头文件中。下面展示了如何使用：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;stack&amp;lt;int&amp;gt; intStack;  //空栈
//填满栈
for (size_t ix = 0; ix != 10; ++ix)
    intStack.push(ix);  //栈保存0-9十个数
while (!intStack.empty()) { //栈中有值就继续循环
    int value = intStack.top();
    //使用栈顶值的代码
    intStack.pop(); //弹出栈顶元素，继续循环
}
&lt;/pre&gt;&lt;/div&gt;


&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;操作&lt;/th&gt;
&lt;th align="left"&gt;意义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;s.pop()&lt;/td&gt;
&lt;td align="left"&gt;删除栈顶元素，但不返回该元素值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;s.push(item)&lt;/td&gt;
&lt;td align="left"&gt;创建一个新元素压入栈顶，该元素通过拷贝或移动 item 而来&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;s.emplace(args)&lt;/td&gt;
&lt;td align="left"&gt;构造一个新元素压入栈顶，该元素通过 args 构造&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;s.top()&lt;/td&gt;
&lt;td align="left"&gt;返回栈顶元素，但不将元素弹出栈&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;每个容器适配器都基于底层容器类型的操作定义了自己的特殊操作，我们只能使用适配器操作，而不能使用底层容器类型的操作。&lt;/p&gt;
&lt;h3&gt;队列适配器&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;queue&lt;/code&gt;和&lt;code&gt;priority_queue&lt;/code&gt;定义在头文件 queue 中。操作方法如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;操作&lt;/th&gt;
&lt;th align="left"&gt;意义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;q.pop()&lt;/td&gt;
&lt;td align="left"&gt;删除 queue 的首元素或 priority_queue 的最高优先级的元素，但不返回该元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;q.front()&lt;/td&gt;
&lt;td align="left"&gt;返回首元素，但不删除此元素，只适用于 queue&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;q.back()&lt;/td&gt;
&lt;td align="left"&gt;返回尾元素，但不删除此元素，只适用于 queue&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;q.top()&lt;/td&gt;
&lt;td align="left"&gt;返回优先级最高的元素，但不删除该元素，只适用于 priority_queue&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;q.push(item)&lt;/td&gt;
&lt;td align="left"&gt;在 queue 末尾或 priority_queue 中恰当的位置创建一个元素，其值为 item&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;q.emplace(args)&lt;/td&gt;
&lt;td align="left"&gt;在 queue 末尾或 priority_queue 中恰当的位置由 args 参数构造一个元素&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</content><category term="C++"></category></entry><entry><title>数据结构——向量</title><link href="https://xutree.github.io/pages/2018/10/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%90%91%E9%87%8F/" rel="alternate"></link><published>2018-10-10T19:50:46+08:00</published><updated>2018-10-12T23:39:31+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-10:/pages/2018/10/10/数据结构向量/</id><summary type="html">&lt;p&gt;数据结构大致可分为：线性结构、半线性结构和非线性结构。线性结构中最基本的称为序列（sequence），根据其中数据项的逻辑次序与其物理存储地址的对应关系不同，又可分为向量（vector）和列表（list）。&lt;/p&gt;
&lt;h2&gt;从数组到向量&lt;/h2&gt;
&lt;p&gt;数组：集合 S 由 n 个元素组成，且各元素之间具有一个线性次序，则可以将它们存放于起始地址 A，物理位置连续的一段存储空间。记为：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;A[0,n) = { A[0], A[1], ..., A[n-1] }&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;将它们存放于起始地址 A，若每个元素占用 s 个单位的空间，则元素 A[i] 的物理地址为：&lt;code&gt;A + i * s&lt;/code&gt;，所以被称作线性数组。&lt;/p&gt;
&lt;p&gt;向量：&lt;code&gt;V[0,n) = { v[0 …&lt;/code&gt;&lt;/p&gt;</summary><content type="html">&lt;p&gt;数据结构大致可分为：线性结构、半线性结构和非线性结构。线性结构中最基本的称为序列（sequence），根据其中数据项的逻辑次序与其物理存储地址的对应关系不同，又可分为向量（vector）和列表（list）。&lt;/p&gt;
&lt;h2&gt;从数组到向量&lt;/h2&gt;
&lt;p&gt;数组：集合 S 由 n 个元素组成，且各元素之间具有一个线性次序，则可以将它们存放于起始地址 A，物理位置连续的一段存储空间。记为：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;A[0,n) = { A[0], A[1], ..., A[n-1] }&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;将它们存放于起始地址 A，若每个元素占用 s 个单位的空间，则元素 A[i] 的物理地址为：&lt;code&gt;A + i * s&lt;/code&gt;，所以被称作线性数组。&lt;/p&gt;
&lt;p&gt;向量：&lt;code&gt;V[0,n) = { v[0], v[1], ..., v[n-1] }&lt;/code&gt;是线性数组的一种抽象和泛化，由具有线性次序的一组元素构成的集合，其中的元素由秩区分。各元素秩互异，且均为 [0, n) 内的整数。采用“寻秩访问”。经过抽象，不限定同一向量中元素都属于同一数据类型，故而不保证它们之间可以相互比较大小。&lt;/p&gt;
&lt;h2&gt;接口&lt;/h2&gt;
&lt;p&gt;作为一种抽象数据类型，向量对象应支持如下操作接口：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;操作接口&lt;/th&gt;
&lt;th align="left"&gt;功能&lt;/th&gt;
&lt;th align="left"&gt;适用对象&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;size()&lt;/td&gt;
&lt;td align="left"&gt;元素总数&lt;/td&gt;
&lt;td align="left"&gt;向量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;get(r)&lt;/td&gt;
&lt;td align="left"&gt;获取秩为 r 的元素&lt;/td&gt;
&lt;td align="left"&gt;向量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;put(r, e)&lt;/td&gt;
&lt;td align="left"&gt;用 e 代替秩为 r 的元素&lt;/td&gt;
&lt;td align="left"&gt;向量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;insert(r, e)&lt;/td&gt;
&lt;td align="left"&gt;e 作为秩为 r 的元素插入，原后继元素依次后移&lt;/td&gt;
&lt;td align="left"&gt;向量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;remove(r)&lt;/td&gt;
&lt;td align="left"&gt;删除秩为 r 的元素，返回该元素中原存放的对象&lt;/td&gt;
&lt;td align="left"&gt;向量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;disordered()&lt;/td&gt;
&lt;td align="left"&gt;判断所有元素是否已按非降序排列&lt;/td&gt;
&lt;td align="left"&gt;向量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;sort()&lt;/td&gt;
&lt;td align="left"&gt;非降序排序&lt;/td&gt;
&lt;td align="left"&gt;向量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;find(e)&lt;/td&gt;
&lt;td align="left"&gt;查找等于 e 且秩最大的元素&lt;/td&gt;
&lt;td align="left"&gt;向量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;search(e)&lt;/td&gt;
&lt;td align="left"&gt;查找目标元素 e，返回不大于 e 且秩最大的元素&lt;/td&gt;
&lt;td align="left"&gt;有序向量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;deduplicate()&lt;/td&gt;
&lt;td align="left"&gt;剔除重复元素&lt;/td&gt;
&lt;td align="left"&gt;向量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;uniquify()&lt;/td&gt;
&lt;td align="left"&gt;剔除重复元素&lt;/td&gt;
&lt;td align="left"&gt;有序向量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;traverse()&lt;/td&gt;
&lt;td align="left"&gt;遍历向量并统一处理所有元素，处理方法由函数对象指定&lt;/td&gt;
&lt;td align="left"&gt;向量&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;Vector 模板类&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;typedef int Rank;   //秩
#define DEFAULT_CAPACITY 3  //默认的初始容量（实际应用中可设置为更大）

template &amp;lt;typename T&amp;gt; class Vector {    //向量模板类
protected:
    Rank _size; int _capacity; T* _elem;    //规模、容量、数据区
    void copyFrom(T const* A, Rank lo, Rank hi);    //复制数组区间A[lo,hi)
    void expand();  //空间不足时扩容
    void shrink();  //装填因子过小时压缩
    bool bubble(Rank lo, Rank hi);  //扫描交换
    void bubbleSort()Rank lo, Rank hi); //气泡排序算法
    Rank max(Rank lo, Rank hi); //选取最大元素
    void selectionSort(Rank lo, Rank hi);   //选择排序算法
    void merge(Rank lo, Rank mi, Rank hi);   //归并算法
    void mergeSort(Rank lo, Rank hi);   //归并排序算法
    Rank partition(Rank lo, Rank hi);   //轴点构造算法
    void quickSort(Rank lo, Rank hi);   //快速排序算法
    void heapSort(Rank lo, Rank hi);    //堆排序
public:
//构造函数
     //容量为 c，规模为 s，所有元素初始化为 v，s&amp;lt;=c
    Vector(int c = DEFAULT_CAPACITY, int s = 0, T v = 0)
    { _elem = new T[_capacity = c]; for(_size = 0; _size &amp;lt; s; _elem[_size++] = v);  }
    Vector(T const* A, Rank n) { copyFrom(A, 0, n); }   //数组整体复制
    Vector(T const* A, Rank lo, Rank hi) { copyFrom(A, lo, hi); }   //区间
    Vector(Vector&amp;lt;T&amp;gt; const&amp;amp; V) { copyFrom(V._elem, 0, V._size); }   //向量整体复制
    Vector(Vector&amp;lt;T&amp;gt; const&amp;amp; V, Rank lo, Rank hi) { copyFrom(V._elem, lo, hi); } //区间
//析构函数
~Vector() { delete [] _elem; }  //释放内部空间
//只读访问接口
    Rank size() const { return _size; } //规模
    bool empty() const { return !_size; }   //判空
    int disordered() const; //判断向量是否已排序
    Rank find(T const&amp;amp; e) const { return find(e, 0, _size); }   //无序向量整体查找
    Rank find(T const&amp;amp; e, Rank lo, Rank hi) const;  //无序向量区间查找
    Rank search(T const&amp;amp; e) const   //有序向量整体查找
    { return (0 &amp;gt;= _size) ? -1 : search(e, 0, _size); }
    Rank search(T const&amp;amp; e, Rank lo, Rank hi) const   //有序向量区间查找
//可写访问接口
    T&amp;amp; operator[](Rank r) const;    //重载下标运算符，可以类似于数组形式引用各元素
    Vector&amp;lt;T&amp;gt; &amp;amp; operator=(Vector&amp;lt;T&amp;gt; const&amp;amp;);    //重载赋值运算符，以便直接克隆向量
    T remove(Rank r);   //删除秩为 r 的元素
    int remove(Rank lo, Rank hi);   //删除秩在区间 [lo,hi) 之内的元素
    Rank insert(Rank r, T const&amp;amp; e);    //插入元素
    Rank insert(T const&amp;amp; e) { return insert(_size, e); }    //默认作为尾元素插入
    void sort(Rank lo, Rank hi);    //对 [lo,hi) 排序
    void sort() { sort(0, _size); } //整体排序
    void unsort(Rank lo, Rank hi);    //对 [lo,hi) 置乱
    void unsort() { unsort(0, _size); } //整体置乱
    int deduplicate();  //无序去重
    int uniquify(); //有序去重
//遍历
    void traverse(void (*)(T&amp;amp;));    //遍历（使用函数指针，只读或局部性修改）
    template &amp;lt;typename VST&amp;gt; void traverse(VST&amp;amp;);    //遍历（使用函数对象，可全局性修改）
};//Vector
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;构造与析构&lt;/h2&gt;
&lt;p&gt;约定：向量中秩为 r 的元素，对应于内部数组中的 _elem[r]，其物理地址为：_elem + r&lt;/p&gt;
&lt;h3&gt;默认构造函数&lt;/h3&gt;
&lt;p&gt;整个默认构造过程顺序进行，没有任何迭代，故忽略用于分配数组空间的时间，需要常数时间。&lt;/p&gt;
&lt;h3&gt;基于复制的构造函数&lt;/h3&gt;
&lt;p&gt;在模板的实现中，我们将基于数组或者向量的复制操作（局部或整体的）都转交给如下的&lt;code&gt;copyFrom&lt;/code&gt;函数处理：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;template &amp;lt;typename T&amp;gt; void Vector&amp;lt;T&amp;gt;::copyFrom(T const* A, Rank lo, Rank hi) {
    _elem = new T[_capacity = 2 * (hi -lo) ]; _size = 0; //分配空间，规模清零
    while( lo &amp;lt;hi) //A[lo,hi) 元素逐一复制
        _elem[_size++] = A[lo++];   //
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;需要 &lt;em&gt;O&lt;/em&gt;(_size) 时间。&lt;/p&gt;
&lt;p&gt;需要强调的是，由于向量内部含有动态分配的空间，默认的“=”运算符不足以支持向量之间的直接赋值。故要重建“=”：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;template &amp;lt;typename T&amp;gt; Vector&amp;lt;T&amp;gt;&amp;amp; Vector&amp;lt;T&amp;gt;::operator=(Vector&amp;lt;T&amp;gt; const&amp;amp; V) {
    if( _elem ) delet [] _elem;
    copyFrom(V._elem, 0, V.size());
    return *this;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;析构&lt;/h3&gt;
&lt;p&gt;若不计系统用于空间回收的时间，整个析构过程只需常数时间。&lt;/p&gt;
&lt;h2&gt;动态空间管理&lt;/h2&gt;
&lt;h3&gt;扩容&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;template &amp;lt;typename T&amp;gt; void Vector&amp;lt;T&amp;gt;::expand() {
    if(_size &amp;lt; _capacity) return;   //尚未满员，不必扩容
    if(_capacity &amp;lt; DEFAULT_CAPACITY) _capacity = DEFAULT_CAPACITY;  //不低于最小容量
    T *oldElem = _elem; _elem = new T[_capacity &amp;lt;&amp;lt; 1]; //容量加倍
    for( int i = 0; i &amp;lt; _size; i++)
        _elem[i] = oldElem[i]; //复制原向量内容（T为基本类型，或以重载赋值运算符
    delete [] oldElem;  //释放原空间
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;分摊运行时间为 &lt;em&gt;O&lt;/em&gt;(1)&lt;/p&gt;
&lt;h3&gt;缩容&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;template &amp;lt;typename T&amp;gt; void Vector&amp;lt;T&amp;gt;::shrink() {
    if(_capacity &amp;lt; DEFAULT_CAPACITY &amp;lt;&amp;lt; 1) return;   //不至收缩到DEFAULT_CAPACITY
    if(_size &amp;lt;&amp;lt; 2 &amp;gt; _capacity) return;  //以25%为界
    T *oldElem = _elem; _elem = new T[_capacity &amp;gt;&amp;gt; 1]; //容量减半
    for( int i = 0; i &amp;lt; _size; i++)
        _elem[i] = oldElem[i]; //复制原向量内容（T为基本类型，或以重载赋值运算符
    delete [] oldElem;  //释放原空间
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;就单次扩容或缩容操作而言，所需时间的确会高达 &lt;em&gt;O&lt;/em&gt;(n)，因此在对单次操作的执行速度及其敏感的应用场合以上策略并不适用，其中缩容操作甚至可以完全不予考虑。&lt;/p&gt;
&lt;h2&gt;常规向量&lt;/h2&gt;
&lt;h3&gt;直接引用元素&lt;/h3&gt;
&lt;p&gt;与数组直接通过下标访问元素的形式相比，向量 ADT（abstract data type）所设置的&lt;code&gt;get()&lt;/code&gt;和&lt;code&gt;put()&lt;/code&gt;接口都显得不甚自然。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;template &amp;lt;typename T&amp;gt; T&amp;amp; Vector&amp;lt;T&amp;gt;::operator[](Rank r) const
{ return _elem[r]; }    //assert: 0 &amp;lt;= r &amp;lt; _size
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;置乱器&lt;/h3&gt;
&lt;p&gt;重载后&lt;code&gt;[]&lt;/code&gt;返回的是对数组元素的引用，这就意味着它既可以取代&lt;code&gt;get()&lt;/code&gt;操作（通常作为赋值表达式的右值），也可以取代&lt;code&gt;set()&lt;/code&gt;操作（通常作为左值）。采用这种形式，可以很清晰地实现如下的向量置乱器：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;template &amp;lt;typename T&amp;gt; void permute(Vector&amp;lt;T&amp;gt;&amp;amp; V) {
    for(int i = V.size(); i &amp;gt; 0; i--)
        swap(V[i-1], V[rand() % i]); //V[i-1] 与 V[0,i) 中某一随机元素交换
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;从理论上讲，上述算法可以枚举出同一向量所有可能的排列，而且能够保证生成各种排列的概率均等。&lt;/p&gt;
&lt;p&gt;为便于对各种向量算法的测试与比较，不妨将上述算法封装到向量 ADT 中，并对外提供向量的置乱接口操作：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;template &amp;lt;typename T&amp;gt; void Vector&amp;lt;T&amp;gt;::unsort(Rank lo, Rank hi) {
    T* V = _elem + lo;
    for(Rank i =hi -lo; i &amp;gt; 0; i--)
        swap(V[i-1], V[rand() % i]);
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上述两段代码的细微差异：上面的代码通过重载“[]”，利用秩间接访问&lt;strong&gt;向量&lt;/strong&gt;元素，下面的代码通过下标直接访问内部&lt;strong&gt;数组&lt;/strong&gt;的元素。&lt;/p&gt;
&lt;h3&gt;判等器和比较器&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;template &amp;lt;typename T&amp;gt; static bool lt(T* a, T* b) { return lt(*a, *b); } //less than
template &amp;lt;typename T&amp;gt; static bool lt(T&amp;amp; a, T&amp;amp; b) { return a &amp;lt; b; } //less than
template &amp;lt;typename T&amp;gt; static bool eq(T* a, T* b) { return eq(*a, *b); } //equal
template &amp;lt;typename T&amp;gt; static bool eq(T&amp;amp; a, T&amp;amp; b) { return a == b; } //equal
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在一些复杂的数据结构中，内部元素本身的类型可能就是指向其他对象的指针，从而外部更多关注的，往往是其所指向对象的大小如直接比较指针，则结果毫无意义，故上面的代码分别出了了指针和引用的情况。&lt;/p&gt;
&lt;h3&gt;无序查找&lt;/h3&gt;
&lt;h4&gt;判等器&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;Vector&lt;/code&gt;模板中的&lt;code&gt;find&lt;/code&gt;接口的语义为“查找与数据对象 e 相等的元素”。这暗示向量元素可以通过相互“比对”判断是否相等。这类仅支持比对，但未必支持比较的向量，称为无序向量（unsorted vector）。&lt;/p&gt;
&lt;h4&gt;顺序查找&lt;/h4&gt;
&lt;p&gt;由于&lt;code&gt;find&lt;/code&gt;函数查找相等的最大秩元素，故从后往前比对：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;template &amp;lt;typename T&amp;gt; Rank Vector&amp;lt;T&amp;gt;::find(T const&amp;amp; e, Rank lo, Rank hi) const {
    while( (lo &amp;lt; hi--) &amp;amp;&amp;amp; (e != _elem[hi]) ); //assert: 0 &amp;lt;= lo &amp;lt; hi &amp;lt;= _size
    return hi;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;最坏情况：&lt;em&gt;O&lt;/em&gt;(n)；最好情况：&lt;em&gt;O&lt;/em&gt;(1)。为输入敏感（input sensitive）算法。&lt;/p&gt;
&lt;h3&gt;插入&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//assert: 0 &amp;lt;= r &amp;lt;= size
template &amp;lt;typename T&amp;gt; Rank Vector&amp;lt;T&amp;gt;::insert(Rank r, T const&amp;amp; e) {
    expan(); //如有必要，扩容
    for(int i = _size; i &amp;gt; r; i--) _elem[i] = _elem[i-1];
    _elem[r] = e; _size++; //插入并更新容量
    return r;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意从后往前搬移数据，以防覆盖。复杂度：若插入位置等概论分布，则平均运行时间为&lt;em&gt;O&lt;/em&gt;(_size)=&lt;em&gt;O&lt;/em&gt;(n)。&lt;/p&gt;
&lt;h3&gt;删除&lt;/h3&gt;
&lt;p&gt;应将单元素删除视为区间删除的特例，并基于后者来实现前者。&lt;/p&gt;
&lt;h4&gt;区间删除&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//删除区间[lo, hi)
template &amp;lt;typename T&amp;gt; int Vector&amp;lt;T&amp;gt;::remove(Rank lo, Rank hi) {
    if(lo === hi) return 0;
    while(hi &amp;lt; _size)   _elem[lo++] = _elem[hi++];
    _size = lo;
    shrink();
    return hi - lo; //返回被删除元素个数
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;单元素删除&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;template &amp;lt;typename T&amp;gt; T Vector&amp;lt;T&amp;gt;::remove(Rank r) {
    T e = _elem[r];
    remove(r, r + 1);
    return e;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;被删除元素在向量中的位置越靠后（前）所需时间越短（长），最好为&lt;em&gt;O&lt;/em&gt;(1)，最坏为&lt;em&gt;O&lt;/em&gt;(n)。&lt;/p&gt;
&lt;h3&gt;唯一化&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;template &amp;lt;typename T&amp;gt; int Vector&amp;lt;T&amp;gt;::deduplicate() {
    int oldSize = _size;
    Rank i = 1;
    while(i &amp;lt; _size)
        (find(_elem[i], 0, i) &amp;lt; 0) ? i++ : remove(i);
    return oldSize - _size;
}
&lt;/pre&gt;&lt;/div&gt;</content><category term="数据结构"></category></entry><entry><title>C++ Primer 第八章 IO 库</title><link href="https://xutree.github.io/pages/2018/10/09/C++_Primer_Chapter_8/" rel="alternate"></link><published>2018-10-09T22:19:51+08:00</published><updated>2018-10-09T22:19:51+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-09:/pages/2018/10/09/C++_Primer_Chapter_8/</id><summary type="html">&lt;h2&gt;IO 类&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;iostream&lt;/code&gt;头文件：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;istream&lt;/code&gt;,&lt;code&gt;wistream&lt;/code&gt;,&lt;code&gt;ostream&lt;/code&gt;,&lt;code&gt;wostream&lt;/code&gt;,&lt;code&gt;iostream&lt;/code&gt;,&lt;code&gt;wiostream&lt;/code&gt;类型。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;fstream&lt;/code&gt;头文件：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ifstream&lt;/code&gt;,&lt;code&gt;wifstream&lt;/code&gt;,&lt;code&gt;ofstream&lt;/code&gt;,&lt;code&gt;wofstream&lt;/code&gt;,&lt;code&gt;fstream&lt;/code&gt;,&lt;code&gt;wfstream&lt;/code&gt;类型。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sstream&lt;/code&gt;头文件：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;istringstream&lt;/code&gt;,&lt;code&gt;wistringstream&lt;/code&gt;,&lt;code&gt;ostringstream&lt;/code&gt;,&lt;code&gt;wostringstream&lt;/code&gt;,&lt;code&gt;stringstream&lt;/code&gt;,&lt;code&gt;wstringstream&lt;/code&gt;类型。&lt;/p&gt;
&lt;p&gt;宽字符版本的类型和函数的名字以一个“w”开始。&lt;/p&gt;
&lt;p&gt;IO 对象无拷贝和赋值。进行 IO 操作的函数通常以引用方式传递和返回值。读写一个 IO 对象会改变其状态，因此传递和返回的引用不能是&lt;code&gt;const&lt;/code&gt;的。&lt;/p&gt;
&lt;h3&gt;条件状态&lt;/h3&gt;
&lt;p&gt;下表中 &lt;em&gt;strm&lt;/em&gt; 是一种 IO 类型：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;状态 …&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;/table&gt;</summary><content type="html">&lt;h2&gt;IO 类&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;iostream&lt;/code&gt;头文件：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;istream&lt;/code&gt;,&lt;code&gt;wistream&lt;/code&gt;,&lt;code&gt;ostream&lt;/code&gt;,&lt;code&gt;wostream&lt;/code&gt;,&lt;code&gt;iostream&lt;/code&gt;,&lt;code&gt;wiostream&lt;/code&gt;类型。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;fstream&lt;/code&gt;头文件：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ifstream&lt;/code&gt;,&lt;code&gt;wifstream&lt;/code&gt;,&lt;code&gt;ofstream&lt;/code&gt;,&lt;code&gt;wofstream&lt;/code&gt;,&lt;code&gt;fstream&lt;/code&gt;,&lt;code&gt;wfstream&lt;/code&gt;类型。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sstream&lt;/code&gt;头文件：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;istringstream&lt;/code&gt;,&lt;code&gt;wistringstream&lt;/code&gt;,&lt;code&gt;ostringstream&lt;/code&gt;,&lt;code&gt;wostringstream&lt;/code&gt;,&lt;code&gt;stringstream&lt;/code&gt;,&lt;code&gt;wstringstream&lt;/code&gt;类型。&lt;/p&gt;
&lt;p&gt;宽字符版本的类型和函数的名字以一个“w”开始。&lt;/p&gt;
&lt;p&gt;IO 对象无拷贝和赋值。进行 IO 操作的函数通常以引用方式传递和返回值。读写一个 IO 对象会改变其状态，因此传递和返回的引用不能是&lt;code&gt;const&lt;/code&gt;的。&lt;/p&gt;
&lt;h3&gt;条件状态&lt;/h3&gt;
&lt;p&gt;下表中 &lt;em&gt;strm&lt;/em&gt; 是一种 IO 类型：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;状态&lt;/th&gt;
&lt;th align="left"&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;em&gt;strm&lt;/em&gt;::iostate&lt;/td&gt;
&lt;td align="left"&gt;iostate 是一种机器相关的类型，提供了表达条件状态的完整功能&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;em&gt;strm&lt;/em&gt;::badbit&lt;/td&gt;
&lt;td align="left"&gt;流已崩溃&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;em&gt;strm&lt;/em&gt;::failbit&lt;/td&gt;
&lt;td align="left"&gt;IO 操作失败了&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;em&gt;strm&lt;/em&gt;::eofbit&lt;/td&gt;
&lt;td align="left"&gt;流到达了文件结束&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;em&gt;strm&lt;/em&gt;::goodbit&lt;/td&gt;
&lt;td align="left"&gt;流未处于错误状态，此值保证为0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;s.eof()&lt;/td&gt;
&lt;td align="left"&gt;若流 s 的 eofbit 置位，返回 true&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;s.fail()&lt;/td&gt;
&lt;td align="left"&gt;若流 s 的 failbit 或 badbit 置位，返回 true&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;s.bad()&lt;/td&gt;
&lt;td align="left"&gt;若流 s 的 badbit 置位，返回 true&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;s.good()&lt;/td&gt;
&lt;td align="left"&gt;若流 s 处于有效状态，返回 true&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;s.clear()&lt;/td&gt;
&lt;td align="left"&gt;将流 s 所以状态位复位，将流的状态设为有效，返回 void&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;s.clear(flags)&lt;/td&gt;
&lt;td align="left"&gt;根据 flags 复位，flags 类型为 &lt;em&gt;strm&lt;/em&gt;::iostate，返回 void&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;s.setstate(flags)&lt;/td&gt;
&lt;td align="left"&gt;根据 flags 置位，flags 类型为 &lt;em&gt;strm&lt;/em&gt;::iostate，返回 void&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;s.rdstate()&lt;/td&gt;
&lt;td align="left"&gt;返回流 s 的当前条件状态，返回值类型为 &lt;em&gt;strm&lt;/em&gt;::iostate&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;badbit&lt;/code&gt;表示系统级错误，如不可恢复的读写错误，一旦被置位，流就无法再使用了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;failbit&lt;/code&gt;表示可恢复的错误，例如期望读取数值却读到一个字符等错误。这种问题通常是可以修正的，流还可以继续使用。&lt;/p&gt;
&lt;p&gt;如果到达文件结尾，&lt;code&gt;eofbit&lt;/code&gt;和&lt;code&gt;failbit&lt;/code&gt;都会被置位。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;goodbit&lt;/code&gt;值为0，表示流未发生错误。&lt;/p&gt;
&lt;p&gt;如果&lt;code&gt;badbit&lt;/code&gt;、&lt;code&gt;failbit&lt;/code&gt;和&lt;code&gt;eofbit&lt;/code&gt;任一个被置位，则检测流状态的条件会失败。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;good()&lt;/code&gt;函数在所有错误位均未置位的情况下返回&lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;我们将流当做条件使用的代码等价于&lt;code&gt;!fail()&lt;/code&gt;。&lt;/p&gt;
&lt;h3&gt;管理条件状态&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;// 记住 cin 的当前状态
auto old_state = cin.rdstate(); // 记住 cin 的当前状态
cin.clean();  // 使 cin 有效
process_input(cin); // 使用 cin
cin.setstate(old_state);  // 将 cin 置为原有状态
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;// 复位 failbit 和 badbit，保持其他标志位布标
cin.clear(cin.rdstate() &amp;amp; ~cin.failbit &amp;amp; ~cin.badbit);
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;管理输出缓冲&lt;/h3&gt;
&lt;p&gt;每个输出流都管理一个缓冲区，用来保存程序读写的数据。&lt;/p&gt;
&lt;p&gt;导致缓冲刷新（即，数据真正写到输出设备或文件）的原因有很多：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;程序正常结束，作为&lt;code&gt;main&lt;/code&gt;函数的&lt;code&gt;return&lt;/code&gt;操作的一部分，缓冲刷新被执行&lt;/li&gt;
&lt;li&gt;缓冲区满&lt;/li&gt;
&lt;li&gt;使用操纵符&lt;code&gt;endl&lt;/code&gt;（插入换行）、&lt;code&gt;ends&lt;/code&gt;（插入空字符）、&lt;code&gt;flush&lt;/code&gt;（什么都不插入）显式刷新&lt;/li&gt;
&lt;li&gt;在每个输出操作之后，可以用操纵符&lt;code&gt;unitbuf&lt;/code&gt;设置流的内部状态，来情况缓冲区。默认情况下，对&lt;code&gt;cerr&lt;/code&gt;是设置&lt;code&gt;unitbuf&lt;/code&gt;的，因此&lt;code&gt;cerr&lt;/code&gt;的内容都是立即刷新的&lt;/li&gt;
&lt;li&gt;一个输出流可以关联到另一个流。当读写被关联的流时，关联到的流的缓冲区会被刷新。默认情况下，&lt;code&gt;cin&lt;/code&gt;和&lt;code&gt;cerr&lt;/code&gt;都关联到&lt;code&gt;cout&lt;/code&gt;。因此读&lt;code&gt;cin&lt;/code&gt;或者写&lt;code&gt;cerr&lt;/code&gt;都会导致&lt;code&gt;cout&lt;/code&gt;的缓冲区被刷新&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;unitbuf 操纵符&lt;/h3&gt;
&lt;p&gt;如果想在每次输出操作后都刷新缓冲区，可以使用&lt;code&gt;unitbuf&lt;/code&gt;操纵符。它告诉流在接下来的每次写操作之后都执行一次&lt;code&gt;flush&lt;/code&gt;刷新。&lt;code&gt;nounitbuf&lt;/code&gt;操纵符则重置流，使其恢复使用正常的系统管理的缓冲区刷新机制：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;cout &amp;lt;&amp;lt; unitbuf;    // 所有输出操作后都会立即刷新缓冲区
// 任何输出都会立即刷新，无缓冲
cout &amp;lt;&amp;lt; nounitbuf;    // 回到正常的缓冲方式
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;关联输入和输出流&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;tie()&lt;/code&gt;有两个重载的版本：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不带参数的版本返回指向输出流的指针。如果本对象当前关联到一个输出流，则返回的就是指向这个流的指针，如果对象未关联到流，则返回空指针&lt;/li&gt;
&lt;li&gt;第二个版本接受一个指向&lt;code&gt;ostream&lt;/code&gt;的指针，将自己关联到此&lt;code&gt;ostream&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每个流同时最多关联到一个流，但多个流可以同时关联到同一个&lt;code&gt;ostream&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;文件输入输出&lt;/h2&gt;
&lt;h3&gt;fstream 特有的操作&lt;/h3&gt;
&lt;p&gt;下表中的 &lt;em&gt;fstream&lt;/em&gt; 是头文件 fstream 中定义的一个类型：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;操作&lt;/th&gt;
&lt;th align="left"&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;em&gt;fstream&lt;/em&gt; fstrm;&lt;/td&gt;
&lt;td align="left"&gt;创建一个未绑定的文件流&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;em&gt;fstream&lt;/em&gt; fstrm(s);&lt;/td&gt;
&lt;td align="left"&gt;创建一个 &lt;em&gt;fstream&lt;/em&gt;，并打开名为 s 的文件。s 可以是 string 类型或者指向 C 风格字符串的指针。这些构造函数都是&lt;code&gt;explicit&lt;/code&gt;的。默认的文件模式 mode 依赖于 &lt;em&gt;fstream&lt;/em&gt; 的类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;em&gt;fstream&lt;/em&gt; fstrm(s, mode);&lt;/td&gt;
&lt;td align="left"&gt;按 mode 打开文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;fstrm.open(s)&lt;/td&gt;
&lt;td align="left"&gt;打开名为 s 的文件并与 fstrm 绑定。s 可以是 string 类型或者指向 C 风格字符串的指针。默认的文件模式 mode 依赖于 &lt;em&gt;fstream&lt;/em&gt; 的类型。返回&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;fstrm.close()&lt;/td&gt;
&lt;td align="left"&gt;关闭与 fstrm 绑定的文件。返回&lt;code&gt;void&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;fstrm.is_open()&lt;/td&gt;
&lt;td align="left"&gt;返回一个布尔值，指出与 fstrm 关联的文件是否打开成功且尚未关闭&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;如果调用&lt;code&gt;open()&lt;/code&gt;失败，&lt;code&gt;failbit&lt;/code&gt;会被置位，条件会为假：&lt;code&gt;if(open(file))&lt;/code&gt;可用于判定。&lt;/p&gt;
&lt;p&gt;对一个已经打开的文件流调用&lt;code&gt;open()&lt;/code&gt;会失败，并且&lt;code&gt;failbit&lt;/code&gt;会被置位。为了将文件流关联到另一个文件，必须先关闭已经关联的文件。&lt;/p&gt;
&lt;p&gt;当一个&lt;code&gt;fstream&lt;/code&gt;对象被销毁时，&lt;code&gt;close&lt;/code&gt;会自动被调用。&lt;/p&gt;
&lt;h3&gt;文件模式&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;文件模式&lt;/th&gt;
&lt;th align="left"&gt;意义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;in&lt;/td&gt;
&lt;td align="left"&gt;只读&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;out&lt;/td&gt;
&lt;td align="left"&gt;只写（会清空已有数据）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;app&lt;/td&gt;
&lt;td align="left"&gt;每次写操作前均定位到文件末尾&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;ate&lt;/td&gt;
&lt;td align="left"&gt;打开文件后立即定位到文件末尾&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;trunc&lt;/td&gt;
&lt;td align="left"&gt;截断文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;binary&lt;/td&gt;
&lt;td align="left"&gt;以二进制方式进行 IO&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;ifstream&lt;/code&gt;默认&lt;code&gt;in&lt;/code&gt;模式；&lt;code&gt;ofstream&lt;/code&gt;默认&lt;code&gt;out&lt;/code&gt;模式；&lt;code&gt;fstream&lt;/code&gt;默认&lt;code&gt;in&lt;/code&gt;和&lt;code&gt;out&lt;/code&gt;模式打开。&lt;/p&gt;
&lt;h2&gt;string 流&lt;/h2&gt;
&lt;h3&gt;fstream 特有的操作&lt;/h3&gt;
&lt;p&gt;下表中的 &lt;em&gt;sstream&lt;/em&gt; 是头文件 sstream 中定义的一个类型：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;操作&lt;/th&gt;
&lt;th align="left"&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;em&gt;sstream&lt;/em&gt; strm;&lt;/td&gt;
&lt;td align="left"&gt;创建一个未绑定的 stringstream 对象&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;&lt;em&gt;sstream&lt;/em&gt; strm(s);&lt;/td&gt;
&lt;td align="left"&gt;strm 是一个 sstream 对象，保存 string s 的一个拷贝。此构造函数时&lt;code&gt;explicit&lt;/code&gt;的&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;strm.str()&lt;/td&gt;
&lt;td align="left"&gt;返回 strm 所保存的 string 的拷贝&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;strm.str(s)&lt;/td&gt;
&lt;td align="left"&gt;将 string s 拷贝到 strm 中，返回 void&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</content><category term="C++"></category></entry><entry><title>C++ Primer 第七章 类</title><link href="https://xutree.github.io/pages/2018/10/09/C++_Primer_Chapter_7/" rel="alternate"></link><published>2018-10-09T20:38:15+08:00</published><updated>2018-10-09T20:38:15+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-09:/pages/2018/10/09/C++_Primer_Chapter_7/</id><summary type="html">&lt;p&gt;类的基本思想是数据抽象和封装。&lt;/p&gt;
&lt;p&gt;数据抽象是一种依赖于接口和实现分离的编程（以及设计）技术。类的接口包括用户可以执行的操作，类的实现包括类的数据成员，负责接口实现的函数体以及定义类所需的各种私有函数。&lt;/p&gt;
&lt;p&gt;封装实现了类的接口和实现的分离。封装后的类隐藏了它的实现细节，类的用户只能使用接口而无法访问实现部分。&lt;/p&gt;
&lt;h2&gt;类的定义&lt;/h2&gt;
&lt;p&gt;定义在类内部的函数时隐式&lt;code&gt;inline&lt;/code&gt;的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;this&lt;/code&gt;是一个常量指针。&lt;/p&gt;
&lt;h3&gt;const 成员函数&lt;/h3&gt;
&lt;p&gt;通过在紧随参数列表之后添加&lt;code&gt;const&lt;/code&gt;，可以定义&lt;code&gt;const&lt;/code&gt;成员函数。&lt;code&gt;const&lt;/code&gt;的作用是修改隐式&lt;code&gt;this&lt;/code&gt;指针的类型。&lt;/p&gt;
&lt;p&gt;默认情况下，&lt;code&gt;this&lt;/code&gt;指针的类型是指向类类型非常量版本的常量指针（顶层常量）。这意味着我们不能把&lt;code&gt;this&lt;/code&gt;绑定到一个常量对象上。&lt;/p&gt;
&lt;p&gt;常量对象，以及常量对象的引用或者指针都只能调用常量成员函数。&lt;/p&gt;
&lt;h3&gt;类作用域和成员函数&lt;/h3&gt;
&lt;p&gt;编译器分两步处理类：首先编译成员的声明，然后才轮到成员函数体（如果有的话）。因此，成员函数体可以随意使用类中的其他成员而无须在意这些成员出现的顺序。&lt;/p&gt;
&lt;p&gt;编译器处理完类中的全部声明后才会处理成员函数的定义。&lt;/p&gt;
&lt;p&gt;这种两阶段的处理方式只适用于成员函数中使用的名字。声明中使用的名字，包括返回类型或者参数列表中使用的名字，都必须在使用前确保可见。如果某个成员的声明使用了类中尚未出现的名字，则编译器将会在定义该类的作用域中继续查找 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;类的基本思想是数据抽象和封装。&lt;/p&gt;
&lt;p&gt;数据抽象是一种依赖于接口和实现分离的编程（以及设计）技术。类的接口包括用户可以执行的操作，类的实现包括类的数据成员，负责接口实现的函数体以及定义类所需的各种私有函数。&lt;/p&gt;
&lt;p&gt;封装实现了类的接口和实现的分离。封装后的类隐藏了它的实现细节，类的用户只能使用接口而无法访问实现部分。&lt;/p&gt;
&lt;h2&gt;类的定义&lt;/h2&gt;
&lt;p&gt;定义在类内部的函数时隐式&lt;code&gt;inline&lt;/code&gt;的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;this&lt;/code&gt;是一个常量指针。&lt;/p&gt;
&lt;h3&gt;const 成员函数&lt;/h3&gt;
&lt;p&gt;通过在紧随参数列表之后添加&lt;code&gt;const&lt;/code&gt;，可以定义&lt;code&gt;const&lt;/code&gt;成员函数。&lt;code&gt;const&lt;/code&gt;的作用是修改隐式&lt;code&gt;this&lt;/code&gt;指针的类型。&lt;/p&gt;
&lt;p&gt;默认情况下，&lt;code&gt;this&lt;/code&gt;指针的类型是指向类类型非常量版本的常量指针（顶层常量）。这意味着我们不能把&lt;code&gt;this&lt;/code&gt;绑定到一个常量对象上。&lt;/p&gt;
&lt;p&gt;常量对象，以及常量对象的引用或者指针都只能调用常量成员函数。&lt;/p&gt;
&lt;h3&gt;类作用域和成员函数&lt;/h3&gt;
&lt;p&gt;编译器分两步处理类：首先编译成员的声明，然后才轮到成员函数体（如果有的话）。因此，成员函数体可以随意使用类中的其他成员而无须在意这些成员出现的顺序。&lt;/p&gt;
&lt;p&gt;编译器处理完类中的全部声明后才会处理成员函数的定义。&lt;/p&gt;
&lt;p&gt;这种两阶段的处理方式只适用于成员函数中使用的名字。声明中使用的名字，包括返回类型或者参数列表中使用的名字，都必须在使用前确保可见。如果某个成员的声明使用了类中尚未出现的名字，则编译器将会在定义该类的作用域中继续查找。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nx"&gt;typedef&lt;/span&gt; &lt;span class="kr"&gt;double&lt;/span&gt; &lt;span class="nx"&gt;Money&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kt"&gt;string&lt;/span&gt; &lt;span class="nx"&gt;bal&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;Account&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="kr"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="nx"&gt;Money&lt;/span&gt; &lt;span class="nx"&gt;balance() {&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;bal&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="kr"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="nx"&gt;Money&lt;/span&gt; &lt;span class="nx"&gt;bal&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="c1"&gt;// ...&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当编译器看到 balance 函数的声明语句时，它将在 Account 类的范围内寻找对 Money 的声明。编译器只考虑 Account 中在使用 Money 前出现的声明，因为没找到匹配的成员，所以编译器会接着到 Account 的外层作用域中查找。在上面的例子中，编译器会找到 Money 的&lt;code&gt;typedef&lt;/code&gt;语句，该类型被用作 balance 函数的返回类型及数据成员 bal 的类型。另一方面，balance 函数体在整个类可见后才被处理。因此，该函数的&lt;code&gt;return&lt;/code&gt;语句返回名为 bal 的成员，而非外层作用域的&lt;code&gt;string&lt;/code&gt;对象。&lt;/p&gt;
&lt;h3&gt;构造函数&lt;/h3&gt;
&lt;p&gt;构造函数不能被声明成&lt;code&gt;const&lt;/code&gt;的。&lt;/p&gt;
&lt;p&gt;当我们创建类的一个&lt;code&gt;const&lt;/code&gt;对象时，直到构造函数完成初始化过程，对象才能真正取得其“常量”属性。因此，构造函数在&lt;code&gt;const&lt;/code&gt;对象的构造过程中可以向其写值。&lt;/p&gt;
&lt;p&gt;如果我们的类没有显式定义构造函数，编译器会生成合成的默认构造函数。对于大多数类来说，合成的默认构造函数按照如下规则初始化类的数据成员：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果存在类内的初始值，用它来初始化成员&lt;/li&gt;
&lt;li&gt;否则，执行默认初始化&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 C++ 11中，如果我们需要默认的行为，那么可以通过在参数列表后面写上 &lt;strong&gt;= default&lt;/strong&gt; 来要求编译器生成构造函数。如果 &lt;strong&gt;= default&lt;/strong&gt; 出现在类的内部，则默认构造函数是内联的；如果它出现在外部，则该成员默认情况下不是内联的。&lt;/p&gt;
&lt;h4&gt;构造函数初始值列表&lt;/h4&gt;
&lt;p&gt;构造函数初始值列表：&lt;code&gt;Sales_data(const std::string &amp;amp;s) : bookNo(s) { }&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果成员是&lt;code&gt;const&lt;/code&gt;或者引用的话，必须将其初始化。类似的，当成员属于某种类类型且该类类型没有定义默认构造函数时，也必须将这个成员初始化。&lt;/p&gt;
&lt;p&gt;随着构造函数体一开始执行，初始化就完成了。我们初始化&lt;code&gt;const&lt;/code&gt;或者引用类型的唯一机会就是通过构造函数初始化。&lt;/p&gt;
&lt;p&gt;构造函数初始值列表只说明用于初始化成员的值。成员的初始化顺序与它们在类定义中出现顺序一致。&lt;/p&gt;
&lt;h4&gt;委托构造函数&lt;/h4&gt;
&lt;p&gt;一个委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程，或者说它把它自己的一些（或者全部）职责委托给了其他构造函数。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;Sales_data&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="kr"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="c1"&gt;// 非委托构造函数&lt;/span&gt;
    &lt;span class="nx"&gt;Sales_data&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt; &lt;span class="nx"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;unsigned&lt;/span&gt; &lt;span class="nx"&gt;cnt&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kr"&gt;double&lt;/span&gt; &lt;span class="nx"&gt;price&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt;
        &lt;span class="nx"&gt;bookNo&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;s&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="nx"&gt;units_sold&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;cnt&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="nx"&gt;revenue&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;cnt&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nx"&gt;price&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="c1"&gt;// 其余构造函数都委托给另外一个构造函数&lt;/span&gt;
    &lt;span class="nx"&gt;Sales_data&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;Sales_data&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="nx"&gt;Sales_data&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kt"&gt;string&lt;/span&gt; &lt;span class="nx"&gt;s&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;Sales_data&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;s&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="nx"&gt;Sales_data&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;istream&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;is&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;Sales_data() {&lt;/span&gt; &lt;span class="nx"&gt;read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;is&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="c1"&gt;//其他成员&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;受委托的构造函数先执行。&lt;/p&gt;
&lt;h2&gt;访问控制与封装&lt;/h2&gt;
&lt;p&gt;定义在 &lt;strong&gt;public&lt;/strong&gt; 说明符之后的成员在整个程序内可被访问，&lt;strong&gt;public&lt;/strong&gt; 成员定义类的接口。&lt;/p&gt;
&lt;p&gt;定义在 &lt;strong&gt;private&lt;/strong&gt; 说明符之后的成员可以被类的成员函数访问，但是不能被使用该类的代码访问。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;class&lt;/code&gt;和&lt;code&gt;struct&lt;/code&gt;定义类唯一的区别就是默认的访问权限。&lt;/p&gt;
&lt;h3&gt;友元&lt;/h3&gt;
&lt;p&gt;通过友元，类可以允许其他类或者函数访问它的&lt;strong&gt;非公有成员&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果类想把一个函数作为它的友元，只需要增加一条以&lt;code&gt;friend&lt;/code&gt;关键字开始的函数声明即可。友元声明只能出现在类定义的内部，但是在类内出现的具体位置不限。友元不是类的成员也不受它所在区域访问控制级别的约束。&lt;/p&gt;
&lt;p&gt;友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明。如果我们希望类的用户能够调用某个友元函数，那么我们必须在友元声明之外再专门对函数进行一次声明。&lt;/p&gt;
&lt;p&gt;友元关系不存在传递性。&lt;/p&gt;
&lt;p&gt;如果一个类指定了友元类，则友元类的成员函数可以访问此类&lt;strong&gt;包括非公有成员在内的所有成员&lt;/strong&gt;。&lt;/p&gt;
&lt;h2&gt;类的其他特性&lt;/h2&gt;
&lt;h3&gt;定义类型成员&lt;/h3&gt;
&lt;p&gt;类可以自定义某种类型在类中的别名。要注意，用来定义类型的成员必须先定义后使用。&lt;/p&gt;
&lt;h3&gt;可变数据成员&lt;/h3&gt;
&lt;p&gt;有时我们希望能够修改类的某个数据成员，即使是在一个&lt;code&gt;const&lt;/code&gt;成员函数内。通过关键字&lt;code&gt;mutable&lt;/code&gt;可以达到这种效果。一个可变数据成员永远不会是&lt;code&gt;const&lt;/code&gt;，即使它是&lt;code&gt;const&lt;/code&gt;对象的成员。&lt;/p&gt;
&lt;h3&gt;返回 *this 的成员函数&lt;/h3&gt;
&lt;p&gt;一个&lt;code&gt;const&lt;/code&gt;成员函数如果以引用的方式返回*this，那么它的返回类型将是常量引用。&lt;/p&gt;
&lt;p&gt;基于&lt;code&gt;const&lt;/code&gt;的重载：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;Screen&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="kr"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="c1"&gt;// 根据对象是否是 const 重载 display 函数&lt;/span&gt;
    &lt;span class="nx"&gt;Screen&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;display&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;ostream&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;os&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;   &lt;span class="nx"&gt;do_display&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;os&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;Screen&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;display&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;ostream&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;os&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;const&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;   &lt;span class="nx"&gt;do_display&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;os&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kr"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
    &lt;span class="c1"&gt;// 该函数负责显示 Screen 的内容&lt;/span&gt;
    &lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="nx"&gt;do_display&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nx"&gt;ostream&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nx"&gt;os&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;   &lt;span class="nx"&gt;os&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="nx"&gt;contents&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;类类型&lt;/h3&gt;
&lt;p&gt;声明方法：&lt;code&gt;Sales_data item1;&lt;/code&gt;或&lt;code&gt;class Sales_data item1;&lt;/code&gt;后一种从 C 语言继承而来。&lt;/p&gt;
&lt;p&gt;类的声明：前向声明，在类声明之后定义之前，类是一个不完全类型。&lt;/p&gt;
&lt;p&gt;不完全类型只能在非常有限的情景下使用：定义指向这种类型的引用或指针，也可以声明（但是不能定义）以不完全类型作为参数或者返回类型的函数。&lt;/p&gt;
&lt;p&gt;直到类被定义之后数据成员才可以被声明成这种类类型。然而，当一个类的名字出现后，它被认为是声明过了（但尚未定义），因此允许包含指向它自身类型的引用或者指针（有没有想到链表结构）。&lt;/p&gt;
&lt;h4&gt;隐式的类类型转换&lt;/h4&gt;
&lt;p&gt;如果构造函数只接受一个实参，则它实际上定义了转换为此类类型的隐式转换机制，有时我们把这种构造函数称为转换构造函数。&lt;/p&gt;
&lt;p&gt;只允许一步类类型转换。类类型转换不是总有效。&lt;/p&gt;
&lt;h4&gt;抑制构造函数定义的隐式转换&lt;/h4&gt;
&lt;p&gt;可以通过将构造函数声明为&lt;code&gt;explicit&lt;/code&gt;加以阻止。&lt;/p&gt;
&lt;p&gt;关键字&lt;code&gt;explicit&lt;/code&gt;只对一个实参的构造函数有效。需要多个实参的构造函数不能用于执行隐式转换，所以无须将这些构造函数指定为&lt;code&gt;explicit&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;只能在类内声明构造函数时使用&lt;code&gt;explicit&lt;/code&gt;关键字，在类外部定义时不应重复。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;explicit&lt;/code&gt;构造函数只能用于直接初始化。&lt;/p&gt;
&lt;p&gt;尽管编译器不会将&lt;code&gt;explicit&lt;/code&gt;的构造函数用于隐式转换过程，但是我们可以使用这样的构造函数显式地强制类型转换：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;item.combine(static_cast&amp;lt;Sales_data&amp;gt;(cin));
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;聚合类&lt;/h3&gt;
&lt;p&gt;当一个类满足如下条件时，我们说它是聚合的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有成员都是&lt;code&gt;public&lt;/code&gt;的&lt;/li&gt;
&lt;li&gt;没有定义任何构造函数&lt;/li&gt;
&lt;li&gt;没有类内初始值&lt;/li&gt;
&lt;li&gt;没有基类，也没有虚函数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;struct Data {
    int ival;
    string s;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以使用初始化列表初始化，初始值的顺序必须与声明的顺序一致。如果初始值列表中的元素个数少于类的成员数量，则靠后的成员被值初始化。&lt;/p&gt;
&lt;h3&gt;字面值常量类&lt;/h3&gt;
&lt;p&gt;字面值类型的类可能含有&lt;code&gt;constexpr&lt;/code&gt;函数成员，它们是隐式&lt;code&gt;const&lt;/code&gt;成员函数。&lt;/p&gt;
&lt;p&gt;数据成员都是字面值类型的聚合类是字面值常量类。&lt;/p&gt;
&lt;p&gt;如果一个类不是聚合类，符合以下要求也是一个字面值常量类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据成员都必须是字面值类型&lt;/li&gt;
&lt;li&gt;类必须至少有一个&lt;code&gt;constexpr&lt;/code&gt;构造函数&lt;/li&gt;
&lt;li&gt;如果一个数据成员含有类内初始值，则内置类型成员的初始值必须是一条常量表达式；如果成员属于某种类类型，则初始值必须使用成员自己的&lt;code&gt;constexpr&lt;/code&gt;构造函数&lt;/li&gt;
&lt;li&gt;类必须使用析构函数的默认定义，该成员负责销毁类的定义&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;尽管构造函数不能是&lt;code&gt;const&lt;/code&gt;的，但是字面值常量类的构造函数可以使&lt;code&gt;constexpr&lt;/code&gt;函数。事实上，一个字面值常量类都必须至少提供一个&lt;code&gt;constexpr&lt;/code&gt;构造函数。通过前置关键字&lt;code&gt;constexpr&lt;/code&gt;就可以声明一个&lt;code&gt;constexpr&lt;/code&gt;构造函数。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;constexpr&lt;/code&gt;构造函数可以声明成&lt;code&gt;=default&lt;/code&gt;或者删除函数的形式，否则，&lt;code&gt;constexpr&lt;/code&gt;构造函数就必须既符合构造函数的要求（意味着不能包含返回语句），又符合&lt;code&gt;constexpr&lt;/code&gt;函数的要求（意味着它唯一可执行语句就是返回语句），综合这两点，&lt;code&gt;constexpr&lt;/code&gt;构造函数体一般来说应该是空的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;constexpr&lt;/code&gt;构造函数必须初始化所有数据成员，初始值或者使用&lt;code&gt;constexpr&lt;/code&gt;构造函数，或者是一条常量表达式。&lt;/p&gt;
&lt;h2&gt;类的静态成员&lt;/h2&gt;
&lt;p&gt;类的静态成员存在于任何对象之外，对象中不包含任何与静态数据成员有关的数据。类似的，静态成员函数也不与任何对象绑定在一起，它们不包含&lt;code&gt;this&lt;/code&gt;指针。作为结果，静态成员函数不能声明成&lt;code&gt;const&lt;/code&gt;的，而且我们也不能在静态函数体内使用&lt;code&gt;this&lt;/code&gt;指针。&lt;/p&gt;
&lt;p&gt;成员函数不用通过作用域运算符就能直接使用静态成员。&lt;/p&gt;
&lt;p&gt;当在类的外部定义静态成员时，不能重复&lt;code&gt;static&lt;/code&gt;关键字，该关键字只出现在类内部的声明语句。&lt;/p&gt;
&lt;p&gt;必须在类的外部定义和初始化每个静态成员（一个例外，如果静态成员是字面值类型的&lt;code&gt;constexpr&lt;/code&gt;可以在类内给它提供一个整数类型的常量表达式初始值），一个静态成员只能被初始化一次。&lt;/p&gt;
&lt;p&gt;类似于全局变量，静态数据成员定义在任何函数之外，一直存在于程序的整个生命周期中。&lt;/p&gt;
&lt;p&gt;静态数据成员可以是不完全类型，非静态数据成员只能声明成它所属类的指针或引用。&lt;/p&gt;
&lt;p&gt;静态数据成员可以作为默认实参，非静态数据成员不行，因为它的值本身属于对象的一部分，这么做的结果是无法真正提供一个对象以便从中获得成员的值（类似于循环定义），将引发错误。&lt;/p&gt;</content><category term="C++"></category></entry><entry><title>C++ Primer 第六章 函数</title><link href="https://xutree.github.io/pages/2018/10/09/C++_Primer_Chapter_6/" rel="alternate"></link><published>2018-10-09T15:55:08+08:00</published><updated>2018-10-09T15:55:08+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-09:/pages/2018/10/09/C++_Primer_Chapter_6/</id><summary type="html">&lt;p&gt;函数是一个命名了的代码块。&lt;/p&gt;
&lt;h2&gt;函数基础&lt;/h2&gt;
&lt;p&gt;为了与 C 语言兼容，可以使用关键字&lt;code&gt;void&lt;/code&gt;表示函数没有形参。&lt;/p&gt;
&lt;p&gt;函数的返回值不能是数组或者函数类型，但可以返回指向数组和函数的指针。&lt;/p&gt;
&lt;p&gt;自动对象：只存在于块执行期间的对象。当块的执行结束后，块中创建的自动对象的值就变成未定义的了。&lt;/p&gt;
&lt;p&gt;局部静态对象：在程序执行路径第一次经过对象定义语句时初始化，并且直到程序终止才销毁。如果没有显示初始化，则执行值初始化，内置类型的局部静态变量初始化为0。&lt;/p&gt;
&lt;h2&gt;参数传递&lt;/h2&gt;
&lt;p&gt;值传递和引用传递。&lt;/p&gt;
&lt;p&gt;当某种类型不支持拷贝操作时，函数只能通过引用形参访问该类型的对象。如 IO 类型。&lt;/p&gt;
&lt;h3&gt;const 形参和实参&lt;/h3&gt;
&lt;p&gt;如果函数无须改变引用形参的值，最好将其声明为常量引用。&lt;/p&gt;
&lt;p&gt;此外，使用引用而非常量引用也会极大地限制函数所能接受的实参类型。例如，我们不能把&lt;code&gt;const&lt;/code&gt;对象、字面值或者需要类型转换的对象传递给普通的引用形参，这种绝不像看起来那么简单，它可能造成出人意料的后果。考虑如下函数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nd"&gt;size_type&lt;/span&gt; &lt;span class="nt"&gt;find_char&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;string&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nt"&gt;s&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;char&lt;/span&gt; &lt;span class="nt"&gt;c&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nd"&gt;size_type …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;函数是一个命名了的代码块。&lt;/p&gt;
&lt;h2&gt;函数基础&lt;/h2&gt;
&lt;p&gt;为了与 C 语言兼容，可以使用关键字&lt;code&gt;void&lt;/code&gt;表示函数没有形参。&lt;/p&gt;
&lt;p&gt;函数的返回值不能是数组或者函数类型，但可以返回指向数组和函数的指针。&lt;/p&gt;
&lt;p&gt;自动对象：只存在于块执行期间的对象。当块的执行结束后，块中创建的自动对象的值就变成未定义的了。&lt;/p&gt;
&lt;p&gt;局部静态对象：在程序执行路径第一次经过对象定义语句时初始化，并且直到程序终止才销毁。如果没有显示初始化，则执行值初始化，内置类型的局部静态变量初始化为0。&lt;/p&gt;
&lt;h2&gt;参数传递&lt;/h2&gt;
&lt;p&gt;值传递和引用传递。&lt;/p&gt;
&lt;p&gt;当某种类型不支持拷贝操作时，函数只能通过引用形参访问该类型的对象。如 IO 类型。&lt;/p&gt;
&lt;h3&gt;const 形参和实参&lt;/h3&gt;
&lt;p&gt;如果函数无须改变引用形参的值，最好将其声明为常量引用。&lt;/p&gt;
&lt;p&gt;此外，使用引用而非常量引用也会极大地限制函数所能接受的实参类型。例如，我们不能把&lt;code&gt;const&lt;/code&gt;对象、字面值或者需要类型转换的对象传递给普通的引用形参，这种绝不像看起来那么简单，它可能造成出人意料的后果。考虑如下函数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nd"&gt;size_type&lt;/span&gt; &lt;span class="nt"&gt;find_char&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;string&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nt"&gt;s&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;char&lt;/span&gt; &lt;span class="nt"&gt;c&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nd"&gt;size_type&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nt"&gt;occurs&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;则只能将 find_char 函数用于&lt;code&gt;string&lt;/code&gt;对象。类似下面的调用将在编译时发生错误：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;find_char(&amp;quot;Hello World&amp;quot;, &amp;#39;o&amp;#39;, ctr);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;还有一个更难察觉的问题。假如其它函数（正确的）将它们的形参定义成常量引用，那么上述的 find_char 函数无法在此类函数中正常使用。例如&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;bool&lt;/span&gt; &lt;span class="nt"&gt;is_sentence&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;const&lt;/span&gt; &lt;span class="nt"&gt;string&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nt"&gt;s&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="n"&gt;size_type&lt;/span&gt; &lt;span class="n"&gt;ctr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="err"&gt;return&lt;/span&gt; &lt;span class="err"&gt;find_char(s,&lt;/span&gt; &lt;span class="err"&gt;&amp;#39;.&amp;#39;,&lt;/span&gt; &lt;span class="err"&gt;ctr)&lt;/span&gt; &lt;span class="err"&gt;==&lt;/span&gt; &lt;span class="err"&gt;s.size()&lt;/span&gt; &lt;span class="err"&gt;-&lt;/span&gt; &lt;span class="err"&gt;1&lt;/span&gt; &lt;span class="err"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="err"&gt;ctr&lt;/span&gt; &lt;span class="err"&gt;==&lt;/span&gt; &lt;span class="err"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;正确的修改思路是改正 find_char 函数的形参。如果实在不能修改 find_char，就在 is_sentence 内部定义一个&lt;code&gt;string&lt;/code&gt;类型的变量，令其为 s 的副本，然后把这个对象传递给 find_char。&lt;/p&gt;
&lt;p&gt;用实参初始化形参时，会忽略顶层&lt;code&gt;const&lt;/code&gt;。也就是说，当形参是顶层&lt;code&gt;const&lt;/code&gt;时，传给它常量对象或者非常量对象都是可以的。&lt;/p&gt;
&lt;p&gt;可以使用一个非常量初始化一个底层&lt;code&gt;const&lt;/code&gt;对象，但反过来不行。&lt;/p&gt;
&lt;h3&gt;数组形参&lt;/h3&gt;
&lt;p&gt;数组的两个性质：不允许拷贝数组；使用数组时会将其转换成指针。&lt;/p&gt;
&lt;p&gt;当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针。&lt;/p&gt;
&lt;p&gt;尽管不能以值传递的方式传递数组，但是我们可以把形参写成类似数组的形式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;void print(const int*);
void print(const int[]);
void print(const int[10]);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;尽管表现形式不同，但是上面的三个函数是等价的：每个函数的唯一形参都是&lt;code&gt;const int*&lt;/code&gt;类型的。如果我们传给 print 函数的是一个数组，则实参自动的转换成指向数组首元素的指针，数组的大小对函数的调用没有影响。&lt;/p&gt;
&lt;p&gt;因为数组是以指针的形式传递给函数的，所以一开始函数并不知道数组的确切尺寸，调用者应该为此提供一些额外的信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用标记指定数组长度：让数组本身包含一个结束标记，例如 C 风格字符串&lt;/li&gt;
&lt;li&gt;使用标准库规范，&lt;code&gt;begin()&lt;/code&gt;和&lt;code&gt;end()&lt;/code&gt;函数&lt;/li&gt;
&lt;li&gt;显示传递一个表示数组大小的形参&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当函数不需要对数组元素执行写操作的时候，数组形参应该是指向&lt;code&gt;const&lt;/code&gt;的指针，注意下面的函数只能作用于大小为10的数组&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;void print(int (&amp;amp;arr)[10])
{
        for (auto elem : arr)
                cout &amp;lt;&amp;lt; elem &amp;lt;&amp;lt; endl;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;main：处理命令行选项&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int main(int argc, char *argv[]) { ... }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;第二个形参 argv 是一个数组，它的元素是指向 C 风格字符串的指针；第一个形参 argc 表示数组中字符串的数量。因为第二个形参是数组，所以 main 函数也可以定义成：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int main(int argc, char **argv) { ... }
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当实参传给 main 函数之后，argv 的第一个元素指向程序的名字或者一个空字符串，接下来的元素依次传递命令行提供的实参，最后一个指针之后的元素值保证为0。&lt;/p&gt;
&lt;h3&gt;含有可变形参的函数&lt;/h3&gt;
&lt;p&gt;为了编写能够处理不同数量实参的函数，C++11 新标准提供了两种主要的方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果所有实参类型相同，可以传递一个名为&lt;code&gt;initializer_list&lt;/code&gt;的标准库类型&lt;/li&gt;
&lt;li&gt;如果实参的类型不同，可以编写可变参数模板&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++ 还有一种特殊的形参类型（即省略号），可以用它传递可变数量的实参，不过需要注意的是，这种功能一般只用于与 C 函数交互的接口程序&lt;/p&gt;
&lt;h4&gt;initializer_list 形参&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;initializer_list&lt;/code&gt;类型定义在同名的头文件中。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;initializer_list&lt;/code&gt;是一种类型模板，提供的操作如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;initializer_list &amp;lt;T&amp;gt; lst;&lt;/code&gt;默认初始化；T 类型元素的空列表。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;initializer_list &amp;lt;T&amp;gt; lst{a,b,c...};&lt;/code&gt;lst 的元素数量和初始值一样多；lst 的元素是对应初始值的副本；列表中的元素是 const。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;lst2(lst);&lt;/code&gt;拷贝或赋值一个&lt;code&gt;initializer_list&lt;/code&gt;对象不会拷贝列表中的元素；拷贝后，原始列表和副本共享元素。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;lst2 = lst;&lt;/code&gt;等价于&lt;code&gt;lst2(lst)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;lst.size();&lt;/code&gt;列表中的元素数量。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;lst.begin();&lt;/code&gt;返回指向 lst 中首元素的指针。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;lst.end();&lt;/code&gt;返回指向 lst 中尾元素下一位置的指针。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;initializer_list&lt;/code&gt;和&lt;code&gt;vector&lt;/code&gt;一样，也是类型模板，定义&lt;code&gt;initializer_list&lt;/code&gt;对象时，必须说明列表中所含对象的类型。和&lt;code&gt;vector&lt;/code&gt;不一样的是，&lt;code&gt;initializer_list&lt;/code&gt;对象中的元素永远是常量值。&lt;/p&gt;
&lt;p&gt;如果想向&lt;code&gt;initializer_list&lt;/code&gt;形参中传递一个值的序列，则必须把序列放在一对花括号内：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//expected和actual是string对象
if (expected != actual)
        error_msg({&amp;quot;functionX&amp;quot;, expected, actual});
else
        error_msg({&amp;quot;functionX&amp;quot;, &amp;quot;okay&amp;quot;});
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;省略符形参&lt;/h4&gt;
&lt;p&gt;省略符形参是为了便于 C++ 程序访问某些特殊的 C 代码而设置的，这些代码使用了名为 varargs 的 C 标准库功能。通常，省略符形参不应用于其他目的。你的 C 编译器文档会描述如何使用 varargs。&lt;/p&gt;
&lt;p&gt;省略符形参只能出现在形参列表的最后一个位置，无外乎两种形式，在第一种形式中，形参声明后面的逗号是可选的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;void foo(parm_list,...);
void foo(...);
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;返回类型和 return 语句&lt;/h2&gt;
&lt;p&gt;返回&lt;code&gt;void&lt;/code&gt;的函数不要求非得有&lt;code&gt;return&lt;/code&gt;语句，以为这类函数的最后一句会隐式的执行&lt;code&gt;return&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;返回的值用于初始化调用点的一个临时量，该临时量就是函数调用的结果。&lt;/p&gt;
&lt;p&gt;不要返回局部对象的引用或指针。&lt;/p&gt;
&lt;p&gt;调用一个返回引用的函数得到左值，其他返回类型得到右值。&lt;/p&gt;
&lt;p&gt;C++ 11新标准规定，函数可以返回花括号包围的值的列表，类似于其他返回结果，此处的列表也用来对表示函数返回的临时量进行初始化。如果列表为空，临时量执行值初始化。如果函数返回的是内置类型，则花括号包围的列表最多包含一个值，且该值所占空间不应该大于目标类型的空间。如果返回的是类类型，由类本身定义初始值如何使用。&lt;/p&gt;
&lt;p&gt;如果控制语句到达了 main 函数的结尾处而且没有&lt;code&gt;return&lt;/code&gt;语句，编译器会隐式的插入一条返回0的&lt;code&gt;return&lt;/code&gt;语句。&lt;/p&gt;
&lt;p&gt;cstdlib 头文件定义了两个预处理变量表示成功与失败：&lt;code&gt;EXIT_SUCCESS&lt;/code&gt;，&lt;code&gt;EXIT_FAILURE&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;int (*func(int i))[10];&lt;/code&gt;func 是一个函数指针，指向：接受一个&lt;code&gt;int&lt;/code&gt;参数，返回值是包含10个&lt;code&gt;int&lt;/code&gt;数组的地址的函数。也可以利用尾置返回类型（C++ 11）写为：&lt;code&gt;auto func(int i) -&amp;gt; int(*)[10];&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;还有一种情况，如果我们知道函数返回的指针将指向哪个数组，就可以使用&lt;code&gt;decltype&lt;/code&gt;关键字声明返回类型。例如，下面的函数返回一个指针，该指针根据参数i的不同指向两个已知数组中的某一个：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int odd[] = {1, 3, 5, 7, 9};
int even[] = {0, 2, 4, 6, 8};
//返回一个指针，该指针指向含有5个整数的数组
decltype(odd) *arrPtr(int i)
{
        return (i % 2) ? &amp;amp;odd : &amp;amp;even;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;arrPtr 使用关键字&lt;code&gt;decltype&lt;/code&gt;表示它的返回类型是个指针，并且该指针所指的对象与 odd 的类型一致。因为 odd 是数组，所以 arrPtr 返回一个指向含有5个整数的数组的指针。有一个地方需要注意，&lt;code&gt;decltype&lt;/code&gt;并不负责把数组类型转换成对应的指针，所以&lt;code&gt;decltype&lt;/code&gt;的结果是个数组，要想表示 arrPtr 返回指针还必须在函数声明时加一个 * 符号。&lt;/p&gt;
&lt;h2&gt;函数重载&lt;/h2&gt;
&lt;h3&gt;顶层 const&lt;/h3&gt;
&lt;p&gt;顶层&lt;code&gt;const&lt;/code&gt;不影响传入函数的对象。一个用于顶层&lt;code&gt;const&lt;/code&gt;的形参无法和一个没有顶层&lt;code&gt;const&lt;/code&gt;的形参区分开，无法重载：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Record lookup(Phone);
Record lookup(const Phone);
//
Record lookup(Phone*);
Record lookup(Phone* const);
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;底层 const&lt;/h3&gt;
&lt;p&gt;底层&lt;code&gt;const&lt;/code&gt;可以实现重载。当我们传递一个非常量对象或者指向非常量对象的指针时，编译器会优先选用非常量的版本：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Record lookup(Account&amp;amp;);
Record lookup(const Account&amp;amp;);
//
Record lookup(Account*);
Record lookup(const Account*);
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;const_cast和重载&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//函数1
const string &amp;amp;shorterString(const string &amp;amp;s1, const strinf &amp;amp;s2)
{
        return s1.size() &amp;lt;= s2.size() ? s1 : s2;
}
//函数2
string &amp;amp;shorterString(string &amp;amp;s1, string &amp;amp;s2)
{
        auto &amp;amp;r = shorterString(const_cast&amp;lt;const string &amp;amp;&amp;gt;(s1),
                                const_cast&amp;lt;const string&amp;amp;&amp;gt;(s2));
        return const_cast&amp;lt;string&amp;amp;&amp;gt;(r);
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;函数1的参数和返回类型都是&lt;code&gt;const string&lt;/code&gt;的引用。我们当然可以对两个非常量的&lt;code&gt;string&lt;/code&gt;实参调用这个函数，但返回的结果仍然是&lt;code&gt;const string&lt;/code&gt;的引用。&lt;/p&gt;
&lt;h3&gt;作用域与重载&lt;/h3&gt;
&lt;p&gt;编译器首先在当前作用域寻找函数，一旦找到，就会忽略掉外层作用域中的同名实体，剩下的工作就是检查函数调用是否有效了。&lt;/p&gt;
&lt;p&gt;在C++语言中，名字查找发生在类型检查之前。&lt;/p&gt;
&lt;h2&gt;特殊用于语言特性&lt;/h2&gt;
&lt;h3&gt;默认实参&lt;/h3&gt;
&lt;p&gt;一旦一个形参被赋予了默认值，它后面的所有形参都必须有默认值。&lt;/p&gt;
&lt;p&gt;在给定的作用域中，一个形参只能被赋予一次默认实参。&lt;/p&gt;
&lt;p&gt;局部变量不能作为默认实参。&lt;/p&gt;
&lt;p&gt;用作函数实参的名字在函数声明所在的作用域内解析，而这些名字的求值过程发生在函数调用时：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sz wd = 80;
char def = &amp;#39;&amp;#39;;
sz ht();
string screen(sz = ht(), sz = wd, char = def);

void f()
{
    def = &amp;#39;*&amp;#39;;  //改变默认实参的值
    sz wd = 100;    //隐藏了外层定义的wd，但是没有改变默认值
    window = screen();  //调用 screen(ht(), 80, &amp;#39;*&amp;#39;)
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;内联函数&lt;/h3&gt;
&lt;p&gt;以空间换时间。在函数返回类型前面加上关键字&lt;code&gt;inline&lt;/code&gt;。内联说明只是向编译器发出一个请求，编译器可以选择忽略这个请求。&lt;/p&gt;
&lt;h3&gt;constexpr 函数&lt;/h3&gt;
&lt;p&gt;能用于常量表达式的函数。函数的返回类型及所有的形参类型都得是字面值类型。函数体中必须有且只有一条&lt;code&gt;return&lt;/code&gt;语句。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;constexpr int new_sz() { return 42; }
constexpr int foo = new_sz();
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;编译器在程序编译时验证 new_sz 函数的返回类型。执行初始化任务时，编译器把对&lt;code&gt;constexpr&lt;/code&gt;函数的调用替换成其结果值。为了能在编译过程中随时展开，&lt;code&gt;constexpr&lt;/code&gt;函数被隐式指定为内联函数。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;constexpr&lt;/code&gt;函数体内也可以包含其他语句，只要这些语句在运行时不执行任何操作就行，例如，空语句、类型别名及&lt;code&gt;using&lt;/code&gt;声明。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;constexpr&lt;/code&gt;函数不一定返回常量表达式，当把这类函数用在需要常量表达式的上下文中时，会出错。&lt;/p&gt;
&lt;p&gt;把内联函数和&lt;code&gt;constexpr&lt;/code&gt;函数放在头文件内。&lt;/p&gt;
&lt;p&gt;和其它函数不一样，内联函数和&lt;code&gt;constexpr&lt;/code&gt;函数可以在程序中多次定义，但是多个定义必须完全一致。&lt;/p&gt;
&lt;h3&gt;调试帮助&lt;/h3&gt;
&lt;h4&gt;assert 预处理宏&lt;/h4&gt;
&lt;p&gt;所谓预处理宏其实是一个预处理变量，它的行为有点类似于内联函数。&lt;code&gt;assert&lt;/code&gt;宏使用一个表达式作为它的条件：&lt;code&gt;assert(expr);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;首先对 expr 求值，如果表达式为假，&lt;code&gt;assert&lt;/code&gt;输出信息并终止程序的执行。如果表达式为真，&lt;code&gt;assert&lt;/code&gt;什么也不做。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;assert&lt;/code&gt;定义在cassert头文件中，&lt;code&gt;assert&lt;/code&gt;宏常用于检查“不能发生”的条件。&lt;/p&gt;
&lt;h4&gt;NDEBUG 预处理变量&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;assert&lt;/code&gt;的行为依赖于&lt;code&gt;NDEBUG&lt;/code&gt;预处理变量的状态。如果定义了&lt;code&gt;NDEBUG&lt;/code&gt;，&lt;code&gt;assert&lt;/code&gt;什么都不做，默认情况下没有定义&lt;code&gt;NDEBUG&lt;/code&gt;，&lt;code&gt;assert&lt;/code&gt;将执行运行时检查。我们可以使用一个&lt;code&gt;#define&lt;/code&gt;语句定义&lt;code&gt;NDEBUG&lt;/code&gt;，从而关闭调试状态。同时，很多编译器都提供了一个命令行选项使我们可以定义预处理变量：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ CC -D NDEBUG main.C &lt;span class="c1"&gt;#use /D with the Mocrosoft compiler.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;除了使用&lt;code&gt;assert&lt;/code&gt;外，也可以使用&lt;code&gt;NDEBUG&lt;/code&gt;编写自己的条件调试代码。如果&lt;code&gt;NDEBUG&lt;/code&gt;未定义，将执行&lt;code&gt;#ifndef&lt;/code&gt;和&lt;code&gt;#endif&lt;/code&gt;之间的代码；如果定义了&lt;code&gt;NDEBUG&lt;/code&gt;，这些代码将被忽略掉。&lt;/p&gt;
&lt;p&gt;编译器为每个函数都定义了&lt;code&gt;__func__&lt;/code&gt;，它是一个&lt;code&gt;const char&lt;/code&gt;局部静态数组，用于存放函数的名字，除了 C++ 编译器定义的&lt;code&gt;__func__&lt;/code&gt;之外，预处理器还定义了另外4个对于程序调试很有用的名字：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;__FILE__&lt;/code&gt; 存放文件名的字符串字面值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__LINE__&lt;/code&gt; 存放当前行号的整型字面值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__TIME__&lt;/code&gt; 存放文件编译时间的字符串字面值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__DATE__&lt;/code&gt; 存放文件编译日期的字符串字面值&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;函数匹配&lt;/h2&gt;
&lt;p&gt;候选函数：函数匹配的第一步是选定本次调用对应的重载函数集。&lt;/p&gt;
&lt;p&gt;可行函数：形参数量与本次提供的实参数量相等（默认形参可以少于）；每个实参的类型与对应的形参相同，或者可以转换成形参的类型。&lt;/p&gt;
&lt;p&gt;寻找最佳匹配（如果有的话）：该函数每个实参的匹配都不劣于其他可行函数需要的匹配；至少有一个实参的匹配优于其他可行函数提供的匹配。&lt;/p&gt;
&lt;p&gt;如果没找到可行函数：编译器报告无匹配函数的错误；如果最佳匹配不唯一，编译器报告二义性错误。&lt;/p&gt;
&lt;h2&gt;函数指针&lt;/h2&gt;
&lt;p&gt;要声明一个函数指针，只需要用指针替换函数名：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;bool (*pf)(const string &amp;amp;, const string &amp;amp;); //未初始化，pf 两端括号必不可少
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当把函数名作为一个值使用时，该函数自动转换为指针，也就是说取地址符是可选的。同样，我们可以直接用函数指针调用函数，解引用符也是可选的。&lt;/p&gt;
&lt;p&gt;不同类型的函数指针之前不存在转换规则。&lt;/p&gt;
&lt;p&gt;函数指针没有指向任何一个函数：将函数指针赋为0或者 &lt;code&gt;nullptr&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;和数组类似，虽然不能定义函数类型的形参，但是可以定义指向函数的指针。此时，形参看起来是函数，实际上被当成指针使用：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;//形参是函数类型，会自动转化为指向函数的指针
void test(bool pf(const string &amp;amp;, const string &amp;amp;));
//等价的定义
void test(bool (*pf)(const string &amp;amp;, const string &amp;amp;));
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果函数返回指向函数的指针，那么必须显示的将返回类型指定为指针。&lt;/p&gt;</content><category term="C++"></category></entry><entry><title>C++ Primer 第五章 语句</title><link href="https://xutree.github.io/pages/2018/10/09/C++_Primer_Chapter_5/" rel="alternate"></link><published>2018-10-09T12:06:33+08:00</published><updated>2018-10-09T12:06:33+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-09:/pages/2018/10/09/C++_Primer_Chapter_5/</id><summary type="html">&lt;h2&gt;空语句&lt;/h2&gt;
&lt;p&gt;使用空语句时应该加上注释，从而令读这段代码的知道该语句是有意省略的。&lt;/p&gt;
&lt;h2&gt;悬垂 else&lt;/h2&gt;
&lt;p&gt;C++ 规定&lt;code&gt;else&lt;/code&gt;与离它最近的尚未匹配的&lt;code&gt;if&lt;/code&gt;匹配。&lt;/p&gt;
&lt;h2&gt;switch 语句&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;switch&lt;/code&gt;语句中的&lt;code&gt;case&lt;/code&gt;标签必须是&lt;strong&gt;整型常量表达式&lt;/strong&gt;或者&lt;strong&gt;可以转换成整型常量表达式的类型&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果某个&lt;code&gt;case&lt;/code&gt;标签匹配成功，将从该标签处开始往后顺序执行所有&lt;code&gt;case&lt;/code&gt;分支，除非程序显示的中断了这一过程，否则直到&lt;code&gt;switch&lt;/code&gt;结尾处才停下来。在大多说情况下，在下一个&lt;code&gt;case&lt;/code&gt;标签之前应该有一条&lt;code&gt;break&lt;/code&gt;语句用于中断。&lt;/p&gt;
&lt;p&gt;标签不应该孤零零的出现，它后面必须跟上一条语句或者另一个&lt;code&gt;case&lt;/code&gt;标签。如果&lt;code&gt;switch&lt;/code&gt;结构以一个空的&lt;code&gt;default&lt;/code&gt;标签作为结束，则该&lt;code&gt;default&lt;/code&gt;标签后面必须跟上一条空语句或一个空块。&lt;/p&gt;
&lt;p&gt;不允许跨过变量的初始化语句直接跳转到该变量作用域内的另一个位置。&lt;/p&gt;
&lt;h2&gt;范围 …&lt;/h2&gt;</summary><content type="html">&lt;h2&gt;空语句&lt;/h2&gt;
&lt;p&gt;使用空语句时应该加上注释，从而令读这段代码的知道该语句是有意省略的。&lt;/p&gt;
&lt;h2&gt;悬垂 else&lt;/h2&gt;
&lt;p&gt;C++ 规定&lt;code&gt;else&lt;/code&gt;与离它最近的尚未匹配的&lt;code&gt;if&lt;/code&gt;匹配。&lt;/p&gt;
&lt;h2&gt;switch 语句&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;switch&lt;/code&gt;语句中的&lt;code&gt;case&lt;/code&gt;标签必须是&lt;strong&gt;整型常量表达式&lt;/strong&gt;或者&lt;strong&gt;可以转换成整型常量表达式的类型&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果某个&lt;code&gt;case&lt;/code&gt;标签匹配成功，将从该标签处开始往后顺序执行所有&lt;code&gt;case&lt;/code&gt;分支，除非程序显示的中断了这一过程，否则直到&lt;code&gt;switch&lt;/code&gt;结尾处才停下来。在大多说情况下，在下一个&lt;code&gt;case&lt;/code&gt;标签之前应该有一条&lt;code&gt;break&lt;/code&gt;语句用于中断。&lt;/p&gt;
&lt;p&gt;标签不应该孤零零的出现，它后面必须跟上一条语句或者另一个&lt;code&gt;case&lt;/code&gt;标签。如果&lt;code&gt;switch&lt;/code&gt;结构以一个空的&lt;code&gt;default&lt;/code&gt;标签作为结束，则该&lt;code&gt;default&lt;/code&gt;标签后面必须跟上一条空语句或一个空块。&lt;/p&gt;
&lt;p&gt;不允许跨过变量的初始化语句直接跳转到该变量作用域内的另一个位置。&lt;/p&gt;
&lt;h2&gt;范围 for&lt;/h2&gt;
&lt;p&gt;在范围&lt;code&gt;for&lt;/code&gt;语句中，预存了&lt;code&gt;end()&lt;/code&gt;的值，一旦程序中添加（删除）元素，&lt;code&gt;end&lt;/code&gt;函数的值就可能变得无效，所以不能通过范围&lt;code&gt;for&lt;/code&gt;语句增加或删除容器的元素。&lt;/p&gt;
&lt;h2&gt;do while 语句&lt;/h2&gt;
&lt;p&gt;应该在括号包围起来的条件后面用一个分号表示语句结束。&lt;/p&gt;
&lt;h2&gt;跳转语句&lt;/h2&gt;
&lt;h3&gt;break 语句&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;break&lt;/code&gt;语句负责终止离它最近的&lt;code&gt;while&lt;/code&gt;、&lt;code&gt;do while&lt;/code&gt;、&lt;code&gt;for&lt;/code&gt;或&lt;code&gt;switch&lt;/code&gt;语句，并从这些语句之后的第一条语句开始继续执行。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;break&lt;/code&gt;语句只能出现在迭代语句或者&lt;code&gt;switch&lt;/code&gt;语句内部（包括嵌套在此类循环里的语句或块的内部）。&lt;code&gt;break&lt;/code&gt;语句的作用范围仅限于最近的循环或者&lt;code&gt;switch&lt;/code&gt;。&lt;/p&gt;
&lt;h3&gt;continue 语句&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;continu&lt;/code&gt;e语句终止最近的循环中的当前迭代并立即开始下一次迭代。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;continue&lt;/code&gt;语句只能出现在&lt;code&gt;for&lt;/code&gt;、&lt;code&gt;while&lt;/code&gt;和&lt;code&gt;do while&lt;/code&gt;的循环的内部，或者嵌套在此类循环里的语句或块的内部。&lt;/p&gt;
&lt;p&gt;和&lt;code&gt;break&lt;/code&gt;语句类似的是，出现在嵌套循环中的&lt;code&gt;continue&lt;/code&gt;语句也仅作用于离它最近的循环。&lt;/p&gt;
&lt;p&gt;和&lt;code&gt;break&lt;/code&gt;语句不同的是，只有当&lt;code&gt;switch&lt;/code&gt;语句嵌套在迭代语句内部时，才能在&lt;code&gt;switch&lt;/code&gt;里使用&lt;code&gt;continue&lt;/code&gt;。&lt;/p&gt;
&lt;h3&gt;goto 语句&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;goto&lt;/code&gt;语句的作用是从&lt;code&gt;goto&lt;/code&gt;语句无条件跳转到同一函数内的另一条语句。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;goto&lt;/code&gt;语句和控制权转向的那条带标签的语句必须位于同一函数之内。&lt;/p&gt;
&lt;h2&gt;异常处理&lt;/h2&gt;
&lt;h3&gt;throw 表达式&lt;/h3&gt;
&lt;p&gt;异常检测部分使用&lt;code&gt;throw&lt;/code&gt;表达式来表示它遇到了无法处理的问题。我们说&lt;code&gt;throw&lt;/code&gt;引发了异常，例如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;throw runtime_error(&amp;quot;Data must refer to same ISBN&amp;quot;);
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;try 语句块&lt;/h3&gt;
&lt;p&gt;异常处理部分使用&lt;code&gt;try&lt;/code&gt;语句处理异常。&lt;code&gt;try&lt;/code&gt;语句块以关键字&lt;code&gt;try&lt;/code&gt;开始，并以一个或多个&lt;code&gt;catch&lt;/code&gt;字句结束。&lt;code&gt;try&lt;/code&gt;语句块中代码抛出的异常通常会被某个catch字句处理，这些字句称为异常处理代码。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;try{
    program-statements
} catch (exception-declaration) {
    handler-statements
} catch (exception-declaration) {
    handler-statements
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;跟在&lt;code&gt;try&lt;/code&gt;块之后的是一个或多个&lt;code&gt;catch&lt;/code&gt;子句。&lt;code&gt;catch&lt;/code&gt;子句包括三个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关键字&lt;code&gt;catch&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;括号内一个（可能未命名的）对象的声明（称作异常声明）&lt;/li&gt;
&lt;li&gt;一个块&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;try&lt;/code&gt;语句块中 program-statements 组成程序的正常逻辑，像其他任何块一样，可以有包含声明在内的任意 C++ 语句。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;try&lt;/code&gt;语句块内声明的变量在块外部无法访问，特别是在&lt;code&gt;catch子&lt;/code&gt;句内也无法访问。&lt;/p&gt;
&lt;p&gt;函数在寻找代码处理的过程中退出，如果最终没能找到任何匹配的&lt;code&gt;catch&lt;/code&gt;子句，程序转到名为&lt;code&gt;terminate&lt;/code&gt;的标准库函数。该函数的行为与系统有关，一般情况下，执行该函数将导致程序非正常退出。&lt;/p&gt;
&lt;h3&gt;标准异常&lt;/h3&gt;
&lt;p&gt;C++ 标准库定义了一组类，用于报告标准库函数遇到的问题，这些异常类也可以在用户别写的程序中使用，它们分别定义在4个头文件中：&lt;/p&gt;
&lt;h4&gt;exception 头文件&lt;/h4&gt;
&lt;p&gt;定义了最通用的异常类&lt;code&gt;exception&lt;/code&gt;。它只报告异常的发生，不提供任何异常信息&lt;/p&gt;
&lt;h4&gt;stdexcept 头文件定义了几种常见的异常类&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;异常类&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;exception&lt;/td&gt;
&lt;td&gt;最常见的问题&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;runtime_error&lt;/td&gt;
&lt;td&gt;只有在运行时才能检测出的问题&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;range_error&lt;/td&gt;
&lt;td&gt;运行时错误：生成的结果超出了有意义的值域范围&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;overflow_error&lt;/td&gt;
&lt;td&gt;运行时错误：计算上溢&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;underflow_error&lt;/td&gt;
&lt;td&gt;运行时错误：计算下溢&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;logic_error&lt;/td&gt;
&lt;td&gt;程序逻辑错误&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;domain_error&lt;/td&gt;
&lt;td&gt;逻辑错误：参数对应的结果值不存在&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;invalid_argument&lt;/td&gt;
&lt;td&gt;逻辑错误：无效参数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;length_error&lt;/td&gt;
&lt;td&gt;逻辑错误：试图创建一个超出该类型最大长度的对象&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;out_of_range&lt;/td&gt;
&lt;td&gt;逻辑错误：使用一个超出有效范围的值&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4&gt;new 头文件&lt;/h4&gt;
&lt;p&gt;定义了&lt;code&gt;bad_alloc&lt;/code&gt;异常类型&lt;/p&gt;
&lt;h4&gt;type_info 头文件&lt;/h4&gt;
&lt;p&gt;定义了&lt;code&gt;bad_cast&lt;/code&gt;异常类型&lt;/p&gt;
&lt;p&gt;标准异常库只定义了几种运算，包括创建和拷贝异常类型的对象，以及为异常类型的对象赋值。我们只能以默认初始化的方式初始化&lt;code&gt;exception&lt;/code&gt;、&lt;code&gt;bad_alloc&lt;/code&gt;和&lt;code&gt;bad_cas&lt;/code&gt;t对象，不允许为这些对象提供初始值。&lt;/p&gt;
&lt;p&gt;其他异常类型的行为则刚好相反。应该使用&lt;code&gt;string&lt;/code&gt;对象或者 C 风格字符串初始化这些类型的对象，但是不允许使用默认初始化的方式。当创建此类对象时，必须提供初始值，该初始值含有错误相关的信息。&lt;/p&gt;
&lt;p&gt;异常类型只定义了一个名为&lt;code&gt;what&lt;/code&gt;的成员函数，该函数没有任何参数，返回值是一个指向 C 风格字符串的&lt;code&gt;const char *&lt;/code&gt;。该字符串的目的是提供关于异常的一些文本信息。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;what&lt;/code&gt;函数返回的 C 风格字符串的内容与异常对象的类型有关。如果异常类型只有一个字符串初始值，则&lt;code&gt;what&lt;/code&gt;返回该字符串。对于其他无初始值的异常类型来说，&lt;code&gt;what&lt;/code&gt;返回的内容由编译器决定。&lt;/p&gt;</content><category term="C++"></category></entry><entry><title>C++ Primer 第四章 表达式</title><link href="https://xutree.github.io/pages/2018/10/07/C++_Primer_Chapter_4/" rel="alternate"></link><published>2018-10-07T10:44:38+08:00</published><updated>2018-10-07T11:08:56+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-07:/pages/2018/10/07/C++_Primer_Chapter_4/</id><summary type="html">&lt;p&gt;重载运算符时，其包括运算对象的类型和返回值的类型，都是由该运算符定义的；但是运算对象的个数、运算符的优先级和结合律都是无法改变的。&lt;/p&gt;
&lt;h2&gt;左值和右值&lt;/h2&gt;
&lt;p&gt;当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。&lt;/p&gt;
&lt;p&gt;一个重要的原则：在需要右值的地方可以用左值来代替，但是不能把右值当成左值（也就是位置）使用。当一个左值被当成右值使用时，实际使用的是它的内容（值）。&lt;/p&gt;
&lt;p&gt;要用到左值的运算符：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;赋值运算符需要一个左值作为其左侧运算对象，得到的结果也仍然是一个左值&lt;/li&gt;
&lt;li&gt;取地址符作用于一个左值运算对象，返回一个指向该运算对象的指针，这个指针是一个右值&lt;/li&gt;
&lt;li&gt;内置解引用运算符、下标运算符、迭代器解引用运算符、&lt;code&gt;string&lt;/code&gt;和&lt;code&gt;vector&lt;/code&gt;的下标运算符的求值结果都是左值&lt;/li&gt;
&lt;li&gt;内置类型和迭代器的递增递减运算符作用于左值运算对象&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;求值顺序&lt;/h2&gt;
&lt;p&gt;优先级规定了运算对象的组合方式，但是没有说明运算对象按照什么顺序求值。对于那些没有指定执行顺序的运算符来说，如果表达式指向并修改了同一个对象，将会引发错误并产生未定义的行为。&lt;/p&gt;
&lt;p&gt;例如，下面的输出表达式是未定义的，我们无法推测编译器是先求 ++i 还是先输出：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int i = 0;
cout &amp;lt;&amp;lt; i …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;重载运算符时，其包括运算对象的类型和返回值的类型，都是由该运算符定义的；但是运算对象的个数、运算符的优先级和结合律都是无法改变的。&lt;/p&gt;
&lt;h2&gt;左值和右值&lt;/h2&gt;
&lt;p&gt;当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。&lt;/p&gt;
&lt;p&gt;一个重要的原则：在需要右值的地方可以用左值来代替，但是不能把右值当成左值（也就是位置）使用。当一个左值被当成右值使用时，实际使用的是它的内容（值）。&lt;/p&gt;
&lt;p&gt;要用到左值的运算符：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;赋值运算符需要一个左值作为其左侧运算对象，得到的结果也仍然是一个左值&lt;/li&gt;
&lt;li&gt;取地址符作用于一个左值运算对象，返回一个指向该运算对象的指针，这个指针是一个右值&lt;/li&gt;
&lt;li&gt;内置解引用运算符、下标运算符、迭代器解引用运算符、&lt;code&gt;string&lt;/code&gt;和&lt;code&gt;vector&lt;/code&gt;的下标运算符的求值结果都是左值&lt;/li&gt;
&lt;li&gt;内置类型和迭代器的递增递减运算符作用于左值运算对象&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;求值顺序&lt;/h2&gt;
&lt;p&gt;优先级规定了运算对象的组合方式，但是没有说明运算对象按照什么顺序求值。对于那些没有指定执行顺序的运算符来说，如果表达式指向并修改了同一个对象，将会引发错误并产生未定义的行为。&lt;/p&gt;
&lt;p&gt;例如，下面的输出表达式是未定义的，我们无法推测编译器是先求 ++i 还是先输出：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int i = 0;
cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot; &amp;quot; &amp;lt;&amp;lt; ++i &amp;lt;&amp;lt; endl;    //未定义的
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;有4种运算符明确规定了运算对象的求值顺序。&amp;amp;&amp;amp;、||、?:、和逗号（，）运算符。&lt;/p&gt;
&lt;p&gt;对于f()+g()*h()+j()的表达式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优先级规定，g() 的返回值和 h() 的返回值相乘&lt;/li&gt;
&lt;li&gt;结合律规定，f() 的返回值先与 g() 和 h() 的乘积相加，所得结果再与 j() 的返回值相加&lt;/li&gt;
&lt;li&gt;对于这些函数的调用顺序没有明确规定&lt;/li&gt;
&lt;li&gt;如果 f、g、h 和 j 是无关函数，它们既不会改变同一对象的状态也不执行 IO 任务，那么函数的调用顺序不受限制。反之，如果其中某几个函数影响同一对象，则它是一条错误的表达式，将产生未定义的行为&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;算术运算符&lt;/h2&gt;
&lt;p&gt;+(正号)、-(负号)、*(乘)、/(除),%(求余)，+(加)、-(减)&lt;/p&gt;
&lt;p&gt;算术运算符的运算对象和求值结果都是右值。&lt;/p&gt;
&lt;p&gt;一元正号负号运算符对运算对象作用后，返回一个（提升后的）副本：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int i = 1024;
int k = -i;
bool b = true;
bool b2 = -b;   //b2 是 true
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;对大多数运算符来说，布尔类型的运算对象将被提升为&lt;code&gt;int&lt;/code&gt;类型。如上，b 参与运算时被提升成整数值1，对它求负-1，转换为布尔值将其作为 b2 的初始值。&lt;/p&gt;
&lt;p&gt;在除法运算中，如果两个运算对象的符号相同则商为正，否则商为负。C++ 语言的早期版本允许结果为负值的商向上或向下取整，C++11 新标准则规定商一律向0取整（即直接切除小数部分）。&lt;/p&gt;
&lt;h2&gt;逻辑和关系运算符&lt;/h2&gt;
&lt;p&gt;运算对象和求值结果都是右值；短路求值；进行比较运算符时，除非比较的对象是布尔类型，否则不要使用布尔字面值&lt;code&gt;true&lt;/code&gt;和&lt;code&gt;false&lt;/code&gt;作为运算对象&lt;/p&gt;
&lt;h2&gt;赋值运算符&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;赋值运算符的左侧运算对象必须是一个可修改的左值&lt;/li&gt;
&lt;li&gt;赋值运算的结果是它的左侧运算对象，并且是一个左值，结果的类型就是左侧运算对象的类型&lt;/li&gt;
&lt;li&gt;如果赋值运算符的左右两个运算对象类型不同，则右侧运算对象将转换成左侧运算对象的类型&lt;/li&gt;
&lt;li&gt;赋值运算满足右结合律：ival = jval = 0；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;++ 和 -- 运算符&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;前置版本将对象本身作为左值返回，后置版本则将对象原始值的副本作为右值返回&lt;/li&gt;
&lt;li&gt;建议：除非必须，否则不用递增递减算符的后置版本&lt;/li&gt;
&lt;li&gt;后置递增运算符的优先级高于解引用运算符，因此 *pbeg++ 等价于 *(pbeg++)，pbeg++ 把 pbeg 的值加1，然后返回 pbeg 的初始值的副本作为其求值结果&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;成员访问运算符&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;由于解引用运算符的优先级低于逗号运算符，因此要对解引用运算符加括号&lt;/li&gt;
&lt;li&gt;箭头运算符作用于一个指针类型的运算对象，结果是一个左值&lt;/li&gt;
&lt;li&gt;点运算符分成两种情况：如果成员所属的对象是左值，那么结果就是左值；反之，如果成员所属的对象是右值，那么结果是右值&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;条件运算符&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;当条件运算符的两个表达式都是左值或者能转换成同一种左值类型时，运算的结果是左值；否则运算的结果是右值&lt;/li&gt;
&lt;li&gt;条件运算符满足右结合律&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;位运算符&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;位运算符作用于整数类型的运算对象&lt;/li&gt;
&lt;li&gt;关于符号位如何处理没有明确的规定，所以强烈建议仅将位运算符作用于处理无符号类型&lt;/li&gt;
&lt;li&gt;移位运算符&lt;ul&gt;
&lt;li&gt;首先令左侧运算对象的内容按照右侧运算对象的要求移动指定位数，然后将经过移动的（可能还进行了提升）左侧运算对象的拷贝作为求值结果。其中，右侧的运算对象一定不能为负，而且值必须严格小于结果的位数，否则就会产生未定义的行为。移出边界之外的位就被舍弃掉了&lt;/li&gt;
&lt;li&gt;移位运算符满足左结合律&lt;/li&gt;
&lt;li&gt;移位运算符的优先级比算术运算符低，比关系运算符、赋值运算符和条件运算符高&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;sizeof运算符&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;sizeof&lt;/code&gt;运算符返回一条表达式或一个类型名字所占的字节数。&lt;code&gt;sizeof&lt;/code&gt;运算符满足右结合律，其所得的值是一个&lt;code&gt;size_t&lt;/code&gt;类型的常量表达式&lt;/p&gt;
&lt;p&gt;两种形式&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sizeof (type)
sizeof expr
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;sizeof&lt;/code&gt;并不直接计算其运算对象的值。&lt;/p&gt;
&lt;p&gt;对于&lt;code&gt;sizeof *p&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因为&lt;code&gt;sizeof&lt;/code&gt;满足右结合律并且与 * 的运算符的优先级一样，所以表达式按照从右到左的顺序结合，等价于：&lt;code&gt;sizeof (*p)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;其次，因为&lt;code&gt;sizeof&lt;/code&gt;不实际求运算对象的值，所以即使 p 是一个无效（即未初始化）的指针也不会有什么影响&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;sizeof&lt;/code&gt;的运算对象中解引用一个无效的指针仍然是一种安全的行为，因为指针实际上并没有被真正使用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sizeof&lt;/code&gt;运算符的结果部分地依赖于其作用的类型：&lt;ul&gt;
&lt;li&gt;对&lt;code&gt;char&lt;/code&gt;或者类型为&lt;code&gt;char&lt;/code&gt;的表达式执行&lt;code&gt;sizeof&lt;/code&gt;运算，结果得1&lt;/li&gt;
&lt;li&gt;对引用类型执行&lt;code&gt;sizeof&lt;/code&gt;运算得到被引用对象所占空间的大小&lt;/li&gt;
&lt;li&gt;对指针执行&lt;code&gt;sizeof&lt;/code&gt;运算得到指针本身所占空间的大小&lt;/li&gt;
&lt;li&gt;对解引用指针执行&lt;code&gt;sizeof&lt;/code&gt;运算得到指针指向的对象所占空间的大小，指针不需有效&lt;/li&gt;
&lt;li&gt;对数值执行&lt;code&gt;sizeof&lt;/code&gt;运算符得到整个数组所占空间的大小。&lt;code&gt;sizeof&lt;/code&gt;运算不会把数组转换成指针来处理&lt;/li&gt;
&lt;li&gt;对&lt;code&gt;string&lt;/code&gt;对象或者&lt;code&gt;vector&lt;/code&gt;对象执行&lt;code&gt;sizeof&lt;/code&gt;运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。即只取决于里面存放的数据类型，与元素的个数无关，是个编译器相关的值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;逗号运算符&lt;/h2&gt;
&lt;p&gt;首先对左侧的表达式求值，然后将求值结果丢弃掉。逗号表达式真正的结果是右侧表达式的值。如果右侧运算对象是左值，那么最终的求值结果也是左值。&lt;/p&gt;
&lt;h2&gt;类型转换&lt;/h2&gt;
&lt;h3&gt;何时发生隐式类型转换&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;在大多数表达式中，比&lt;code&gt;int&lt;/code&gt;类型小的整数值首先提升为较大的整数类型&lt;/li&gt;
&lt;li&gt;在条件中，非布尔值转换成布尔类型&lt;/li&gt;
&lt;li&gt;初始化过程中，初始值转换成变量的类型；在赋值语句中，右侧运算对象装换成左侧运算对象的类型&lt;/li&gt;
&lt;li&gt;如果算术运算或关系运算的运算对象有多种类型，需要转换成同一种类型&lt;/li&gt;
&lt;li&gt;函数调用时也会发生类型转换&lt;/li&gt;
&lt;li&gt;数组转换成指针（当数组被用作&lt;code&gt;decltype&lt;/code&gt;关键字的参数，或者作为取地址符、&lt;code&gt;sizeof&lt;/code&gt;即&lt;code&gt;typeid&lt;/code&gt;等运算符的运算对象时，上述转换不会发生，如果用一个引用来初始化数组，上述转换也不会发生）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;指针的转换&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;常量整数值0或者字面值&lt;code&gt;nullptr&lt;/code&gt;能转换成任意指针类型&lt;/li&gt;
&lt;li&gt;指向任意非常量的指针能转换成&lt;code&gt;void *&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;指向任意对象的指针能转换成&lt;code&gt;const void *&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;转换成常量：允许将指向非常量类型的指针转换成指向相应的常量类型的指针，对于引用也是这样。相反的转换并不存在，因为它试图删掉底层&lt;code&gt;const&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;类类型定义的转换&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;类类型能定义由编译器自动执行的转换，不过编译器每次只能执行一种类类型的转换，如果同时提出多个转换请求，这些请求将被拒绝&lt;/li&gt;
&lt;li&gt;之前遇到过的类类型转换&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;string s, t = &amp;quot;a value&amp;quot;;    //字符串字面值转换成 string 类型
wile( cin &amp;gt;&amp;gt; s)     //while 的条件部分把 cin 转换成布尔值
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;显示转换&lt;/h3&gt;
&lt;p&gt;虽然有时不得不使用强制类型转换，但这种方法本质上是非常危险的。&lt;/p&gt;
&lt;h3&gt;命名的强制类型转换&lt;/h3&gt;
&lt;p&gt;一个命名的强制类型转换具有如下格式：&lt;code&gt;cast-name&amp;lt;type&amp;gt;(expression);&lt;/code&gt;type 是转换的目标类型。如果 type 是引用类型，则结果是左值；expression 是要转换的值；cast-name 是&lt;code&gt;static_cast&lt;/code&gt;、&lt;code&gt;dynamic_cast&lt;/code&gt;、&lt;code&gt;const_cast&lt;/code&gt;和&lt;code&gt;reinterpret_cast&lt;/code&gt;中的一种。&lt;code&gt;dynamic_cast&lt;/code&gt;支持运行时类型识别。&lt;/p&gt;
&lt;h3&gt;static_cast&lt;/h3&gt;
&lt;p&gt;任何具有明确定义的类型转换，只要不包含底层&lt;code&gt;const&lt;/code&gt;，都可以使用&lt;code&gt;static_cast&lt;/code&gt;。当需要把一个较大的算术类型赋给较小的类型时，&lt;code&gt;static_cast&lt;/code&gt;非常有用。此时，强制类型转换告诉程序的读者和编译器：我们知道并且不在乎潜在的精度损失。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;static_cast&lt;/code&gt;对于编译器无法自动执行的类型转换也非常有用。例如，我们可以使用它找回&lt;code&gt;void *&lt;/code&gt;指针中的值:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;void *p = &amp;amp;d;
double *dp = static_cast&amp;lt;double *&amp;gt;(p);
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;const_cast&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;const_cast&lt;/code&gt;只能改变运算对象的底层&lt;code&gt;const&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;const char *pc;
char *p = const_cast&amp;lt;char*&amp;gt;(pc);//正确，但通过p写值是未定义的行为
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;只有&lt;code&gt;const_cast&lt;/code&gt;能改变表达式的常量属性。&lt;/p&gt;
&lt;h3&gt;reinterpret_cast&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;einterpret_cast&lt;/code&gt;通常为运算对象的位模式提供较低层次上的重新解释。&lt;/p&gt;
&lt;p&gt;假如有以下转换：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int *ip;
char *pc = reinterpret_cast&amp;lt;char*&amp;gt;(ip);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们必须牢记 pc 所指的真实对象是一个 int 而非字符，如果把 pc 当成普通的字符指针使用就可能在运行时发生错误。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;string str(pc);     //可能导致异常的运行时行为
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;reinterpret_cast&lt;/code&gt;本质上依赖于机器。要想安全地使用&lt;code&gt;reinterpret_cast&lt;/code&gt;必须对涉及的类型和编译器实现转换的过程都非常了解。&lt;/p&gt;
&lt;p&gt;强制类型转换干扰了正常的类型检查，因此强烈建议避免使用强制类型转换。&lt;/p&gt;
&lt;h3&gt;旧式的强制类型转换&lt;/h3&gt;
&lt;p&gt;在早期版本的 C++ 语言中，显示地进行强制类型转换包含两种形式：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;type (expr);    //函数形式的强制类型转换
(type) expr;    //C 语言风格的强制类型转换
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;根据所设计的类型不同，旧式的强制类型转换分别具有与&lt;code&gt;const_cast&lt;/code&gt;，&lt;code&gt;static_cast&lt;/code&gt;或&lt;code&gt;reinterpret_cast&lt;/code&gt;相似的行为。当我们在某处执行旧式的强制类型转换时，如果换成&lt;code&gt;const_cast&lt;/code&gt;和&lt;code&gt;static_cast&lt;/code&gt;也合法，则其行为与相应的命名转换一致。如果替换后不合法，则旧式强制类型转换执行与&lt;code&gt;reinterpret_cast&lt;/code&gt;类似的功能。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;char *pc = (char*) ip;  //ip是指向整数的指针
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上述代码的效果与&lt;code&gt;reinterpret_cast&lt;/code&gt;一样。&lt;/p&gt;</content><category term="C++"></category></entry><entry><title>C++ Primer 第三章 字符串、向量和数组</title><link href="https://xutree.github.io/pages/2018/10/06/C++_Primer_Chapter_3/" rel="alternate"></link><published>2018-10-06T22:31:16+08:00</published><updated>2018-10-07T10:48:54+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-06:/pages/2018/10/06/C++_Primer_Chapter_3/</id><summary type="html">&lt;p&gt;&lt;code&gt;string&lt;/code&gt;表示可变长的字符数组。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vector&lt;/code&gt;存放的是某种给定类型对象的可变长序列。&lt;/p&gt;
&lt;p&gt;数组和其他内置类型一样，实现与硬件密切相关，在灵活性上稍显不足。&lt;/p&gt;
&lt;p&gt;命名空间&lt;code&gt;using&lt;/code&gt;声明：&lt;code&gt;using namespace::name;&lt;/code&gt;例如：&lt;code&gt;using std::cin;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;头文件不应包含&lt;code&gt;using&lt;/code&gt;声明，防止名字冲突。&lt;/p&gt;
&lt;h2&gt;标准库类型 string&lt;/h2&gt;
&lt;h3&gt;头文件和声明&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="n"&gt;using&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kr"&gt;string&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;定义和初始化&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;string s1;  //默认初始化，空字符串
string s2 = s1; //s2是s1的副本，等价于 s2(s1)
string s3 = &amp;quot;hiya&amp;quot;; //s3是字符串字面值的副本，等价于s3(&amp;quot;hiya&amp;quot;)
string s4(10 …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;&lt;code&gt;string&lt;/code&gt;表示可变长的字符数组。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vector&lt;/code&gt;存放的是某种给定类型对象的可变长序列。&lt;/p&gt;
&lt;p&gt;数组和其他内置类型一样，实现与硬件密切相关，在灵活性上稍显不足。&lt;/p&gt;
&lt;p&gt;命名空间&lt;code&gt;using&lt;/code&gt;声明：&lt;code&gt;using namespace::name;&lt;/code&gt;例如：&lt;code&gt;using std::cin;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;头文件不应包含&lt;code&gt;using&lt;/code&gt;声明，防止名字冲突。&lt;/p&gt;
&lt;h2&gt;标准库类型 string&lt;/h2&gt;
&lt;h3&gt;头文件和声明&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="n"&gt;using&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="kr"&gt;string&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;定义和初始化&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;string s1;  //默认初始化，空字符串
string s2 = s1; //s2是s1的副本，等价于 s2(s1)
string s3 = &amp;quot;hiya&amp;quot;; //s3是字符串字面值的副本，等价于s3(&amp;quot;hiya&amp;quot;)
string s4(10, &amp;#39;c&amp;#39;); //s4的内容是cccccccccc
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;string 对象上的操作&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;操作&lt;/th&gt;
&lt;th&gt;意义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;os &amp;lt;&amp;lt; s&lt;/td&gt;
&lt;td&gt;将 s 写到输出流 os 中，返回 os&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;is &amp;gt;&amp;gt; s&lt;/td&gt;
&lt;td&gt;从 is 中读取字符串赋给 s，字符串以空白分隔，返回 is&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;getline(is, s)&lt;/td&gt;
&lt;td&gt;从 is 中读取一行赋给 s，返回 is&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s.empty()&lt;/td&gt;
&lt;td&gt;s 为空返回 true，否则返回 false&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s.size()&lt;/td&gt;
&lt;td&gt;返回 s 中字符的个数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s[n]&lt;/td&gt;
&lt;td&gt;返回 s 中第 n 个字符的引用，位置 n 从0记起&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s1 + s2&lt;/td&gt;
&lt;td&gt;返回连接后的结果&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s1 = s2&lt;/td&gt;
&lt;td&gt;用 s2 的副本代替 s1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s1 == s2&lt;/td&gt;
&lt;td&gt;如果 s1 和 s2 中所含的字符完全一样，则他们相等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s1 != s2&lt;/td&gt;
&lt;td&gt;string 对象的相等性判断对大小写敏感&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;lt;, &amp;lt;=, &amp;gt;, &amp;gt;=&lt;/td&gt;
&lt;td&gt;利用字符在字典里的顺序进行比较，大小写敏感&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;读取未知数量的 string 对象&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int main()
{
    string word;
    while (cin &amp;gt;&amp;gt; word)
        cout &amp;lt;&amp;lt; word &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;直到遇到结束标记或者非法输入才会停止&lt;/p&gt;
&lt;h3&gt;使用 getline 读取一整行&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int main()
{
    string line;
    while (getline(cin,line))
        cout &amp;lt;&amp;lt; line &amp;lt;&amp;lt; endl;
    return 0;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;getline&lt;/code&gt;函数的参数是一个输入流和一个&lt;code&gt;string&lt;/code&gt;对象，&lt;code&gt;getline&lt;/code&gt;从给定的输入流中读入内容，直到遇到换行符为止（注意换行符也被读进来了），然后把所读的内容存入&lt;code&gt;string&lt;/code&gt;对象中（注意不存换行符）。如果输入一开始就是换行符，那么所得的结果是个空&lt;code&gt;string&lt;/code&gt;。&lt;/p&gt;
&lt;h3&gt;string::size_type 类型&lt;/h3&gt;
&lt;p&gt;是一个无符号类型的值。如果一个表达式中已经有&lt;code&gt;size&lt;/code&gt;函数就不要再使用&lt;code&gt;int&lt;/code&gt;了，这样可以避免混用&lt;code&gt;int&lt;/code&gt;和&lt;code&gt;unsigned&lt;/code&gt;可能带来的问题。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;string&lt;/code&gt;对象可以和字符字符串字面值相加，只要保证 + 号两侧的运算对象至少有一个&lt;code&gt;string&lt;/code&gt;对象即可。&lt;/p&gt;
&lt;p&gt;由于某些历史原因，也为了和 C 兼容，所以 C++ 中的字符串字面值并不是标准库&lt;code&gt;string&lt;/code&gt;类型。&lt;/p&gt;
&lt;h3&gt;处理 string 对象里的字符&lt;/h3&gt;
&lt;p&gt;包含在&lt;code&gt;cctype&lt;/code&gt;头文件中：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;意义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;isalunm(c)&lt;/td&gt;
&lt;td&gt;当 c 是字母或数字时为真&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;isalpha(c)&lt;/td&gt;
&lt;td&gt;当 c 是字母时为真&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;iscntrl(c)&lt;/td&gt;
&lt;td&gt;当 c 是控制字符时为真&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;isdigit(c)&lt;/td&gt;
&lt;td&gt;当 c 是数字时为真&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;isgraph(c)&lt;/td&gt;
&lt;td&gt;当 c 不是空格但可打印时为真&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;islower(c)&lt;/td&gt;
&lt;td&gt;当 c 是小写字母时为真&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;isprint(c)&lt;/td&gt;
&lt;td&gt;当 c 是可打印字符时为真（即 c 是空格或 c 具有可视形式）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ispunct(c)&lt;/td&gt;
&lt;td&gt;当 c 是标点符号时为真（即 c 不是控制字符、数字、字母、可打印空白中的一种）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;isspace(c)&lt;/td&gt;
&lt;td&gt;当 c 是空白时为真（即 c 是空格、横向制表符、纵向制表符、回车符、换行符、进纸符中的一种）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;isupper(c)&lt;/td&gt;
&lt;td&gt;当 c 是大写字母时为真&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;isxdigit(c)&lt;/td&gt;
&lt;td&gt;当 c 是十六进制数字时为真&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;tolower(c)&lt;/td&gt;
&lt;td&gt;输出 c 的小写&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;toupper(c)&lt;/td&gt;
&lt;td&gt;输出 c 的大写&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;C++ 标准库除了定义 C++ 语言特有的功能外，也兼容了 C 语言的标准库。C 语言的头文件形如 name.h，C++ 则将这些文件命名为 cname。因此&lt;code&gt;cctype&lt;/code&gt;头文件和&lt;code&gt;ctype.h&lt;/code&gt; 头文件的内容是一样的，只不过从命名规范上来讲更符合 C++ 语言的要求。特别地，在名为 cname 的头文件中定义的名字从属于命名空间&lt;code&gt;std&lt;/code&gt;。&lt;/p&gt;
&lt;h3&gt;范围 for&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;for (declaration: expression)
        statement
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;expression 是一个对象，用于表示一个序列；declaration 负责定义一个变量，该变量将被用于访问序列中的基础元素，每次迭代，declaration 部分的变量会被初始化为 expression 部分的下一个元素值。&lt;/p&gt;
&lt;p&gt;使用范围for输出&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;string str(&amp;quot;some string&amp;quot;);
        for (auto c : str)
cout &amp;lt;&amp;lt; c &amp;lt;&amp;lt; endl;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;使用范围for修改&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;string s(&amp;quot;Hello World!&amp;quot;);
for (auto &amp;amp;c : s)
        c = toupper(c);
cout &amp;lt;&amp;lt; s &amp;lt;&amp;lt; endl;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;下标运算符 [ ]&lt;/h3&gt;
&lt;p&gt;[ ]接收的输入参数是&lt;code&gt;string:size_type&lt;/code&gt;类型的值，这个参数表示要访问的字符的位置，返回值是该位置上字符的引用。&lt;code&gt;string&lt;/code&gt;对象的下标必须大于等于0而小于&lt;code&gt;s.size()&lt;/code&gt;。&lt;/p&gt;
&lt;h2&gt;标准库类型 vector&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;vector&lt;/code&gt;表示对象的集合，其中所有对象的类型都相同，也常被称作容器，是一种类模板&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;vector&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="n"&gt;using&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;编译器根据模板创建类或函数的过程称为实例化，对于类模板，我们通过提供一些额外信息来指定模板到底实例化成什么样的类：在模板名字后面跟一对尖括号，在括号内放上信息&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;vector&amp;lt;int&amp;gt; ivec;
vector&amp;lt;Sales_item&amp;gt; Sales_vec;
vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; file;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在早期版本的 C++ 标准中如果&lt;code&gt;vector&lt;/code&gt;的元素还是&lt;code&gt;vector&lt;/code&gt;（或者其他模板类型），则其定义的形式与现在的 C++11 新标准略有不同。过去，必须在外层&lt;code&gt;vector&lt;/code&gt;对象的右尖括号和其元素类型之间添加一个空格，如应写成&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;初始化&lt;/h3&gt;
&lt;p&gt;默认初始化。&lt;/p&gt;
&lt;p&gt;列表初始化。&lt;/p&gt;
&lt;p&gt;值初始化：通常情况下，可以只提供vector对象容纳的元素数量而略去初始值。此时库会创建一个值初始化的元素初值，并把它赋给容器中的所有元素。这个初值由vector对象中元素的类型决定。内置类型：0；类类型：由类默认初始化。&lt;/p&gt;
&lt;h3&gt;添加元素&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;push_back&lt;/code&gt;：负责把一个值当成&lt;code&gt;vector&lt;/code&gt;对象的尾元素压到&lt;code&gt;vector&lt;/code&gt;对象的尾端&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;vector&amp;lt;int&amp;gt; v2;
for (int i = 0; i != 100; ++i)
        v2.push_back(i);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如果循环内部包含有向&lt;code&gt;vector&lt;/code&gt;对象添加元素的语句，则不能使用范围&lt;code&gt;for&lt;/code&gt;循环。&lt;/p&gt;
&lt;h3&gt;其他vector操作&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;v.empty()&lt;/td&gt;
&lt;td&gt;如果 v 不含有任何元素，返回真；否则返回假&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;v.size()&lt;/td&gt;
&lt;td&gt;返回 v 中元素的个数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;v.push_back(t)&lt;/td&gt;
&lt;td&gt;向 v 的尾端添加一个值为 t 的元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;v[n]&lt;/td&gt;
&lt;td&gt;返回 v 中第 n 个位置上元素的引用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;v1 = v2&lt;/td&gt;
&lt;td&gt;用 v2 中的元素拷贝替换 v1 中的元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td a，b，c...&gt;v1 = &lt;/td&gt;
&lt;td&gt;用列表中元素的拷贝替换 v1 中的元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;v1 == v2&lt;/td&gt;
&lt;td&gt;v1 和 v2 相等当且仅当它们的元素数量相同且对应位置的元素值都相同&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;v1 != v2&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;lt;,&amp;lt;=,&amp;gt;,&amp;gt;=&lt;/td&gt;
&lt;td&gt;以字典顺序进行比较&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;vector 的 size_type&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;vector&amp;lt;int&amp;gt;::size_type      //正确
vector::size_type           //错误
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;和&lt;code&gt;string&lt;/code&gt;一样，&lt;code&gt;vector&lt;/code&gt;对象的下标也是从0开始计算，&lt;code&gt;vector&lt;/code&gt;对象（以及&lt;code&gt;string&lt;/code&gt;对象）的下标运算符可用于访问已存在的元素，而不能用于添加元素。&lt;/p&gt;
&lt;h2&gt;迭代器&lt;/h2&gt;
&lt;p&gt;所有标准库容器都可以使用迭代器，但只有少数的几种才同时支持下标运算符。&lt;/p&gt;
&lt;p&gt;严格来讲，&lt;code&gt;string&lt;/code&gt;不属于容器类型，但是&lt;code&gt;string&lt;/code&gt;支持很多与容器类型相似的操作。&lt;code&gt;vector&lt;/code&gt;支持下标运算符，这点和&lt;code&gt;string&lt;/code&gt;一样。&lt;/p&gt;
&lt;p&gt;和指针不一样，获取迭代器不是使用取地址符，有迭代器的类型同时拥有返回迭代器的成员。&lt;code&gt;begin&lt;/code&gt;和&lt;code&gt;end&lt;/code&gt;：&lt;code&gt;auto b = v.begin(), e = v.end();&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;end&lt;/code&gt;成员负责返回指向容器“尾元素的下一位置”的迭代器。常被称作尾后迭代器或尾迭代器。&lt;/p&gt;
&lt;p&gt;如果容器为空，则&lt;code&gt;begin&lt;/code&gt;和&lt;code&gt;end&lt;/code&gt;返回的是同一个迭代器，都是尾后迭代器。&lt;/p&gt;
&lt;h3&gt;标准容器迭代器的运算符&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;符号&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;*iter&lt;/td&gt;
&lt;td&gt;返回迭代器 iter 所指元素的引用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;iter-&amp;gt;mem&lt;/td&gt;
&lt;td&gt;解引用 iter 并获取该元素的名为 mem 的成员，等价于(*iter).mem&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;++iter&lt;/td&gt;
&lt;td&gt;令 iter 指向容器中的下一个元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;--iter&lt;/td&gt;
&lt;td&gt;令 iter 指向容器中的上一个元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;iter1 == iter2&lt;/td&gt;
&lt;td&gt;判断两个迭代器是否相等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;iter1 != iter2&lt;/td&gt;
&lt;td&gt;如果指向同一元素或者他们是同一容器的尾后迭代器&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;因为&lt;code&gt;end&lt;/code&gt;返回的迭代器并不实际指向某个元素，所以不能对其进行递增或解引用操作。C++ 程序员习惯性地使用&lt;code&gt;!=&lt;/code&gt;，其原因和他们更愿意使用迭代器而非下标的原因一样：这种编程风格在标准库提供的所有容器上都有效，因为所有标准库容器都定义了&lt;code&gt;==&lt;/code&gt;和&lt;code&gt;!=&lt;/code&gt;。&lt;/p&gt;
&lt;h3&gt;迭代器类型&lt;/h3&gt;
&lt;p&gt;拥有迭代器的标准库类型使用&lt;code&gt;iterator&lt;/code&gt;和&lt;code&gt;const_iterator&lt;/code&gt;来表示迭代器的类型&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nd"&gt;iterator&lt;/span&gt; &lt;span class="nt"&gt;it&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;   &lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="nt"&gt;it&lt;/span&gt; &lt;span class="nt"&gt;能读写&lt;/span&gt; &lt;span class="nt"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nt"&gt;的元素&lt;/span&gt;
&lt;span class="nt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nd"&gt;iterator&lt;/span&gt; &lt;span class="nt"&gt;it2&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;       &lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="nt"&gt;it2&lt;/span&gt; &lt;span class="nt"&gt;能读写&lt;/span&gt; &lt;span class="nt"&gt;string&lt;/span&gt; &lt;span class="nt"&gt;对象中的元素&lt;/span&gt;
&lt;span class="nt"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="nt"&gt;const_iterator&lt;/span&gt; &lt;span class="nt"&gt;it3&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;  &lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="nt"&gt;it3&lt;/span&gt; &lt;span class="nt"&gt;只能读元素&lt;/span&gt;&lt;span class="err"&gt;，&lt;/span&gt;&lt;span class="nt"&gt;不能写元素&lt;/span&gt;
&lt;span class="nt"&gt;string&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="nd"&gt;const_iterator&lt;/span&gt; &lt;span class="nt"&gt;it4&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;     &lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="nt"&gt;it4&lt;/span&gt; &lt;span class="nt"&gt;只能读字符&lt;/span&gt;&lt;span class="err"&gt;，&lt;/span&gt;&lt;span class="nt"&gt;不能写字符&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;begin&lt;/code&gt;和&lt;code&gt;end&lt;/code&gt;返回的具体类型由对象是否是常量决定，如果对象是常量，&lt;code&gt;begin&lt;/code&gt;和&lt;code&gt;end&lt;/code&gt;返回&lt;code&gt;const_iterator&lt;/code&gt;；如果对象不是常量，返回&lt;code&gt;iterator&lt;/code&gt;。如果对象只需读操作而无需写操作的话最好使用常量类型迭代器。为了专门得到&lt;code&gt;const_iterator&lt;/code&gt;，C++11 标准引入两个新函数：&lt;code&gt;cbegin&lt;/code&gt;和&lt;code&gt;cend&lt;/code&gt;。任何一种可能改变容器容量的操作，都会是迭代器失效。&lt;/p&gt;
&lt;h3&gt;迭代器运算&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;string&lt;/code&gt;和&lt;code&gt;vector&lt;/code&gt;的迭代器提供了更多额外的运算符：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;iter + n&lt;/code&gt;：迭代器加上一个整数值仍得到一个迭代器，迭代器指示的新位置与原来相比向前移动了若干个元素。结果迭代器或者指示容器内的一个元素，或者指示容器尾元素的下一位置。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;iter - n&lt;/code&gt;：迭代器减去一个整数值仍得一个迭代器，迭代器指示的新位置与原来相比向后移动了若干位置。结果迭代器或者指示容器内的一个元素，或者指示容器尾元素的下一位置。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;iter1 - iter2&lt;/code&gt;：两个迭代器相减的结果是它们之间的距离，也就是说，将运算符右侧的迭代器向前移动差值个元素后将得到左侧的迭代器。参与运算的两个迭代器必须指向的是同一容器中的元素或者尾元素的下一位置。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;gt;, &amp;gt;=, &amp;lt;, &amp;lt;=&lt;/code&gt;：迭代器的关系运算符，如果迭代器指向的容器位置在另一个迭代器所指位置之前，则说前者小于后者。&lt;/p&gt;
&lt;h2&gt;数组&lt;/h2&gt;
&lt;p&gt;因为数组的大小固定，因此在对某些特殊的应用来说程序的运行时性能较好，但是相应的也损失了一些灵活性。&lt;/p&gt;
&lt;p&gt;数组的维度必须是一个常量表达式。&lt;/p&gt;
&lt;p&gt;默认情况下数组的元素被默认初始化。&lt;/p&gt;
&lt;p&gt;和内置类型的变量一样，如果在函数内部定义了某种内置类型的数组，那么默认初始化会令数组含有未定义的值。&lt;/p&gt;
&lt;p&gt;定义数组的时候必须指定数组的类型，不允许用auto关键字由初始值的列表推断类型。&lt;/p&gt;
&lt;p&gt;字符数组可以利用字符串字面值初始化，此时注意字符串字面值末尾的空字符，也会被拷贝到字符数组中。&lt;/p&gt;
&lt;p&gt;不允许拷贝和赋值。一些编译器支持数组的赋值，这就是所谓的编译器扩展，但一般来说，最好避免使用非标准特性，因为可能在其他编译器上无法正常工作。&lt;/p&gt;
&lt;p&gt;理解复杂的数组声明：由内向外阅读&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int *ptrs[10];   //ptrs 是含有10个整型指针的数组
int (*Parray)[10] = &amp;amp;arr;   //Parray 是指针，指向一个含有10个整数的数组
int (&amp;amp;arrRef)[10] = arr;    //arrRef 是引用，引用一个含有10个整数的数组
int *(&amp;amp;arry)[10] = ptrs;    //arry 是引用，引用一个含有10个整型指针的数组
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;访问数组元素&lt;/h3&gt;
&lt;p&gt;数组的索引从0开始。&lt;/p&gt;
&lt;p&gt;在使用数组下标的时候，通常将其定义为&lt;code&gt;size_t&lt;/code&gt;类型。&lt;code&gt;size_t&lt;/code&gt;是一种机器相关的无符号类型，它被设计的足够大以便能表示内存中任意对象的大小。&lt;/p&gt;
&lt;p&gt;在 cstddef 头文件中定义了&lt;code&gt;size_t&lt;/code&gt;类型，这个文件是 C 标准库 stddef.h 头文件的 C++ 版本。&lt;/p&gt;
&lt;p&gt;使用数组的时候编译器一般会把它转换成指针。&lt;/p&gt;
&lt;p&gt;通常情况下，使用取地址符来获取指向某个对象的指针，取地址符可以用于任何对象。数组的元素也是对象，对数组使用下标运算符得到该数组指定位置的元素，对数组元素应用取地址符就能得到指向该元素的指针。&lt;/p&gt;
&lt;p&gt;数组还有一个特性：在很多时候用到数组名字的地方，编译器都会自动地将其替换为一个指向数组首元素的指针&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;string *p2 = nums;  //等价于 p2 = &amp;amp;nums[0]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;所以如果使用数组作为一个auto变量的初始值时，推断的类型是指针而非数组&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int ia[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9,};
auto ia2(ia);       // ia2 是一个整型指针，指向 ia 的第一个元素
ia2 = 42;       //错误，ia2 是一个指针，不能用 int 赋值
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当使用&lt;code&gt;decltype&lt;/code&gt;关键字时上述转换不会发生，&lt;code&gt;decltype(ia)&lt;/code&gt;返回的类型是由10个整数构成的数组&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;decltype(ia) ia3 = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
ia3 = p;        //错误，不能用整型指针给数组赋值
ia3[4] = i;     //正确：把 i 的值赋给 ia3 的一个元素
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;为了让指针的使用更简单、更安全，C++11 新标准引入两个名为&lt;code&gt;begin&lt;/code&gt;和&lt;code&gt;end&lt;/code&gt;的函数，不过数组毕竟不是类类型，因此这两个函数不是成员函数。正确的使用形式是将数组作为它们的参数&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int ia[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};
int *beg = begin(ia);
int *last = end(ia);
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;begin&lt;/code&gt;函数返回指向 ia 首元素的指针，&lt;code&gt;end&lt;/code&gt;函数返回指向 ia 尾元素下一位置的指针，这两个函数定义在 iterator 头文件中&lt;/p&gt;
&lt;p&gt;两个指针相减结果的类型是一种名为&lt;code&gt;ptrdiff_t&lt;/code&gt;的类型，和&lt;code&gt;size_t&lt;/code&gt;一样，它也是定义在 cstddef 头文件中的机器相关的类型。因为差值可能是负值，所以它是一种带符号类型。&lt;/p&gt;
&lt;p&gt;内置的下标运算符所用的索引值不是无符号类型，这一点和&lt;code&gt;vector&lt;/code&gt;和&lt;code&gt;string&lt;/code&gt;不一样&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int *p = &amp;amp;ia[2];
int k = p[-2];      //k 是 ia[0] 那个元素
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;C 风格字符串&lt;/h3&gt;
&lt;p&gt;按此习惯书写的字符串存放在字符数组中并以空字符结束。&lt;/p&gt;
&lt;p&gt;C 语言标准库提供了一组函数用于操作 C 风格字符串，它们定义在 cstring 头文件中，cstring 是 C 语言头文件 string.h 的 C++ 版本。&lt;/p&gt;
&lt;h3&gt;与旧代码的接口&lt;/h3&gt;
&lt;p&gt;任何出现字符串字面值的地方都可以用空字符结尾的字符数组来代替。不能用string对象直接初始化指向字符的指针，为了完成该功能，string专门提供了一个名为c_str的成员函数&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;char *str = s;      //错误，不能用 string 对象初始化 char*
const char *str = s.c_str();    //正确
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们无法保证 c_str 函数返回的数组一直有效，事实上，如果后续的操作改变了 s 的值就可能让之前返回的数组失去效用&lt;/p&gt;
&lt;p&gt;使用数组初始化&lt;code&gt;vector&lt;/code&gt;对象&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;int int_arr[] = {0, 1, 2, 3, 4, 5};
vector&amp;lt;int&amp;gt; ivec(begin(int_arr),end(int_arr));
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;现代的 C++ 程序员应当尽量使用&lt;code&gt;vector&lt;/code&gt;和迭代器，避免使用内置的数组和指针，应该尽量使用&lt;code&gt;string&lt;/code&gt;，避免使用 C 风格的基于数组的字符串。&lt;/p&gt;
&lt;p&gt;多维数组：要使用范围 for 语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型。&lt;/p&gt;
&lt;p&gt;缓冲区溢出：主要原因是试图通过一个越界的索引访问容器内容。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;difference_type&lt;/code&gt;：由&lt;code&gt;string&lt;/code&gt;和&lt;code&gt;vector&lt;/code&gt;定义的一种带符号整数类型，表示两个迭代器之间的距离。&lt;/p&gt;</content><category term="C++"></category></entry><entry><title>C++ Primer 第二章 变量和基本类型</title><link href="https://xutree.github.io/pages/2018/10/06/C++_Primer_Chapter_2/" rel="alternate"></link><published>2018-10-06T22:02:54+08:00</published><updated>2018-10-07T10:48:38+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-06:/pages/2018/10/06/C++_Primer_Chapter_2/</id><summary type="html">&lt;h2&gt;类型&lt;/h2&gt;
&lt;p&gt;下表列出了 C++ 标准规定的数据类型尺寸的最小值，同时允许编译器赋予这些类型更大的尺寸&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;th&gt;最小尺寸&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;bool&lt;/td&gt;
&lt;td&gt;布尔类型&lt;/td&gt;
&lt;td&gt;未定义&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;char&lt;/td&gt;
&lt;td&gt;字符&lt;/td&gt;
&lt;td&gt;8位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;wchar_t&lt;/td&gt;
&lt;td&gt;宽字符&lt;/td&gt;
&lt;td&gt;16位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;char16_t&lt;/td&gt;
&lt;td&gt;Unicode 字符&lt;/td&gt;
&lt;td&gt;16位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;char32_t&lt;/td&gt;
&lt;td&gt;Unicode 字符&lt;/td&gt;
&lt;td&gt;32位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;short&lt;/td&gt;
&lt;td&gt;短整型&lt;/td&gt;
&lt;td&gt;16位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;整型&lt;/td&gt;
&lt;td&gt;16位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;long&lt;/td&gt;
&lt;td&gt;长整型&lt;/td&gt;
&lt;td&gt;32位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;long long&lt;/td&gt;
&lt;td&gt;长整型&lt;/td&gt;
&lt;td&gt;64位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;float&lt;/td&gt;
&lt;td&gt;单精度浮点数&lt;/td&gt;
&lt;td&gt;6位有效数字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;double&lt;/td&gt;
&lt;td&gt;双精度浮点数&lt;/td&gt;
&lt;td&gt;10位有效数字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;long double&lt;/td&gt;
&lt;td&gt;扩展精度浮点数&lt;/td&gt;
&lt;td&gt;10位有效数字&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;一个&lt;code&gt;char …&lt;/code&gt;&lt;/p&gt;</summary><content type="html">&lt;h2&gt;类型&lt;/h2&gt;
&lt;p&gt;下表列出了 C++ 标准规定的数据类型尺寸的最小值，同时允许编译器赋予这些类型更大的尺寸&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;th&gt;最小尺寸&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;bool&lt;/td&gt;
&lt;td&gt;布尔类型&lt;/td&gt;
&lt;td&gt;未定义&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;char&lt;/td&gt;
&lt;td&gt;字符&lt;/td&gt;
&lt;td&gt;8位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;wchar_t&lt;/td&gt;
&lt;td&gt;宽字符&lt;/td&gt;
&lt;td&gt;16位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;char16_t&lt;/td&gt;
&lt;td&gt;Unicode 字符&lt;/td&gt;
&lt;td&gt;16位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;char32_t&lt;/td&gt;
&lt;td&gt;Unicode 字符&lt;/td&gt;
&lt;td&gt;32位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;short&lt;/td&gt;
&lt;td&gt;短整型&lt;/td&gt;
&lt;td&gt;16位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;整型&lt;/td&gt;
&lt;td&gt;16位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;long&lt;/td&gt;
&lt;td&gt;长整型&lt;/td&gt;
&lt;td&gt;32位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;long long&lt;/td&gt;
&lt;td&gt;长整型&lt;/td&gt;
&lt;td&gt;64位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;float&lt;/td&gt;
&lt;td&gt;单精度浮点数&lt;/td&gt;
&lt;td&gt;6位有效数字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;double&lt;/td&gt;
&lt;td&gt;双精度浮点数&lt;/td&gt;
&lt;td&gt;10位有效数字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;long double&lt;/td&gt;
&lt;td&gt;扩展精度浮点数&lt;/td&gt;
&lt;td&gt;10位有效数字&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;一个&lt;code&gt;char&lt;/code&gt;的空间应确保可以存放机器基本字符集中任意字符对应的数字值。也就是说，一个&lt;code&gt;char&lt;/code&gt;的大小和一个机器字节一样。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;wchar_t&lt;/code&gt;类型用于确保可以存放机器最大扩展字符集中的任意一个字符。&lt;/p&gt;
&lt;p&gt;C++ 语言规定，一个&lt;code&gt;int&lt;/code&gt;至少和一个&lt;code&gt;short&lt;/code&gt;一样大，一个&lt;code&gt;long&lt;/code&gt;至少和一个&lt;code&gt;int&lt;/code&gt;一样大，一个&lt;code&gt;long long&lt;/code&gt;至少和一个&lt;code&gt;long&lt;/code&gt;一样大。&lt;/p&gt;
&lt;p&gt;可寻址的最小内存块成称为“字节（byte）”，存储的基本单元称为“字（word）”，它通常有几个字节组成。&lt;/p&gt;
&lt;p&gt;在 C++ 语言中，一个字节至少能容纳机器基本字符串中的字符。大多数机器的字节由8比特构成，字则由32或64比特构成，也就是4字节或8字节。&lt;/p&gt;
&lt;p&gt;C++ 标准指定了一个浮点数有效位数的最小值，然而大多数编译器都实现了更高的精度。通常，&lt;code&gt;float&lt;/code&gt;以1个字（32比特）来表示，&lt;code&gt;double&lt;/code&gt;以2个字（64位）来表示，&lt;code&gt;long double&lt;/code&gt;以3或4个字（96或128比特）来表示。一般来说，&lt;code&gt;float&lt;/code&gt;和&lt;code&gt;double&lt;/code&gt;分别有7和16个有效位；类型&lt;code&gt;long double&lt;/code&gt;则常常被用于有特殊浮点要求的硬件，它的具体实现不同，精度也各不相同。&lt;/p&gt;
&lt;p&gt;类型&lt;code&gt;int&lt;/code&gt;、&lt;code&gt;short&lt;/code&gt;、&lt;code&gt;long&lt;/code&gt;和&lt;code&gt;long long&lt;/code&gt;都是带符号的，通过在这些类型名前添加&lt;code&gt;unsigned&lt;/code&gt;就可以得到无符号类型。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;char&lt;/code&gt;、&lt;code&gt;signed char&lt;/code&gt;和&lt;code&gt;unsigned char&lt;/code&gt;，&lt;code&gt;char&lt;/code&gt;是否等于&lt;code&gt;signed char&lt;/code&gt;由编译器决定。&lt;/p&gt;
&lt;p&gt;C++ 标准并没有规定带符号类型应如何表示，但是约定了在表示范围内正值和负值的量应该平衡。因此，8比特的&lt;code&gt;signed char&lt;/code&gt;理论上可以表示-127至127区间内的值，大多数现代计算机将实际的表示范围定为-128至127。&lt;/p&gt;
&lt;h2&gt;如何选择类型&lt;/h2&gt;
&lt;p&gt;明知数值不可能为负数，选用无符号类型。&lt;/p&gt;
&lt;p&gt;如果数值超过了&lt;code&gt;int&lt;/code&gt;的表示范围，选用&lt;code&gt;long long&lt;/code&gt;，因为&lt;code&gt;long&lt;/code&gt;一般和&lt;code&gt;int&lt;/code&gt;有一样的尺寸。&lt;/p&gt;
&lt;p&gt;算术表达式中不要使用&lt;code&gt;bool&lt;/code&gt;或&lt;code&gt;char&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;执行浮点数运算选用&lt;code&gt;double&lt;/code&gt;。因为&lt;code&gt;float&lt;/code&gt;通常精度不够而且计算代价相差无几。&lt;code&gt;long double&lt;/code&gt;提供的精度一般情况下是没有必要的而且计算代价大。&lt;/p&gt;
&lt;h2&gt;类型转换&lt;/h2&gt;
&lt;p&gt;非布尔 -&amp;gt; 布尔：0 -&amp;gt; &lt;code&gt;false&lt;/code&gt;，其他 -&amp;gt; &lt;code&gt;ture&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;布尔 -&amp;gt; 非布尔：&lt;code&gt;false&lt;/code&gt;-&amp;gt; 0，&lt;code&gt;ture&lt;/code&gt; -&amp;gt; 1。&lt;/p&gt;
&lt;p&gt;浮点 -&amp;gt; 整型：仅保留小数点前。&lt;/p&gt;
&lt;p&gt;整型 -&amp;gt; 浮点：小数部分记为0，如果该整数所占的空间超过浮点类型的容量，精度可能损失。&lt;/p&gt;
&lt;p&gt;当我们赋给无符号类型一个超过它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。&lt;/p&gt;
&lt;p&gt;当我们赋给带符号类型一个超出它表示范围的值时，结果是未定义的。此时，程序可能继续工作、可能崩溃，也可能生成垃圾数据。&lt;/p&gt;
&lt;p&gt;当一个算术表达式中既有无符号数又有&lt;code&gt;int&lt;/code&gt;值时，那个&lt;code&gt;int&lt;/code&gt;会转换成无符号数。把&lt;code&gt;int&lt;/code&gt;转换成无符号数的过程和把&lt;code&gt;int&lt;/code&gt;赋值给无符号变量一样。&lt;/p&gt;
&lt;p&gt;当从一个无符号数中减去一个值时，我们必须确保结果不是负值，否则实际结果会是取模后的值。&lt;/p&gt;
&lt;h2&gt;字面值常量&lt;/h2&gt;
&lt;p&gt;整型和浮点型字面值。&lt;/p&gt;
&lt;p&gt;字符和字符串字面值：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;‘a’ 和“a”，字符串字面值最后补’\0’&lt;/li&gt;
&lt;li&gt;如果两个字符串字面值位置紧邻且仅由空格、缩进和换行分隔，则它们是一个整体&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;布尔字面值：&lt;code&gt;true&lt;/code&gt;、&lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;指针字面值：&lt;code&gt;nullptr&lt;/code&gt;。&lt;/p&gt;
&lt;h2&gt;指定字面值的类型&lt;/h2&gt;
&lt;p&gt;字符和字符串字面值&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;前缀&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;u&lt;/td&gt;
&lt;td&gt;char16_t&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;U&lt;/td&gt;
&lt;td&gt;char32_t&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;L&lt;/td&gt;
&lt;td&gt;wchar_t&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;u8&lt;/td&gt;
&lt;td&gt;char&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;整型字面值&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;后缀&lt;/th&gt;
&lt;th&gt;最小匹配类型&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;u 或 U&lt;/td&gt;
&lt;td&gt;unsigned&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;l 或 L&lt;/td&gt;
&lt;td&gt;long&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ll 或 LL&lt;/td&gt;
&lt;td&gt;long long&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;浮点型字面值&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;后缀&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;f 或 F&lt;/td&gt;
&lt;td&gt;float&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;l 或 L&lt;/td&gt;
&lt;td&gt;long double&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;列表初始化&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;int units_sold{0}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;列表初始化的重要特点：如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将报错。&lt;/p&gt;
&lt;h2&gt;默认初始化&lt;/h2&gt;
&lt;p&gt;内置类型变量&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定义于任何函数之外，初始化为0&lt;/li&gt;
&lt;li&gt;定义于函数体内的局部静态变量，初始化为0&lt;/li&gt;
&lt;li&gt;定义于函数体内的非局部静态变量，不被初始化，试图拷贝或以其他方式访问此类值将引发错误&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每个类各自决定其初始化对象的方式。&lt;/p&gt;
&lt;h2&gt;分离式编译&lt;/h2&gt;
&lt;p&gt;将程序分割为若干个文件，每个文件可被独立编译&lt;/p&gt;
&lt;h2&gt;声明&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;extern int i;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;extern&lt;/code&gt;语句如果包含初始值就不再是声明，而变成定义了：&lt;code&gt;extern int i = 0;&lt;/code&gt;在函数体内部，试图初始化一个由&lt;code&gt;extern&lt;/code&gt;关键字标记的变量将引发错误。&lt;/p&gt;
&lt;p&gt;静态类型语言：在编译阶段执行类型检查&lt;/p&gt;
&lt;h2&gt;C++ 标识符&lt;/h2&gt;
&lt;p&gt;字母、数字、下划线，必须以字母或下划线开头，长度无限制，大小写敏感。&lt;/p&gt;
&lt;p&gt;C++ 为标准库保留了一些名字&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自定义标识符中不能连续出现两个下划线&lt;/li&gt;
&lt;li&gt;不能以下划线紧接大写字母开头&lt;/li&gt;
&lt;li&gt;定义在函数体外的函数不能以下划线开头&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;作用域操作符 ::&lt;/h2&gt;
&lt;p&gt;若左侧为空，则指代全局作用域&lt;/p&gt;
&lt;h2&gt;复合类型&lt;/h2&gt;
&lt;h3&gt;引用&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;int &amp;amp;b = a;&lt;/code&gt;b指向a。&lt;/p&gt;
&lt;p&gt;引用必须初始化。&lt;/p&gt;
&lt;p&gt;引用本身不是一个对象，不能定义引用的引用。&lt;/p&gt;
&lt;p&gt;引用必须绑定到对象上，不能绑定到字面值或者某个表达式的计算结果上。&lt;/p&gt;
&lt;p&gt;除了两种例外，所有引用的类型都要和它所绑定的对象严格匹配：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可&lt;/li&gt;
&lt;li&gt;允许将基类的引用绑定到派生类上&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;指针&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;int *b = &amp;amp;a;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;指针是一个对象。&lt;/p&gt;
&lt;p&gt;在块作用域内定义的指针如果未初始化，将拥有一个不确定的值。&lt;/p&gt;
&lt;p&gt;除了两种例外，所有指针的类型都要和它所指向的对象严格匹配：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;允许一个指向常量的指针指向一个非常量对象&lt;/li&gt;
&lt;li&gt;允许将基类的指针绑定到派生类上&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;试图拷贝或以其他方式访问无效指针的值将引起错误，编译器不负责检查此类错误。&lt;/p&gt;
&lt;p&gt;任何非零的指针对应的条件值都是true。&lt;/p&gt;
&lt;p&gt;合法指针可以比较大小：== 或 !=。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;void *&lt;/code&gt;是一个特殊的指针类型，可用于存放任意对象的地址，只支持有限的操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;拿它和别的指针比较&lt;/li&gt;
&lt;li&gt;作为函数的输入或输出&lt;/li&gt;
&lt;li&gt;赋给另外一个&lt;code&gt;void *&lt;/code&gt;指针&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;理解复合类型的声明&lt;/h2&gt;
&lt;p&gt;变量的定义包括一个基本数据类型和一组声明符。&lt;/p&gt;
&lt;p&gt;一条定义语句可能定义出不同类型的变量：&lt;code&gt;int i = 1024, *p = &amp;amp;i, &amp;amp;r =i;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;面对一条比较复杂的指针或者引用的声明语句时，从右往左阅读有助于弄清楚它的真实含义，例如：&lt;code&gt;int \*&amp;amp;r;&lt;/code&gt;首先 r 是一个引用，其次 r 是一个指针的引用，再次 r 是一个指向整型指针的引用。&lt;/p&gt;
&lt;h2&gt;const 限定符&lt;/h2&gt;
&lt;p&gt;因为&lt;code&gt;const&lt;/code&gt;对象一旦创建就无法改变其值，所以必须初始化。&lt;/p&gt;
&lt;p&gt;当用一个对象去初始化另外一个对象，它们是不是&lt;code&gt;const&lt;/code&gt;都无关紧要，常量的特性仅仅在执行改变其值的操作时才会发挥作用。&lt;/p&gt;
&lt;p&gt;默认情况下，&lt;code&gt;const&lt;/code&gt;对象仅在文件内有效。&lt;/p&gt;
&lt;p&gt;如果想在多个文件之间共享&lt;code&gt;const&lt;/code&gt;对象，必须在变量的定义之前添加&lt;code&gt;extern&lt;/code&gt;关键字。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;const&lt;/code&gt;的引用，常量引用的初始化：初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。尤其，允许为一个常量引用绑定非常量的对象、字面值甚至是一个表达式。实际上是通过绑定到一个临时量对象上实现的。&lt;/p&gt;
&lt;p&gt;对&lt;code&gt;const&lt;/code&gt;的引用可能引用一个并非&lt;code&gt;const&lt;/code&gt;的对象，常量引用仅对引用可参与的操作做了限制，对于引用的对象本身是不是常量未做限制。&lt;/p&gt;
&lt;h2&gt;指针和 const&lt;/h2&gt;
&lt;h3&gt;指向常量的指针&lt;/h3&gt;
&lt;p&gt;允许一个指向常量的指针指向一个非常量对象。&lt;/p&gt;
&lt;p&gt;仅对指向常量的指针可参与的操作做了限制，对于指向的对象本身是不是常量未做限制。&lt;/p&gt;
&lt;h3&gt;const 指针&lt;/h3&gt;
&lt;p&gt;指针是对象，可以把指针本身定为常量。&lt;/p&gt;
&lt;p&gt;常量指针必须初始化，一经初始化就不能再改变。&lt;/p&gt;
&lt;p&gt;把*放在&lt;code&gt;const&lt;/code&gt;关键字之前说明指针是一个常量。&lt;/p&gt;
&lt;h3&gt;顶层和底层 const&lt;/h3&gt;
&lt;p&gt;顶层&lt;code&gt;const&lt;/code&gt;：指针本身是个常量。&lt;/p&gt;
&lt;p&gt;底层&lt;code&gt;const&lt;/code&gt;：指针所值的对象是一个常量。&lt;/p&gt;
&lt;p&gt;更一般的，顶层&lt;code&gt;const&lt;/code&gt;可以表示任意的对象是常量，这一点对任意数据类型都适用。底层&lt;code&gt;const&lt;/code&gt;则与指针和引用等复合类型的基本类型部分有关。&lt;/p&gt;
&lt;p&gt;执行对象的拷贝操作时，顶层&lt;code&gt;const&lt;/code&gt;不受影响；拷入和拷出的对象必须具有相同的底层&lt;code&gt;const&lt;/code&gt;资格，或者两个对象的数据类型必须能够转换。一般来说，非常量可以转换成常量，反之不行。&lt;/p&gt;
&lt;h3&gt;constexpr 和常量表达式&lt;/h3&gt;
&lt;p&gt;常量表达式：值不会改变并且在编译过程就能得到计算结果的表达式。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;constexpr&lt;/code&gt;变量：由编译器来验证变量的值是否是一个常量表达式，声明为&lt;code&gt;constexpr&lt;/code&gt;的变量一定是一个常量，并且必须用常量表达式初始化。&lt;/p&gt;
&lt;p&gt;字面值类型：算术类型、引用、指针、字面值常量类、枚举。&lt;/p&gt;
&lt;p&gt;声明&lt;code&gt;constexpr&lt;/code&gt;用到的类型为字面值类型。&lt;/p&gt;
&lt;p&gt;一个&lt;code&gt;constexpr&lt;/code&gt;指针的初始值必须是&lt;code&gt;nullptr&lt;/code&gt;或者0，或者是存储于某个固定地址中的对象：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函数体内定义的变量一般并非存放在固定地址中，&lt;code&gt;constexpr&lt;/code&gt;指针不能指向这样的变量（局部静态对象除外）&lt;/li&gt;
&lt;li&gt;定义于所有函数体之外的对象地址固定不变，能用来初始化&lt;code&gt;constexpr&lt;/code&gt;指针&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在&lt;code&gt;constexpr&lt;/code&gt;声明中如果定义了一个指针，限定符&lt;code&gt;constexpr&lt;/code&gt;仅对指针有效，与指针所指的对象无关。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;constexpr&lt;/code&gt;把它所定义的对象置为顶层&lt;code&gt;const&lt;/code&gt;。&lt;/p&gt;
&lt;h2&gt;处理类型&lt;/h2&gt;
&lt;h3&gt;类型别名&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;typedef double wages;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;using SI = Sales_item;&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;auto 类型说明符&lt;/h3&gt;
&lt;p&gt;让编译器自己去分析表达式所属的类型。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;auto&lt;/code&gt;也能在一条语句中声明多个变量。因为一条声明语句只能有一个基本数据类型，所以该语句中所有变量的基本数据类型都必须一样。&lt;/p&gt;
&lt;p&gt;当引用被用作初始化&lt;code&gt;auto&lt;/code&gt;变量时，编译器以引用所引用对象的类型作为&lt;code&gt;auto&lt;/code&gt;的类型。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;auto&lt;/code&gt;一般会忽略顶层&lt;code&gt;const&lt;/code&gt;，同时底层&lt;code&gt;const&lt;/code&gt;会保留下来。&lt;/p&gt;
&lt;p&gt;如果希望推断出的&lt;code&gt;auto&lt;/code&gt;类型是一个顶层&lt;code&gt;const&lt;/code&gt;，需要明确指出。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;auto&lt;/code&gt;引用&lt;code&gt;auto &amp;amp;b = a;&lt;/code&gt;初始值 a 的顶层&lt;code&gt;const&lt;/code&gt;会保留。&lt;/p&gt;
&lt;h3&gt;decltype 类型指示符&lt;/h3&gt;
&lt;p&gt;选择并返回操作数的数据类型，编译器分析表达式得到它的类型，却不实际计算表达式的值，编译器并不实际调用f。&lt;/p&gt;
&lt;p&gt;如果&lt;code&gt;decltype&lt;/code&gt;使用的表达式是一个变量，则&lt;code&gt;decltype&lt;/code&gt;返回该变量的类型（包括顶层&lt;code&gt;const&lt;/code&gt;和引用在内），需要指出的是，引用从来都作为其所指对象的同义词出现，只有在&lt;code&gt;decltype&lt;/code&gt;处是一个例外。&lt;/p&gt;
&lt;p&gt;如果&lt;code&gt;decltype&lt;/code&gt;使用的表达式不是一个变量，则&lt;code&gt;decltype&lt;/code&gt;返回该表达式的结果对应的类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因为 r 是一个引用，&lt;code&gt;decltype(r)&lt;/code&gt;的结果是引用类型，如果想让结果类型是 r 所指的类型，可以把 r 作为表达式的一部分，显然这个表达式的结果是一个具体的值而非一个引用&lt;/li&gt;
&lt;li&gt;如果表达式的内容是解引用操作，则&lt;code&gt;decltype&lt;/code&gt;将得到引用类型&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果&lt;code&gt;decltype&lt;/code&gt;使用的表达式是一个变量：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不加括号，得到该变量的类型&lt;/li&gt;
&lt;li&gt;加括号，得到引用类型&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;自定义数据结构：结构体和类&lt;/h2&gt;
&lt;p&gt;记得定义末尾的分号。可以类内初始化。&lt;/p&gt;
&lt;h2&gt;头文件保护符&lt;/h2&gt;
&lt;p&gt;头文件保护符依赖于预处理变量。&lt;/p&gt;
&lt;p&gt;预处理变量由两个状态：已定义和未定义。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;#define&lt;/code&gt;指令把一个名字设定为预处理变量。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;#ifdef&lt;/code&gt;当且仅当变量已定义时为真。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;#ifndef&lt;/code&gt;当且仅当变量未定义时为真。&lt;/p&gt;
&lt;p&gt;一旦检查结果为真，则执行后续操作直到遇到&lt;code&gt;#endif&lt;/code&gt;指令为止&lt;/p&gt;</content><category term="C++"></category></entry><entry><title>C++ Primer 第一章 开始</title><link href="https://xutree.github.io/pages/2018/10/05/C++_Primer_Chapter_1/" rel="alternate"></link><published>2018-10-05T23:11:35+08:00</published><updated>2018-10-07T10:48:26+08:00</updated><author><name>Shu</name></author><id>tag:xutree.github.io,2018-10-05:/pages/2018/10/05/C++_Primer_Chapter_1/</id><summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;code&gt;g++ -std=c++14  -Wall -o test test.cpp&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iostream&lt;/code&gt; &lt;code&gt;cin&lt;/code&gt; &lt;code&gt;cout&lt;/code&gt; &lt;code&gt;cerr&lt;/code&gt; &lt;code&gt;clog&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;运算符返回其左侧的运算对象&lt;/li&gt;
&lt;li&gt;写入&lt;code&gt;endl&lt;/code&gt;的效果是结束当前行，并将与设备关联的缓冲区中的内容刷到设备中。缓冲刷新操作可以保证到目前为止程序所产生的所有输出都真正写入到输出流中，而不是仅停留在内存中等待写入流&lt;/li&gt;
&lt;li&gt;小心程序崩溃，输出可能还留在缓冲区的情况，利用&lt;code&gt;endl&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;标准库定义的所有名字都在命名空间&lt;code&gt;std&lt;/code&gt;中&lt;/li&gt;
&lt;li&gt;当我们使用一个&lt;code&gt;istream&lt;/code&gt;对象作为条件时，其效果是检测流的状态。流有效，即流未遇到错误，那么检测成功。当遇到文件结束符（end of file），或遇到一个无效输入时，&lt;code&gt;istream&lt;/code&gt;对象的状态会变为无效。无效的&lt;code&gt;istream&lt;/code&gt;对象会使条件为假&lt;/li&gt;
&lt;li&gt;文件结束符：Windows 先Ctrl + Z，后Enter …&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;ul&gt;
&lt;li&gt;&lt;code&gt;g++ -std=c++14  -Wall -o test test.cpp&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iostream&lt;/code&gt; &lt;code&gt;cin&lt;/code&gt; &lt;code&gt;cout&lt;/code&gt; &lt;code&gt;cerr&lt;/code&gt; &lt;code&gt;clog&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;运算符返回其左侧的运算对象&lt;/li&gt;
&lt;li&gt;写入&lt;code&gt;endl&lt;/code&gt;的效果是结束当前行，并将与设备关联的缓冲区中的内容刷到设备中。缓冲刷新操作可以保证到目前为止程序所产生的所有输出都真正写入到输出流中，而不是仅停留在内存中等待写入流&lt;/li&gt;
&lt;li&gt;小心程序崩溃，输出可能还留在缓冲区的情况，利用&lt;code&gt;endl&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;标准库定义的所有名字都在命名空间&lt;code&gt;std&lt;/code&gt;中&lt;/li&gt;
&lt;li&gt;当我们使用一个&lt;code&gt;istream&lt;/code&gt;对象作为条件时，其效果是检测流的状态。流有效，即流未遇到错误，那么检测成功。当遇到文件结束符（end of file），或遇到一个无效输入时，&lt;code&gt;istream&lt;/code&gt;对象的状态会变为无效。无效的&lt;code&gt;istream&lt;/code&gt;对象会使条件为假&lt;/li&gt;
&lt;li&gt;文件结束符：Windows 先Ctrl + Z，后Enter 或 Return；UNIX：Ctrl +D&lt;/li&gt;
&lt;li&gt;标准库文件通常不带后缀。编译器一般不关心头文件名的形式，但有的IDE对此有特定要求&lt;/li&gt;
&lt;li&gt;头文件包含：标准库头文件 &amp;lt;&amp;gt;     非标准库头文件 ""&lt;/li&gt;
&lt;li&gt;文件重定向：从文件读入\&amp;lt;infile，输出到文件&gt;outfile&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cerr&lt;/code&gt;(无缓冲标准错误) 没有缓冲，发送给它的内容立即被输出&lt;/li&gt;
&lt;li&gt;&lt;code&gt;clog&lt;/code&gt;(缓冲标准错误)  有缓冲，缓冲区满时输出&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cout&lt;/code&gt;标准输出&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cout&lt;/code&gt;是在终端显示器输出，&lt;code&gt;cout&lt;/code&gt;流在内存中对应开辟了一个缓冲区，用来存放流中的数据，当向&lt;code&gt;cout&lt;/code&gt;流插入一个&lt;code&gt;endl&lt;/code&gt;，不论缓冲区是否满了，都立即输出流中所有数据，然后插入一个换行符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cerr&lt;/code&gt;流对象是标准错误流，指定为和显示器关联，和&lt;code&gt;cout&lt;/code&gt;作用差不多，有点不同就是&lt;code&gt;cout&lt;/code&gt;通常是传到显示器输出，但可以被重定向输出到文件，而&lt;code&gt;cerr&lt;/code&gt;流中的信息只能在显示器输出&lt;/li&gt;
&lt;li&gt;&lt;code&gt;clog&lt;/code&gt;流也是标准错误流，作用和&lt;code&gt;cerr&lt;/code&gt;一样，区别在于&lt;code&gt;cerr&lt;/code&gt;不经过缓冲区，直接向显示器输出信息，而&lt;code&gt;clog&lt;/code&gt;中的信息存放在缓冲区，缓冲区满或者遇到&lt;code&gt;endl&lt;/code&gt;时才输出&lt;/li&gt;
&lt;li&gt;对于为什么有&lt;code&gt;cerr&lt;/code&gt;和&lt;code&gt;clog&lt;/code&gt;？比如，你的程序遇到调用栈用完了的威胁（无限，没有出口的递归。你说，你到什么地方借内存，存放你的错误信息？所以有了&lt;code&gt;cerr&lt;/code&gt;。其目的，就是在你最需要它的紧急情况下，还能得到输出功能的支持&lt;/li&gt;
&lt;li&gt;缓冲区的目的，就是减少刷屏的次数——比如，你的程序输出圣经中的一篇文章。不带缓冲的话，就会每写一个字母，就输出一个字母，然后刷屏。有了缓冲，你将看到若干句子“同时”就出现在了屏幕上（由内存翻新到显存，然后刷新屏幕）&lt;/li&gt;
&lt;/ul&gt;</content><category term="C++"></category></entry></feed>