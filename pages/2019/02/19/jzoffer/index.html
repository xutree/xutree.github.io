<!DOCTYPE html>
<html lang="en-US">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="author" content="Shu" />
    <meta name="copyright" content="Shu" />

<meta name="keywords" content="剑指offer, 面试, 算法, 读书笔记, " />
    <title>剑指offer  · You Know Nothing
</title>
    <link rel="stylesheet" type="text/css" href="https://xutree.github.io/theme/css/slim-081711.css" media="screen">
    <link rel="stylesheet" type="text/css" href="https://xutree.github.io/theme/css/bootstrap-combined.min.css" media="screen">
    <link rel="stylesheet" type="text/css" href="https://xutree.github.io/theme/css/style.css" media="screen">
    <link rel="stylesheet" type="text/css" href="https://xutree.github.io/theme/css/solarizedlight.css" media="screen">
</head>

<body>
    <div id="content-sans-footer">
        <div class="navbar navbar-static-top">
            <div class="navbar-inner">
                <div class="container">
                    <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </a>
                    <a class="brand" href="https://xutree.github.io/"><span class=site-name>You Know Nothing</span></a>
                    <div class="nav-collapse collapse">
                        <ul class="nav pull-right top-menu">
                            <li ><a href="https://xutree.github.io/index.html">主页</a></li>
                            <li ><a href="https://xutree.github.io/categories.html">分类</a></li>
                            <li ><a href="https://xutree.github.io/tags.html">标签</a></li>
                            <li ><a href="https://xutree.github.io/archives.html">归档</a></li>
                            <li>
                                <form class="navbar-search" action="https://xutree.github.io/search.html" onsubmit="return validateForm(this.elements['q'].value);"> <input type="text" class="search-query" placeholder="关键字搜索" name="q" id="tipue_search_input"></form>
                            </li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
        <div class="container-fluid">
            <div class="row-fluid">
                <div class="span1"></div>
                <div class="span10">
<article>
    <div class="row-fluid">
        <header class="page_header span10 offset2">
            <h1><a href="https://xutree.github.io/pages/2019/02/19/jzoffer/"> 剑指offer  </a></h1>
        </header>
    </div>

    <div class="row-fluid">
        <!--  -->
        <div class="span2" style="float:left;font-size:1em;">
            <nav>
                <!-- <h4>目录</h4> -->
                <div class="toc">
<ul>
<li><a href="#1">1. 二维数组中的查找</a></li>
<li><a href="#2">2. 替换空格</a></li>
<li><a href="#3">3. 从尾到头打印链表</a></li>
<li><a href="#4">4. 重建二叉树</a></li>
<li><a href="#5">5. 用两个栈实现队列</a></li>
<li><a href="#6">6. 旋转数组的最小数字</a></li>
</ul>
</div>
            </nav>
        </div>
        <div class="span8 article-content">

                
<h2 id="1">1. 二维数组中的查找</h2>
<p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">Solution</span> <span class="p">{</span>
<span class="kr">public</span><span class="o">:</span>
    <span class="kt">bool</span> <span class="nx">Find</span><span class="p">(</span><span class="kr">int</span> <span class="nx">target</span><span class="p">,</span> <span class="nx">vector</span><span class="o">&lt;</span><span class="nx">vector</span><span class="o">&lt;</span><span class="kr">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="nx">array</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 注意 size 是成员函数，要加括号</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">array</span><span class="p">.</span><span class="nx">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="kc">false</span><span class="p">;</span> <span class="c1">// 为空，返回</span>
        <span class="kr">int</span> <span class="nx">row</span> <span class="o">=</span> <span class="nx">array</span><span class="p">.</span><span class="nx">size</span><span class="p">();</span>
        <span class="kr">int</span> <span class="nx">col</span> <span class="o">=</span> <span class="nx">array</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">size</span><span class="p">();</span>
        <span class="c1">// 从右上角开始查找</span>
        <span class="k">for</span> <span class="p">(</span><span class="kr">int</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">j</span> <span class="o">=</span> <span class="nx">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">m</span> <span class="o">&amp;&amp;</span> <span class="nx">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">array</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="o">==</span> <span class="nx">target</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">array</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nx">target</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">j</span><span class="o">--</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nx">i</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
<p><strong>思路</strong>：如我们从右上角的数据开始出发，比他小的数必定在它的左侧，就往左找；比他大的数必定在它的下侧，就往下找。</p>
<h2 id="2">2. 替换空格</h2>
<p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
<div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">Solution</span> <span class="p">{</span>
<span class="kr">public</span><span class="o">:</span>
    <span class="k">void</span> <span class="nx">replaceSpace</span><span class="p">(</span><span class="kr">char</span> <span class="o">*</span><span class="nx">str</span><span class="p">,</span><span class="kr">int</span> <span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 先统计总共有多少空格</span>
        <span class="kr">int</span> <span class="nx">count_space</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kr">int</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">str</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="s1">' '</span><span class="p">)</span> <span class="nx">count_space</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="kr">int</span> <span class="nx">new_length</span> <span class="o">=</span> <span class="nx">length</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">count_space</span><span class="p">;</span>
        <span class="c1">// 从后开始移位</span>
        <span class="k">for</span> <span class="p">(</span><span class="kr">int</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">j</span> <span class="o">=</span> <span class="nx">new_length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">j</span> <span class="o">&gt;=</span><span class="mi">0</span><span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">str</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="s1">' '</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">str</span><span class="p">[</span><span class="nx">j</span><span class="o">--</span><span class="p">]</span> <span class="o">=</span> <span class="s1">'0'</span><span class="p">;</span>
                <span class="nx">str</span><span class="p">[</span><span class="nx">j</span><span class="o">--</span><span class="p">]</span> <span class="o">=</span> <span class="s1">'2'</span><span class="p">;</span>
                <span class="nx">str</span><span class="p">[</span><span class="nx">j</span><span class="o">--</span><span class="p">]</span> <span class="o">=</span> <span class="s1">'%'</span><span class="p">;</span>
                <span class="nx">i</span><span class="o">--</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nx">str</span><span class="p">[</span><span class="nx">j</span><span class="o">--</span><span class="p">]</span> <span class="o">=</span> <span class="nx">str</span><span class="p">[</span><span class="nx">i</span><span class="o">--</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">// 字符串结束标志</span>
        <span class="nx">str</span><span class="p">[</span><span class="nx">new_length</span><span class="p">]</span> <span class="o">=</span> <span class="s1">'\0'</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
<p><strong>思路</strong>：从后往前移位可避免重复移位。</p>
<h2 id="3">3. 从尾到头打印链表</h2>
<p>输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。</p>
<div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm">*  struct ListNode {</span>
<span class="cm">*        int val;</span>
<span class="cm">*        struct ListNode *next;</span>
<span class="cm">*        ListNode(int x) :</span>
<span class="cm">*              val(x), next(NULL) {</span>
<span class="cm">*        }</span>
<span class="cm">*  };</span>
<span class="cm">*/</span>
<span class="kr">class</span> <span class="nx">Solution</span> <span class="p">{</span>
<span class="kr">public</span><span class="o">:</span>
    <span class="nx">vector</span><span class="o">&lt;</span><span class="kr">int</span><span class="o">&gt;</span> <span class="nx">printListFromTailToHead</span><span class="p">(</span><span class="nx">ListNode</span><span class="o">*</span> <span class="nx">head</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">ListNode</span><span class="o">*</span> <span class="nx">node</span> <span class="o">=</span> <span class="nx">head</span><span class="p">;</span>
        <span class="nx">stack</span><span class="o">&lt;</span><span class="kr">int</span><span class="o">&gt;</span> <span class="nx">st</span><span class="p">;</span>
        <span class="kr">int</span> <span class="nx">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="nx">node</span> <span class="o">!=</span> <span class="nx">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 用 -&gt;</span>
            <span class="nx">st</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">node</span><span class="o">-&gt;</span><span class="nx">val</span><span class="p">);</span>
            <span class="nx">count</span><span class="o">++</span><span class="p">;</span>
            <span class="nx">node</span> <span class="o">=</span> <span class="nx">node</span><span class="o">-&gt;</span><span class="nx">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// 为了效率我们静态 vector 开辟空间</span>
        <span class="nx">vector</span><span class="o">&lt;</span><span class="kr">int</span><span class="o">&gt;</span> <span class="nx">res</span><span class="p">(</span><span class="nx">count</span><span class="p">);</span>
        <span class="k">for</span><span class="p">(</span><span class="kr">int</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">count</span> <span class="o">&amp;&amp;</span> <span class="nx">st</span><span class="p">.</span><span class="nx">empty</span><span class="p">()</span> <span class="o">!=</span> <span class="kc">true</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// 如果静态开辟 vector 不能使用push_back</span>
            <span class="c1">// 否则会在原来数据的基础上增加</span>
            <span class="c1">// res.push_back(st.top());</span>
            <span class="c1">// 注意栈的三个主要函数</span>
            <span class="nx">res</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">st</span><span class="p">.</span><span class="nx">top</span><span class="p">();</span>
            <span class="nx">st</span><span class="p">.</span><span class="nx">pop</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">res</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
<p><strong>思路</strong>：首先我们想到的就是反转链表了,如果把链表反转了，然后再返回头，这样再次遍历的时候就相当于从尾到头打印了。但是在面试时候，如果我们打算修改输入的数据，最好先问问面试官是不是允许修改。通常打印只是一个只读操作，我们肯定不希望输入时候修改链表的内容。</p>
<p><strong>利用栈的后进先出特性</strong>：单链表的遍历只能从前往后，但是需要从尾往头输出，这不是典型的“先进后出”么，那么我们可以用栈模拟输出。每经过一个结点的时候，把该结点放到一个栈中。当遍历完整个链表后，再从栈顶开始逐个输出结点的值，此时输出的结点的顺序已经反转过来了。注意包含 <strong>stack</strong> 头文件。</p>
<p><strong>递归实现</strong></p>
<div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm">*  struct ListNode {</span>
<span class="cm">*        int val;</span>
<span class="cm">*        struct ListNode *next;</span>
<span class="cm">*        ListNode(int x) :</span>
<span class="cm">*              val(x), next(NULL) {</span>
<span class="cm">*        }</span>
<span class="cm">*  };</span>
<span class="cm">*/</span>
<span class="kr">class</span> <span class="nx">Solution</span> <span class="p">{</span>
<span class="kr">public</span><span class="o">:</span>
    <span class="nx">vector</span><span class="o">&lt;</span><span class="kr">int</span><span class="o">&gt;</span> <span class="nx">res</span><span class="p">;</span> <span class="c1">// 保存结果</span>
    <span class="nx">vector</span><span class="o">&lt;</span><span class="kr">int</span><span class="o">&gt;</span> <span class="nx">printListFromTailToHead</span><span class="p">(</span><span class="nx">ListNode</span><span class="o">*</span> <span class="nx">head</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">head</span> <span class="o">!=</span> <span class="nx">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">printListFromTailToHead</span><span class="p">(</span><span class="nx">head</span><span class="o">-&gt;</span><span class="nx">next</span><span class="p">);</span>
            <span class="nx">res</span><span class="p">.</span><span class="nx">push_back</span><span class="p">(</span><span class="nx">head</span><span class="o">-&gt;</span><span class="nx">val</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">res</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
<h2 id="4">4. 重建二叉树</h2>
<p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>
<div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * Definition for binary tree</span>
<span class="cm"> * struct TreeNode {</span>
<span class="cm"> *     int val;</span>
<span class="cm"> *     TreeNode *left;</span>
<span class="cm"> *     TreeNode *right;</span>
<span class="cm"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span>
<span class="cm"> * };</span>
<span class="cm"> */</span>
<span class="kr">class</span> <span class="nx">Solution</span> <span class="p">{</span>
<span class="kr">public</span><span class="o">:</span>
    <span class="nx">TreeNode</span><span class="o">*</span> <span class="nx">reConstructBinaryTree</span><span class="p">(</span><span class="nx">vector</span><span class="o">&lt;</span><span class="kr">int</span><span class="o">&gt;</span> <span class="nx">pre</span><span class="p">,</span><span class="nx">vector</span><span class="o">&lt;</span><span class="kr">int</span><span class="o">&gt;</span> <span class="nx">vin</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 遍历长度应该相同</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">pre</span><span class="p">.</span><span class="nx">size</span><span class="p">()</span> <span class="o">!=</span> <span class="nx">vin</span><span class="p">.</span><span class="nx">size</span><span class="p">())</span> <span class="k">return</span> <span class="nx">NULL</span><span class="p">;</span>
        <span class="c1">// 非空</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">pre</span><span class="p">.</span><span class="nx">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="nx">NULL</span><span class="p">;</span>
        <span class="kr">int</span> <span class="nx">length</span> <span class="o">=</span> <span class="nx">pre</span><span class="p">.</span><span class="nx">size</span><span class="p">();</span>
        <span class="c1">// 前序遍历的第一个节点是根节点</span>
        <span class="kr">int</span> <span class="nx">value</span> <span class="o">=</span> <span class="nx">pre</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="nx">TreeNode</span><span class="o">*</span> <span class="nx">root</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">TreeNode</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
        <span class="c1">// 在中序遍历中查找根的位置</span>
        <span class="kr">int</span> <span class="nx">rootIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="nx">rootIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">rootIndex</span> <span class="o">&lt;</span> <span class="nx">length</span><span class="p">;</span> <span class="nx">rootIndex</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="nx">vin</span><span class="p">[</span><span class="nx">rootIndex</span><span class="p">]</span> <span class="o">==</span> <span class="nx">value</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">rootIndex</span> <span class="o">&gt;=</span> <span class="nx">length</span><span class="p">)</span> <span class="k">return</span> <span class="nx">NULL</span><span class="p">;</span>
        <span class="c1">// 区分左子树和右子树</span>
        <span class="c1">// 中序遍历中，根左边的就是左子数，右边的就是右子树</span>
        <span class="c1">// 前序遍历中，根后面是先遍历左子树，然后是右子树</span>
        <span class="c1">// 首先确定左右子树的长度，从中序遍历 vin 中确定</span>
        <span class="kr">int</span> <span class="nx">leftLength</span> <span class="o">=</span> <span class="nx">rootIndex</span><span class="p">;</span>
        <span class="kr">int</span> <span class="nx">rightLength</span> <span class="o">=</span> <span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="nx">rootIndex</span><span class="p">;</span>
        <span class="nx">vector</span><span class="o">&lt;</span><span class="kr">int</span><span class="o">&gt;</span> <span class="nx">preLeft</span><span class="p">(</span><span class="nx">leftLength</span><span class="p">),</span> <span class="nx">vinLeft</span><span class="p">(</span><span class="nx">leftLength</span><span class="p">);</span>
        <span class="nx">vector</span><span class="o">&lt;</span><span class="kr">int</span><span class="o">&gt;</span> <span class="nx">preRight</span><span class="p">(</span><span class="nx">rightLength</span><span class="p">),</span> <span class="nx">vinRight</span><span class="p">(</span><span class="nx">rightLength</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="kr">int</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">rootIndex</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">preLeft</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">pre</span><span class="p">[</span><span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
                <span class="nx">vinLeft</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">vin</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">i</span> <span class="o">&gt;</span> <span class="nx">rootIndex</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">preRight</span><span class="p">[</span><span class="nx">i</span> <span class="o">-</span> <span class="nx">rootIndex</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">pre</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
                <span class="nx">vinRight</span><span class="p">[</span><span class="nx">i</span> <span class="o">-</span> <span class="nx">rootIndex</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">vin</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="nx">root</span><span class="o">-&gt;</span><span class="nx">left</span> <span class="o">=</span> <span class="nx">reConstructBinaryTree</span><span class="p">(</span><span class="nx">preLeft</span><span class="p">,</span> <span class="nx">vinLeft</span><span class="p">);</span>
        <span class="nx">root</span><span class="o">-&gt;</span><span class="nx">right</span> <span class="o">=</span> <span class="nx">reConstructBinaryTree</span><span class="p">(</span><span class="nx">preRight</span><span class="p">,</span> <span class="nx">vinRight</span><span class="p">);</span>

        <span class="k">return</span> <span class="nx">root</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
<h2 id="5">5. 用两个栈实现队列</h2>
<p>用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。 队列中的元素为 int 类型。</p>
<div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">Solution</span>
<span class="p">{</span>
<span class="kr">public</span><span class="o">:</span>
    <span class="k">void</span> <span class="nx">push</span><span class="p">(</span><span class="kr">int</span> <span class="nx">node</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">stack1</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">node</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kr">int</span> <span class="nx">pop() {</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">stack2</span><span class="p">.</span><span class="nx">empty</span><span class="p">())</span> <span class="p">{</span>
            <span class="c1">// 空队列，返回 -1</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">stack1</span><span class="p">.</span><span class="nx">empty</span><span class="p">())</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="nx">stack1</span><span class="p">.</span><span class="nx">empty</span><span class="p">())</span> <span class="p">{</span>
                <span class="kr">int</span> <span class="nx">temp</span> <span class="o">=</span> <span class="nx">stack1</span><span class="p">.</span><span class="nx">top</span><span class="p">();</span>
                <span class="nx">stack2</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">temp</span><span class="p">);</span>
                <span class="nx">stack1</span><span class="p">.</span><span class="nx">pop</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="kr">int</span> <span class="nx">res</span> <span class="o">=</span> <span class="nx">stack2</span><span class="p">.</span><span class="nx">top</span><span class="p">();</span>
        <span class="nx">stack2</span><span class="p">.</span><span class="nx">pop</span><span class="p">();</span>
        <span class="k">return</span> <span class="nx">res</span><span class="p">;</span>
    <span class="p">}</span>

<span class="kr">private</span><span class="o">:</span>
    <span class="nx">stack</span><span class="o">&lt;</span><span class="kr">int</span><span class="o">&gt;</span> <span class="nx">stack1</span><span class="p">;</span>
    <span class="nx">stack</span><span class="o">&lt;</span><span class="kr">int</span><span class="o">&gt;</span> <span class="nx">stack2</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
<p><strong>思路</strong>：始终维护 s1 作为输入栈，以 s2 作为输出栈：</p>
<ul>
<li>入队时，将元素压入 s1</li>
<li>出队时，判断 s2 是否为空，如不为空，则直接弹出顶元素；如为空，则将 s1 的元素逐个“倒入” s2，把最后一个元素弹出并出队。这个思路，避免了反复“倒”栈，仅在需要时才“倒”一次。</li>
</ul>
<h2 id="6">6. 旋转数组的最小数字</h2>
<p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>
<div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">Solution</span> <span class="p">{</span>
<span class="kr">public</span><span class="o">:</span>
    <span class="kr">int</span> <span class="nx">minNumberInRotateArray</span><span class="p">(</span><span class="nx">vector</span><span class="o">&lt;</span><span class="kr">int</span><span class="o">&gt;</span> <span class="nx">rotateArray</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">rotateArray</span><span class="p">.</span><span class="nx">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="c1">//  如果把排序数组前面 0 个元素搬到后面，也就是说其实没有旋转，</span>
        <span class="c1">//  那么第 0 个元素就是最小的元素</span>
        <span class="c1">//  因此我们将 mid 初始化为 0</span>
        <span class="kr">int</span> <span class="nx">mid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kr">int</span> <span class="nx">low</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">high</span> <span class="o">=</span> <span class="nx">rotateArray</span><span class="p">.</span><span class="nx">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="nx">rotateArray</span><span class="p">[</span><span class="nx">low</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="nx">rotateArray</span><span class="p">[</span><span class="nx">high</span><span class="p">])</span> <span class="p">{</span>
            <span class="c1">//  如果前一个元素与后一个元素差一位</span>
            <span class="c1">//  说明找到了最大最小的元素</span>
            <span class="k">if</span><span class="p">(</span><span class="nx">high</span> <span class="o">-</span> <span class="nx">low</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">mid</span> <span class="o">=</span> <span class="nx">high</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="nx">mid</span> <span class="o">=</span> <span class="p">(</span><span class="nx">low</span> <span class="o">+</span> <span class="nx">high</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
            <span class="c1">// rotateArray[low] rotateArray[mid] rotateArray[high]三者相等</span>
            <span class="c1">// 无法确定中间元素是属于前面还是后面的递增子数组</span>
            <span class="c1">// 只能顺序查找</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">rotateArray</span><span class="p">[</span><span class="nx">low</span><span class="p">]</span> <span class="o">==</span> <span class="nx">rotateArray</span><span class="p">[</span><span class="nx">mid</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="nx">rotateArray</span><span class="p">[</span><span class="nx">mid</span><span class="p">]</span> <span class="o">==</span> <span class="nx">rotateArray</span><span class="p">[</span><span class="nx">high</span><span class="p">])</span> <span class="p">{</span>
               <span class="k">return</span> <span class="nx">MinOrder</span><span class="p">(</span><span class="nx">rotateArray</span><span class="p">,</span> <span class="nx">low</span><span class="p">,</span> <span class="nx">high</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="c1">//  如果该中间元素位于前面的递增子数组，那么它应该大于或者等于第一个指针指向的元素</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">rotateArray</span><span class="p">[</span><span class="nx">mid</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="nx">rotateArray</span><span class="p">[</span><span class="nx">low</span><span class="p">])</span> <span class="p">{</span>
                <span class="nx">low</span> <span class="o">=</span> <span class="nx">mid</span><span class="p">;</span>          <span class="c1">//  此时最小的元素位于中间元素的后面</span>
            <span class="p">}</span>
            <span class="c1">// 如果中间元素位于后面的递增子数组，那么它应该小于或者等于第二个指针指 向的元素</span>
            <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">rotateArray</span><span class="p">[</span><span class="nx">mid</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="nx">rotateArray</span><span class="p">[</span><span class="nx">high</span><span class="p">])</span> <span class="p">{</span>
                <span class="nx">high</span> <span class="o">=</span> <span class="nx">mid</span><span class="p">;</span>         <span class="c1">//  此时最小的元素位于中间元素的前面</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">rotateArray</span><span class="p">[</span><span class="nx">mid</span><span class="p">];</span>
    <span class="p">}</span>

<span class="kr">private</span><span class="o">:</span>
    <span class="c1">// 顺序寻找最小值</span>
    <span class="kr">int</span> <span class="nx">MinOrder</span><span class="p">(</span><span class="nx">vector</span><span class="o">&lt;</span><span class="kr">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="nx">num</span><span class="p">,</span> <span class="kr">int</span> <span class="nx">low</span><span class="p">,</span> <span class="kr">int</span> <span class="nx">high</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kr">int</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">num</span><span class="p">[</span><span class="nx">low</span><span class="p">];</span>
        <span class="k">for</span> <span class="p">(</span><span class="kr">int</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">low</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">high</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="nx">num</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">result</span><span class="p">)</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">num</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
<p><strong>思路</strong>：和二分查找法一样，用两个指针分别指向数组的第一个元素和最后一个元素。我们注意到旋转之后的数组实际上可以划分为两个排序的子数组，而且前面的子数组的元素都大于或者等于后面子数组的元素。我们还可以注意到最小的元素刚好是这两个子数组的分界线。</p>
<p>我们试着用二元查找法的思路在寻找这个最小的元素。</p>
<p>首先我们用两个指针，分别指向数组的第一个元素和最后一个元素。按照题目旋转的规则，第一个元素应该是大于或者等于最后一个元素的（这其实不完全对，还有特例。后面再讨论特例）。</p>
<p>接着我们得到处在数组中间的元素。</p>
<p>如果该中间元素位于前面的递增子数组，那么它应该大于或者等于第一个指针指向的元素。
此时数组中最小的元素应该位于该中间 元素的后面。我们可以把第一指针指向该中间元素，这样可以缩小寻找的范围。</p>
<p>同样，如果中间元素位于后面的递增子数组，那么它应该小于或者等于第二个指针指 向的元素。此时该数组中最小的元素应该位于该中间元素的前面。我们可以把第二个指针指向该中间元素，这样同样可以缩小寻找的范围。我们接着再用更新之后的 两个指针，去得到和比较新的中间元素，循环下去。</p>
<p>按照上述的思路，我们的第一个指针总是指向前面递增数组的元素，而第二个指针总是指向后面递增数组的元素。最后第一个指针将指向前面子数组的最后一个元素， 而第二个指针会指向后面子数组的第一个元素。也就是它们最终会指向两个相邻的元素，而第二个指针指向的刚好是最小的元素。这就是循环结束的条件。</p>
<p>我们考虑下特殊情况，我们的循环判断是以 <code>rotateArray[low] &gt;= rotateArray[high]</code> 为条件的，不满足这个的特殊情况有那些呢？</p>
<p>由于是把递增排序数组前面的若干个数据搬到后面去，因此第一个数字总是大于或者等于最后一个数字，但按照定义还有一个</p>
<p>特例：开始时就 <code>rotateArray[low] &lt; rotateArray[high]</code>，那么循环不会执行.如果数组旋转后仍然有序，即 <code>rotateArray[low] &lt; rotateArray[high]</code> 如果把排序数组前面 0 个元素搬到后面，也就是说其实没有旋转。那么第 0 个元素就是最小的元素，因此我们将 mid 初始化为 0。</p>
<p>如果 <code>rotateArray[low] = rotateArray[high]</code></p>
<p>测试用例: [2, 3, 4, 2, 2, 2, 2]，此时 <code>rotateArray[low] rotateArray[mid] rotateArray[high]</code> 三者相等，无法确定中间元素是属于前面还是后面的递增子数组，只能顺序查找。</p>
                <aside>
                    <hr />
                    <nav class="related">
                        <h1>
                            <font color="#771515"><em>RELATED</em></font>
                        </h1>
                        <ul>
                            <li>
                                <a href="https://xutree.github.io/pages/2018/10/27/find_maximum_subarray/">最大子数组问题</a>
                            </li>
                            <li>
                                <a href="https://xutree.github.io/pages/2018/10/26/sort/">排序算法</a>
                            </li>
                        </ul>
                    </nav>
                    <nav class="older">
                        <h1>
                            <font color="#771515"><em>OLDER</em></font>
                        </h1>
                        <ul>
                            <li>
                                <a href="https://xutree.github.io/pages/2019/01/22/Torch_libpng/">
                                    为 Torch 安装特定版本的 libpng
                                </a>
                            </li>
                            <li>
                                <a href="https://xutree.github.io/pages/2018/12/07/dl-5/">
                                    深度学习 第五章 机器学习基础
                                </a>
                            </li>
                            <li>
                                <a href="https://xutree.github.io/pages/2018/11/24/dl-4/">
                                    深度学习 第四章 数值计算
                                </a>
                            </li>
                            <li>
                                <a href="https://xutree.github.io/pages/2018/11/21/dl-3/">
                                    深度学习 第三章 概率与信息论
                                </a>
                            </li>
                            <li>
                                <a href="https://xutree.github.io/pages/2018/11/21/dl-2/">
                                    深度学习 第二章 线性代数
                                </a>
                            </li>
                        </ul>
                    </nav>
                    <nav class="newer">
                        <h1>
                            <font color="#771515"><em>NEWER</em></font>
                        </h1>
                        <ul>
                            <li>
                                <a href="https://xutree.github.io/pages/2019/02/20/树/">
                                    数据结构——树
                                </a>
                            </li>
                        </ul>
                    </nav>
                    <!-- Gitalk 评论 start  -->

                    <!-- Link Gitalk 的支持文件  -->
                    <!-- <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
                    <script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script>
                    <div id="gitalk-container"></div>
                    <script type="text/javascript">
                        var dateTime = Date.now();
                        var timestamp = Math.floor(dateTime / 1000);
                        var gitalk = new Gitalk({

                            // gitalk的主要参数
                            clientID: '93f43349e9fd3154bfad',
                            clientSecret: 'd6d09d1d7261f6b62f46b39e5fcace85b81c3cd7',
                            repo: 'xutree.github.io',
                            owner: 'xutree',
                            admin: ['xutree'],
                            id: String(timestamp)

                        });
                        gitalk.render('gitalk-container');
                    </script> -->
                    <!-- Gitalk end -->
                </aside>
            </div>
            <section>
                <div class="span2" style="float:right;font-size:0.9em;">
                    <h4>发布日期</h4>
                    <time pubdate="pubdate" datetime="2019-02-19T15:32:21+08:00">2019-02-19 15:32:21</time>
                    <h4>最后更新</h4>
                    <div class="last_updated">2019-02-20 17:14:54</div>
                    <h4>分类</h4>
                    <a class="category-link" href="/categories.html#读书笔记-ref">读书笔记</a>
                    <h4>标签</h4>
                    <ul class="list-of-tags tags-in-article">
                        <li><a href="/tags.html#剑指offer-ref">剑指offer
                                <span>1</span>
</a></li>
                        <li><a href="/tags.html#面试-ref">面试
                                <span>1</span>
</a></li>
                        <li><a href="/tags.html#算法-ref">算法
                                <span>3</span>
</a></li>
                    </ul>

                </div>
            </section>
        </div>
</article>
                </div>
                <div class="span1"></div>
            </div>
        </div>
    </div>
<footer>
<div id="footer">
    <ul class="footer-content">
        <li class="elegant-power">Powered by <a href="http://getpelican.com/" title="Pelican Home Page">Pelican</a>. Theme: <a href="http://oncrashreboot.com/pelican-elegant" title="Theme Elegant Home Page">Elegant</a> by <a href="http://oncrashreboot.com" title="Talha Mansoor Home Page">Talha Mansoor</a></li>
    </ul>
</div>
</footer>    <script src="https://code.jquery.com/jquery.min.js"></script>
    <script src="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.1/js/bootstrap.min.js"></script>
    <script>
        function validateForm(query) {
            return (query.length > 0);
        }
    </script>
</body>

</html>