<!DOCTYPE html>
<html lang="en-US">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="author" content="Shu" />
    <meta name="copyright" content="Shu" />

<meta name="keywords" content="Java, Java, " />
    <title>Head first Java 笔记  · You Know Nothing
</title>
    <link rel="stylesheet" type="text/css" href="https://xutree.github.io/theme/css/slim-081711.css" media="screen">
    <link rel="stylesheet" type="text/css" href="https://xutree.github.io/theme/css/bootstrap-combined.min.css" media="screen">
    <link rel="stylesheet" type="text/css" href="https://xutree.github.io/theme/css/style.css" media="screen">
    <link rel="stylesheet" type="text/css" href="https://xutree.github.io/theme/css/solarizedlight.css" media="screen">
</head>

<body>
    <div id="content-sans-footer">
        <div class="navbar navbar-static-top">
            <div class="navbar-inner">
                <div class="container">
                    <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </a>
                    <a class="brand" href="https://xutree.github.io/"><span class=site-name>You Know Nothing</span></a>
                    <div class="nav-collapse collapse">
                        <ul class="nav pull-right top-menu">
                            <li ><a href="https://xutree.github.io/index.html">主页</a></li>
                            <li ><a href="https://xutree.github.io/categories.html">分类</a></li>
                            <li ><a href="https://xutree.github.io/tags.html">标签</a></li>
                            <li ><a href="https://xutree.github.io/archives.html">归档</a></li>
                            <li>
                                <form class="navbar-search" action="https://xutree.github.io/search.html" onsubmit="return validateForm(this.elements['q'].value);"> <input type="text" class="search-query" placeholder="关键字搜索" name="q" id="tipue_search_input"></form>
                            </li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
        <div class="container-fluid">
            <div class="row-fluid">
                <div class="span1"></div>
                <div class="span10">
<article>
    <div class="row-fluid">
        <header class="page_header span10 offset2">
            <h1><a href="https://xutree.github.io/pages/2019/09/16/headfirstjava/"> Head first Java 笔记  </a></h1>
        </header>
    </div>

    <div class="row-fluid">
        <!--  -->
        <div class="span2" style="float:left;font-size:1em;">
            <nav>
                <!-- <h4>目录</h4> -->
                <div class="toc">
<ul>
<li><a href="#1">1. 基本概念</a></li>
<li><a href="#2">2. 类与对象</a></li>
<li><a href="#3-primitive">3. primitive 主数据类型和引用</a></li>
<li><a href="#4">4. 方法操作实例变量</a></li>
<li><a href="#5">5. 超强力方法</a></li>
<li><a href="#6-java-api">6. 认识 Java 的 API</a></li>
<li><a href="#7">7. 继承与多态</a></li>
<li><a href="#8">8. 接口和抽象类</a></li>
<li><a href="#9">9. 构造器与垃圾收集器</a></li>
<li><a href="#10">10. 数字与静态</a></li>
<li><a href="#11">11. 异常处理</a></li>
<li><a href="#12">12. 图形用户接口</a></li>
<li><a href="#13-swing">13. swing</a></li>
<li><a href="#14">14. 序列化和文件的输入输出</a></li>
<li><a href="#15">15. 网络联机</a></li>
<li><a href="#16">16. 集合与泛型</a></li>
<li><a href="#17-jar">17. 包、jar 存档文件和部署</a></li>
<li><a href="#18-rmi">18. 远程部署的 RMI</a></li>
<li><a href="#19">19. 其他</a></li>
</ul>
</div>
            </nav>
        </div>
        <div class="span8 article-content">

                
<h3 id="1">1. 基本概念</h3>
<ul>
<li><code>Java</code> 源代码编译成字节码，在不同平台上通过 <code>JVM</code> 执行字节码</li>
<li><code>System.out.print</code> 输出在同一行，<code>System.out.println</code> 输出会换行</li>
</ul>
<h3 id="2">2. 类与对象</h3>
<ul>
<li>任何变量只要加上 <code>public</code>、<code>static</code> 和 <code>final</code>，基本上都会变成全局取用的常数</li>
<li>可以把文件打包成 <strong>.jar</strong>，在其中加入 <strong>manifest</strong> 文件告知哪个文件中带有 <code>main()</code> 函数</li>
<li>所有的 <code>Java</code> 程序都定义在类中</li>
<li>面向对象设计不需要改动之前已经测试好的程序代码</li>
<li>类是蓝图描述对象如何创建</li>
<li>对象本身已知道的事务称为<strong>实例变量</strong>，他代表对象的<strong>状态</strong></li>
<li>对象可执行的动作称为方法，他代表类的<strong>行为</strong></li>
<li><code>Java</code> 的程序在执行期是一组会相互交谈的对象</li>
</ul>
<h3 id="3-primitive">3. <code>primitive</code> 主数据类型和引用</h3>
<ul>
<li>对于任意一个 <code>Java</code> 虚拟机来说，所有的引用大小都一样，但不同的虚拟机之间可能会以不同的方式表示引用</li>
<li>数组是对象</li>
<li><code>primitive</code> 主数据类型的值是该值的字节表示</li>
<li>引用变量的额值代表位于堆之对象的存取方法</li>
</ul>
<h3 id="4">4. 方法操作实例变量</h3>
<ul>
<li>类所描述的是对象知道什么与执行什么</li>
<li><code>Java</code> 是值传递，应用对象的值类似于对象的地址</li>
<li>将实例变量标记为私有的，并提供公有的 <code>getter</code> 和 <code>setter</code> 来控制存取动作</li>
<li>实例变量永远有默认值，局部变量没有默认值</li>
<li>实例变量声明在类内而不是方法中</li>
<li>局部变量声明在方法中</li>
<li>使用 <strong>==</strong> 来比较两个 <code>primitive</code> 主数据类型，或者判断两个引用是否引用同一个对象</li>
<li>使用 <code>equals()</code> 来判断两个对象是否在意义上相等</li>
</ul>
<h3 id="5">5. 超强力方法</h3>
<ul>
<li><code>Java</code> 程序应该从高层的设计开始</li>
<li>伪码、测试码、真实码</li>
<li>伪码描述要做什么事情而不是如何做</li>
<li>实现之前应该先编写测试码</li>
<li>使用 <code>Interger.parseInt()</code> 来取得 <code>String</code> 的整数值</li>
</ul>
<h3 id="6-java-api">6. 认识 <code>Java</code> 的 <code>API</code></h3>
<ul>
<li><code>ArrayList</code> 方法<ul>
<li><code>add(Object elem)</code></li>
<li><code>remove(int index)</code></li>
<li><code>remove(Object elem)</code></li>
<li><code>contains(Object elem)</code></li>
<li><code>isEmpty()</code></li>
<li><code>indexOf(Object elem)</code></li>
<li><code>size()</code></li>
<li><code>get(int index)</code></li>
</ul>
</li>
<li><code>ArrayList</code> 自动调整大小</li>
<li>一般数组在创建时就必须确定大小</li>
<li>存放对象给一般数组时必须指定位置，<code>ArrayList</code> 直接 <code>add</code></li>
<li>一般数组使用特殊的语法 <code>[]</code></li>
<li><code>ArrayList</code> 类似于 <code>C++</code> 中的模板类</li>
<li>在 <code>Java</code> 中，类被包装在包中</li>
<li>数组用 <code>length</code> 这个变量取得大小</li>
<li>类有完整的名称，都是由包的名称与类的名称所组成的。<code>ArrayList</code> 实际上叫做 <code>java.util.ArrayList</code></li>
</ul>
<h3 id="7">7. 继承与多态</h3>
<ul>
<li>is-a：是一个对象</li>
<li>has-a：是一个实例变量</li>
<li>继承概念下的 is-a 是个单向的关系</li>
<li>在子类可以不用完全覆盖掉父类的功能，只是再加上额外的行为，可以用 <code>super</code> 关键字取用父类，且必须是第一条语句</li>
<li><code>public</code> 类型的成员（实例变量和方法）会被继承</li>
<li><code>private</code> 类型的成员（实例变量和方法）不会被继承</li>
<li>子类是父类 <code>extends</code> 来的</li>
<li>继承下来的方法可以被覆盖掉，但实例变量不能被覆盖掉</li>
<li>继承避免了重复的程序代码，定义出共同的协议</li>
<li>运用多态时，引用类型可以是实际对象类型的父类</li>
<li>参数和返回类型也可以多态</li>
<li>非公有的类只能被同一个包的类继承</li>
<li>使用 <code>final</code> 修饰的类不能被继承</li>
<li>拥有 <code>private</code> 构造函数的类不能被继承</li>
<li>覆盖的规则：参数必须要一样，返回类型必须要兼容；不能减低方法的存取权限</li>
</ul>
<h3 id="8">8. 接口和抽象类</h3>
<ul>
<li><code>abstract class Myclass extends Object {}</code></li>
<li><code>public abstract void eat();</code></li>
<li>含有抽象方法的类一定是抽象类</li>
<li>抽象的类可以带有抽象的和非抽象的方法</li>
<li>抽象方法没有内容，他的声明以分号结束，只是为了标记多态而存在，在继承树结构下的第一个具体类必须要实现所有的抽象方法</li>
<li><code>Java</code> 所有类都是从 <code>Object</code> 类继承而来<ul>
<li><code>equals(Object c)</code></li>
<li><code>getClass()</code></li>
<li><code>hashCode()</code></li>
<li><code>toString()</code></li>
</ul>
</li>
<li>任何从 <code>ArrayList&lt;Object&gt;</code> 取出的东西都会被当做 <code>Object</code> 类型的引用而不管他原来是什么</li>
<li>不管实际上所引用的对象是什么类型，只有在引用变量的类型就是带有某方法的类型时才能调用该方法</li>
<li><code>Father father = new Son()</code> 是<strong>父类引用指向子类对象</strong>而不是父类对象指向子类引用</li>
<li><strong>子类的引用不能指向父类的对象</strong></li>
<li><strong>当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，再去调用子类的同名方法</strong></li>
<li>多态：继承、重写、父类引用指向子类对象</li>
<li><code>a instanceOf b</code> 判断 a 是不是 b 的对象</li>
<li>多重继承，致命方块 ---&gt; 接口</li>
<li>接口的定义 <code>public interface Pet {...}</code></li>
<li>接口的实现 <code>public class Dog extends Canine implements Pet {...}</code></li>
<li>接口的方法默认是 <code>public</code> 和 <code>abstract</code> 的</li>
<li>不同继承树的类也可以实现相同的接口</li>
<li><strong>如果想要定义出类扮演的角色，使用接口</strong></li>
<li><code>Java</code> 不允许多重继承</li>
<li>接口就好像 100\% 纯天然抽象类</li>
<li><code>class</code> 可以实现多个接口</li>
<li>实现接口的类必须实现他的所有方法</li>
</ul>
<h3 id="9">9. 构造器与垃圾收集器</h3>
<ul>
<li>对象的生存空间是堆（heap），方法调用及变量的生存空间是栈（stack）</li>
<li>非 <code>primitive</code> 的变量只是保存了对象的引用而已，如果局部变量是对象的引用，只有变量本身会放在栈上，对象在堆上</li>
<li>实例变量存在于对象所属的堆空间上</li>
<li>如果实例变量全是主数据类型，<code>Java</code> 会依据主数据类型的大小为该实例变量留下空间</li>
<li>如果实例变量是个对象，<code>Java</code> 会给变量的值留下空间，至于所指的对象是否在堆上，要看此实例变量有没有被赋值</li>
<li>唯一能够调用构造函数的方法就是新建一个类</li>
<li>构造函数没有返回值</li>
<li><code>Java</code> 可以有与类同名的函数而不会变成构造函数，只要其有返回值即可</li>
<li>最好要有不带参数的构造函数，让人可以选择使用默认值</li>
<li>编译器只会在你完全没有设定构造函数时才会调用</li>
<li>可以使用 <code>this</code> 从某个构造函数调用同一个类的另一个构造函数，<code>this()</code> 只能用在构造函数中，且必须是第一条语句，<code>super()</code> 和 <code>this</code> 不可兼得</li>
</ul>
<h3 id="10">10. 数字与静态</h3>
<ul>
<li>在 <code>Math</code> 这个类中所有的方法都不需要实例变量值，因为这些方法都是静态的，所以你无须实例，你会用到的只有他的类本身</li>
<li><code>Math</code> 的构造函数是私有的，你不能创建他的实例</li>
<li>如果类只有静态的方法，你可以将构造函数标记为 <code>private</code> 以避免被初始化</li>
<li>静态方法是属于类本身的</li>
<li><code>static</code> 关键字</li>
<li>静态的方法不能调用非静态的变量和非静态的方法</li>
<li>虽然可以用类的实例调用静态方法，但是尽量避免</li>
<li>静态变量被所有的实例共享</li>
<li>静态变量会在该类的任何静态方法执行之前就初始化</li>
<li>静态变量的默认值等于该变量类型的默认值</li>
<li>静态的 <code>final</code> 变量是常数</li>
<li>常数变量的名称应该都大写</li>
<li>静态初始化程序是一段在加载类时会执行的程序代码，它会在其他程序可以使用该类之前就执行，所以很适合放静态 <code>final</code> 变量的初始程序</li>
<li>静态 <code>final</code> 变量的初始化：声明的时候、在静态初始化程序中</li>
<li><code>Math</code> 的方法<ul>
<li><code>Math.random()</code>：0.0~1.0 之间的双精度浮点数</li>
<li><code>Math.abs()</code>：有重载的版本，传入整数会返回整数，双精度会返回双精度</li>
<li><code>Math.round()</code>：有重载的版本，根据传入是浮点还是双精度，四舍五入返回整型或长整型</li>
<li><code>Math.min()</code>：有 <code>int</code>、<code>long</code>、<code>float</code> 和 <code>double</code> 重载的版本</li>
<li><code>Math.max()</code>：有 <code>int</code>、<code>long</code>、<code>float</code> 和 <code>double</code> 重载的版本</li>
</ul>
</li>
<li>包装类<ul>
<li><code>Boolean</code></li>
<li><code>Character</code></li>
<li><code>Byte</code></li>
<li><code>Short</code></li>
<li><code>Integer</code></li>
<li><code>Long</code></li>
<li><code>Float</code></li>
<li><code>Double</code></li>
</ul>
</li>
<li>
<ul>
<li>是 <code>Java</code> 唯一重载过得运算符，<code>String str = "" + 12;</code></li>
</ul>
</li>
<li>数字格式化 <code>String.format()</code></li>
<li><code>%[参数][标记][宽度][.精度]type</code>，标记比如数字逗号分隔或正负号，参数是指哪一个</li>
<li>完整的日期和时间 <code>String.format("%tc", new Date());</code></li>
<li>只有时间 <code>String.format("%tr", new Date());</code></li>
<li>周，月，日 <code>String.format("%tA, %&lt;tB, %&lt;td", new Date());</code></li>
<li>用 <code>java.util.Calendar</code> 操作日期，是抽象类</li>
<li><code>Calendar cal = Calendar.getInstance();</code> 一般会返回一个 <code>java.util.GregorianCalendar</code> 实例</li>
<li>可以静态导入，类似于 C++ 的命名空间</li>
</ul>
<h3 id="11">11. 异常处理</h3>
<ul>
<li>异常是一种 <code>Exception</code> 类型的对象</li>
<li>除了 <code>RuntimeExceptions</code> 之外，编译器保证：如果你有抛出异常，一定要使用 <code>throw</code> 来声明这件事；如果你调用会抛出异常的方法，你必须的确认你知道异常的可能性（try catch 或者继续抛出）</li>
<li><code>finally</code> 块是用来存放不管有没有异常都得执行的程序，即使前面有 <code>return</code> 也要执行</li>
<li>有多个 <code>catch</code> 块时要从小到大排列</li>
</ul>
<h3 id="12">12. 图形用户接口</h3>
<ul>
<li>GUI 从创建窗口开始 <code>JFrame frame = new JFrame();</code></li>
<li>加入组件 <code>frame.getContenPane().add(button);</code></li>
<li><code>JFrame</code> 与其他组件不同，不能直接加上组件，要用他的 content pane</li>
<li>显示窗口 <code>frame.setSize(300, 300); frame.setVisible(true);</code></li>
<li>监听 GUI 事件才知道用户对接口做了什么事情</li>
<li>你必须要对事件源注册所要监听的时间。事件源是一种会根据用户操作而触发的机制</li>
<li>事件注册 add<eventtype>Listener <code>button.addActionListener(this);</code></eventtype></li>
<li>内部类可以使用外部所有的方法与变量</li>
<li>内部类的实例一定会绑定外部类的实例上</li>
<li>你也可以从外部类以外的程序代码来初始化内部实例</li>
</ul>
<div class="highlight"><pre><span></span>    <span class="k">class</span> <span class="n">Foo</span> {
        <span class="n">public</span> <span class="n">static</span> <span class="nb">void</span> <span class="n">main</span> (<span class="n">String</span>[] <span class="n">args</span>) {
            <span class="n">MyOuter</span> <span class="n">outerObj</span> = <span class="nb">new</span> <span class="n">MyOuter</span>();
            <span class="n">MyOuter</span>.<span class="n">MyInner</span> <span class="n">innerObj</span> = <span class="n">outerObj</span>.<span class="nb">new</span> <span class="n">MyInner</span>();
        }
    }
</pre></div>
<ul>
<li>内部类提供了在一个类中实现同一接口的多次机会</li>
</ul>
<h3 id="13-swing">13. swing</h3>
<ul>
<li>布局管理器：<ul>
<li><code>Borderlayout</code> 五个区域，框架默认</li>
<li><code>Flowlayout</code> 书写顺序，面板默认</li>
<li><code>Boxlayout</code> 垂直排列</li>
</ul>
</li>
</ul>
<h3 id="14">14. 序列化和文件的输入输出</h3>
<ul>
<li>将序列化对象写入文件</li>
</ul>
<div class="highlight"><pre><span></span>    FileOutputStream fileStream = new FileOutputStream("filename");
    ObjectOutputStream os = new ObjectOutputStream(fileStream)
    os.writeObject(obj);
    os.close();
</pre></div>
<ul>
<li>解序列化</li>
</ul>
<div class="highlight"><pre><span></span>    FileInputStream fileStream = new FileInputStream("filename");
    ObjectInputStream os = new ObjectInputStream(fileStream);
    Object obj = os.readObject();
    os.close();
</pre></div>
<ul>
<li>当对象被序列化时，该对象的实例变量也会被序列化，且所有被引用的对象也被序列化</li>
<li>如果想让类能够被序列化，就实现 <code>Serializable</code>，这是一个 tag 标记接口，没有任何方法需要实现，唯一的目的就是声明他的类是可以被序列化的</li>
<li>如果某实例变量是不能或不应该被序列化的，就把他标为 <code>transient</code></li>
<li>解序列化时，新的对象会被放在堆上，但构造函数不会执行</li>
<li>如果对象在继承树上有个不可序列化的祖先类，则该类和之上类的构造函数就会执行</li>
<li>对象的实例变量会被还原成序列化时点的状态值，<code>transient</code> 变量会被赋值 <code>null</code> 的对象引用或主数据的默认值</li>
<li>静态变量属于类，不会被序列化</li>
<li>将字符串写入文本</li>
</ul>
<div class="highlight"><pre><span></span>    try {
        FileWriter writer = new FileWriter("filename");
        writer.write("hello world");
        writer.close();
    } catch(IOException ex) {
        ex.printStackTrace();
    }
</pre></div>
<ul>
<li>读取文本文件</li>
</ul>
<div class="highlight"><pre><span></span>    try {
        File myFile = new File("filename");
        FileReader fileReader = new FileReader(myFile);
        BufferedReader reader = new BufferedReader(fileReader);
        String line = null;
        line = reader.readLine();
        reader.close();
    } catch(Exception ex) {
        ex.printStackTrace();
    }
</pre></div>
<ul>
<li><code>java.io.File</code> 类代表磁盘上的文件</li>
<li>创建代表存盘文件的对象</li>
</ul>
<div class="highlight"><pre><span></span>    File f = new File("filename");
</pre></div>
<ul>
<li>建立新目录</li>
</ul>
<div class="highlight"><pre><span></span>    File dir = new File("dirname");
    dir.mkdir();
</pre></div>
<ul>
<li>列出目录下的内容</li>
</ul>
<div class="highlight"><pre><span></span>    if (dir.isDirectory()) {
        String[] dirContents = dir.list();
        for (Sting file : dirContents) {
            System.out.println(file);
        }
    }
</pre></div>
<ul>
<li>每当对象被序列化时，该对象都会有一个版本 ID，可自己在类中定义</li>
</ul>
<div class="highlight"><pre><span></span>    static final long serialVersionUID = -7526832723882L;
</pre></div>
<h3 id="15">15. 网络联机</h3>
<ul>
<li>读取数据</li>
</ul>
<div class="highlight"><pre><span></span>    Socket chatSocket = new Socket("196.164.1.103", 5000)`;
    InputStreamReader stream = new InputStreamReader(chatSocket.getInputStream());
    BufferedReader reader = new BufferedReader(stream);
    String message = reader.readLine();
</pre></div>
<ul>
<li>写数据</li>
</ul>
<div class="highlight"><pre><span></span>    Socket chatSocket = new Socket("196.164.1.103", 5000)`;
    PrintWriter writer = new PrintWriter(chatSocket.getOutputStream());
    writer.println("message to send");
    writer.print("another message");
</pre></div>
<ul>
<li>TCP 端口是一个 16 位宽，用来识别服务器上特定程序的数字</li>
<li>HTTP：80、Telnet：23、POP3：110、SMTP：25、FTP：20、HTTPS：443、Time：37</li>
<li>0~1023 的 TCP 端口号是留给已知的特定服务的</li>
<li>我们可以使用 1024~65535 之间的端口</li>
<li>通信</li>
</ul>
<div class="highlight"><pre><span></span>    ServerSocket serverSock = new ServerSocket(4242);
    Socket chatSocket = new Socket("196.164.1.103", 4242)`;
    Socket sock = serverSock.accept();
</pre></div>
<ul>
<li>服务器可以使用 <code>ServerSocket</code> 来等待用户对特定端口的请求，当接受到请求后，他会做一个 <code>Socket</code> 连接来接受客户端的请求</li>
<li>启动新的线程</li>
</ul>
<div class="highlight"><pre><span></span>    Runnable threadJob = new MyRunnable();
    Thread myThread = new Thread(threadJob);
    myThread.start();
</pre></div>
<ul>
<li><code>Runnable</code> 这个接口只有一个 <code>run()</code> 方法</li>
<li>线程的 <code>sleep()</code> 这个方法能够保证一件事，在指定的沉睡时间之前，昏睡的线程一定不会被唤醒</li>
<li><code>Java</code> 中每个线程都有独立的执行空间</li>
<li>要把 <code>Runnable</code> 传给 <code>Thread</code> 的构造函数才能启动新的线程</li>
<li><code>start()</code> 之前，线程处于新建立的状态</li>
<li>使用 <code>synchronized</code> 关键字来修饰方法使他每次只能被单一的线程存取</li>
<li><code>synchronized</code> 关键字代表线程需要一把钥匙来存取被同步化过的线程</li>
<li>要保护数据，就把作用在数据上的方法给同步化</li>
<li>锁是配在对象上的，锁住的是存取数据的方法</li>
<li>同步化一部分</li>
</ul>
<div class="highlight"><pre><span></span>    public void go() {
        doStuff();

        synchronized(this) {
            criticalStuff();
            moreCriticalStuff();
        }
    }
</pre></div>
<ul>
<li><code>Java</code> 没有处理死锁的机制，他甚至不会知道死锁的发生</li>
<li><code>sleep()</code> 方法可能抛出 <code>InterruptedRxception</code> 异常，所以要包在 <code>try/cathc</code> 里或者把他声明出来</li>
<li>可以用 <code>setName()</code> 方法给线程命名</li>
<li>类本身也有锁，保护静态变量</li>
</ul>
<h3 id="16">16. 集合与泛型</h3>
<ul>
<li><code>TreeSet</code>、<code>LinkedHashList</code>、<code>HashSet</code></li>
<li><code>ArrayList</code>、<code>LinkedList</code>、<code>Vector</code></li>
<li><code>TreeMap</code>、<code>HashMap</code>、<code>LinkedHashMap</code>、<code>Hashtable</code></li>
<li><code>Collections.sort(List list);</code></li>
<li><code>TreeSet</code> 自动排序</li>
<li>在泛型中，<code>extend</code> 代表 <code>extend</code> 或 <code>implement</code></li>
<li><code>sort()</code> 可以提供第二个比较器参数</li>
<li><code>List</code> 存储对象的引用，可重复引用相同对象</li>
<li><code>SET</code> 不允许重复</li>
<li><code>MAP</code> 键不可重复，值可重复</li>
<li><code>HashSet</code> 用 <code>hashCode()</code> 和 <code>equals()</code> 检查重复</li>
<li>数组的类型是在运行期检查的，集合的类型是在编译期检查的</li>
<li>万用字符</li>
</ul>
<div class="highlight"><pre><span></span>    <span class="kr">public</span> <span class="k">void</span> <span class="nx">takeAnimals</span><span class="p">(</span><span class="nb">Array</span><span class="cp">&lt;?</span> <span class="nx">entends</span> <span class="nx">Animal</span><span class="o">&gt;</span> <span class="nx">animals</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="nx">Animal</span> <span class="nx">a</span> <span class="o">:</span> <span class="nx">animals</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">a</span><span class="o">.</span><span class="nx">eat</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
</pre></div>
<ul>
<li>在方法参数中使用万用字符时，编译器会阻止任何可能破坏引用参数所指集合的行为</li>
<li>下面的声明都对</li>
</ul>
<div class="highlight"><pre><span></span>    <span class="kr">public</span> <span class="o">&lt;</span><span class="nx">T</span> <span class="kr">extends</span> <span class="nx">Animal</span><span class="o">&gt;</span> <span class="k">void</span> <span class="nx">takeThing</span><span class="p">(</span><span class="nx">ArrayList</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="nx">list</span><span class="p">)</span>
    <span class="kr">public</span> <span class="k">void</span> <span class="nx">takeThing</span><span class="p">(</span><span class="nx">ArrayList</span><span class="cp">&lt;?</span> <span class="k">extends</span> <span class="nx">Animal</span><span class="o">&gt;</span> <span class="k">list</span><span class="p">)</span>
</pre></div>
<ul>
<li>关于 <code>sort</code> 方法</li>
</ul>
<div class="highlight"><pre><span></span><span class="kr">public</span> <span class="kr">static</span> <span class="o">&lt;</span><span class="nx">T</span> <span class="kr">extends</span> <span class="nx">Comparable</span><span class="cp">&lt;?</span> <span class="nx">super</span> <span class="nx">T</span><span class="o">&gt;&gt;</span> <span class="nx">void</span> <span class="nb">sort</span><span class="p">(</span><span class="k">List</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="k">list</span><span class="p">)</span>
</pre></div>
<h3 id="17-jar">17. 包、jar 存档文件和部署</h3>
<ul>
<li>将源代码与类文件分离，一般建立 <strong>source</strong> 和 <strong>classes</strong> 目录，将源代码存储在 source 下，编译时加 <strong>-d</strong> 编译选项把类文件输出到 classes 目录</li>
<li>把程序包进 jar（Java Archive），这种文件是个 <strong>pkzip</strong> 格式文件，可执行的 JAR 代表用户不需要吧文件抽出来就能运行，方法是建立 <strong>manifest</strong> 文件，它会带有 JAR 的信息，告诉 JVM 哪个类含有 <code>main()</code> 方法</li>
<li>manifest.txt 文件包括：<code>Main-Class: MyApp</code> 在此行要有换行，此文件放在 <strong>classes</strong> 目录下</li>
</ul>
<div class="highlight"><pre><span></span>    <span class="c">% cd MiniProject/classes</span>
    <span class="c">% jar -cvmf manifest.txt app1.jar *.class</span>
    <span class="o">//</span> 或
    <span class="c">% jar -cvmf manifest.txt app1.jar MyApp.class</span>
</pre></div>
<ul>
<li>执行，直接双击 jar 文件或者 <code>% jave -jar app1.jar</code></li>
<li>用包防止类名称冲突</li>
<li>反向域名.工程名.类名</li>
<li>你必须把类放在与包层级结构相同的目录下</li>
<li>把类加入到包中 <code>package 反向域名.工程名;</code>，一般让类位于完整名称的目录下</li>
<li>编译和执行包</li>
</ul>
<div class="highlight"><pre><span></span>    <span class="c">% javac -d ../classes com/headfirstjava/PackageExercise.java</span>
    <span class="o">//</span> 或编译包里的所有文件
    <span class="c">% javac -d ../classes com/headfirstjava/*.java</span>
    <span class="o">//</span> 执行
    <span class="c">% java ../classes/com.headfirstjava.PackageExercise</span>
</pre></div>
<ul>
<li>-d 选项会要求编译器将结果根据包的结构来建立目录并输出，如果目录还没有建好，编译器会自动处理这些工作</li>
<li>从包创建可执行的 JAR</li>
<li>包的第一层目录必须是 JAR 的第一层目录</li>
<li>在 manifest 文件中加入完整的类名称 Main-Class: com.headfirstjava.PackageExercise</li>
<li>执行 jar 工具，只要从 com 开始就行</li>
</ul>
<div class="highlight"><pre><span></span>    <span class="c">% cd MyProject/classes</span>
    <span class="c">% jar -cvmf manifest.txt packEx,jar com</span>
</pre></div>
<ul>
<li>解压</li>
</ul>
<div class="highlight"><pre><span></span>    <span class="c">% jar -tf packEx.jar</span>
    <span class="o">//</span> 或
    <span class="c">% jar -xf packEx.jar</span>
</pre></div>
<ul>
<li><strong>Java Web Start</strong> 工作方式</li>
<li>客户点击某个网页上 JWS 应用程序的链接（.jnlp 文件）</li>
</ul>
<div class="highlight"><pre><span></span>    <span class="nt">&lt;a</span> <span class="na">href=</span><span class="s">"MyApp.jnlp"</span><span class="nt">&gt;</span>Click<span class="nt">&lt;/a&gt;</span>
</pre></div>
<ul>
<li>Web 服务器收到请求发出 .jnlp 文件给客户端的浏览器</li>
<li>浏览器启动 JWS，JWS 的 helper app 读取 .jnlp 文件，然后想服务器请求 MyApp.jar</li>
<li>Web 服务器发送 .jar 文件</li>
<li>JWS 取得 JAR 并调用指定的 main() 来启动应用程序</li>
<li>.jnlp：Java Network Lanuch Protocol 是一个 XML 文件，里面包含许多设置</li>
<li>创建和部署 JWS 的步骤</li>
<li>将程序制作成可执行 JAR</li>
<li>编写 .jnlp 文件</li>
<li>把 .jnlp 和 JAR 文件放到 Web 服务器</li>
<li>对 Web 服务器设定新的 mime 类型 <code>application/x-java-jnlp-file</code> 确保浏览器知道所接受的文件是什么</li>
<li>设定网页链接到 .jnlp 文件</li>
</ul>
<h3 id="18-rmi">18. 远程部署的 RMI</h3>
<ul>
<li>远程程序调用 Remote Method Invocation</li>
<li>使用 RMI 时，你必须要决定协议，JRMP 是 RMI 原生的协议，它是为 <code>Java</code> 对 <code>Java</code> 之间的远程调用设计的；另外，IIOP 是为了 CORBA （Common Object Request Broker Architecture）而产生的，它让你可以调用 <code>Java</code> 对象或者其他类型的远程方法，比较复杂，因为若两端不全是 <code>Java</code> 的话，就会发生一系列的转译和交谈操作</li>
<li>在 RMI 中，客户端的辅助设施称为 <strong>stub</strong>，而服务端的辅助设施称为 <strong>skeleton</strong></li>
<li>创建远程服务<ul>
<li><strong>创建 Remote 接口</strong>。远程的接口定义了客户端可以远程调用的方法。它是个作为服务的多态化类，stub 和服务都会实现此接口</li>
<li><strong>实现 Remote</strong>。这是真正执行的类，他实现出定义在该接口上的方法，它是客户端会调用的对象</li>
<li><strong>用 rmic 产生 stub 和 skeleton</strong>（可以省略）</li>
<li><strong>启动 RMI registry</strong>。rimiregistry 就像是电话簿。用户会从此处取得代理（客户端的 stub/helper 对象）</li>
<li>启动远程服务并注册</li>
</ul>
</li>
<li>创建远程接口。继承 <code>Remote</code> 接口（标记接口），抛出 <code>RemoteException</code> 异常，返回 <code>primitive</code> 或 <code>Serializable</code> 类型</li>
</ul>
<div class="highlight"><pre><span></span>    public interface MyRemote extends Remote {
        public String sayHello() throws RemoteException;
    }
</pre></div>
<ul>
<li>实现远程接口</li>
</ul>
<div class="highlight"><pre><span></span>    public class MyRemoteImpl extends UnicastRemoteObject implements MyRemote {
        public String sayHello() {
            return "Server says, 'Hey'";
        }
    }
    // 处理 UnicastRemoteObject 抛出的异常
    public MyRemoteImpl() throws RemoteException {}
    // 注册
    try {
        MyRemote service = new MyRemoteImpl();
        Name.rebind("Remote Hello", service);
    } catch (Exception ex) { ... }
</pre></div>
<ul>
<li>产生 stub 和 skeleton。对实现处的类（不是 remote 类）执行 rmic</li>
<li>执行 rimiregistry。注意要从可以存取到该类的目录来启动</li>
<li>启动服务。调用另一个命令行来启动服务</li>
<li>客户端取得 stub 对象</li>
</ul>
<div class="highlight"><pre><span></span>    <span class="nt">MyRemote</span> <span class="nt">service</span> <span class="o">=</span> <span class="o">(</span><span class="nt">MyRemote</span><span class="o">)</span> <span class="nt">Naming</span><span class="p">.</span><span class="nc">lookup</span><span class="o">(</span><span class="s2">"rmi://127.0.0.1/Remote Hello"</span><span class="o">);</span>
</pre></div>
<ul>
<li>注意：在启动远程服务之前先要 rimiregistry；参数和返回类型必须是可序列化的；将 stub 类交给客户端</li>
<li>servlet<ul>
<li>servlet 是完全在 HTTP 服务器上运行的 Java 程序</li>
<li>用来处理与用户交互的网页程序</li>
<li>需要相关包才能编译，不是标准库里的</li>
<li>要有支持 servlet 的服务器</li>
<li>servlet 要放在特定位置</li>
<li>servlet 一般继承自 HttpServlet 并覆盖 doGet() 和 doPost()</li>
<li>servlet 要输出带有完整标识的 HTML 网页</li>
</ul>
</li>
<li>EJB：Enterprise JavaBeans</li>
<li>EJB 服务具有一组光靠 RMI 不会有的服务，比如交易管理、安全性、并发性、数据库和网络功能等，EJB 服务器作用于 RMI 调用和服务层之间</li>
<li>jini</li>
</ul>
<h3 id="19">19. 其他</h3>
<ul>
<li>右移 &gt;&gt;，左边补 1，正负号不变</li>
</ul>
<div class="highlight"><pre><span></span>int x = -11; // 11110101
int y = x &gt;&gt; 2; // 11111101
</pre></div>
<ul>
<li>无符号右移，&gt;&gt;&gt;，左边补 0，正负号可能会改变</li>
</ul>
<div class="highlight"><pre><span></span>int x = -11; // 11110101
int y = x &gt;&gt;&gt; 2; // 00111101
</pre></div>
<ul>
<li>左移，&lt;&lt;，右边补 0，正负号可能改变</li>
</ul>
<div class="highlight"><pre><span></span>int x = -11; // 11110101
int y = x &lt;&lt; 2; // 11010100
</pre></div>
<ul>
<li>为了安全性和节省空间，<code>String</code> 是不变的，创建新的 <code>String</code> 时，JVM 会把它放到 <code>String Pool</code> 的特殊存储区域，不受 GC 管理</li>
<li>断言 <code>assert</code>，带有断言的编译和执行</li>
</ul>
<div class="highlight"><pre><span></span><span class="c">% javac TestDriveGame.java</span>
<span class="c">% java -ea TestDriveGame</span>
</pre></div>
<ul>
<li>枚举</li>
</ul>
<div class="highlight"><pre><span></span>public enum Members {JERRY, BOBBY, PHIL};
public Members selectBandMember;

if (selectBandMember == Members.JERRY) {
    //
}
</pre></div>
                <aside>
                    <hr />
                    <nav class="older">
                        <h1>
                            <font color="#771515"><em>OLDER</em></font>
                        </h1>
                        <ul>
                            <li>
                                <a href="https://xutree.github.io/pages/2019/09/07/cast/">
                                    C++ 中的类型转换
                                </a>
                            </li>
                            <li>
                                <a href="https://xutree.github.io/pages/2019/08/16/深入浅出SQL/">
                                    深入浅出 SQL
                                </a>
                            </li>
                            <li>
                                <a href="https://xutree.github.io/pages/2019/06/01/sl-12/">
                                    统计学习方法 第十二章 统计学习方法总结
                                </a>
                            </li>
                            <li>
                                <a href="https://xutree.github.io/pages/2019/05/17/sl-11/">
                                    统计学习方法 第十一章 条件随机场
                                </a>
                            </li>
                            <li>
                                <a href="https://xutree.github.io/pages/2019/04/19/sl-10/">
                                    统计学习方法 第十章 隐马尔科夫模型
                                </a>
                            </li>
                        </ul>
                    </nav>
                    <nav class="newer">
                        <h1>
                            <font color="#771515"><em>NEWER</em></font>
                        </h1>
                        <ul>
                            <li>
                                <a href="https://xutree.github.io/pages/2019/09/24/alg_4th/">
                                    算法（第四版）
                                </a>
                            </li>
                            <li>
                                <a href="https://xutree.github.io/pages/2019/09/25/nielsen/">
                                    量子信息和量子计算——量子计算部分
                                </a>
                            </li>
                            <li>
                                <a href="https://xutree.github.io/pages/2019/09/28/pythonpckf/">
                                    Python3 网络爬虫开发实践
                                </a>
                            </li>
                            <li>
                                <a href="https://xutree.github.io/pages/2019/09/28/MySQL教程/">
                                    MySQL 教程
                                </a>
                            </li>
                            <li>
                                <a href="https://xutree.github.io/pages/2019/09/28/dl-5/">
                                    深度学习 第五章 机器学习基础
                                </a>
                            </li>
                        </ul>
                    </nav>
                    <!-- Gitalk 评论 start  -->

                    <!-- Link Gitalk 的支持文件  -->
                    <!-- <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
                    <script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script>
                    <div id="gitalk-container"></div>
                    <script type="text/javascript">
                        var dateTime = Date.now();
                        var timestamp = Math.floor(dateTime / 1000);
                        var gitalk = new Gitalk({

                            // gitalk的主要参数
                            clientID: '93f43349e9fd3154bfad',
                            clientSecret: 'd6d09d1d7261f6b62f46b39e5fcace85b81c3cd7',
                            repo: 'xutree.github.io',
                            owner: 'xutree',
                            admin: ['xutree'],
                            id: String(timestamp)

                        });
                        gitalk.render('gitalk-container');
                    </script> -->
                    <!-- Gitalk end -->
                </aside>
            </div>
            <section>
                <div class="span2" style="float:right;font-size:0.9em;">
                    <h4>发布日期</h4>
                    <time pubdate="pubdate" datetime="2019-09-16T22:30:04+08:00">2019-09-16 22:30:04</time>
                    <h4>最后更新</h4>
                    <div class="last_updated">2019-09-18 20:07:48</div>
                    <h4>分类</h4>
                    <a class="category-link" href="/categories.html#Java-ref">Java</a>
                    <h4>标签</h4>
                    <ul class="list-of-tags tags-in-article">
                        <li><a href="/tags.html#Java-ref">Java
                                <span>1</span>
</a></li>
                    </ul>

                </div>
            </section>
        </div>
</article>
                </div>
                <div class="span1"></div>
            </div>
        </div>
    </div>
<footer>
<div id="footer">
    <ul class="footer-content">
        <li class="elegant-power">Powered by <a href="http://getpelican.com/" title="Pelican Home Page">Pelican</a>. Theme: <a href="http://oncrashreboot.com/pelican-elegant" title="Theme Elegant Home Page">Elegant</a> by <a href="http://oncrashreboot.com" title="Talha Mansoor Home Page">Talha Mansoor</a></li>
    </ul>
</div>
</footer>    <script src="https://code.jquery.com/jquery.min.js"></script>
    <script src="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.1/js/bootstrap.min.js"></script>
    <script>
        function validateForm(query) {
            return (query.length > 0);
        }
    </script>
</body>

</html>