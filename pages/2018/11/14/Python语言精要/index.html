<!DOCTYPE html>
<html lang="en-US">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="author" content="Shu" />
    <meta name="copyright" content="Shu" />

<meta name="keywords" content="Python, 读书笔记, " />
    <title>Python 语言精要  · You Know Nothing
</title>
    <link rel="stylesheet" type="text/css" href="https://xutree.github.io/theme/css/slim-081711.css" media="screen">
    <link rel="stylesheet" type="text/css" href="https://xutree.github.io/theme/css/bootstrap-combined.min.css" media="screen">
    <link rel="stylesheet" type="text/css" href="https://xutree.github.io/theme/css/style.css" media="screen">
    <link rel="stylesheet" type="text/css" href="https://xutree.github.io/theme/css/solarizedlight.css" media="screen">
        <link href="https://xutree.github.io/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="You Know Nothing - Full Atom Feed" />
        <link href="https://xutree.github.io/feeds/读书笔记.atom.xml" type="application/atom+xml" rel="alternate" title="You Know Nothing - 读书笔记 Category Atom Feed" />
        <link href="https://xutree.github.io/feeds/基础知识.atom.xml" type="application/atom+xml" rel="alternate" title="You Know Nothing - 基础知识 Category Atom Feed" />
        <link href="https://xutree.github.io/feeds/教程.atom.xml" type="application/atom+xml" rel="alternate" title="You Know Nothing - 教程 Category Atom Feed" />
        <link href="https://xutree.github.io/feeds/其他.atom.xml" type="application/atom+xml" rel="alternate" title="You Know Nothing - 其他 Category Atom Feed" />
        <link href="https://xutree.github.io/feeds/趣闻.atom.xml" type="application/atom+xml" rel="alternate" title="You Know Nothing - 趣闻 Category Atom Feed" />
</head>

<body>
    <div id="content-sans-footer">
        <div class="navbar navbar-static-top">
            <div class="navbar-inner">
                <div class="container">
                    <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </a>
                    <a class="brand" href="https://xutree.github.io/"><span class=site-name>You Know Nothing</span></a>
                    <div class="nav-collapse collapse">
                        <ul class="nav pull-right top-menu">
                            <li ><a href="https://xutree.github.io/index.html">主页</a></li>
                            <li ><a href="https://xutree.github.io/categories.html">分类</a></li>
                            <li ><a href="https://xutree.github.io/tags.html">标签</a></li>
                            <li ><a href="https://xutree.github.io/archives.html">归档</a></li>
                            <li>
                                <form class="navbar-search" action="https://xutree.github.io/search.html" onsubmit="return validateForm(this.elements['q'].value);"> <input type="text" class="search-query" placeholder="关键字搜索" name="q" id="tipue_search_input"></form>
                            </li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
        <div class="container-fluid">
            <div class="row-fluid">
                <div class="span1"></div>
                <div class="span10">
<article>
    <div class="row-fluid">
        <header class="page_header span10 offset2">
            <h1><a href="https://xutree.github.io/pages/2018/11/14/Python语言精要/"> Python 语言精要  </a></h1>
        </header>
    </div>

    <div class="row-fluid">
        <!--  -->
            <div class="span8 offset2 article-content">

                <h2>1. 基础知识</h2>
<ul>
<li>缩进，而不是大括号</li>
<li>Python 语句还能不依分号结束，不过分号也是可以有的，如
    <code>a = 5; b = 6; c = 7</code></li>
<li>万物皆对象<ul>
<li>Python 解释器中的任何数值、字符串、数据结构、函数、类、模块等都待在自己的“盒子”里，而这个”盒子”就是 Python 对象</li>
<li>每个对象都有一个与之相关的类型（比如字符串和函数）以及内部数据</li>
</ul>
</li>
<li>变量和按引用传递<ul>
<li>列表和元组的赋值皆为引用</li>
<li>若想拷贝，则利用切片
```<blockquote>
<blockquote>
<blockquote>
<p>a = [1, 2, 3]
b = a[:] #拷贝
c = a #引用
```</p>
</blockquote>
</blockquote>
</blockquote>
</li>
<li>切片只能赋值第一层列表，若列表中还包含列表，则内部列表仍为引用。元组内的列表也是。
    <code>&gt;&gt;&gt; a = [1, 2, [3, 4, 5], 6]
    &gt;&gt;&gt; a
    [1, 2, [3, 4, 5], 6]
    &gt;&gt;&gt; b=a[:]
    &gt;&gt;&gt; b
    [1, 2, [3, 4, 5], 6]
    &gt;&gt;&gt; b.append(7)
    &gt;&gt;&gt; b
    [1, 2, [3, 4, 5], 6, 7]
    &gt;&gt;&gt; a
    [1, 2, [3, 4, 5], 6]
    &gt;&gt;&gt; b[2].append(6)
    &gt;&gt;&gt; b
    [1, 2, [3, 4, 5, 6], 6, 7]
    &gt;&gt;&gt; a
    [1, 2, [3, 4, 5, 6], 6]</code></li>
<li>当你将对象以参数的形式传入函数时，其实只是传入一个引用而已</li>
</ul>
</li>
<li>跟许多编译型语言（如 Java 和 C++）相反，Python 中的对象引用没有与之关联的类型信息。下面这些代码不会有什么问题。对象的类型信息是保存在它自己内部的
    <code>&gt;&gt;&gt; a = 5
    &gt;&gt;&gt; type(a)
    &lt;class 'int'&gt;
    &gt;&gt;&gt; a = 'foo'
    &gt;&gt;&gt; type(a)
    &lt;class 'str'&gt;</code></li>
<li>Python 可以别认为是一种强类型语言，所有对象都有一个特定的类型（或类），隐式转换只在很明显的情况下才会发生，例如浮点转化为整数参与相加运算，而字符串则不行</li>
<li>isinstance 函数检查一个对象是否是某个特定类型的的实例
    <code>&gt;&gt;&gt; a = 5
    &gt;&gt;&gt; isinstance(a,int)
    True</code>
    isinstance 可以接受由类型组成的元组
    <code>&gt;&gt;&gt; a = 5; b = 4.5
    &gt;&gt;&gt; isinstance(a, (int, float))
    True</code></li>
<li>属性和方法(. + tab 键)
    <code>&gt;&gt;&gt; a = 5
    &gt;&gt;&gt; a.
    a.__abs__(           a.__format__(        a.__mul__(           a.__rlshift__(       a.__sub__(
    a.__add__(           a.__ge__(            a.__ne__(            a.__rmod__(          a.__subclasshook__(
    a.__and__(           a.__getattribute__(  a.__neg__(           a.__rmul__(          a.__truediv__(
    a.__bool__(          a.__getnewargs__(    a.__new__(           a.__ror__(           a.__trunc__(
    a.__ceil__(          a.__gt__(            a.__or__(            a.__round__(         a.__xor__(
    a.__class__(         a.__hash__(          a.__pos__(           a.__rpow__(          a.bit_length(
    a.__delattr__(       a.__index__(         a.__pow__(           a.__rrshift__(       a.conjugate(
    a.__dir__(           a.__init__(          a.__radd__(          a.__rshift__(        a.denominator
    a.__divmod__(        a.__int__(           a.__rand__(          a.__rsub__(          a.from_bytes(
    a.__doc__            a.__invert__(        a.__rdivmod__(       a.__rtruediv__(      a.imag
    a.__eq__(            a.__le__(            a.__reduce__(        a.__rxor__(          a.numerator
    a.__float__(         a.__lshift__(        a.__reduce_ex__(     a.__setattr__(       a.real
    a.__floor__(         a.__lt__(            a.__repr__(          a.__sizeof__(        a.to_bytes(
    a.__floordiv__(      a.__mod__(           a.__rfloordiv__(     a.__str__(</code>
    getattr、hasattr 和 setattr 函数也很实用</li>
<li>是否可以迭代<ul>
<li>验证
    <code>def isiterable(obj):
            try:
                iter(obj)
                return True
            except TypeError:
                return False</code></li>
<li>转换
    <code>if not isinstance(x, list) and isiterable(x):
            x = list(x)</code></li>
</ul>
</li>
<li>要判断两个引用是否指向同一个对象，可以用 is 和 is not 关键字
    <code>&gt;&gt;&gt; a = [1, 2, 3]
    &gt;&gt;&gt; b = a
    &gt;&gt;&gt; c = list(a) #list 函数始终会创建新列表
    &gt;&gt;&gt; a is b
    True
    &gt;&gt;&gt; a is c
    False
    &gt;&gt;&gt; a == c
    True</code></li>
<li>is 和 is not 常常用于判断变量是否为 None，因为 None 的实例只有一个
    <code>&gt;&gt;&gt; a = None
    &gt;&gt;&gt; a is None
    True</code></li>
<li>
<p>二元运算符</p>
<table>
<thead>
<tr>
<th align="left">运算</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">a + b</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">a - b</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">a * b</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">a / b</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">a // b</td>
<td align="left">丢弃小数</td>
</tr>
<tr>
<td align="left">a ** b</td>
<td align="left">a 的 b 次方</td>
</tr>
<tr>
<td align="left">a &amp; b</td>
<td align="left">与，整数位与</td>
</tr>
<tr>
<td align="left">a | b</td>
<td align="left">或，整数位或</td>
</tr>
<tr>
<td align="left">a ^ b</td>
<td align="left">异或，整数位异或</td>
</tr>
<tr>
<td align="left">a == b, a != b, a &lt;= b, a &lt; b, a &gt;= b, a &gt; b</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">a <em>is</em> b, a <em>is not</em> b</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">- 在 Python 中，求值会立刻发生，而不是用到的时候计算，有一些技术可以实现延迟计算</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">- 字符串和元组是不可变的</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">- 标量类型</td>
<td align="left"></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">None</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">str</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">unicode</td>
<td align="left">Unicode 字符串类型</td>
</tr>
<tr>
<td align="left">float</td>
<td align="left">双精度（64 位）浮点数。注意，没有 double</td>
</tr>
<tr>
<td align="left">bool</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">int</td>
<td align="left">有符号整数，其最大值由平台决定</td>
</tr>
<tr>
<td align="left">long</td>
<td align="left">任意精度的有符号整数。大的 int 值会被自动转换为 long</td>
</tr>
<tr>
<td align="left">- 虚数单位用 j 表示</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">- 对于带有换行的多行字符串，可以用三重引号</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">- Python 的字符串是不可变的，想修改只能创建一个新的</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">- list(str)</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">- r"..."</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">- 字符串格式化</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">```</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">&gt;&gt;&gt; template = '%.2f %s are worth $%d'</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">&gt;&gt;&gt; template % (4.5560, 'Argentine Pesos', 1)</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">'4.56 Argentine Pesos are worth $1'</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">```</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">- 几乎所有 Python 内置类型以及任何定义了 __nonzero__ 方法的类都能在 if 语句中被解释为 True 和 False。可用 bool( )函数测试。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">- 类型转换：str( )、 bool( )、 int( )、 float( )等</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">- None 不是一个保留字，它只是 NoneType 的一个实例</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">- 时间和日期</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">```</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">&gt;&gt;&gt; from datetime import datetime, date, time</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">&gt;&gt;&gt; dt = datetime(2018, 4, 5, 14, 1, 23)</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">&gt;&gt;&gt; dt.strftime('%m/%d/%Y %H:%M')</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">'04/05/2018 14:01'</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">&gt;&gt;&gt; datetime.strptime('20180401','%Y%m%d')</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">datetime.datetime(2018, 4, 1, 0, 0)</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">&gt;&gt;&gt; dt.replace(minute=0, second=0)</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">datetime.datetime(2018, 4, 5, 14, 0)</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">```</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">两个 datetime 对象的差会产生一个 datetime.timedelta 对象。datetime.timedelta 加到一个 datetime 上会产生一个新的 datetime</td>
<td align="left"></td>
</tr>
</tbody>
</table>
</li>
</ul>
<h2>2. 控制流</h2>
<ul>
<li>if、elif 和 else</li>
</ul>
<div class="highlight"><pre><span></span>if x &lt; 0:
        print(&quot;It&#39;s negative&quot;)
elif x == 0:
        print(&quot;Equal to zero&quot;)
elif 0 &lt; x &lt; 5:
        print(&quot;Positive but smaller than 5&quot;)
else:
        print(&quot;Positive and larger than or equal to 5&quot;)
</pre></div>


<ul>
<li>for</li>
</ul>
<div class="highlight"><pre><span></span>for value in collection:
        #操作
</pre></div>


<ul>
<li>break、continue 和 pass</li>
<li>while</li>
<li>异常处理<ul>
<li>把可能发生异常的语句放在 try/except 块中</li>
<li>except 后面可不跟参数表示捕获所有异常，或者跟一个异常元组</li>
<li>finally 用于不管 try 成功与否都能被执行</li>
<li>你也可以让某些代码只在 try 块成功时执行，使用 else 即可
<code>f = open(path, 'w')
try:
        write_to_file(f)
except:
        print('Failed')
else:
        print('Succeeded')
finally:
        f.close()</code></li>
</ul>
</li>
<li>range 产生序列,不包括结束值</li>
</ul>
<div class="highlight"><pre><span></span>range(起始，结束，步长)
</pre></div>


<ul>
<li>三元表达式</li>
</ul>
<div class="highlight"><pre><span></span>&gt;&gt;&gt; a = 5
&gt;&gt;&gt; &#39;Non-negative&#39; if a &gt;= 0 else &#39;Negative&#39;
&#39;Non-negative&#39;
</pre></div>


<h2>3. 数据结构和序列</h2>
<ul>
<li>元组<ul>
<li>元组（tuple）是一种一维的、定长的、不可变的 Python 对象序列</li>
<li>逗号分隔
```<blockquote>
<blockquote>
<blockquote>
<p>tup = 4, 5, 6
tup
(4, 5, 6)
```</p>
</blockquote>
</blockquote>
</blockquote>
</li>
<li>tuple 函数可将任何序列或迭代器转换为元组
```<blockquote>
<blockquote>
<blockquote>
<p>tup = 4, 5, 6
tup
(4, 5, 6)
tuple([1, 2, 3])
(1, 2, 3)
tup = tuple('xushu')
tup
('x', 'u', 's', 'h', 'u')
```</p>
</blockquote>
</blockquote>
</blockquote>
</li>
<li>用[ ] 索引，从 0 开始</li>
<li>存储在元组中的对象本身可能是可变的，但一旦创建完毕，存放在各个插槽中的对象就不能再修改了</li>
<li>元组可以通过 + 号运算符连接成更长的元组</li>
<li>跟列表一样，对一个元组乘以一个整数，相当于连接该元组的多个副本
```<blockquote>
<blockquote>
<blockquote>
<p>a=1, [2, 3, 4], 5
a
(1, [2, 3, 4], 5)
b=a*3
b
(1, [2, 3, 4], 5, 1, [2, 3, 4], 5, 1, [2, 3, 4], 5)
a[1].append(6)
a
(1, [2, 3, 4, 6], 5)
b #注意 b 变了
(1, [2, 3, 4, 6], 5, 1, [2, 3, 4, 6], 5, 1, [2, 3, 4, 6], 5)
```
对象本身不会被复制，这里涉及到的是它们的引用</p>
</blockquote>
</blockquote>
</blockquote>
</li>
<li>元组拆包（unpacking）
```<blockquote>
<blockquote>
<blockquote>
<p>tup = (4, 5, 6)
a, b, c = tup
b
5
tup = 4, 5, (6, 7)
a, b, (c, d) = tup
d
7
<code>交换变量名</code>
a, b = b, a
<code>变量拆包功能常用于对由元组或列表组成的序列进行迭代</code>
seq = [(1, 2, 3), (4, 5, 6), (7, 8, 9)]
for a, b, c in seq:
        pass
```
另一种常见的用法是处理从函数返回的多个值</p>
</blockquote>
</blockquote>
</blockquote>
</li>
<li>元组方法：由于元组的大小和内存不能被修改，所以实例方法很少。最有用的是 count( )，它用于计算指定值出现的次数
```<blockquote>
<blockquote>
<blockquote>
<p>tup
(4, 5, [6, 7, 4])
tup.count([6,7,4])
1
```</p>
</blockquote>
</blockquote>
</blockquote>
</li>
</ul>
</li>
<li>列表<ul>
<li>可变长，内容可修改</li>
<li>通过[ ]或者 list 函数定义</li>
<li>添加尾部：list.append(a)</li>
<li>插入位置: list.insert(1,a)</li>
<li>移除并返回指定索引的元素：b = list.pop(2)</li>
<li>删除第一个符号要求的值：list.remove(a)</li>
<li>是否在列表中：a in list<ul>
<li>注意：判断列表是否含有某个值的操作比字典（dict）和集合（set）慢得多，因为 python 会对列表进行线性扫描，而另外两个（基于哈希表）则可以瞬间完成判断</li>
<li>散列表（Hash table，也叫哈希表），是根据键（Key）而直接访问在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表</li>
</ul>
</li>
<li>一次添加多个元素：list.extend(a, b, c)</li>
<li>合并列表：list + list<ul>
<li>注意：列表的合并是一种相当耗费资源的操作，需要新建列表并复制，而 extend 会好很多
```</li>
</ul>
<h1>高效</h1>
<p>everything = []
for chunk in list_of_lists:
        everything.extend(chunk)</p>
<h1>低效</h1>
<p>everything = []
for chunk in list_of_lists:
        everything = everything + (chunk)
```</p>
</li>
<li>就地排序：list.sort()</li>
<li>按键就地排序：list.sort(key=len)</li>
<li>二分搜索<ul>
<li>内置的 bisect 模块实现了二分搜索和插入操作</li>
<li>bisect.bisect 可以找出新元素被插入到哪个位置才能保持原列表的有序性</li>
<li>bisect.insort 则将新元素插入到那个位置</li>
<li>bisect 模块不会判断原列表是否有序，因开销太大，所以不要应用于无序列表</li>
</ul>
</li>
<li>切片<ul>
<li>seq[1:5:2]</li>
<li>为切片赋值：seq[3:4] = [6, 3]，即将这一段替换
```<blockquote>
<blockquote>
<blockquote>
<p>seq
[1, 2, 3, 4, 5, 6]
seq[3:4]=[8,8,8]
seq
[1, 2, 3, 8, 8, 8, 5, 6]
seq[3:4]=[8,[8,8]]
seq
[1, 2, 3, 8, [8, 8], 8, 8, 5, 6]
```</p>
</blockquote>
</blockquote>
</blockquote>
</li>
<li>全切：seq[:]</li>
<li>负数表示从末尾开始切：seq[-4:]</li>
<li>反序：seq[::-1]</li>
</ul>
</li>
<li>内置的序列函数<ul>
<li>enumerate<ul>
<li>在对一个序列进行迭代时，常常需要跟踪当前项的索引。下面是一种 diy 的办法
<code>i = 0
for value in collection:
        #用 value 做一些事情
        i += 1</code>
而 enumerate 函数返回序列的(i, value)元组：
<code>for i, value in enumerate(collection):
        #用 value 做一些事情</code></li>
<li>在对数据进行索引时，enumerate 还有一种不错的使用模式，即求取一个将序列值（假定是唯一的）映射到其所在位置的字典
```<blockquote>
<blockquote>
<blockquote>
<p>some_list = ['foo', 'bar', 'baz']
mapping = dict((v, i) for i, v in enumerate(some_list))
mapping
{'bar': 1, 'baz': 2, 'foo': 0}
```</p>
</blockquote>
</blockquote>
</blockquote>
</li>
</ul>
</li>
<li>非就地排序：sorted(list)</li>
<li>zip：压缩配对
```<blockquote>
<blockquote>
<blockquote>
<p>seq1 = ['foo', 'bar', 'baz']
seq2 = ['one', 'two', 'three']
zip(seq1, seq2)
<zip object at 0x1040c8f48>
list(zip(seq1, seq2))
[('foo', 'one'), ('bar', 'two'), ('baz', 'three')]
seq3 = [False, True]
zip(seq1, seq2, seq3)
<zip object at 0x1040c8fc8>
list(zip(seq1, seq2, seq3)) #取决于最短的列表
[('foo', 'one', False), ('bar', 'two', True)]
<code>解压缩</code>
test = [(1,'one'), (2, 'two')]
first, second = zip(*test)
first
(1, 2)
second
('one', 'two')
```</p>
</blockquote>
</blockquote>
</blockquote>
</li>
<li>reversed：逆序迭代
```<blockquote>
<blockquote>
<blockquote>
<p>list(reversed(range(10)))
[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
```</p>
</blockquote>
</blockquote>
</blockquote>
</li>
</ul>
</li>
<li>字典<ul>
<li>哈希映射（hash map）、相联数组（associative array）</li>
<li>通过键访问键值</li>
<li>判断键是否在字典内：a in dict</li>
<li>删除：del[key]</li>
<li>删除返回指定值： dict.pop(key)</li>
<li>键、值列表：dict.keys( )、 dict.values( )，虽然键值对没有特定的顺序，但这两个函数会以相同的顺序输出键和值。python3 会返回迭代器</li>
<li>合并字典：dict1.update(dict2)</li>
<li>默认值<ul>
<li>dict 的 get 和 pop 方法可以接受一个可供返回的默认值</li>
<li>根据首字母分类
```
words = ['apple', 'bat', 'bar', 'atom', 'book']<blockquote>
<blockquote>
<blockquote>
<p>by_words = {}
for word in words:
...     letter = word[0]
...     if letter not in by_words:
...             by_words[letter] = [word]
...     else:
...             by_words[letter].append(word)
...
by_words
{'b': ['bat', 'bar', 'book'], 'a': ['apple', 'atom']}
<code>字典的 setdefault 方法可以达到上述目的。上面的 if-else 块可以写作</code>
by_words.setdefault(letter, []).append(word)
<code>内置的 collections 模块有一个叫做 defaultdict 的类，它使该过程更简单。传入一个类型或函数（用于生成字典各插槽所使用的默认值）即可创建出一个 defaultdict：</code>
from collections import defaultdict
by_letter = defaultdict(list)
for word in words:
        by_letter[word[0]].append(word)
<code>defaultdict 的初始化器只需要一个可调用对象（例如各种函数），并不需要明确的类型。因此，如果你将默认值设置成 4，只需传入一个能返回 4 的函数即可：</code>
counts = defaultdict(lambda: 4)
```</p>
</blockquote>
</blockquote>
</blockquote>
</li>
</ul>
</li>
<li>字典键的有效类型：键必须是不可变对象，如标量类型（整数，浮点数，字符串）或元组（元组中的所有对象也必须是不可变的），即可哈希性（hashability）。通过 hash 函数，可以判断是否是可哈希的。如果要将列表当做键，最简单的就是将其转换为元组</li>
</ul>
</li>
</ul>
</li>
<li>
<p>集合</p>
<ul>
<li>元素唯一</li>
<li>set 创建或者大括号</li>
<li>集合运算</li>
</ul>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">其他表示法</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">a.add(x)</td>
<td align="left">N/A</td>
<td align="left">添加 x 元素到集合 a</td>
</tr>
<tr>
<td align="left">a.remove(x)</td>
<td align="left">N/A</td>
<td align="left">删除</td>
</tr>
<tr>
<td align="left">a.union(b)</td>
<td align="left">a | b</td>
<td align="left">并</td>
</tr>
<tr>
<td align="left">a.intersection(b)</td>
<td align="left">a \&amp; b</td>
<td align="left">交</td>
</tr>
<tr>
<td align="left">a.difference(b)</td>
<td align="left">a - b</td>
<td align="left">a 中不属于 b 的元素</td>
</tr>
<tr>
<td align="left">a.symmetric_difference(b)</td>
<td align="left">a ^ b</td>
<td align="left">对称差（异或），a 或 b 中不同时属于 a 和 b 的元素</td>
</tr>
<tr>
<td align="left">a.issubset(b)</td>
<td align="left">N/A</td>
<td align="left">a 是 b 的子集为 True</td>
</tr>
<tr>
<td align="left">a.issuperset(b)</td>
<td align="left">N/A</td>
<td align="left">b 是 a 的子集为 True</td>
</tr>
<tr>
<td align="left">a.isdisjoint(b)</td>
<td align="left">N/A</td>
<td align="left">如果 a 和 b 没有公共元素，为 True</td>
</tr>
<tr>
<td align="left">- 列表、集合以及字典的推导式</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">- 列表：</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">```</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">[expr for val in collection if condition]</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">```</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">- 字典：</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">```</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td : align="left" collection condition for if in key-expr val value-expr></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">```</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">- 集合：</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">```</td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left" collection condition expr for if in val></td>
<td align="left"></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">```</td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody>
</table>
</li>
</ul>
<h2>4. 函数</h2>
<ul>
<li>注意作用域</li>
</ul>
<div class="highlight"><pre><span></span>a = []
&gt;&gt;&gt; def func():
...     for i in range(5):
...             a.append(i)
...
&gt;&gt;&gt; func()
&gt;&gt;&gt; a
[0, 1, 2, 3, 4]
</pre></div>


<p>下面的例子若想改变 a，则需要在函数内部加上 global a 语句</p>
<div class="highlight"><pre><span></span>&gt;&gt;&gt; a = 1
&gt;&gt;&gt; def func():
...     a = 2
...
&gt;&gt;&gt; func()
&gt;&gt;&gt; a
1
</pre></div>


<ul>
<li>可以返回字典和元组</li>
<li>函数也是对象
下面代码用于清理数据</li>
</ul>
<div class="highlight"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">states</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;    Alabama &#39;</span><span class="p">,</span> <span class="s1">&#39;Georgia!&#39;</span><span class="p">,</span> <span class="s1">&#39;Georgia&#39;</span><span class="p">,</span> <span class="s1">&#39;georgia&#39;</span><span class="p">,</span> <span class="s1">&#39;FIOrIda&#39;</span><span class="p">,</span> <span class="s1">&#39;south     carolina##&#39;</span><span class="p">,</span> <span class="s1">&#39;West virginia?&#39;</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">re</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">def</span> <span class="nf">clean_string</span><span class="p">(</span><span class="n">strings</span><span class="p">):</span>
<span class="o">...</span>     <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
<span class="o">...</span>     <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">strings</span><span class="p">:</span>
<span class="o">...</span>             <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
<span class="o">...</span>             <span class="n">value</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s1">&#39;[!#?]&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>      <span class="c1">#移除标点符号</span>
<span class="o">...</span>             <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">title</span><span class="p">()</span>
<span class="o">...</span>             <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
<span class="o">...</span>     <span class="k">return</span> <span class="n">result</span>
<span class="o">...</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">clean_string</span><span class="p">(</span><span class="n">states</span><span class="p">)</span>
<span class="p">[</span><span class="s1">&#39;Alabama&#39;</span><span class="p">,</span> <span class="s1">&#39;Georgia&#39;</span><span class="p">,</span> <span class="s1">&#39;Georgia&#39;</span><span class="p">,</span> <span class="s1">&#39;Georgia&#39;</span><span class="p">,</span> <span class="s1">&#39;Fiorida&#39;</span><span class="p">,</span> <span class="s1">&#39;South     Carolina&#39;</span><span class="p">,</span> <span class="s1">&#39;West Virginia&#39;</span><span class="p">]</span>
</pre></div>


<p>其实还有另外一种不错的方法：将需要在一组给定字符串上执行的所有运算做成一个列表：</p>
<div class="highlight"><pre><span></span>&gt;&gt;&gt; def remove_punctuation(value):
...     return re.sub(&#39;[!#?]&#39;, &#39;&#39;, value)
...
&gt;&gt;&gt; cleans_ops = [str.strip, remove_punctuation, str.title]
&gt;&gt;&gt; def clean_strings(strings, ops):
...     result = []
...     for value in strings:
...             for function in ops:
...                     value = function(value)
...             result.append(value)
...     return result
...
&gt;&gt;&gt; clean_strings(states, cleans_ops)
[&#39;Alabama&#39;, &#39;Georgia&#39;, &#39;Georgia&#39;, &#39;Georgia&#39;, &#39;Fiorida&#39;, &#39;South     Carolina&#39;, &#39;West Virginia&#39;]
</pre></div>


<p>这种多函数模式使你能在很高的层次上轻松修改字符串的转换方式，还可以将函数用作其他函数的参数，比如内置的 map 函数，它用于在一组数据上应用一个函数</p>
<div class="highlight"><pre><span></span>&gt;&gt;&gt; map(remove_punctuation, states)
&lt;map object at 0x1040cc0f0&gt;
&gt;&gt;&gt; list(map(remove_punctuation, states))
[&#39;    Alabama &#39;, &#39;Georgia&#39;, &#39;Georgia&#39;, &#39;georgia&#39;, &#39;FIOrIda&#39;, &#39;south     carolina&#39;, &#39;West virginia&#39;]
</pre></div>


<ul>
<li>匿名函数（lambda 函数）</li>
</ul>
<div class="highlight"><pre><span></span>def short_function(x):
        return x * 2
#等价于
equiv_anon = lambda x: x * 2
</pre></div>


<p>另外一个例子，根据列表中各字符串中不同字母的数量排序：</p>
<div class="highlight"><pre><span></span>&gt;&gt;&gt; strings = [&#39;foo&#39;, &#39;card&#39;, &#39;bar&#39;, &#39;aaaa&#39;, &#39;abab&#39;]
&gt;&gt;&gt; strings.sort(key=lambda x: len(set(list(x))))
&gt;&gt;&gt; strings
[&#39;aaaa&#39;, &#39;foo&#39;, &#39;abab&#39;, &#39;bar&#39;, &#39;card&#39;]
</pre></div>


<ul>
<li>闭包（closure）：返回函数的函数<ul>
<li>由其他函数动态生成并返回的函数</li>
<li>被返回函数可以访问其创建者的局部命名空间中的变量
```<blockquote>
<blockquote>
<blockquote>
<p>def make_closure(a):
...     def closure():
...             print('I know the secret: %d' % a)
...     return closure
...
closure = make_closure(5)
closure()
I know the secret: 5
```</p>
</blockquote>
</blockquote>
</blockquote>
</li>
<li>虽然闭包的内部状态一般都是静态的，但也允许使用可变对象。例如，下面这个函数可以返回一个能够记录其参数（曾经传入的一切参数）的函数：
```<blockquote>
<blockquote>
<blockquote>
<p>def make_watcher():
...     have_seen = {}
...     def has_been_seen(x):
...             if x in have_seen:
...                     return True
...             else:
...                     have_seen[x] = True
...                     return False
...     return has_been_seen
...
watcher = make_watcher()
vals = [5, 6, 1, 5, 1, 6, 3, 5]
[watcher(x) for x in vals]
[False, False, False, True, True, True, False, True]
```</p>
</blockquote>
</blockquote>
</blockquote>
</li>
<li>一个技术限制：虽然可以修改内部状态对象（比如说向字典添加键值对），但不能绑定外层函数作用域中的变量。一个解决办法是：修改字典或列表，而不是绑定变量
```<blockquote>
<blockquote>
<blockquote>
<p>def make_counter():
...     count = [0]
...     def counter():
...             #增加并返回当前的 count
...             count[0] += 1
...             return count[0]
...     return counter
...
counter = make_counter()
counter()
1
counter()
2
counter()
3
```</p>
</blockquote>
</blockquote>
</blockquote>
</li>
<li>在实际工作中，你可以编写带有大量选项的非常一般化的函数，然后再组装出更检点更专门化的函数。下面的例子中创建一个字符串格式化函数：
```<blockquote>
<blockquote>
<blockquote>
<p>def format_and_pad(template, space):
...     def formatter(x):
...             return (template % x).rjust(space)
...     return formatter
<code>然后，你可以创建一个始终返回 15 位字符串的浮点数格式化器</code>
fmt = format_and_pad('%.4f', 15)
fmt(1.756)
'         1.7560'
```</p>
</blockquote>
</blockquote>
</blockquote>
</li>
</ul>
</li>
<li>扩展调用语法和*args、**kwargs<ul>
<li>调用函数时，位置参数被打包成元组，关键字参数被打包成字典</li>
<li>函数实际接收的是一个元组*args 和一个字典**kwargs
```<blockquote>
<blockquote>
<blockquote>
<p>def say_hello_then_call_f(f, *args, <strong>kwargs):
...     print('args is ' + str(args))
...     print('kwargs is ' + str(kwargs))
...     print("Hello! Now I'm going to call %s" % f)
...     return f(*args, </strong>kwargs)
...
def g(x, y, z=1):
...     return (x + y) / z
...
say_hello_then_call_f(g, 1, 2, z=5.)
args is (1, 2)
kwargs is {'z': 5.0}
Hello! Now I'm going to call <function g at 0x1040c5950>
0.6
```</p>
</blockquote>
</blockquote>
</blockquote>
</li>
</ul>
</li>
<li>柯里化（currying）：部分参数应用（partial argument application）</li>
</ul>
<div class="highlight"><pre><span></span>def add_numbers(x, y):
        return x + y
add_five = lambda y: add_numbers(5, y)
</pre></div>


<p>add_numbers 的第二个参数称为“柯里化的”。内置的 functools 模块可以用 partial 函数将此过程简化</p>
<div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="n">add_five</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">add_numbers</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
</pre></div>


<ul>
<li>
<p>生成器</p>
<ul>
<li>生成器是构造新的可迭代对象的一种简单方式。一般的函数执行之后会返回单个值，而生成器则是延迟返回一个值序列，即每返回一个值之后暂停，直到下一个值被请求时再继续</li>
<li>要创建一个生成器，只需将函数中的 return 替换为 yield 即可</li>
<li>生成器表达式
```<blockquote>
<blockquote>
<blockquote>
<p>gen = (x ** 2 for x in range(100))
gen
<generator object <genexpr> at 0x1040bbbf8&gt;
sum(gen)
328350
```</p>
</blockquote>
</blockquote>
</blockquote>
</li>
<li>itertools 模块：标准库 iterator 模块中有一组用于许多常见数据算法的生成器。例如，groupby 可以接受任何序列和一个函数。它根据函数的返回值对序列中的连续元素进行分组
```<blockquote>
<blockquote>
<blockquote>
<p>import itertools
first_letter = lambda x: x[0]
names = ['Alan', 'Adam', 'Wes', 'Will', 'Albert', 'Steven']
for letter, names in itertools.groupby(names, first_letter):
...     print(letter + ' ' + str(list(names))) #names 是一个生成器
...
A ['Alan', 'Adam']
W ['Wes', 'Will']
A ['Albert']
S ['Steven']
```</p>
</blockquote>
</blockquote>
</blockquote>
</li>
<li>一些常用的 itertools 函数</li>
</ul>
<table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">imap(func, *iterables)</td>
<td align="left">内置函数 map 的生成器版，将 func 应用于参数序列的各个打包元组</td>
</tr>
<tr>
<td align="left">ifilter(func,iterable)</td>
<td align="left">内置函数 filter 的生成器版，当 func(x)为 True 时输出元素 x</td>
</tr>
<tr>
<td align="left">combinations(iterable,k)</td>
<td align="left">生成一个由 iterable 中所有可能的 k 元元组组成的序列（不考虑顺序）</td>
</tr>
<tr>
<td align="left">permutations(iterable,k)</td>
<td align="left">生成一个由 iterable 中所有可能的 k 元元组组成的序列（考虑顺序）</td>
</tr>
<tr>
<td align="left">groupby(iterable,keyfunc)</td>
<td align="left">为每个唯一键生成一个(key,sub-iterator)</td>
</tr>
</tbody>
</table>
</li>
</ul>
<h2>5. 文件和操作系统</h2>
<ul>
<li>打开</li>
</ul>
<div class="highlight"><pre><span></span>path = &#39;./test.txt&#39;
f = oepn(path)
</pre></div>


<p>默认只读模式（'r'）
- 行迭代</p>
<div class="highlight"><pre><span></span>for lines in f:
        pass
</pre></div>


<ul>
<li>得到没有 EOL</li>
</ul>
<div class="highlight"><pre><span></span>lines = [x.rstrip() for x in open(path)]
</pre></div>


<ul>
<li>文件模式</li>
</ul>
<table>
<thead>
<tr>
<th align="left">模式</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">r</td>
<td align="left">只读</td>
</tr>
<tr>
<td align="left">w</td>
<td align="left">只写。创建新文件（删除同名的任何文件）</td>
</tr>
<tr>
<td align="left">a</td>
<td align="left">附加到现有文件（不存在就创建一个）</td>
</tr>
<tr>
<td align="left">r+</td>
<td align="left">读写模式</td>
</tr>
<tr>
<td align="left">b</td>
<td align="left">附加说明某模式用于二进制文件，即'rb'或'wb'</td>
</tr>
<tr>
<td align="left">U</td>
<td align="left">通用换行模式。单独使用 U 或附加到其他读模式（如'rU'）</td>
</tr>
<tr>
<td align="left">- 写：write 或 writelines</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">- 重要的 Python 文件方法或属性</td>
<td align="left"></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">属性</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">read([size])</td>
<td align="left">以字符串形式返回文件数据，可选的 size 参数用于说明读取的字节数</td>
</tr>
<tr>
<td align="left">readlines([size])</td>
<td align="left">将文件返回为行列表，可选参数 size</td>
</tr>
<tr>
<td align="left">write(str)</td>
<td align="left">将字符串写入文件</td>
</tr>
<tr>
<td align="left">close()</td>
<td align="left">关闭句柄</td>
</tr>
<tr>
<td align="left">flush()</td>
<td align="left">清空内部 I/O 缓存区，并将数据强行写回磁盘</td>
</tr>
<tr>
<td align="left">seek(pos)</td>
<td align="left">移动到指定的文件位置（整数）</td>
</tr>
<tr>
<td align="left">tell()</td>
<td align="left">以整数形式返回当前文件位置</td>
</tr>
<tr>
<td align="left">closed</td>
<td align="left">如果文件已关闭，则为 True</td>
</tr>
</tbody>
</table>
                <aside>
                    <hr />
                    <nav class="older">
                        <h1>
                            <font color="#771515"><em>OLDER</em></font>
                        </h1>
                        <ul>
                            <li>
                                <a href="https://xutree.github.io/pages/2018/11/12/8/">
                                    统计学习方法 第八章 提升方法
                                </a>
                            </li>
                            <li>
                                <a href="https://xutree.github.io/pages/2018/11/12/7_4/">
                                    统计学习方法 第七章 支持向量机（4）——序列最小最优化算法
                                </a>
                            </li>
                            <li>
                                <a href="https://xutree.github.io/pages/2018/11/12/7_3/">
                                    统计学习方法 第七章 支持向量机（3）——非线性支持向量机
                                </a>
                            </li>
                            <li>
                                <a href="https://xutree.github.io/pages/2018/11/11/7_2/">
                                    统计学习方法 第七章 支持向量机（2）——线性支持向量机
                                </a>
                            </li>
                            <li>
                                <a href="https://xutree.github.io/pages/2018/11/11/7_1/">
                                    统计学习方法 第七章 支持向量机（1）——线性可分支持向量机
                                </a>
                            </li>
                        </ul>
                    </nav>
                </aside>
            </div>
            <section>
                <div class="span2" style="float:right;font-size:0.9em;">
                    <h4>发布日期</h4>
                    <time pubdate="pubdate" datetime="2018-11-14T12:32:08+08:00">2018-11-14 12:32:08</time>
                    <h4>最后更新</h4>
                    <div class="last_updated">2018-11-14 12:32:08</div>
                    <h4>分类</h4>
                    <a class="category-link" href="/categories.html#读书笔记-ref">读书笔记</a>
                    <h4>标签</h4>
                    <ul class="list-of-tags tags-in-article">
                        <li><a href="/tags.html#Python-ref">Python
                                <span>1</span>
</a></li>
                    </ul>

                </div>
            </section>
        </div>
</article>
                </div>
                <div class="span1"></div>
            </div>
        </div>
    </div>
<footer>
<div id="footer">
    <ul class="footer-content">
        <li class="elegant-power">Powered by <a href="http://getpelican.com/" title="Pelican Home Page">Pelican</a>. Theme: <a href="http://oncrashreboot.com/pelican-elegant" title="Theme Elegant Home Page">Elegant</a> by <a href="http://oncrashreboot.com" title="Talha Mansoor Home Page">Talha Mansoor</a></li>
    </ul>
</div>
</footer>    <script src="https://code.jquery.com/jquery.min.js"></script>
    <script src="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.1/js/bootstrap.min.js"></script>
    <script>
        function validateForm(query) {
            return (query.length > 0);
        }
    </script>
</body>

</html>