<!DOCTYPE html>
<html lang="en-US">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="author" content="Shu" />
    <meta name="copyright" content="Shu" />

<meta name="keywords" content="剑指offer, 面试, 算法, 读书笔记, " />
    <title>剑指 offer (2)  · You Know Nothing
</title>
    <link rel="stylesheet" type="text/css" href="https://xutree.github.io/theme/css/slim-081711.css" media="screen">
    <link rel="stylesheet" type="text/css" href="https://xutree.github.io/theme/css/bootstrap-combined.min.css" media="screen">
    <link rel="stylesheet" type="text/css" href="https://xutree.github.io/theme/css/style.css" media="screen">
    <link rel="stylesheet" type="text/css" href="https://xutree.github.io/theme/css/solarizedlight.css" media="screen">
</head>

<body>
    <div id="content-sans-footer">
        <div class="navbar navbar-static-top">
            <div class="navbar-inner">
                <div class="container">
                    <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </a>
                    <a class="brand" href="https://xutree.github.io/"><span class=site-name>You Know Nothing</span></a>
                    <div class="nav-collapse collapse">
                        <ul class="nav pull-right top-menu">
                            <li ><a href="https://xutree.github.io/index.html">主页</a></li>
                            <li ><a href="https://xutree.github.io/categories.html">分类</a></li>
                            <li ><a href="https://xutree.github.io/tags.html">标签</a></li>
                            <li ><a href="https://xutree.github.io/archives.html">归档</a></li>
                            <li>
                                <form class="navbar-search" action="https://xutree.github.io/search.html" onsubmit="return validateForm(this.elements['q'].value);"> <input type="text" class="search-query" placeholder="关键字搜索" name="q" id="tipue_search_input"></form>
                            </li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
        <div class="container-fluid">
            <div class="row-fluid">
                <div class="span1"></div>
                <div class="span10">
<article>
    <div class="row-fluid">
        <header class="page_header span10 offset2">
            <h1><a href="https://xutree.github.io/pages/2018/10/08/jzoffer2/"> 剑指 offer (2)  </a></h1>
        </header>
    </div>

    <div class="row-fluid">
        <!--  -->
        <div class="span2" style="float:left;font-size:1em;">
            <nav>
                <!-- <h4>目录</h4> -->
                <div class="toc">
<ul>
<li><a href="#1-1">1. 整数中 1 出现的次数</a></li>
<li><a href="#2">2. 把数组排成最小的数</a></li>
<li><a href="#3">3. 丑数</a></li>
<li><a href="#4">4. 第一个只出现一次的字符</a></li>
<li><a href="#5">5. 数组中的逆序对</a></li>
<li><a href="#6">6. 两个链表的第一个公共结点</a></li>
<li><a href="#7">7. 数字在排序数组中出现的次数</a></li>
<li><a href="#8">8. 二叉树的深度</a></li>
<li><a href="#9">9. 平衡二叉树</a></li>
<li><a href="#10">10. 只出现一次的数字</a></li>
<li><a href="#11-s">11. 和为 \(S\) 的连续正数序列</a></li>
<li><a href="#12-s">12. 和为 \(S\) 的两个数字</a></li>
<li><a href="#13">13. 左旋转字符串</a></li>
<li><a href="#14">14. 翻转单词顺序列</a></li>
<li><a href="#15">15. 扑克牌顺子</a></li>
<li><a href="#16">16. 孩子们的游戏（圆圈中最后剩下的数）</a></li>
<li><a href="#17-123n">17. 求 \(1+2+3+...+n\)</a></li>
<li><a href="#18">18. 不用加减乘除做加法</a></li>
<li><a href="#19">19. 将一个字符串转换成一个整数</a></li>
<li><a href="#20">20. 数组中重复的数字</a></li>
<li><a href="#21">21. 构建乘积数组</a></li>
<li><a href="#22">22. 正则表达式匹配</a></li>
<li><a href="#23">23. 表示数值的字符串</a></li>
<li><a href="#24">24. 字符流中第一个只出现一次的字符</a></li>
<li><a href="#25">25. 链表中环入口</a></li>
<li><a href="#26">26. 删除链表中重复的结点</a></li>
<li><a href="#27">27. 二叉树的下一个结点</a></li>
<li><a href="#28">28. 对称的二叉树</a></li>
<li><a href="#29">29. 按照之字形打印二叉树</a></li>
<li><a href="#30">30. 把二叉树打印出多行</a></li>
<li><a href="#31">31. 序列化二叉树</a></li>
<li><a href="#32-k">32. 二叉搜索树的第 \(k\) 个结点</a></li>
<li><a href="#33">33. 数据流中的中位数</a></li>
<li><a href="#34">34. 滑动窗口的最大值</a></li>
<li><a href="#35">35. 矩阵中的路径</a></li>
<li><a href="#37">37. 机器人的运动范围</a></li>
</ul>
</div>
            </nav>
        </div>
        <div class="span8 article-content">

                
<h2 id="1-1">1. 整数中 1 出现的次数</h2>
<p>求出 1~13 的整数中 1 出现的次数，并算出 100~1300 的整数中 1 出现的次数？为此他特别数了一下 1~13 中包含 1 的数字有 1、10、11、12、13 因此共出现 6 次，但是对于后面问题他就没辙了。ACMer 希望你们帮帮他，并把问题更加普遍化，可以很快的求出任意非负整数区间中 1 出现的次数（从 1 到 <span class="math">\(n\)</span> 中 1 出现的次数）。</p>
<div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">Solution</span> <span class="p">{</span>
<span class="kr">public</span><span class="o">:</span>
    <span class="kr">int</span> <span class="nx">NumberOf1Between1AndN_Solution</span><span class="p">(</span><span class="kr">int</span> <span class="nx">n</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kr">long</span> <span class="nx">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="kr">long</span> <span class="nx">before</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">current</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">after</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="nx">n</span> <span class="o">/</span> <span class="nx">i</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">before</span> <span class="o">=</span> <span class="nx">n</span> <span class="o">/</span> <span class="p">(</span><span class="nx">i</span> <span class="o">*</span> <span class="mi">10</span><span class="p">);</span>
            <span class="nx">current</span> <span class="o">=</span> <span class="p">(</span><span class="nx">n</span> <span class="o">/</span> <span class="nx">i</span><span class="p">)</span> <span class="o">%</span> <span class="mi">10</span><span class="p">;</span>
            <span class="nx">after</span> <span class="o">=</span> <span class="nx">n</span> <span class="o">-</span> <span class="p">(</span><span class="nx">n</span> <span class="o">/</span> <span class="nx">i</span><span class="p">)</span> <span class="o">*</span> <span class="nx">i</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">current</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
                <span class="nx">count</span> <span class="o">+=</span> <span class="nx">before</span> <span class="o">*</span> <span class="nx">i</span> <span class="o">+</span> <span class="nx">i</span><span class="p">;</span>
            <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">current</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
                <span class="nx">count</span> <span class="o">+=</span> <span class="nx">before</span> <span class="o">*</span> <span class="nx">i</span><span class="p">;</span>
            <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">current</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
                <span class="nx">count</span> <span class="o">+=</span> <span class="nx">before</span> <span class="o">*</span> <span class="nx">i</span> <span class="o">+</span> <span class="nx">after</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="nx">i</span> <span class="o">*=</span> <span class="mi">10</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">count</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
<h2 id="2">2. 把数组排成最小的数</h2>
<p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组 {3，32，321}，则打印出这三个数字能排成的最小数字为 321323。</p>
<div class="highlight"><pre><span></span><span class="c1">// #include &lt;sstream&gt;</span>
<span class="nx">template</span><span class="o">&lt;</span><span class="kr">class</span> <span class="nx">T</span><span class="o">&gt;</span>
<span class="kt">string</span> <span class="nx">ToString</span><span class="p">(</span><span class="kr">const</span> <span class="nx">T</span><span class="o">&amp;</span> <span class="nx">t</span><span class="p">)</span> <span class="p">{</span>

    <span class="nx">ostringstream</span> <span class="nx">oss</span><span class="p">;</span>  <span class="c1">//  创建一个流</span>
    <span class="nx">oss</span> <span class="o">&lt;&lt;</span> <span class="nx">t</span><span class="p">;</span>            <span class="c1">//  把值传递如流中</span>
    <span class="k">return</span> <span class="nx">oss</span><span class="p">.</span><span class="nx">str</span><span class="p">();</span>  <span class="c1">//  获取转换后的字符转并将其写入 result</span>
<span class="p">}</span>

<span class="kr">class</span> <span class="nx">Solution</span> <span class="p">{</span>
<span class="kr">public</span><span class="o">:</span>
    <span class="c1">///  比较函数</span>
    <span class="c1">//  我们比较的不是两个字符串本身的大小，而是他们拼接后的两个数字的大小</span>
    <span class="kr">static</span> <span class="kt">bool</span> <span class="nx">Compare</span><span class="p">(</span><span class="kr">const</span> <span class="kt">string</span> <span class="o">&amp;</span><span class="nx">left</span><span class="p">,</span> <span class="kr">const</span> <span class="kt">string</span> <span class="o">&amp;</span><span class="nx">right</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">string</span> <span class="nx">leftright</span> <span class="o">=</span> <span class="nx">left</span> <span class="o">+</span> <span class="nx">right</span><span class="p">;</span>
        <span class="kt">string</span> <span class="nx">rightleft</span> <span class="o">=</span> <span class="nx">right</span> <span class="o">+</span> <span class="nx">left</span><span class="p">;</span>
        <span class="k">return</span> <span class="nx">leftright</span> <span class="o">&lt;</span> <span class="nx">rightleft</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">string</span> <span class="nx">PrintMinNumber</span><span class="p">(</span><span class="nx">vector</span><span class="o">&lt;</span><span class="kr">int</span><span class="o">&gt;</span> <span class="nx">numbers</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">string</span> <span class="nx">res</span> <span class="o">=</span> <span class="s2">""</span><span class="p">;</span>
        <span class="kt">string</span> <span class="nx">str</span><span class="p">;</span>

        <span class="nx">vector</span><span class="o">&lt;</span><span class="kt">string</span><span class="o">&gt;</span> <span class="nx">strNum</span><span class="p">;</span>

        <span class="c1">///  将整数转换成字符串</span>
        <span class="k">for</span><span class="p">(</span><span class="nx">unsigned</span> <span class="kr">int</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">numbers</span><span class="p">.</span><span class="nx">size</span><span class="p">();</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">str</span> <span class="o">=</span> <span class="nx">ToString</span><span class="p">(</span><span class="nx">numbers</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
            <span class="nx">strNum</span><span class="p">.</span><span class="nx">push_back</span><span class="p">(</span><span class="nx">str</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">///  对字符串按照拼接后的大小进行排序</span>
        <span class="c1">// #include &lt;algorithm&gt;</span>
        <span class="nx">sort</span><span class="p">(</span><span class="nx">strNum</span><span class="p">.</span><span class="nx">begin</span><span class="p">(),</span> <span class="nx">strNum</span><span class="p">.</span><span class="nx">end</span><span class="p">(),</span> <span class="nx">Compare</span><span class="p">);</span>

        <span class="c1">///  拼接结果</span>
        <span class="k">for</span><span class="p">(</span><span class="nx">unsigned</span> <span class="kr">int</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">strNum</span><span class="p">.</span><span class="nx">size</span><span class="p">();</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span>
            <span class="nx">res</span> <span class="o">+=</span> <span class="nx">strNum</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
        <span class="k">return</span> <span class="nx">res</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
<h2 id="3">3. 丑数</h2>
<p>把只包含质因子 2、3 和 5的数称作丑数（Ugly Number）。例如 6、8 都是丑数，但 14 不是，因为它包含质因子 7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第 <span class="math">\(N\)</span> 个丑数。</p>
<div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">Solution</span> <span class="p">{</span>
<span class="c1">// 自己添加</span>
<span class="kr">protected</span><span class="o">:</span>
    <span class="kr">int</span> <span class="nx">ugly</span><span class="p">[</span><span class="mi">10000</span><span class="p">];</span>
    <span class="kr">int</span> <span class="nx">min</span><span class="p">(</span><span class="kr">int</span> <span class="nx">a</span><span class="p">,</span> <span class="kr">int</span> <span class="nx">b</span><span class="p">,</span> <span class="kr">int</span> <span class="nx">c</span><span class="p">)</span> <span class="p">{</span>
        <span class="kr">int</span> <span class="nx">temp</span> <span class="o">=</span> <span class="p">(</span><span class="nx">a</span> <span class="o">&lt;</span> <span class="nx">b</span> <span class="o">?</span> <span class="nx">a</span> : <span class="kt">b</span><span class="p">);</span>
        <span class="k">return</span> <span class="p">(</span><span class="nx">temp</span> <span class="o">&lt;</span> <span class="nx">c</span> <span class="o">?</span> <span class="nx">temp</span> : <span class="kt">c</span><span class="p">);</span>
    <span class="p">}</span>
<span class="kr">public</span><span class="o">:</span>
    <span class="kr">int</span> <span class="nx">GetUglyNumber_Solution</span><span class="p">(</span><span class="kr">int</span> <span class="nx">index</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">ugly</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="kr">int</span> <span class="nx">index2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kr">int</span> <span class="nx">index3</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kr">int</span> <span class="nx">index5</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kr">int</span> <span class="nx">n</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="nx">n</span> <span class="o">&lt;</span> <span class="nx">index</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">//竞争产生下一个丑数</span>
            <span class="kr">int</span> <span class="nx">val</span> <span class="o">=</span> <span class="nx">min</span><span class="p">(</span><span class="nx">ugly</span><span class="p">[</span><span class="nx">index2</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="nx">ugly</span><span class="p">[</span><span class="nx">index3</span><span class="p">]</span><span class="o">*</span><span class="mi">3</span><span class="p">,</span> <span class="nx">ugly</span><span class="p">[</span><span class="nx">index5</span><span class="p">]</span><span class="o">*</span><span class="mi">5</span><span class="p">);</span>

            <span class="k">if</span> <span class="p">(</span><span class="nx">val</span> <span class="o">==</span> <span class="nx">ugly</span><span class="p">[</span><span class="nx">index2</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">//将产生这个丑数的index*向后挪一位；</span>
                <span class="o">++</span><span class="nx">index2</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">val</span> <span class="o">==</span> <span class="nx">ugly</span><span class="p">[</span><span class="nx">index3</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>   <span class="c1">//这里不能用elseif，因为可能有两个最小值，这时都要挪动；</span>
                <span class="o">++</span><span class="nx">index3</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">val</span> <span class="o">==</span> <span class="nx">ugly</span><span class="p">[</span><span class="nx">index5</span><span class="p">]</span> <span class="o">*</span> <span class="mi">5</span><span class="p">)</span>
                <span class="o">++</span><span class="nx">index5</span><span class="p">;</span>
            <span class="nx">ugly</span><span class="p">[</span><span class="nx">n</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="nx">val</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="kr">int</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">ugly</span><span class="p">[</span><span class="nx">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
        <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
<h2 id="4">4. 第一个只出现一次的字符</h2>
<p>在一个字符串（0&lt;= 字符串长度 &lt;= 10000，全部由字母组成）中找到第一个只出现一次的字符，并返回它的位置，如果没有则返回 -1（需要区分大小写）。</p>
<div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">Solution</span> <span class="p">{</span>
<span class="kr">public</span><span class="o">:</span>
    <span class="kr">int</span> <span class="nx">FirstNotRepeatingChar</span><span class="p">(</span><span class="kt">string</span> <span class="nx">str</span><span class="p">)</span> <span class="p">{</span>
        <span class="kr">int</span> <span class="nx">x</span><span class="p">[</span><span class="mi">26</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">},</span> <span class="nx">y</span><span class="p">[</span><span class="mi">26</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>

        <span class="k">for</span><span class="p">(</span><span class="nx">unsigned</span> <span class="kr">int</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">str</span><span class="p">.</span><span class="nx">size</span><span class="p">();</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">//  小写字母</span>
            <span class="k">if</span><span class="p">(</span><span class="s1">'a'</span> <span class="o">&lt;=</span> <span class="nx">str</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="nx">str</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="s1">'z'</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span><span class="p">(</span><span class="nx">x</span><span class="p">[</span><span class="nx">str</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">-</span> <span class="s1">'a'</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                    <span class="c1">//  首次出现保存出现位置</span>
                    <span class="nx">x</span><span class="p">[</span><span class="nx">str</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">-</span> <span class="s1">'a'</span><span class="p">]</span> <span class="o">=</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="c1">//  出现多次, 就置标识-1</span>
                    <span class="nx">x</span><span class="p">[</span><span class="nx">str</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">-</span> <span class="s1">'a'</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="s1">'A'</span> <span class="o">&lt;=</span> <span class="nx">str</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="nx">str</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="s1">'Z'</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span><span class="p">(</span><span class="nx">y</span><span class="p">[</span><span class="nx">str</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">-</span> <span class="s1">'A'</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
                     <span class="c1">//  首次出现保存出现位置</span>
                     <span class="nx">y</span><span class="p">[</span><span class="nx">str</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">-</span> <span class="s1">'A'</span><span class="p">]</span><span class="o">=</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="c1">//  出现多次, 就置标识-1</span>
                    <span class="nx">y</span><span class="p">[</span><span class="nx">str</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">-</span> <span class="s1">'A'</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">//  由于标识数组中</span>
        <span class="c1">//  只出现一次的字符会存储出现的位置</span>
        <span class="c1">//  出现多次的字符就存储标识-1</span>
        <span class="c1">//  因此查找数组中非-1的最小值即可</span>
        <span class="kr">int</span> <span class="nx">res</span> <span class="o">=</span> <span class="nx">INT_MAX</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kr">int</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">26</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="nx">x</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">x</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="nx">res</span> <span class="o">=</span> <span class="nx">min</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span> <span class="nx">x</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
            <span class="p">}</span>
            <span class="k">if</span><span class="p">(</span><span class="nx">y</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">y</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="nx">res</span> <span class="o">=</span> <span class="nx">min</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span> <span class="nx">y</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">res</span> <span class="o">&gt;</span> <span class="nx">str</span><span class="p">.</span><span class="nx">size</span><span class="p">()</span> <span class="o">?</span> <span class="o">-</span><span class="nx">1</span> : <span class="kt">res</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
<h2 id="5">5. 数组中的逆序对</h2>
<p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数 <span class="math">\(P\)</span>。并将 <span class="math">\(P\)</span> 对 1000000007 取模的结果输出。 即输出 <code>P % 1000000007</code>。</p>
<div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">Solution</span> <span class="p">{</span>
<span class="kr">public</span><span class="o">:</span>
    <span class="kr">int</span> <span class="nx">InversePairs</span><span class="p">(</span><span class="nx">vector</span><span class="o">&lt;</span><span class="kr">int</span><span class="o">&gt;</span> <span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">data</span><span class="p">.</span><span class="nx">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="nx">vector</span><span class="o">&lt;</span><span class="kr">int</span><span class="o">&gt;</span> <span class="nx">temp</span><span class="p">(</span><span class="nx">data</span><span class="p">.</span><span class="nx">size</span><span class="p">());</span>
        <span class="kr">long</span> <span class="kr">long</span> <span class="nx">sum</span> <span class="o">=</span> <span class="nx">CountMergePairs</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">data</span><span class="p">.</span><span class="nx">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">temp</span><span class="p">);</span>
        <span class="k">return</span> <span class="nx">sum</span> <span class="o">%</span> <span class="mi">1000000007</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kr">long</span> <span class="kr">long</span> <span class="nx">CountMergePairs</span><span class="p">(</span><span class="nx">vector</span><span class="o">&lt;</span><span class="kr">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="nx">data</span><span class="p">,</span> <span class="kr">int</span> <span class="nx">start</span><span class="p">,</span> <span class="kr">int</span> <span class="nx">end</span><span class="p">,</span> <span class="nx">vector</span><span class="o">&lt;</span><span class="kr">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="nx">temp</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kr">long</span> <span class="kr">long</span> <span class="nx">PairsNum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">start</span> <span class="o">&lt;</span> <span class="nx">end</span><span class="p">)</span> <span class="p">{</span>
            <span class="kr">int</span> <span class="nx">mid</span> <span class="o">=</span> <span class="p">(</span><span class="nx">start</span> <span class="o">+</span> <span class="nx">end</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
            <span class="nx">PairsNum</span> <span class="o">+=</span> <span class="nx">CountMergePairs</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="nx">start</span><span class="p">,</span> <span class="nx">mid</span><span class="p">,</span> <span class="nx">temp</span><span class="p">);</span>    <span class="c1">//统计左边子数组的逆序对</span>
            <span class="nx">PairsNum</span> <span class="o">+=</span> <span class="nx">CountMergePairs</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="nx">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">end</span><span class="p">,</span> <span class="nx">temp</span><span class="p">);</span>  <span class="c1">//统计右边子数组的逆序对</span>
            <span class="nx">PairsNum</span> <span class="o">+=</span> <span class="nx">MergePairsBetweenArray</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="nx">start</span><span class="p">,</span> <span class="nx">mid</span><span class="p">,</span> <span class="nx">end</span><span class="p">,</span> <span class="nx">temp</span><span class="p">);</span> <span class="c1">//统计左右子数组间的逆序对</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">PairsNum</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kr">long</span> <span class="kr">long</span> <span class="nx">MergePairsBetweenArray</span><span class="p">(</span><span class="nx">vector</span><span class="o">&lt;</span><span class="kr">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="nx">data</span><span class="p">,</span> <span class="kr">int</span> <span class="nx">start</span><span class="p">,</span> <span class="kr">int</span> <span class="nx">mid</span><span class="p">,</span> <span class="kr">int</span> <span class="nx">end</span><span class="p">,</span> <span class="nx">vector</span><span class="o">&lt;</span><span class="kr">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="nx">temp</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kr">int</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">start</span><span class="p">;</span>
        <span class="kr">int</span> <span class="nx">j</span> <span class="o">=</span> <span class="nx">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="kr">int</span> <span class="nx">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">//辅助数组的最后一位</span>
        <span class="kr">long</span> <span class="kr">long</span> <span class="nx">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="c1">//设置两个指针i,j分别从右往左依次比较，</span>
        <span class="c1">//将较大的依次放入辅助数组的右边</span>
        <span class="k">while</span><span class="p">(</span><span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">mid</span> <span class="o">&amp;&amp;</span> <span class="nx">j</span> <span class="o">&lt;=</span> <span class="nx">end</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="nx">data</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nx">data</span><span class="p">[</span><span class="nx">j</span><span class="p">])</span> <span class="p">{</span>
                <span class="nx">count</span> <span class="o">+=</span> <span class="nx">mid</span> <span class="o">-</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
                <span class="nx">temp</span><span class="p">[</span><span class="nx">k</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="nx">data</span><span class="p">[</span><span class="nx">j</span><span class="o">++</span><span class="p">];</span>
            <span class="p">}</span> <span class="k">else</span>
                <span class="nx">temp</span><span class="p">[</span><span class="nx">k</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="nx">data</span><span class="p">[</span><span class="nx">i</span><span class="o">++</span><span class="p">];</span>
        <span class="p">}</span>

        <span class="c1">//将其中一个数组中还剩下的元素拷贝到辅助数组中，</span>
        <span class="c1">//两个循环只会执行其中的一个</span>
        <span class="k">while</span><span class="p">(</span><span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">mid</span><span class="p">)</span>
            <span class="nx">temp</span><span class="p">[</span><span class="nx">k</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="nx">data</span><span class="p">[</span><span class="nx">i</span><span class="o">++</span><span class="p">];</span>
        <span class="k">while</span><span class="p">(</span><span class="nx">j</span> <span class="o">&lt;=</span> <span class="nx">end</span><span class="p">)</span>
            <span class="nx">temp</span><span class="p">[</span><span class="nx">k</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="nx">data</span><span class="p">[</span><span class="nx">j</span><span class="o">++</span><span class="p">];</span>

        <span class="c1">//从辅助数组中将元素拷贝到原数组中，使其有序排列</span>
        <span class="k">for</span><span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">k</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span>
            <span class="nx">data</span><span class="p">[</span><span class="nx">start</span> <span class="o">+</span> <span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">temp</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>

        <span class="k">return</span> <span class="nx">count</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
<h2 id="6">6. 两个链表的第一个公共结点</h2>
<p>输入两个链表，找出它们的第一个公共结点。</p>
<div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm">struct ListNode {</span>
<span class="cm">    int val;</span>
<span class="cm">    struct ListNode *next;</span>
<span class="cm">    ListNode(int x) :</span>
<span class="cm">            val(x), next(NULL) {</span>
<span class="cm">    }</span>
<span class="cm">};*/</span>
<span class="kr">class</span> <span class="nx">Solution</span> <span class="p">{</span>
<span class="kr">public</span><span class="o">:</span>
    <span class="nx">ListNode</span><span class="o">*</span> <span class="nx">FindFirstCommonNode</span><span class="p">(</span> <span class="nx">ListNode</span><span class="o">*</span> <span class="nx">pHead1</span><span class="p">,</span> <span class="nx">ListNode</span><span class="o">*</span> <span class="nx">pHead2</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">unordered_map</span><span class="o">&lt;</span><span class="nx">ListNode</span><span class="o">*</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="nx">umap</span><span class="p">;</span>

        <span class="nx">ListNode</span><span class="o">*</span> <span class="nx">left</span> <span class="o">=</span> <span class="nx">pHead1</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="nx">left</span> <span class="o">!=</span> <span class="nx">NULL</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="nx">umap</span><span class="p">.</span><span class="nx">insert</span><span class="p">(</span><span class="nx">make_pair</span><span class="p">(</span><span class="nx">left</span><span class="p">,</span> <span class="mi">1</span> <span class="p">));</span>
            <span class="nx">left</span> <span class="o">=</span> <span class="nx">left</span><span class="o">-&gt;</span><span class="nx">next</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="nx">ListNode</span><span class="o">*</span> <span class="nx">right</span> <span class="o">=</span> <span class="nx">pHead2</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="nx">right</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">umap</span><span class="p">.</span><span class="nx">count</span><span class="p">(</span><span class="nx">right</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">return</span> <span class="nx">right</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="nx">right</span> <span class="o">=</span> <span class="nx">right</span><span class="o">-&gt;</span><span class="nx">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">NULL</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
<h2 id="7">7. 数字在排序数组中出现的次数</h2>
<p>统计一个数字在排序数组中出现的次数。</p>
<div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">Solution</span> <span class="p">{</span>
<span class="kr">public</span><span class="o">:</span>
    <span class="kr">int</span> <span class="nx">GetNumberOfK</span><span class="p">(</span><span class="nx">vector</span><span class="o">&lt;</span><span class="kr">int</span><span class="o">&gt;</span> <span class="nx">data</span> <span class="p">,</span><span class="kr">int</span> <span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">data</span><span class="p">.</span><span class="nx">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kr">int</span> <span class="nx">index</span> <span class="o">=</span> <span class="nx">BinarySearch</span><span class="p">(</span><span class="nx">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">data</span><span class="p">.</span><span class="nx">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">k</span><span class="p">);</span>
        <span class="kr">int</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">index</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="nx">index</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">data</span><span class="p">.</span><span class="nx">size</span><span class="p">();</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="nx">data</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="nx">k</span><span class="p">)</span>
                    <span class="nx">res</span><span class="o">++</span><span class="p">;</span>
                <span class="k">else</span>
                    <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">for</span> <span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="nx">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="nx">data</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="nx">k</span><span class="p">)</span>
                    <span class="nx">res</span><span class="o">++</span><span class="p">;</span>
                <span class="k">else</span>
                    <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">res</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kr">int</span> <span class="nx">BinarySearch</span><span class="p">(</span><span class="nx">vector</span><span class="o">&lt;</span><span class="kr">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="nx">data</span><span class="p">,</span> <span class="kr">int</span> <span class="nx">low</span><span class="p">,</span> <span class="kr">int</span> <span class="nx">high</span><span class="p">,</span> <span class="kr">int</span> <span class="nx">k</span><span class="p">)</span> <span class="p">{</span>
        <span class="kr">int</span> <span class="nx">mid</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="nx">low</span> <span class="o">&lt;=</span> <span class="nx">high</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">mid</span> <span class="o">=</span> <span class="p">(</span><span class="nx">low</span> <span class="o">+</span> <span class="nx">high</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">data</span><span class="p">[</span><span class="nx">mid</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nx">k</span><span class="p">)</span>
                <span class="nx">high</span> <span class="o">=</span> <span class="nx">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
            <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">data</span><span class="p">[</span><span class="nx">mid</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">k</span><span class="p">)</span>
                <span class="nx">low</span> <span class="o">=</span> <span class="nx">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="k">else</span>
                <span class="k">return</span> <span class="nx">mid</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
<h2 id="8">8. 二叉树的深度</h2>
<p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p>
<div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm">struct TreeNode {</span>
<span class="cm">    int val;</span>
<span class="cm">    struct TreeNode *left;</span>
<span class="cm">    struct TreeNode *right;</span>
<span class="cm">    TreeNode(int x) :</span>
<span class="cm">            val(x), left(NULL), right(NULL) {</span>
<span class="cm">    }</span>
<span class="cm">};*/</span>
<span class="kr">class</span> <span class="nx">Solution</span> <span class="p">{</span>
<span class="kr">public</span><span class="o">:</span>
    <span class="kr">int</span> <span class="nx">TreeDepth</span><span class="p">(</span><span class="nx">TreeNode</span><span class="o">*</span> <span class="nx">pRoot</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nx">TreeDepthRecursion</span><span class="p">(</span><span class="nx">pRoot</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kr">int</span> <span class="nx">TreeDepthRecursion</span><span class="p">(</span><span class="nx">TreeNode</span> <span class="o">*</span><span class="nx">root</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">root</span> <span class="o">==</span> <span class="nx">NULL</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="kr">int</span> <span class="nx">leftDepth</span> <span class="o">=</span> <span class="nx">TreeDepthRecursion</span><span class="p">(</span><span class="nx">root</span><span class="o">-&gt;</span><span class="nx">left</span><span class="p">);</span>
            <span class="kr">int</span> <span class="nx">rightDepth</span> <span class="o">=</span> <span class="nx">TreeDepthRecursion</span><span class="p">(</span><span class="nx">root</span><span class="o">-&gt;</span><span class="nx">right</span><span class="p">);</span>

            <span class="k">return</span> <span class="nx">max</span><span class="p">(</span><span class="nx">leftDepth</span><span class="p">,</span> <span class="nx">rightDepth</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

<span class="p">};</span>
</pre></div>
<h2 id="9">9. 平衡二叉树</h2>
<p>输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p>
<div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">Solution</span> <span class="p">{</span>
<span class="kr">public</span><span class="o">:</span>
    <span class="kt">bool</span> <span class="nx">IsBalanced_Solution</span><span class="p">(</span><span class="nx">TreeNode</span><span class="o">*</span> <span class="nx">pRoot</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">pRoot</span> <span class="o">==</span> <span class="nx">NULL</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
        <span class="c1">//int leftDepth = TreeDepth(pRoot-&gt;left);</span>
        <span class="c1">//int rightDepth = TreeDepth(pRoot-&gt;right);</span>

        <span class="c1">//if(fabs(leftDepth - rightDepth) &lt;= 1)</span>
        <span class="c1">//    return IsBalanced_Solution(pRoot-&gt;left) &amp;&amp; IsBalanced_Solution(pRoot-&gt;right);</span>
        <span class="c1">//else</span>
        <span class="c1">//    return false;</span>
        <span class="kr">int</span> <span class="nx">depth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">return</span> <span class="nx">IsVALWithDepth</span><span class="p">(</span><span class="nx">pRoot</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">depth</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kr">int</span> <span class="nx">TreeDepth</span><span class="p">(</span><span class="nx">TreeNode</span> <span class="o">*</span><span class="nx">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">root</span> <span class="o">==</span> <span class="nx">NULL</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

    <span class="kr">int</span> <span class="nx">leftDepth</span> <span class="o">=</span> <span class="nx">TreeDepth</span><span class="p">(</span><span class="nx">root</span><span class="o">-&gt;</span><span class="nx">left</span><span class="p">);</span>
    <span class="kr">int</span> <span class="nx">rightDepth</span> <span class="o">=</span> <span class="nx">TreeDepth</span><span class="p">(</span><span class="nx">root</span><span class="o">-&gt;</span><span class="nx">right</span><span class="p">);</span>

    <span class="c1">//  返回左右子树中深度最深的</span>
    <span class="k">return</span> <span class="nx">max</span><span class="p">(</span><span class="nx">leftDepth</span><span class="p">,</span> <span class="nx">rightDepth</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="nx">IsVALWithDepth</span><span class="p">(</span><span class="nx">TreeNode</span> <span class="o">*</span><span class="nx">root</span><span class="p">,</span> <span class="kr">int</span> <span class="o">*</span><span class="nx">depth</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">root</span> <span class="o">==</span> <span class="nx">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="o">*</span><span class="nx">depth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kr">int</span> <span class="nx">leftDepth</span><span class="p">,</span> <span class="nx">rightDepth</span><span class="p">;</span>

        <span class="kt">bool</span> <span class="nx">left</span> <span class="o">=</span> <span class="nx">IsVALWithDepth</span><span class="p">(</span><span class="nx">root</span><span class="o">-&gt;</span><span class="nx">left</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">leftDepth</span><span class="p">);</span>
        <span class="kt">bool</span> <span class="nx">right</span> <span class="o">=</span> <span class="nx">IsVALWithDepth</span><span class="p">(</span><span class="nx">root</span><span class="o">-&gt;</span><span class="nx">right</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">rightDepth</span><span class="p">);</span>

        <span class="k">if</span><span class="p">(</span><span class="nx">left</span> <span class="o">==</span> <span class="kc">true</span> <span class="o">&amp;&amp;</span> <span class="nx">right</span> <span class="o">==</span> <span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="nx">fabs</span><span class="p">(</span><span class="nx">leftDepth</span> <span class="o">-</span> <span class="nx">rightDepth</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="o">*</span><span class="nx">depth</span> <span class="o">=</span> <span class="nx">max</span><span class="p">(</span><span class="nx">leftDepth</span><span class="p">,</span> <span class="nx">rightDepth</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
                <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
<p><strong>思路</strong>：1. 首先得到二叉树的深度，然后递归的判断每个节点的左右子树是否满足平衡条件；2. 这个递归法有很大缺陷，在求该结点的的左右子树深度时遍历一遍树，再次判断子树的平衡性时又遍历一遍树结构，造成遍历多次。我们在递归的过程中用 depth 来保存层数，然后递归的过程中同步遍历。</p>
<h2 id="10">10. 只出现一次的数字</h2>
<p>一个整型数组里除了两个数字之外，其他的数字都出现了偶数次。请写程序找出这两个只出现一次的数字。</p>
<div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">Solution</span> <span class="p">{</span>
<span class="kr">public</span><span class="o">:</span>
    <span class="k">void</span> <span class="nx">FindNumsAppearOnce</span><span class="p">(</span><span class="nx">vector</span><span class="o">&lt;</span><span class="kr">int</span><span class="o">&gt;</span> <span class="nx">data</span><span class="p">,</span><span class="kr">int</span><span class="o">*</span> <span class="nx">num1</span><span class="p">,</span><span class="kr">int</span> <span class="o">*</span><span class="nx">num2</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 注意星号！！！</span>
        <span class="o">*</span><span class="nx">num1</span> <span class="o">=</span> <span class="o">*</span><span class="nx">num2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">data</span><span class="p">.</span><span class="nx">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="kr">int</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">data</span><span class="p">.</span><span class="nx">size</span><span class="p">();</span>
        <span class="kr">int</span> <span class="nx">XOR</span> <span class="o">=</span> <span class="nx">data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="k">for</span> <span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span>
            <span class="nx">XOR</span> <span class="o">^=</span> <span class="nx">data</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
        <span class="kr">int</span> <span class="nx">flag</span> <span class="o">=</span> <span class="nx">XOR</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">-</span><span class="nx">XOR</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 注意加括号，先算术运算，后移位运算，最后位运算。</span>
            <span class="k">if</span> <span class="p">((</span><span class="nx">data</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="nx">flag</span><span class="p">)</span> <span class="o">==</span> <span class="nx">flag</span><span class="p">)</span>
                <span class="o">*</span><span class="nx">num1</span> <span class="o">^=</span> <span class="nx">data</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
            <span class="k">else</span>
                <span class="o">*</span><span class="nx">num2</span> <span class="o">^=</span> <span class="nx">data</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
<h2 id="11-s">11. 和为 <span class="math">\(S\)</span> 的连续正数序列</h2>
<p>小明很喜欢数学,有一天他在做数学作业时,要求计算出 9~16 的和,他马上就写出了正确答案是 100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为 100（至少包括两个数）。没多久,他就得到另一组连续正数和为 100 的序列：18，19，20，21，22。现在把问题交给你,你能不能也很快的找出所有和为 <span class="math">\(S\)</span> 的连续正数序列? Good Luck!</p>
<div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">Solution</span> <span class="p">{</span>
<span class="kr">public</span><span class="o">:</span>
    <span class="nx">vector</span><span class="o">&lt;</span><span class="nx">vector</span><span class="o">&lt;</span><span class="kr">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="nx">FindContinuousSequence</span><span class="p">(</span><span class="kr">int</span> <span class="nx">sum</span><span class="p">)</span> <span class="p">{</span>
        <span class="kr">int</span> <span class="nx">l</span><span class="p">,</span> <span class="nx">r</span><span class="p">,</span> <span class="nx">s</span><span class="p">;</span>
        <span class="nx">vector</span><span class="o">&lt;</span><span class="nx">vector</span><span class="o">&lt;</span><span class="kr">int</span><span class="o">&gt;&gt;</span> <span class="nx">res</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="nx">l</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">r</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="nx">l</span> <span class="o">&lt;</span> <span class="p">(</span><span class="nx">sum</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="nx">r</span> <span class="o">&lt;</span> <span class="nx">sum</span><span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
            <span class="nx">s</span> <span class="o">=</span> <span class="p">(</span><span class="nx">r</span> <span class="o">-</span> <span class="nx">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="p">(</span><span class="nx">l</span> <span class="o">+</span> <span class="nx">r</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">s</span> <span class="o">&lt;</span> <span class="nx">sum</span><span class="p">)</span>
                <span class="nx">r</span><span class="o">++</span><span class="p">;</span>
            <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">s</span> <span class="o">&gt;</span> <span class="nx">sum</span><span class="p">)</span>
                <span class="nx">l</span><span class="o">++</span><span class="p">;</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="nx">vector</span><span class="o">&lt;</span><span class="kr">int</span><span class="o">&gt;</span> <span class="nx">temp</span><span class="p">;</span>
                <span class="k">for</span> <span class="p">(</span><span class="kr">int</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">l</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">r</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                    <span class="nx">temp</span><span class="p">.</span><span class="nx">push_back</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="nx">res</span><span class="p">.</span><span class="nx">push_back</span><span class="p">(</span><span class="nx">temp</span><span class="p">);</span>
                <span class="nx">l</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span>  
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">res</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
<p><strong>思路</strong>：滑动窗口法。</p>
<h2 id="12-s">12. 和为 <span class="math">\(S\)</span> 的两个数字</h2>
<p>输入一个递增排序的数组和一个数字 <span class="math">\(S\)</span>，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于 <span class="math">\(S\)</span>，输出两个数的乘积最小的。</p>
<div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">Solution</span> <span class="p">{</span>
<span class="kr">public</span><span class="o">:</span>
    <span class="nx">vector</span><span class="o">&lt;</span><span class="kr">int</span><span class="o">&gt;</span> <span class="nx">FindNumbersWithSum</span><span class="p">(</span><span class="nx">vector</span><span class="o">&lt;</span><span class="kr">int</span><span class="o">&gt;</span> <span class="nx">array</span><span class="p">,</span><span class="kr">int</span> <span class="nx">sum</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">vector</span><span class="o">&lt;</span><span class="kr">int</span><span class="o">&gt;</span> <span class="nx">res</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">array</span><span class="p">.</span><span class="nx">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="k">return</span> <span class="nx">res</span><span class="p">;</span>
        <span class="kr">int</span> <span class="nx">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">r</span> <span class="o">=</span> <span class="nx">array</span><span class="p">.</span><span class="nx">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(;</span> <span class="nx">l</span> <span class="o">&lt;</span> <span class="p">(</span><span class="nx">sum</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="nx">l</span> <span class="o">&lt;</span> <span class="nx">r</span><span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">array</span><span class="p">[</span><span class="nx">l</span><span class="p">]</span> <span class="o">+</span> <span class="nx">array</span><span class="p">[</span><span class="nx">r</span><span class="p">]</span> <span class="o">==</span> <span class="nx">sum</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">res</span><span class="p">.</span><span class="nx">push_back</span><span class="p">(</span><span class="nx">array</span><span class="p">[</span><span class="nx">l</span><span class="p">]);</span>
                <span class="nx">res</span><span class="p">.</span><span class="nx">push_back</span><span class="p">(</span><span class="nx">array</span><span class="p">[</span><span class="nx">r</span><span class="p">]);</span>
                <span class="k">return</span> <span class="nx">res</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">array</span><span class="p">[</span><span class="nx">l</span><span class="p">]</span> <span class="o">+</span> <span class="nx">array</span><span class="p">[</span><span class="nx">r</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nx">sum</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">r</span><span class="o">--</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nx">l</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">res</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
<p><strong>思路</strong>：从两端开始查找，距离越远积越小。</p>
<h2 id="13">13. 左旋转字符串</h2>
<p>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列 <span class="math">\(S\)</span>，请你把其循环左移 <span class="math">\(K\)</span> 位后的序列输出。例如，字符序列 <span class="math">\(S=abcXYZdef\)</span>，要求输出循环左移 3 位后的结果，即 <span class="math">\(XYZdefabc\)</span>。是不是很简单？OK，搞定它。</p>
<div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">Solution</span> <span class="p">{</span>
<span class="kr">public</span><span class="o">:</span>
    <span class="kt">string</span> <span class="nx">LeftRotateString</span><span class="p">(</span><span class="kt">string</span> <span class="nx">str</span><span class="p">,</span> <span class="kr">int</span> <span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">str</span><span class="p">.</span><span class="nx">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="s2">""</span><span class="p">;</span>
        <span class="c1">// 不修改原字符串</span>
        <span class="kt">string</span> <span class="nx">res</span><span class="p">(</span><span class="nx">str</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">n</span> <span class="o">&gt;</span> <span class="nx">str</span><span class="p">.</span><span class="nx">size</span><span class="p">())</span>
             <span class="nx">n</span> <span class="o">%=</span> <span class="nx">str</span><span class="p">.</span><span class="nx">size</span><span class="p">();</span>
        <span class="k">for</span><span class="p">(</span><span class="kr">int</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">str</span><span class="p">.</span><span class="nx">size</span><span class="p">();</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span>
            <span class="nx">res</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">str</span><span class="p">[(</span><span class="nx">i</span> <span class="o">+</span> <span class="nx">n</span><span class="p">)</span> <span class="o">%</span> <span class="nx">str</span><span class="p">.</span><span class="nx">size</span><span class="p">()];</span>
        <span class="k">return</span> <span class="nx">res</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
<h2 id="14">14. 翻转单词顺序列</h2>
<p>牛客最近来了一个新员工 Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事 Cat 对 Fish 写的内容颇感兴趣，有一天他向 Fish 借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是 “I am a student.”。Cat 对一一的翻转这些单词顺序可不在行，你能帮助他么？</p>
<div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">Solution</span> <span class="p">{</span>
<span class="kr">public</span><span class="o">:</span>
    <span class="kt">string</span> <span class="nx">ReverseSentence</span><span class="p">(</span><span class="kt">string</span> <span class="nx">str</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">str</span><span class="p">.</span><span class="nx">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="nx">str</span><span class="p">;</span>
        <span class="kt">string</span> <span class="nx">res</span> <span class="o">=</span> <span class="s2">""</span><span class="p">,</span> <span class="nx">tmp</span> <span class="o">=</span> <span class="s2">""</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="nx">unsigned</span> <span class="kr">int</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">str</span><span class="p">.</span><span class="nx">size</span><span class="p">();</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="nx">str</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">==</span> <span class="s1">' '</span><span class="p">)</span>       <span class="c1">//  发现一个单词</span>
            <span class="p">{</span>
                <span class="nx">res</span> <span class="o">=</span> <span class="s2">" "</span> <span class="o">+</span> <span class="nx">tmp</span> <span class="o">+</span> <span class="nx">res</span><span class="p">;</span>      <span class="c1">//  顺序的拼接, 前面需要一个空格</span>
                <span class="nx">tmp</span> <span class="o">=</span> <span class="s2">""</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span>
            <span class="p">{</span>
                <span class="nx">tmp</span> <span class="o">+=</span> <span class="nx">str</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">tmp</span><span class="p">.</span><span class="nx">size</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>     <span class="c1">//  拼接最后一个单子, 前面无需空格</span>
        <span class="p">{</span>
            <span class="nx">res</span> <span class="o">=</span> <span class="nx">tmp</span> <span class="o">+</span> <span class="nx">res</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">res</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
<p><strong>思路</strong>：从后向前重新组装字符串。</p>
<h2 id="15">15. 扑克牌顺子</h2>
<p>LL 今天心情特别好，因为他去买了一副扑克牌，发现里面居然有 2 个大王，2 个小王（一副牌原本是 54 张）...他随机从中抽出了 5 张牌，想测测自己的手气，看看能不能抽到顺子，如果抽到的话，他决定去买体育彩票,嘿嘿！！他想了想，决定大小王可以看成任何数字，并且 A 看作 1，J 为 11，Q 为 12 K 为 13。现在，要求你使用这幅牌模拟上面的过程，然后告诉我们 LL 的运气如何，如果牌能组成顺子就输出 true，否则就输出 false。为了方便起见，你可以认为大小王是0。</p>
<div class="highlight"><pre><span></span><span class="err">#</span><span class="nx">define</span> <span class="nx">BIT_GET</span><span class="p">(</span><span class="kt">number</span><span class="p">,</span> <span class="nx">pos</span><span class="p">)</span> <span class="p">((</span><span class="kt">number</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="nx">pos</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>     <span class="c1">/// 用宏得到某数的某位</span>

<span class="err">#</span><span class="nx">define</span> <span class="nx">BIT_SET</span><span class="p">(</span><span class="kt">number</span><span class="p">,</span> <span class="nx">pos</span><span class="p">)</span> <span class="p">((</span><span class="kt">number</span><span class="p">)</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="nx">pos</span><span class="p">))</span>    <span class="c1">/// 把某位置1</span>

<span class="err">#</span><span class="nx">define</span> <span class="nx">BIT_CLR</span><span class="p">(</span><span class="kt">number</span><span class="p">,</span> <span class="nx">pos</span><span class="p">)</span> <span class="p">((</span><span class="kt">number</span><span class="p">)</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="nx">pos</span><span class="p">)))</span> <span class="c1">/// 把某位清0</span>

<span class="err">#</span><span class="nx">define</span> <span class="nx">BIT_CPL</span><span class="p">(</span><span class="kt">number</span><span class="p">,</span> <span class="nx">pos</span><span class="p">)</span> <span class="p">((</span><span class="kt">number</span><span class="p">)</span> <span class="o">^=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="nx">pos</span><span class="p">))</span>    <span class="c1">/// 把number的POS位取反</span>

<span class="kr">class</span> <span class="nx">Solution</span> <span class="p">{</span>
<span class="kr">public</span><span class="o">:</span>
    <span class="kt">bool</span> <span class="nx">IsContinuous</span><span class="p">(</span> <span class="nx">vector</span><span class="o">&lt;</span><span class="kr">int</span><span class="o">&gt;</span> <span class="nx">numbers</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">numbers</span><span class="p">.</span><span class="nx">size</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">5</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
        <span class="kr">int</span> <span class="nx">min</span> <span class="o">=</span> <span class="nx">INT_MAX</span><span class="p">;</span>
        <span class="kr">int</span> <span class="nx">max</span> <span class="o">=</span> <span class="nx">INT_MIN</span><span class="p">;</span>
        <span class="kr">int</span> <span class="nx">flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kr">int</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">numbers</span><span class="p">.</span><span class="nx">size</span><span class="p">();</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="kr">int</span> <span class="nx">num</span> <span class="o">=</span> <span class="nx">numbers</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
            <span class="k">if</span><span class="p">(</span><span class="nx">num</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">num</span> <span class="o">&gt;</span> <span class="mi">13</span><span class="p">)</span> <span class="c1">//  牌只能在0~13之间</span>
                <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
            <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="nx">num</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>       <span class="c1">//  0用来答题任何牌，因此不能参与最大最小牌的比对</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="c1">//  非0元素不能重复</span>
            <span class="k">if</span><span class="p">(</span><span class="nx">BIT_GET</span><span class="p">(</span><span class="nx">flag</span><span class="p">,</span> <span class="nx">num</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>     <span class="c1">//  如果flag的第num位为1, 说明num重复</span>
                <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
            <span class="k">else</span>
                <span class="nx">BIT_SET</span><span class="p">(</span><span class="nx">flag</span><span class="p">,</span> <span class="nx">num</span><span class="p">);</span>     <span class="c1">//  将标识flag的第num位置为1</span>
            <span class="c1">//  寻找最大最小的牌</span>
            <span class="k">if</span><span class="p">(</span><span class="nx">num</span> <span class="o">&gt;</span> <span class="nx">max</span><span class="p">)</span>
                <span class="nx">max</span> <span class="o">=</span> <span class="nx">num</span><span class="p">;</span>
            <span class="k">if</span><span class="p">(</span><span class="nx">num</span> <span class="o">&lt;</span> <span class="nx">min</span><span class="p">)</span>
                <span class="nx">min</span> <span class="o">=</span> <span class="nx">num</span><span class="p">;</span>
            <span class="c1">//  如果最大值和最小值的差值大于4, 那么必应不能补齐</span>
            <span class="k">if</span><span class="p">(</span><span class="nx">max</span> <span class="o">-</span> <span class="nx">min</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
<p><strong>思路</strong>：条件： 5张牌，顺子，除 0 之外不能重复。</p>
<p>结论： 非 0 元素的极差（最大值最小值的差）不超过 4， 非 0 元素不重复。</p>
<p>也可以排序后看 0 能不能填补空缺。</p>
<div class="highlight"><pre><span></span>// 左移、右移 &gt; 位运算 &gt; 逻辑运算

#define BIT_GET(number, pos) ((number) &gt;&gt; (pos) &amp; 1)     
/// 用宏得到某数的某位

#define BIT_SET(number, pos) ((number) |= 1 &lt;&lt; (pos))    
/// 把某位置1

#define BIT_CLR(number, pos) ((number) &amp;= ~(1 &lt;&lt; (pos)))
/// 把某位清0

#define BIT_CPL(number, pos) ((number) ^= 1 &lt;&lt; (pos))    
/// 把number的POS位取反
</pre></div>
<h2 id="16">16. 孩子们的游戏（圆圈中最后剩下的数）</h2>
<p>每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友，今年亦是如此。HF 作为牛客的资深元老，自然也准备了一些小游戏。其中，有个游戏是这样的：首先，让小朋友们围成一个大圈。然后，他随机指定一个数 <span class="math">\(m\)</span>，让编号为 0 的小朋友开始报数。每次喊到 <span class="math">\(m-1\)</span> 的那个小朋友要出列唱首歌，然后可以在礼品箱中任意的挑选礼物，并且不再回到圈中，从他的下一个小朋友开始,继续 0...<span class="math">\(m-1\)</span> 报数....这样下去....直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!)。请你试着想下，哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从 0 到 <span class="math">\(n-1\)</span>)。</p>
<div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">Solution</span> <span class="p">{</span>
<span class="kr">public</span><span class="o">:</span>
    <span class="kr">int</span> <span class="nx">LastRemaining_Solution</span><span class="p">(</span><span class="kr">int</span> <span class="nx">n</span><span class="p">,</span> <span class="kr">int</span> <span class="nx">m</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">n</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="nx">m</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="kr">int</span> <span class="nx">last</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kr">int</span> <span class="nx">step</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="nx">step</span> <span class="o">&lt;=</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">step</span><span class="o">++</span><span class="p">)</span>
            <span class="nx">last</span> <span class="o">=</span> <span class="p">(</span><span class="nx">last</span> <span class="o">+</span> <span class="nx">m</span><span class="p">)</span> <span class="o">%</span> <span class="nx">step</span><span class="p">;</span>
        <span class="k">return</span> <span class="nx">last</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
<p><a href="https://blog.csdn.net/fuxuemingzhu/article/details/79702974">https://blog.csdn.net/fuxuemingzhu/article/details/79702974</a></p>
<h2 id="17-123n">17. 求 <span class="math">\(1+2+3+...+n\)</span></h2>
<p>要求不能使用乘除法、for、while、if、else、switch、case 等关键字及条件判断语句（A?B:C）。</p>
<div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">Solution</span> <span class="p">{</span>
<span class="kr">public</span><span class="o">:</span>
    <span class="kr">int</span> <span class="nx">Sum_Solution</span><span class="p">(</span><span class="kr">int</span> <span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="kr">int</span> <span class="nx">ans</span> <span class="o">=</span> <span class="nx">n</span><span class="p">;</span>
        <span class="nx">n</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">ans</span> <span class="o">+=</span> <span class="nx">Sum_Solution</span><span class="p">(</span><span class="nx">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
        <span class="k">return</span> <span class="nx">ans</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
<h2 id="18">18. 不用加减乘除做加法</h2>
<p>写一个函数，求两个整数之和，要求在函数体内不得使用 +、-、*、/ 四则运算符号。</p>
<div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">Solution</span> <span class="p">{</span>
<span class="kr">public</span><span class="o">:</span>
    <span class="kr">int</span> <span class="nx">Add</span><span class="p">(</span><span class="kr">int</span> <span class="nx">num1</span><span class="p">,</span> <span class="kr">int</span> <span class="nx">num2</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kr">int</span> <span class="nx">temp</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="nx">num2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="nx">temp</span> <span class="o">=</span> <span class="nx">num1</span> <span class="o">^</span> <span class="nx">num2</span><span class="p">;</span>         <span class="c1">//  计算不带进位的情况</span>
            <span class="nx">num2</span> <span class="o">=</span> <span class="p">(</span><span class="nx">num1</span> <span class="o">&amp;</span> <span class="nx">num2</span><span class="p">)</span> <span class="o">&lt;&lt;</span><span class="mi">1</span><span class="p">;</span>   <span class="c1">//  计算带进位的情况</span>
            <span class="nx">num1</span> <span class="o">=</span> <span class="nx">temp</span><span class="p">;</span>
            <span class="c1">//  now num1 = 不带进位的情况, num2 = 带进位的情况</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="nx">num1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
<h2 id="19">19. 将一个字符串转换成一个整数</h2>
<p>将一个字符串转换成一个整数（实现 Integer.valueOf(string) 的功能，但是 string 不符合数字要求时返回 0），要求不能使用字符串转换整数的库函数。 数值为 0 或者字符串不是一个合法的数值则返回 0。</p>
<div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">Solution</span> <span class="p">{</span>
<span class="kr">public</span><span class="o">:</span>
    <span class="kr">int</span> <span class="nx">StrToInt</span><span class="p">(</span><span class="kt">string</span> <span class="nx">str</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">string</span><span class="o">::</span><span class="nx">iterator</span> <span class="nx">pstr</span> <span class="o">=</span> <span class="nx">str</span><span class="p">.</span><span class="nx">begin</span><span class="p">();</span>
        <span class="c1">//  排除前导的空格</span>
        <span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="nx">pstr</span> <span class="o">==</span> <span class="s1">' '</span><span class="p">)</span>  <span class="c1">//  排除前导的空格</span>
            <span class="nx">pstr</span><span class="o">++</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="nx">minus</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
        <span class="c1">//  判断符号位+ -</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="nx">pstr</span> <span class="o">==</span> <span class="s1">'+'</span><span class="p">)</span>
            <span class="nx">pstr</span><span class="o">++</span><span class="p">;</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="nx">pstr</span> <span class="o">==</span> <span class="s1">'-'</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">pstr</span><span class="o">++</span><span class="p">;</span>
            <span class="nx">minus</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="kr">long</span> <span class="kr">long</span> <span class="kr">int</span> <span class="nx">value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="nx">pstr</span> <span class="o">!=</span> <span class="nx">str</span><span class="p">.</span><span class="nx">end</span><span class="p">();</span> <span class="nx">pstr</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="s1">'0'</span> <span class="o">&lt;=</span> <span class="o">*</span><span class="nx">pstr</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="nx">pstr</span> <span class="o">&lt;=</span> <span class="s1">'9'</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">value</span> <span class="o">*=</span> <span class="mi">10</span><span class="p">;</span>
                <span class="nx">value</span> <span class="o">+=</span> <span class="o">*</span><span class="nx">pstr</span> <span class="o">-</span> <span class="s1">'0'</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="c1">//  解决OVER_FLOW的问题</span>
            <span class="c1">//  INT_MAX     2147483647</span>
            <span class="c1">//  INT_MIN     -2147483648  minus = true</span>
            <span class="c1">//  负数绝对值最大为INT_MAX + 1</span>
            <span class="c1">//  正数最大值为INT_MAX</span>
            <span class="k">if</span><span class="p">((</span><span class="nx">minus</span> <span class="o">==</span> <span class="kc">true</span>  <span class="o">&amp;&amp;</span> <span class="nx">value</span> <span class="o">&gt;</span> <span class="p">(</span><span class="nx">unsigned</span> <span class="kr">long</span><span class="p">)(</span><span class="nx">INT_MAX</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="o">||</span> <span class="p">(</span><span class="nx">minus</span> <span class="o">==</span> <span class="kc">false</span> <span class="o">&amp;&amp;</span> <span class="nx">value</span> <span class="o">&gt;</span> <span class="nx">INT_MAX</span><span class="p">))</span>
                <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">pstr</span> <span class="o">!=</span> <span class="nx">str</span><span class="p">.</span><span class="nx">end</span><span class="p">())</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">minus</span> <span class="o">==</span> <span class="kc">true</span><span class="p">)</span>
                <span class="nx">value</span> <span class="o">=</span> <span class="o">-</span><span class="nx">value</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">value</span> <span class="o">&gt;=</span> <span class="nx">INT_MAX</span><span class="p">)</span>
                <span class="nx">value</span> <span class="o">=</span> <span class="nx">INT_MAX</span><span class="p">;</span>
            <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">value</span> <span class="o">&lt;=</span> <span class="nx">INT_MIN</span><span class="p">)</span>
                <span class="nx">value</span> <span class="o">=</span> <span class="nx">INT_MIN</span><span class="p">;</span>
            <span class="k">return</span> <span class="p">(</span><span class="kr">int</span><span class="p">)</span><span class="nx">value</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
<h2 id="20">20. 数组中重复的数字</h2>
<p>在一个长度为 <span class="math">\(n\)</span> 的数组里的所有数字都在 0 到 <span class="math">\(n-1\)</span> 的范围内。数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为 7 的数组 {2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字 2。</p>
<div class="highlight"><pre><span></span><span class="err">#</span><span class="nx">define</span> <span class="nx">SET_SYMBOL_BIT</span><span class="p">(</span><span class="nx">num</span><span class="p">)</span>  <span class="p">((</span><span class="nx">num</span><span class="p">)</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">31</span><span class="p">))</span>       <span class="cm">/*  设置符号位为1 */</span>
<span class="err">#</span><span class="nx">define</span> <span class="nx">GET_ORIGIN_NUM</span><span class="p">(</span><span class="nx">num</span><span class="p">)</span>  <span class="p">((</span><span class="nx">num</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">31</span><span class="p">)))</span>     <span class="cm">/*  获取到源数据  */</span>
<span class="err">#</span><span class="nx">define</span> <span class="nx">GET_SYMBOL_BIT</span><span class="p">(</span><span class="nx">num</span><span class="p">)</span>  <span class="p">(((</span><span class="nx">num</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">31</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>        <span class="cm">/*  获取符号位(标识)*/</span>
<span class="kr">class</span> <span class="nx">Solution</span> <span class="p">{</span>
<span class="kr">public</span><span class="o">:</span>
    <span class="c1">// Parameters:</span>
    <span class="c1">//        numbers:     an array of integers</span>
    <span class="c1">//        length:      the length of array numbers</span>
    <span class="c1">//        duplication: (Output) the duplicated number in the array number</span>
    <span class="c1">// Return value:       true if the input is valid, and there are some duplications in the array number</span>
    <span class="c1">//                     otherwise false</span>
    <span class="kt">bool</span> <span class="nx">duplicate</span><span class="p">(</span><span class="kr">int</span> <span class="nx">numbers</span><span class="p">[],</span> <span class="kr">int</span> <span class="nx">length</span><span class="p">,</span> <span class="kr">int</span><span class="o">*</span> <span class="nx">duplication</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">*</span><span class="nx">duplication</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">CheckValidity</span><span class="p">(</span><span class="nx">numbers</span><span class="p">,</span> <span class="nx">length</span><span class="p">)</span> <span class="o">==</span> <span class="kc">false</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="kr">int</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">//  当前数字numbers[i]的标识即是numbers[numbers[i]]的符号位</span>
            <span class="c1">//  检查numbers[i]</span>
            <span class="k">if</span><span class="p">(</span><span class="nx">GET_SYMBOL_BIT</span><span class="p">(</span><span class="nx">numbers</span><span class="p">[</span><span class="nx">GET_ORIGIN_NUM</span><span class="p">(</span><span class="nx">numbers</span><span class="p">[</span><span class="nx">i</span><span class="p">])])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="o">*</span><span class="nx">duplication</span> <span class="o">=</span> <span class="nx">GET_ORIGIN_NUM</span><span class="p">(</span><span class="nx">numbers</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span>
                <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nx">SET_SYMBOL_BIT</span><span class="p">(</span><span class="nx">numbers</span><span class="p">[</span><span class="nx">GET_ORIGIN_NUM</span><span class="p">(</span><span class="nx">numbers</span><span class="p">[</span><span class="nx">i</span><span class="p">])]);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="nx">CheckValidity</span><span class="p">(</span><span class="kr">int</span> <span class="o">*</span><span class="nx">numbers</span><span class="p">,</span> <span class="kr">int</span> <span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">//  输入数据不合法</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">numbers</span> <span class="o">==</span> <span class="nx">NULL</span> <span class="o">||</span> <span class="nx">length</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
        <span class="c1">//  元素必须在[0, n-1]的范围</span>
        <span class="k">for</span><span class="p">(</span><span class="kr">int</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span>
            <span class="k">if</span><span class="p">(</span><span class="nx">numbers</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">numbers</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
        <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
<p><strong>思路</strong>：1. 排序后判断重复；2. 符号位标识法；3. 固定偏移法；4. 将元素放在自己该在的位置。</p>
<h2 id="21">21. 构建乘积数组</h2>
<p>给定一个数组 A[0,1,...,n-1]，请构建一个数组 B[0,1,...,n-1]，其中 B 中的元素 B[i]=A[0]*A[1]*...*A[i-1]*A[i+1]*...*A[n-1]。不能使用除法。</p>
<div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">Solution</span> <span class="p">{</span>
<span class="kr">public</span><span class="o">:</span>
    <span class="nx">vector</span><span class="o">&lt;</span><span class="kr">int</span><span class="o">&gt;</span> <span class="nx">multiply</span><span class="p">(</span><span class="kr">const</span> <span class="nx">vector</span><span class="o">&lt;</span><span class="kr">int</span><span class="o">&gt;&amp;</span> <span class="nx">A</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">vector</span><span class="o">&lt;</span><span class="kr">int</span><span class="o">&gt;</span> <span class="nx">B</span><span class="p">(</span><span class="nx">A</span><span class="p">.</span><span class="nx">size</span><span class="p">());</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">A</span><span class="p">.</span><span class="nx">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="nx">B</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kr">int</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">temp</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">A</span><span class="p">.</span><span class="nx">size</span><span class="p">();</span> <span class="nx">i</span><span class="o">++</span><span class="p">){</span>
            <span class="nx">B</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">temp</span><span class="p">;</span>
            <span class="nx">temp</span> <span class="o">*=</span> <span class="nx">A</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="p">(</span><span class="kr">int</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">A</span><span class="p">.</span><span class="nx">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">temp</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">B</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">*=</span> <span class="nx">temp</span><span class="p">;</span>
            <span class="nx">temp</span> <span class="o">*=</span> <span class="nx">A</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">B</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
<h2 id="22">22. 正则表达式匹配</h2>
<p>请实现一个函数用来匹配包括'.'和'*'的正则表达式。模式中的字符'.'表示任意一个字符，而'*'表示它前面的字符可以出现任意次（包含 0 次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串 "aaa" 与模式 "a.a" 和 "ab<em>ac</em>a" 匹配，但是与 "aa.a" 和 "ab*a" 均不匹配。</p>
<div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">Solution</span> <span class="p">{</span>
<span class="kr">public</span><span class="o">:</span>
    <span class="kt">bool</span> <span class="nx">match</span><span class="p">(</span><span class="kr">char</span><span class="o">*</span> <span class="nx">str</span><span class="p">,</span> <span class="kr">char</span><span class="o">*</span> <span class="nx">pattern</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="cm">/**</span>
<span class="cm">         * f[i][j]: if s[0..i-1] matches p[0..j-1]</span>
<span class="cm">         * if p[j - 1] != '*'</span>
<span class="cm">         *      f[i][j] = f[i - 1][j - 1] &amp;&amp; s[i - 1] == p[j - 1]</span>
<span class="cm">         * if p[j - 1] == '*', denote p[j - 2] with x</span>
<span class="cm">         *      f[i][j] is true iff any of the following is true</span>
<span class="cm">         *      1) "x*" repeats 0 time and matches empty: f[i][j - 2]</span>
<span class="cm">         *      2) "x*" repeats &gt;= 1 times and matches "x*x": s[i - 1] == x &amp;&amp; f[i - 1][j]</span>
<span class="cm">         * '.' matches any single character</span>
<span class="cm">         */</span>
        <span class="kr">int</span> <span class="nx">m</span> <span class="o">=</span> <span class="nx">strlen</span><span class="p">(</span><span class="nx">str</span><span class="p">),</span> <span class="nx">n</span> <span class="o">=</span> <span class="nx">strlen</span><span class="p">(</span><span class="nx">pattern</span><span class="p">);</span>
        <span class="nx">vector</span><span class="o">&lt;</span><span class="nx">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;&gt;</span> <span class="nx">f</span><span class="p">(</span><span class="nx">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">false</span><span class="p">));</span>
        <span class="nx">f</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kr">int</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">m</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span>
            <span class="nx">f</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
        <span class="c1">// p[0.., j - 3, j - 2, j - 1] matches empty iff p[j - 1] // is '*' and p[0..j - 3] matches empty</span>
        <span class="k">for</span> <span class="p">(</span><span class="kr">int</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;=</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span>
            <span class="nx">f</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="o">=</span> <span class="nx">j</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="s1">'*'</span> <span class="o">==</span> <span class="nx">pattern</span><span class="p">[</span><span class="nx">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="nx">f</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="nx">j</span> <span class="o">-</span> <span class="mi">2</span><span class="p">];</span>

        <span class="k">for</span> <span class="p">(</span><span class="kr">int</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">m</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span>
            <span class="k">for</span> <span class="p">(</span><span class="kr">int</span> <span class="nx">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">j</span> <span class="o">&lt;=</span> <span class="nx">n</span><span class="p">;</span> <span class="nx">j</span><span class="o">++</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="nx">pattern</span><span class="p">[</span><span class="nx">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">'*'</span><span class="p">)</span>
                    <span class="nx">f</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="o">=</span> <span class="nx">f</span><span class="p">[</span><span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="nx">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">str</span><span class="p">[</span><span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="nx">pattern</span><span class="p">[</span><span class="nx">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">||</span> <span class="s1">'.'</span> <span class="o">==</span> <span class="nx">pattern</span><span class="p">[</span><span class="nx">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
                <span class="k">else</span>
        <span class="c1">// p[0] cannot be '*' so no need to check "j &gt; 1" here</span>
                    <span class="nx">f</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span><span class="p">]</span> <span class="o">=</span> <span class="nx">f</span><span class="p">[</span><span class="nx">i</span><span class="p">][</span><span class="nx">j</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> <span class="o">||</span> <span class="p">(</span><span class="nx">str</span><span class="p">[</span><span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="nx">pattern</span><span class="p">[</span><span class="nx">j</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> <span class="o">||</span> <span class="s1">'.'</span> <span class="o">==</span> <span class="nx">pattern</span><span class="p">[</span><span class="nx">j</span> <span class="o">-</span> <span class="mi">2</span><span class="p">])</span> <span class="o">&amp;&amp;</span> <span class="nx">f</span><span class="p">[</span><span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="nx">j</span><span class="p">];</span>

        <span class="k">return</span> <span class="nx">f</span><span class="p">[</span><span class="nx">m</span><span class="p">][</span><span class="nx">n</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
<h2 id="23">23. 表示数值的字符串</h2>
<p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串 "+100"，"5e2"，"-123"，"3.1416" 和 "-1E-16" 都表示数值。 但是 "12e"，"1a3.14"，"1.2.3"，"+-5" 和 "12e+4.3" 都不是。</p>
<div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">Solution</span> <span class="p">{</span>
<span class="kr">public</span><span class="o">:</span>
    <span class="kt">bool</span> <span class="nx">isNumeric</span><span class="p">(</span><span class="kr">char</span><span class="o">*</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="kt">string</span> <span class="o">==</span> <span class="nx">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="kt">string</span> <span class="o">==</span> <span class="s1">'+'</span> <span class="o">||</span> <span class="o">*</span><span class="kt">string</span> <span class="o">==</span> <span class="s1">'-'</span><span class="p">)</span>
             <span class="o">++</span><span class="kt">string</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="kt">string</span> <span class="o">==</span> <span class="s1">'\0'</span><span class="p">)</span> <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="nx">res</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
        <span class="nx">ScanDigits</span><span class="p">(</span><span class="o">&amp;</span><span class="kt">string</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="kt">string</span> <span class="o">!=</span> <span class="s1">'\0'</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="kt">string</span> <span class="o">==</span> <span class="s1">'.'</span><span class="p">)</span> <span class="p">{</span>
                <span class="o">++</span><span class="kt">string</span><span class="p">;</span>
                <span class="nx">ScanDigits</span><span class="p">(</span><span class="o">&amp;</span><span class="kt">string</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="kt">string</span> <span class="o">==</span> <span class="s1">'e'</span> <span class="o">||</span> <span class="o">*</span><span class="kt">string</span> <span class="o">==</span><span class="s1">'E'</span><span class="p">)</span> <span class="p">{</span>
                    <span class="nx">res</span> <span class="o">=</span> <span class="nx">IsExponential</span><span class="p">(</span><span class="o">&amp;</span><span class="kt">string</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span> <span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="kt">string</span> <span class="o">==</span> <span class="s1">'e'</span> <span class="o">||</span> <span class="o">*</span><span class="kt">string</span> <span class="o">==</span> <span class="s1">'E'</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">res</span> <span class="o">=</span> <span class="nx">IsExponential</span><span class="p">(</span><span class="o">&amp;</span><span class="kt">string</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nx">res</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">res</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="kt">string</span> <span class="o">==</span> <span class="s1">'\0'</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">void</span> <span class="nx">ScanDigits</span><span class="p">(</span><span class="kr">char</span><span class="o">**</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="o">**</span><span class="kt">string</span> <span class="o">!=</span> <span class="s1">'\0'</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">**</span><span class="kt">string</span> <span class="o">&gt;=</span> <span class="s1">'0'</span> <span class="o">&amp;&amp;</span> <span class="o">**</span><span class="kt">string</span> <span class="o">&lt;=</span> <span class="s1">'9'</span><span class="p">))</span> <span class="p">{</span>
            <span class="o">++</span><span class="p">(</span><span class="o">*</span><span class="kt">string</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
     <span class="kt">bool</span> <span class="nx">IsExponential</span><span class="p">(</span><span class="kr">char</span><span class="o">**</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
         <span class="o">++</span><span class="p">(</span><span class="o">*</span><span class="kt">string</span><span class="p">);</span>
         <span class="k">if</span> <span class="p">(</span><span class="o">**</span><span class="kt">string</span> <span class="o">==</span> <span class="s1">'+'</span> <span class="o">||</span> <span class="o">**</span><span class="kt">string</span> <span class="o">==</span> <span class="s1">'-'</span><span class="p">)</span>
             <span class="o">++</span><span class="p">(</span><span class="o">*</span><span class="kt">string</span><span class="p">);</span>
         <span class="k">if</span> <span class="p">(</span><span class="o">**</span><span class="kt">string</span> <span class="o">==</span> <span class="s1">'\0'</span><span class="p">)</span>
             <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
         <span class="nx">ScanDigits</span><span class="p">(</span><span class="kt">string</span><span class="p">);</span>
         <span class="k">return</span> <span class="p">(</span><span class="o">**</span><span class="kt">string</span> <span class="o">==</span> <span class="s1">'\0'</span><span class="p">)</span> <span class="o">?</span> <span class="kc">true</span> <span class="o">:</span> <span class="kc">false</span><span class="p">;</span>
     <span class="p">}</span>

<span class="p">};</span>
</pre></div>
<p><strong>思路</strong>：</p>
<p>1) 首先看第一个字符是不是正负号。
2) 如果是，在字符串上移动一个字符，继续扫描剩余的字符串中0到9的数位。
3) 如果是一个小数，则将遇到小数点。
4) 另外，如果是用科学计数法表示的数值，在整数或者小数的后面还有可能遇到“e”或者“E”。</p>
<h2 id="24">24. 字符流中第一个只出现一次的字符</h2>
<p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符"go"时，第一个只出现一次的字符是"g"。当从该字符流中读出前六个字符“google"时，第一个只出现一次的字符是"l"。</p>
<div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">Solution</span>
<span class="p">{</span>
<span class="kr">public</span><span class="o">:</span>
    <span class="nx">Solution</span><span class="p">(){</span>
        <span class="nx">str</span><span class="o">=</span><span class="s2">""</span><span class="p">;</span>
        <span class="c1">// #include &lt;cstring&gt;</span>
        <span class="nx">memset</span><span class="p">(</span><span class="nx">count</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="nx">sizeof</span><span class="p">(</span><span class="nx">count</span><span class="p">));</span>
    <span class="p">}</span>
  <span class="c1">//Insert one char from stringstream</span>
    <span class="k">void</span> <span class="nx">Insert</span><span class="p">(</span><span class="kr">char</span> <span class="nx">ch</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">str</span> <span class="o">+=</span> <span class="nx">ch</span><span class="p">;</span>
        <span class="nx">count</span><span class="p">[(</span><span class="kr">int</span><span class="p">)</span><span class="nx">ch</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="c1">//return the first appearence once char in current stringstream</span>
    <span class="kr">char</span> <span class="nx">FirstAppearingOnce() {</span>
        <span class="kr">int</span> <span class="nx">len</span> <span class="o">=</span> <span class="nx">str</span><span class="p">.</span><span class="nx">size</span><span class="p">();</span>
        <span class="k">for</span><span class="p">(</span><span class="kr">int</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">len</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">count</span><span class="p">[(</span><span class="kr">int</span><span class="p">)</span><span class="nx">str</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">return</span> <span class="nx">str</span><span class="p">[</span><span class="nx">i</span><span class="p">];</span>
        <span class="k">return</span> <span class="s1">'#'</span><span class="p">;</span>
    <span class="p">}</span>
<span class="kr">private</span><span class="o">:</span>
    <span class="kt">string</span> <span class="nx">str</span><span class="p">;</span>
    <span class="kr">int</span> <span class="nx">count</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span>
<span class="p">};</span>
</pre></div>
<h2 id="25">25. 链表中环入口</h2>
<p>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出 null。</p>
<div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm">struct ListNode {</span>
<span class="cm">    int val;</span>
<span class="cm">    struct ListNode *next;</span>
<span class="cm">    ListNode(int x) :</span>
<span class="cm">        val(x), next(NULL) {</span>
<span class="cm">    }</span>
<span class="cm">};</span>
<span class="cm">*/</span>
<span class="kr">class</span> <span class="nx">Solution</span> <span class="p">{</span>
<span class="kr">public</span><span class="o">:</span>
    <span class="nx">ListNode</span><span class="o">*</span> <span class="nx">EntryNodeOfLoop</span><span class="p">(</span><span class="nx">ListNode</span><span class="o">*</span> <span class="nx">pHead</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">pHead</span> <span class="o">==</span> <span class="nx">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="nx">NULL</span><span class="p">;</span>
        <span class="nx">ListNode</span> <span class="o">*</span><span class="nx">p1</span> <span class="o">=</span> <span class="nx">pHead</span><span class="p">,</span> <span class="o">*</span><span class="nx">p2</span> <span class="o">=</span> <span class="nx">pHead</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="nx">p1</span> <span class="o">!=</span> <span class="nx">NULL</span> <span class="o">&amp;&amp;</span> <span class="nx">p2</span> <span class="o">!=</span> <span class="nx">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">p1</span> <span class="o">=</span> <span class="nx">p1</span><span class="o">-&gt;</span><span class="nx">next</span><span class="p">;</span>
            <span class="nx">p2</span> <span class="o">=</span> <span class="nx">p2</span><span class="o">-&gt;</span><span class="nx">next</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">p2</span> <span class="o">==</span> <span class="nx">NULL</span><span class="p">)</span>
                <span class="k">return</span> <span class="nx">NULL</span><span class="p">;</span>
            <span class="nx">p2</span> <span class="o">=</span> <span class="nx">p2</span><span class="o">-&gt;</span><span class="nx">next</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">p1</span> <span class="o">==</span> <span class="nx">p2</span><span class="p">)</span>
                <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="nx">p1</span> <span class="o">=</span> <span class="nx">pHead</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="nx">p1</span> <span class="o">!=</span> <span class="nx">p2</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">p1</span> <span class="o">=</span> <span class="nx">p1</span><span class="o">-&gt;</span><span class="nx">next</span><span class="p">;</span>
            <span class="nx">p2</span> <span class="o">=</span> <span class="nx">p2</span><span class="o">-&gt;</span><span class="nx">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">p1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
<p><strong>思路</strong>：双指针，第二个指针比第一个指针多走环节点整数倍。</p>
<h2 id="26">26. 删除链表中重复的结点</h2>
<p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p>
<div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm">struct ListNode {</span>
<span class="cm">    int val;</span>
<span class="cm">    struct ListNode *next;</span>
<span class="cm">    ListNode(int x) :</span>
<span class="cm">        val(x), next(NULL) {</span>
<span class="cm">    }</span>
<span class="cm">};</span>
<span class="cm">*/</span>
<span class="kr">class</span> <span class="nx">Solution</span> <span class="p">{</span>
<span class="kr">public</span><span class="o">:</span>
    <span class="nx">ListNode</span><span class="o">*</span> <span class="nx">deleteDuplication</span><span class="p">(</span><span class="nx">ListNode</span><span class="o">*</span> <span class="nx">pHead</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">pHead</span> <span class="o">==</span> <span class="nx">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="nx">NULL</span><span class="p">;</span>
        <span class="nx">ListNode</span> <span class="o">*</span><span class="nx">phony</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">ListNode</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        <span class="nx">phony</span><span class="o">-&gt;</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">pHead</span><span class="p">;</span>
        <span class="nx">ListNode</span> <span class="o">*</span><span class="nx">p</span> <span class="o">=</span> <span class="nx">pHead</span><span class="p">,</span> <span class="o">*</span><span class="nx">last</span> <span class="o">=</span> <span class="nx">phony</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="nx">p</span> <span class="o">!=</span> <span class="nx">NULL</span> <span class="o">&amp;&amp;</span> <span class="nx">p</span><span class="o">-&gt;</span><span class="nx">next</span> <span class="o">!=</span> <span class="nx">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">p</span><span class="o">-&gt;</span><span class="nx">val</span> <span class="o">==</span> <span class="nx">p</span><span class="o">-&gt;</span><span class="nx">next</span><span class="o">-&gt;</span><span class="nx">val</span><span class="p">)</span> <span class="p">{</span>
                <span class="kr">int</span> <span class="nx">val</span> <span class="o">=</span> <span class="nx">p</span><span class="o">-&gt;</span><span class="nx">val</span><span class="p">;</span>
                <span class="k">while</span> <span class="p">(</span><span class="nx">p</span> <span class="o">!=</span> <span class="nx">NULL</span> <span class="o">&amp;&amp;</span> <span class="nx">p</span><span class="o">-&gt;</span><span class="nx">val</span> <span class="o">==</span> <span class="nx">val</span><span class="p">)</span>
                    <span class="nx">p</span> <span class="o">=</span> <span class="nx">p</span><span class="o">-&gt;</span><span class="nx">next</span><span class="p">;</span>
                <span class="nx">last</span><span class="o">-&gt;</span><span class="nx">next</span> <span class="o">=</span> <span class="nx">p</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nx">last</span> <span class="o">=</span> <span class="nx">p</span><span class="p">;</span>
                <span class="nx">p</span> <span class="o">=</span> <span class="nx">p</span><span class="o">-&gt;</span><span class="nx">next</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">phony</span><span class="o">-&gt;</span><span class="nx">next</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
<p><strong>思路</strong>：</p>
<p>1) 我们每次都判断当前结点的值与下一个节点的值是否重复
2) 如果重复就循环寻找下一个不重复的节点，将他们链接新新链表的尾部（其实就是删除重复的节点）</p>
<h2 id="27">27. 二叉树的下一个结点</h2>
<p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p>
<div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm">struct TreeLinkNode {</span>
<span class="cm">    int val;</span>
<span class="cm">    struct TreeLinkNode *left;</span>
<span class="cm">    struct TreeLinkNode *right;</span>
<span class="cm">    struct TreeLinkNode *next;</span>
<span class="cm">    TreeLinkNode(int x) :val(x), left(NULL), right(NULL), next(NULL) {</span>

<span class="cm">    }</span>
<span class="cm">};</span>
<span class="cm">*/</span>
<span class="kr">class</span> <span class="nx">Solution</span> <span class="p">{</span>
<span class="kr">public</span><span class="o">:</span>
    <span class="nx">TreeLinkNode</span><span class="o">*</span> <span class="nx">GetNext</span><span class="p">(</span><span class="nx">TreeLinkNode</span><span class="o">*</span> <span class="nx">pNode</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">pNode</span> <span class="o">==</span> <span class="nx">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="nx">NULL</span><span class="p">;</span>
        <span class="c1">// 不要在局部函数内定义需要返回的变量，局部函数执行完就销毁了。</span>
        <span class="nx">TreeLinkNode</span> <span class="o">*</span><span class="nx">Next</span> <span class="o">=</span> <span class="nx">NULL</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">pNode</span><span class="o">-&gt;</span><span class="nx">right</span> <span class="o">!=</span> <span class="nx">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">TreeLinkNode</span> <span class="o">*</span><span class="nx">temp</span> <span class="o">=</span> <span class="nx">pNode</span><span class="o">-&gt;</span><span class="nx">right</span><span class="p">;</span>
            <span class="k">while</span> <span class="p">(</span><span class="nx">temp</span><span class="o">-&gt;</span><span class="nx">left</span> <span class="o">!=</span> <span class="nx">NULL</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">temp</span> <span class="o">=</span> <span class="nx">temp</span><span class="o">-&gt;</span><span class="nx">left</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="nx">Next</span> <span class="o">=</span> <span class="nx">temp</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nx">TreeLinkNode</span> <span class="o">*</span><span class="nx">parent</span> <span class="o">=</span> <span class="nx">pNode</span><span class="o">-&gt;</span><span class="nx">next</span><span class="p">;</span>
            <span class="nx">TreeLinkNode</span> <span class="o">*</span><span class="nx">current</span> <span class="o">=</span> <span class="nx">pNode</span><span class="p">;</span>
            <span class="k">while</span> <span class="p">(</span><span class="nx">parent</span> <span class="o">!=</span> <span class="nx">NULL</span> <span class="o">&amp;&amp;</span> <span class="nx">current</span> <span class="o">==</span> <span class="nx">parent</span><span class="o">-&gt;</span><span class="nx">right</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">current</span> <span class="o">=</span> <span class="nx">parent</span><span class="p">;</span>
                <span class="nx">parent</span> <span class="o">=</span> <span class="nx">parent</span><span class="o">-&gt;</span><span class="nx">next</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="nx">Next</span> <span class="o">=</span> <span class="nx">parent</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">Next</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
<p><strong>思路</strong>：</p>
<p>1) 如果当前结点有右子树, 那么其中序遍历的下一个结点就是其右子树的最左结点
2) 如果当前结点没有右子树, 而它是其父结点的左子结点那么其中序遍历的下一个结点就是他的父亲结点
3) 如果当前结点没有右子树，而它还是其父结点的右子结点，这种情况下其下一个结点应该是当前结点所在的左子树的根, 因此我们可以顺着其父节点一直向上遍历, 直到找到一个是它父结点的左子结点的结点</p>
<h2 id="28">28. 对称的二叉树</h2>
<p>请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p>
<div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm">struct TreeNode {</span>
<span class="cm">    int val;</span>
<span class="cm">    struct TreeNode *left;</span>
<span class="cm">    struct TreeNode *right;</span>
<span class="cm">    TreeNode(int x) :</span>
<span class="cm">            val(x), left(NULL), right(NULL) {</span>
<span class="cm">    }</span>
<span class="cm">};</span>
<span class="cm">*/</span>
<span class="kr">class</span> <span class="nx">Solution</span> <span class="p">{</span>
<span class="kr">public</span><span class="o">:</span>
    <span class="kt">bool</span> <span class="nx">isSymmetrical</span><span class="p">(</span><span class="nx">TreeNode</span><span class="o">*</span> <span class="nx">pRoot</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">pRoot</span> <span class="o">==</span> <span class="nx">NULL</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>   
        <span class="k">return</span> <span class="nx">isSymmetricalRecursion</span><span class="p">(</span><span class="nx">pRoot</span><span class="o">-&gt;</span><span class="nx">left</span><span class="p">,</span> <span class="nx">pRoot</span><span class="o">-&gt;</span><span class="nx">right</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kt">bool</span> <span class="nx">isSymmetricalRecursion</span><span class="p">(</span><span class="nx">TreeNode</span> <span class="o">*</span><span class="nx">pLeft</span><span class="p">,</span> <span class="nx">TreeNode</span> <span class="o">*</span><span class="nx">pRight</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">pLeft</span> <span class="o">==</span> <span class="nx">NULL</span> <span class="o">&amp;&amp;</span> <span class="nx">pRight</span> <span class="o">==</span> <span class="nx">NULL</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">pLeft</span> <span class="o">==</span> <span class="nx">NULL</span> <span class="o">||</span> <span class="nx">pRight</span> <span class="o">==</span> <span class="nx">NULL</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">pLeft</span><span class="o">-&gt;</span><span class="nx">val</span> <span class="o">!=</span> <span class="nx">pRight</span><span class="o">-&gt;</span><span class="nx">val</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
        <span class="c1">//  左子树的左与右子树的右对称</span>
        <span class="c1">//  左子树的右与右子树的左对称</span>
        <span class="k">return</span> <span class="nx">isSymmetricalRecursion</span><span class="p">(</span><span class="nx">pLeft</span><span class="o">-&gt;</span><span class="nx">left</span><span class="p">,</span> <span class="nx">pRight</span><span class="o">-&gt;</span><span class="nx">right</span><span class="p">)</span>
            <span class="o">&amp;&amp;</span> <span class="nx">isSymmetricalRecursion</span><span class="p">(</span><span class="nx">pLeft</span><span class="o">-&gt;</span><span class="nx">right</span><span class="p">,</span> <span class="nx">pRight</span><span class="o">-&gt;</span><span class="nx">left</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
<div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">Solution</span>
<span class="p">{</span>
<span class="kr">public</span><span class="o">:</span>
    <span class="kt">bool</span> <span class="nx">isSymmetrical</span><span class="p">(</span><span class="nx">TreeNode</span> <span class="o">*</span><span class="nx">root</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">root</span> <span class="o">==</span> <span class="nx">NULL</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span><span class="p">(</span><span class="nx">root</span><span class="o">-&gt;</span><span class="nx">left</span> <span class="o">==</span> <span class="nx">NULL</span>
        <span class="o">&amp;&amp;</span> <span class="nx">root</span><span class="o">-&gt;</span><span class="nx">right</span> <span class="o">==</span> <span class="nx">NULL</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span><span class="p">((</span><span class="nx">root</span><span class="o">-&gt;</span><span class="nx">left</span> <span class="o">==</span> <span class="nx">NULL</span> <span class="o">&amp;&amp;</span> <span class="nx">root</span><span class="o">-&gt;</span><span class="nx">right</span> <span class="o">!=</span> <span class="nx">NULL</span><span class="p">)</span>
        <span class="o">||</span> <span class="p">(</span><span class="nx">root</span><span class="o">-&gt;</span><span class="nx">left</span> <span class="o">!=</span> <span class="nx">NULL</span> <span class="o">&amp;&amp;</span> <span class="nx">root</span><span class="o">-&gt;</span><span class="nx">right</span> <span class="o">==</span> <span class="nx">NULL</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="nx">deque</span><span class="o">&lt;</span> <span class="nx">TreeNode</span> <span class="o">*</span> <span class="o">&gt;</span> <span class="nx">dq</span><span class="p">;</span>
        <span class="nx">dq</span><span class="p">.</span><span class="nx">push_front</span><span class="p">(</span><span class="nx">root</span><span class="o">-&gt;</span><span class="nx">left</span><span class="p">);</span>
        <span class="nx">dq</span><span class="p">.</span><span class="nx">push_back</span><span class="p">(</span><span class="nx">root</span><span class="o">-&gt;</span><span class="nx">right</span><span class="p">);</span>

        <span class="k">while</span><span class="p">(</span><span class="nx">dq</span><span class="p">.</span><span class="nx">empty</span><span class="p">(</span> <span class="p">)</span> <span class="o">!=</span> <span class="kc">true</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="nx">TreeNode</span><span class="o">*</span> <span class="nx">lroot</span> <span class="o">=</span> <span class="nx">dq</span><span class="p">.</span><span class="nx">front</span><span class="p">();</span>
            <span class="nx">TreeNode</span><span class="o">*</span> <span class="nx">rroot</span> <span class="o">=</span> <span class="nx">dq</span><span class="p">.</span><span class="nx">back</span><span class="p">();</span>
            <span class="nx">dq</span><span class="p">.</span><span class="nx">pop_front</span><span class="p">();</span>
            <span class="nx">dq</span><span class="p">.</span><span class="nx">pop_back</span><span class="p">();</span>

            <span class="k">if</span><span class="p">(</span><span class="nx">lroot</span> <span class="o">-&gt;</span> <span class="nx">val</span> <span class="o">!=</span> <span class="nx">rroot</span> <span class="o">-&gt;</span> <span class="nx">val</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">if</span><span class="p">((</span><span class="nx">lroot</span><span class="o">-&gt;</span><span class="nx">right</span> <span class="o">==</span> <span class="nx">NULL</span> <span class="o">&amp;&amp;</span> <span class="nx">rroot</span><span class="o">-&gt;</span><span class="nx">left</span> <span class="o">!=</span> <span class="nx">NULL</span><span class="p">)</span>
            <span class="o">||</span> <span class="p">(</span><span class="nx">lroot</span><span class="o">-&gt;</span><span class="nx">right</span> <span class="o">!=</span> <span class="nx">NULL</span> <span class="o">&amp;&amp;</span> <span class="nx">rroot</span><span class="o">-&gt;</span><span class="nx">left</span> <span class="o">==</span> <span class="nx">NULL</span><span class="p">))</span>
            <span class="p">{</span>
                <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">if</span><span class="p">(</span><span class="nx">lroot</span><span class="o">-&gt;</span><span class="nx">right</span> <span class="o">!=</span> <span class="nx">NULL</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="nx">dq</span><span class="p">.</span><span class="nx">push_front</span><span class="p">(</span><span class="nx">lroot</span><span class="o">-&gt;</span><span class="nx">right</span><span class="p">);</span>
                <span class="nx">dq</span><span class="p">.</span><span class="nx">push_back</span><span class="p">(</span><span class="nx">rroot</span><span class="o">-&gt;</span><span class="nx">left</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="k">if</span><span class="p">((</span><span class="nx">lroot</span><span class="o">-&gt;</span><span class="nx">left</span> <span class="o">==</span> <span class="nx">NULL</span> <span class="o">&amp;&amp;</span> <span class="nx">rroot</span><span class="o">-&gt;</span><span class="nx">right</span> <span class="o">!=</span> <span class="nx">NULL</span><span class="p">)</span>
            <span class="o">||</span> <span class="p">(</span><span class="nx">lroot</span><span class="o">-&gt;</span><span class="nx">left</span> <span class="o">!=</span> <span class="nx">NULL</span> <span class="o">&amp;&amp;</span> <span class="nx">rroot</span><span class="o">-&gt;</span><span class="nx">right</span> <span class="o">==</span> <span class="nx">NULL</span><span class="p">))</span>
            <span class="p">{</span>
                <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">if</span><span class="p">(</span><span class="nx">lroot</span><span class="o">-&gt;</span><span class="nx">left</span> <span class="o">!=</span> <span class="nx">NULL</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="nx">dq</span><span class="p">.</span><span class="nx">push_front</span><span class="p">(</span><span class="nx">lroot</span><span class="o">-&gt;</span><span class="nx">left</span><span class="p">);</span>
                <span class="nx">dq</span><span class="p">.</span><span class="nx">push_back</span><span class="p">(</span><span class="nx">rroot</span><span class="o">-&gt;</span><span class="nx">right</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
<h2 id="29">29. 按照之字形打印二叉树</h2>
<p>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p>
<div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm">struct TreeNode {</span>
<span class="cm">    int val;</span>
<span class="cm">    struct TreeNode *left;</span>
<span class="cm">    struct TreeNode *right;</span>
<span class="cm">    TreeNode(int x) :</span>
<span class="cm">            val(x), left(NULL), right(NULL) {</span>
<span class="cm">    }</span>
<span class="cm">};</span>
<span class="cm">*/</span>
<span class="kr">class</span> <span class="nx">Solution</span> <span class="p">{</span>
<span class="kr">public</span><span class="o">:</span>
    <span class="nx">vector</span><span class="o">&lt;</span><span class="nx">vector</span><span class="o">&lt;</span><span class="kr">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="nx">Print</span><span class="p">(</span><span class="nx">TreeNode</span><span class="o">*</span> <span class="nx">pRoot</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">vector</span><span class="o">&lt;</span><span class="nx">vector</span><span class="o">&lt;</span><span class="kr">int</span><span class="o">&gt;&gt;</span> <span class="nx">ret</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">pRoot</span> <span class="o">==</span> <span class="nx">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="nx">ret</span><span class="p">;</span>
        <span class="nx">vector</span><span class="o">&lt;</span><span class="kr">int</span><span class="o">&gt;</span> <span class="nx">curr</span><span class="p">;</span>
        <span class="nx">deque</span><span class="o">&lt;</span><span class="nx">TreeNode</span><span class="o">*&gt;</span> <span class="nx">deq</span><span class="p">;</span>
        <span class="nx">deq</span><span class="p">.</span><span class="nx">push_back</span><span class="p">(</span><span class="nx">NULL</span><span class="p">);</span><span class="c1">//层分隔符</span>
        <span class="nx">deq</span><span class="p">.</span><span class="nx">push_back</span><span class="p">(</span><span class="nx">pRoot</span><span class="p">);</span>
        <span class="kt">bool</span> <span class="nx">leftToRight</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="nx">deq</span><span class="p">.</span><span class="nx">size</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">){</span>
            <span class="nx">TreeNode</span><span class="o">*</span> <span class="nx">node</span> <span class="o">=</span> <span class="nx">deq</span><span class="p">.</span><span class="nx">front</span><span class="p">();</span>
            <span class="nx">deq</span><span class="p">.</span><span class="nx">pop_front</span><span class="p">();</span>
            <span class="k">if</span><span class="p">(</span><span class="nx">node</span> <span class="o">==</span> <span class="nx">NULL</span><span class="p">)</span>    <span class="c1">//  到达每层分隔符</span>
            <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="nx">leftToRight</span> <span class="o">==</span> <span class="kc">true</span><span class="p">)</span>    <span class="c1">//  从前完后遍历</span>
                <span class="p">{</span>
                    <span class="nx">deque</span><span class="o">&lt;</span><span class="nx">TreeNode</span><span class="o">*&gt;::</span><span class="nx">iterator</span> <span class="nx">iter</span><span class="p">;</span>
                    <span class="k">for</span><span class="p">(</span><span class="nx">iter</span> <span class="o">=</span> <span class="nx">deq</span><span class="p">.</span><span class="nx">begin</span><span class="p">();</span> <span class="nx">iter</span> <span class="o">!=</span> <span class="nx">deq</span><span class="p">.</span><span class="nx">end</span><span class="p">();</span> <span class="nx">iter</span><span class="o">++</span><span class="p">)</span>
                        <span class="nx">curr</span><span class="p">.</span><span class="nx">push_back</span><span class="p">((</span><span class="o">*</span><span class="nx">iter</span><span class="p">)</span><span class="o">-&gt;</span><span class="nx">val</span><span class="p">);</span>
                <span class="p">}</span> <span class="k">else</span>                        <span class="c1">//  从后往前遍历</span>
                <span class="p">{</span>
                    <span class="nx">deque</span><span class="o">&lt;</span><span class="nx">TreeNode</span><span class="o">*&gt;::</span><span class="nx">reverse_iterator</span> <span class="nx">riter</span><span class="p">;</span>
                    <span class="k">for</span><span class="p">(</span><span class="nx">riter</span> <span class="o">=</span> <span class="nx">deq</span><span class="p">.</span><span class="nx">rbegin</span><span class="p">();</span> <span class="nx">riter</span> <span class="o">&lt;</span> <span class="nx">deq</span><span class="p">.</span><span class="nx">rend</span><span class="p">();</span> <span class="nx">riter</span><span class="o">++</span><span class="p">)</span>
                        <span class="nx">curr</span><span class="p">.</span><span class="nx">push_back</span><span class="p">((</span><span class="o">*</span><span class="nx">riter</span><span class="p">)</span><span class="o">-&gt;</span><span class="nx">val</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="nx">leftToRight</span> <span class="o">=</span> <span class="o">!</span><span class="nx">leftToRight</span><span class="p">;</span>
                <span class="nx">ret</span><span class="p">.</span><span class="nx">push_back</span><span class="p">(</span><span class="nx">curr</span><span class="p">);</span>
                <span class="nx">curr</span><span class="p">.</span><span class="nx">clear</span><span class="p">();</span>
                <span class="nx">deq</span><span class="p">.</span><span class="nx">push_back</span><span class="p">(</span><span class="nx">NULL</span><span class="p">);</span><span class="c1">//添加层分隔符</span>
                <span class="k">continue</span><span class="p">;</span><span class="c1">//一定要continue</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">node</span><span class="o">-&gt;</span><span class="nx">left</span> <span class="o">!=</span> <span class="nx">NULL</span><span class="p">)</span>
                <span class="nx">deq</span><span class="p">.</span><span class="nx">push_back</span><span class="p">(</span><span class="nx">node</span><span class="o">-&gt;</span><span class="nx">left</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">node</span><span class="o">-&gt;</span><span class="nx">right</span> <span class="o">!=</span> <span class="nx">NULL</span><span class="p">)</span>
                <span class="nx">deq</span><span class="p">.</span><span class="nx">push_back</span><span class="p">(</span><span class="nx">node</span><span class="o">-&gt;</span><span class="nx">right</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">ret</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
<h2 id="30">30. 把二叉树打印出多行</h2>
<p>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p>
<div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm">struct TreeNode {</span>
<span class="cm">    int val;</span>
<span class="cm">    struct TreeNode *left;</span>
<span class="cm">    struct TreeNode *right;</span>
<span class="cm">    TreeNode(int x) :</span>
<span class="cm">            val(x), left(NULL), right(NULL) {</span>
<span class="cm">    }</span>
<span class="cm">};</span>
<span class="cm">*/</span>
<span class="kr">class</span> <span class="nx">Solution</span> <span class="p">{</span>
<span class="kr">public</span><span class="o">:</span>
        <span class="nx">vector</span><span class="o">&lt;</span><span class="nx">vector</span><span class="o">&lt;</span><span class="kr">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="nx">Print</span><span class="p">(</span><span class="nx">TreeNode</span><span class="o">*</span> <span class="nx">pRoot</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">vector</span><span class="o">&lt;</span><span class="nx">vector</span><span class="o">&lt;</span><span class="kr">int</span><span class="o">&gt;&gt;</span> <span class="nx">res</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">pRoot</span> <span class="o">==</span> <span class="nx">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="nx">res</span><span class="p">;</span>
            <span class="nx">vector</span><span class="o">&lt;</span><span class="kr">int</span><span class="o">&gt;</span> <span class="nx">temp</span><span class="p">;</span>
            <span class="nx">TreeNode</span><span class="o">*</span> <span class="nx">curr</span><span class="p">;</span>
            <span class="nx">queue</span><span class="o">&lt;</span><span class="nx">TreeNode</span><span class="o">*&gt;</span> <span class="nx">node</span><span class="p">;</span>
            <span class="nx">node</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">pRoot</span><span class="p">);</span>
            <span class="nx">node</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">NULL</span><span class="p">);</span>
            <span class="k">while</span> <span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">empty</span><span class="p">()</span> <span class="o">!=</span> <span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
                <span class="nx">curr</span> <span class="o">=</span> <span class="nx">node</span><span class="p">.</span><span class="nx">front</span><span class="p">();</span>
                <span class="nx">node</span><span class="p">.</span><span class="nx">pop</span><span class="p">();</span>
                <span class="k">if</span> <span class="p">(</span><span class="nx">curr</span> <span class="o">!=</span> <span class="nx">NULL</span><span class="p">)</span> <span class="p">{</span>
                    <span class="nx">temp</span><span class="p">.</span><span class="nx">push_back</span><span class="p">(</span><span class="nx">curr</span><span class="o">-&gt;</span><span class="nx">val</span><span class="p">);</span>
                    <span class="k">if</span> <span class="p">(</span><span class="nx">curr</span><span class="o">-&gt;</span><span class="nx">left</span> <span class="o">!=</span> <span class="nx">NULL</span><span class="p">)</span> <span class="nx">node</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">curr</span><span class="o">-&gt;</span><span class="nx">left</span><span class="p">);</span>
                    <span class="k">if</span> <span class="p">(</span><span class="nx">curr</span><span class="o">-&gt;</span><span class="nx">right</span> <span class="o">!=</span> <span class="nx">NULL</span><span class="p">)</span> <span class="nx">node</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">curr</span><span class="o">-&gt;</span><span class="nx">right</span><span class="p">);</span>
                <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">node</span><span class="p">.</span><span class="nx">empty</span><span class="p">()</span> <span class="o">!=</span> <span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
                    <span class="nx">res</span><span class="p">.</span><span class="nx">push_back</span><span class="p">(</span><span class="nx">temp</span><span class="p">);</span>
                    <span class="nx">temp</span><span class="p">.</span><span class="nx">clear</span><span class="p">();</span>
                    <span class="nx">node</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">NULL</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">temp</span><span class="p">.</span><span class="nx">size</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="nx">res</span><span class="p">.</span><span class="nx">push_back</span><span class="p">(</span><span class="nx">temp</span><span class="p">);</span>
            <span class="k">return</span> <span class="nx">res</span><span class="p">;</span>
        <span class="p">}</span>

<span class="p">};</span>
</pre></div>
<h2 id="31">31. 序列化二叉树</h2>
<p>请实现两个函数，分别用来序列化和反序列化二叉树。</p>
<div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm">struct TreeNode {</span>
<span class="cm">    int val;</span>
<span class="cm">    struct TreeNode *left;</span>
<span class="cm">    struct TreeNode *right;</span>
<span class="cm">    TreeNode(int x) :</span>
<span class="cm">            val(x), left(NULL), right(NULL) {</span>
<span class="cm">    }</span>
<span class="cm">};</span>
<span class="cm">*/</span>
<span class="kr">class</span> <span class="nx">Solution</span> <span class="p">{</span>
<span class="kr">public</span><span class="o">:</span>
    <span class="cm">/*  序列化二叉树  */</span>
    <span class="kr">char</span><span class="o">*</span> <span class="nx">Serialize</span><span class="p">(</span><span class="nx">TreeNode</span> <span class="o">*</span><span class="nx">root</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">root</span> <span class="o">==</span> <span class="nx">NULL</span><span class="p">){</span>
            <span class="kr">char</span> <span class="o">*</span><span class="nx">serial</span> <span class="o">=</span> <span class="k">new</span> <span class="kr">char</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
            <span class="nx">strcpy</span><span class="p">(</span><span class="nx">serial</span><span class="p">,</span> <span class="s2">"#,"</span><span class="p">);</span>
            <span class="k">return</span> <span class="nx">serial</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="kt">string</span> <span class="nx">str</span><span class="p">;</span>
        <span class="nx">Serialize</span><span class="p">(</span><span class="nx">root</span><span class="p">,</span> <span class="nx">str</span><span class="p">);</span>
        <span class="kr">const</span> <span class="kr">char</span>  <span class="o">*</span><span class="nx">c_str</span> <span class="o">=</span> <span class="nx">str</span><span class="p">.</span><span class="nx">c_str</span><span class="p">();</span>
        <span class="kr">char</span> <span class="o">*</span><span class="nx">serial</span> <span class="o">=</span> <span class="k">new</span> <span class="kr">char</span><span class="p">[</span><span class="nx">str</span><span class="p">.</span><span class="nx">length</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
        <span class="nx">strcpy</span><span class="p">(</span><span class="nx">serial</span><span class="p">,</span> <span class="nx">c_str</span><span class="p">);</span>
        <span class="k">return</span> <span class="nx">serial</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nx">TreeNode</span><span class="o">*</span> <span class="nx">Deserialize</span><span class="p">(</span><span class="kr">char</span> <span class="o">*</span><span class="nx">str</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">str</span> <span class="o">==</span> <span class="nx">NULL</span><span class="o">||</span> <span class="o">*</span><span class="nx">str</span> <span class="o">==</span> <span class="s1">'\0'</span><span class="p">)</span>
            <span class="k">return</span> <span class="nx">NULL</span><span class="p">;</span>
        <span class="kr">int</span> <span class="nx">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">return</span> <span class="nx">Deserialize</span><span class="p">(</span><span class="nx">str</span><span class="p">,</span> <span class="nx">index</span><span class="p">);</span>
    <span class="p">}</span>
<span class="kr">private</span><span class="o">:</span>
    <span class="k">void</span> <span class="nx">Serialize</span><span class="p">(</span><span class="nx">TreeNode</span> <span class="o">*</span><span class="nx">root</span><span class="p">,</span> <span class="kt">string</span> <span class="o">&amp;</span><span class="nx">str</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">root</span> <span class="o">==</span> <span class="nx">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">str</span> <span class="o">+=</span> <span class="s2">"#,"</span><span class="p">;</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="cm">/*  先序遍历的方式, 序列化二叉树  */</span>
        <span class="nx">str</span> <span class="o">+=</span> <span class="p">(</span><span class="nx">toString</span><span class="p">(</span><span class="nx">root</span><span class="o">-&gt;</span><span class="nx">val</span><span class="p">)</span> <span class="o">+</span> <span class="s2">","</span><span class="p">);</span>
        <span class="nx">Serialize</span><span class="p">(</span><span class="nx">root</span><span class="o">-&gt;</span><span class="nx">left</span><span class="p">,</span> <span class="nx">str</span><span class="p">);</span>
        <span class="nx">Serialize</span><span class="p">(</span><span class="nx">root</span><span class="o">-&gt;</span><span class="nx">right</span><span class="p">,</span> <span class="nx">str</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="cm">/*  反序列化二叉树</span>
<span class="cm">     *  将一个序列化的字符串转换成二叉树  */</span>
    <span class="nx">TreeNode</span><span class="o">*</span> <span class="nx">Deserialize</span><span class="p">(</span><span class="kr">char</span> <span class="o">*</span><span class="nx">str</span><span class="p">,</span> <span class="kr">int</span> <span class="o">&amp;</span><span class="nx">index</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">str</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span> <span class="o">==</span> <span class="s1">'#'</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">index</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
            <span class="k">return</span> <span class="nx">NULL</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="cm">/*  获取到节点的数字权值  */</span>
        <span class="kr">int</span> <span class="nx">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="nx">str</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">','</span> <span class="o">&amp;&amp;</span> <span class="nx">str</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">'\0'</span><span class="p">){</span>
            <span class="nx">num</span> <span class="o">=</span> <span class="nx">num</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">+</span> <span class="p">(</span><span class="nx">str</span><span class="p">[</span><span class="nx">index</span><span class="p">]</span> <span class="o">-</span> <span class="s1">'0'</span><span class="p">);</span>
            <span class="nx">index</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="nx">index</span><span class="o">++</span><span class="p">;</span>
        <span class="nx">TreeNode</span> <span class="o">*</span><span class="nx">root</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">TreeNode</span><span class="p">(</span><span class="nx">num</span><span class="p">);</span>
        <span class="nx">root</span><span class="o">-&gt;</span><span class="nx">left</span> <span class="o">=</span> <span class="nx">Deserialize</span><span class="p">(</span><span class="nx">str</span><span class="p">,</span> <span class="nx">index</span><span class="p">);</span>
        <span class="nx">root</span><span class="o">-&gt;</span><span class="nx">right</span> <span class="o">=</span> <span class="nx">Deserialize</span><span class="p">(</span><span class="nx">str</span><span class="p">,</span> <span class="nx">index</span><span class="p">);</span>
        <span class="k">return</span> <span class="nx">root</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">string</span> <span class="nx">toString</span><span class="p">(</span><span class="kr">int</span> <span class="nx">num</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">stringstream</span> <span class="nx">ss</span><span class="p">;</span>
        <span class="nx">ss</span> <span class="o">&lt;&lt;</span> <span class="nx">num</span><span class="p">;</span>
        <span class="k">return</span> <span class="nx">ss</span><span class="p">.</span><span class="nx">str</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
<h2 id="32-k">32. 二叉搜索树的第 <span class="math">\(k\)</span> 个结点</h2>
<p>给定一棵二叉搜索树，请找出其中的第 <span class="math">\(k\)</span> 小的结点。例如，（5，3，7，2，4，6，8） 中，按结点数值大小顺序第三小结点的值为 4。</p>
<div class="highlight"><pre><span></span><span class="cm">/*</span>
<span class="cm">struct TreeNode {</span>
<span class="cm">    int val;</span>
<span class="cm">    struct TreeNode *left;</span>
<span class="cm">    struct TreeNode *right;</span>
<span class="cm">    TreeNode(int x) :</span>
<span class="cm">            val(x), left(NULL), right(NULL) {</span>
<span class="cm">    }</span>
<span class="cm">};</span>
<span class="cm">*/</span>
<span class="kr">class</span> <span class="nx">Solution</span> <span class="p">{</span>
<span class="kr">private</span><span class="o">:</span>
    <span class="nx">unsigned</span> <span class="kr">int</span> <span class="nx">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kr">public</span><span class="o">:</span>
    <span class="nx">TreeNode</span><span class="o">*</span> <span class="nx">KthNode</span><span class="p">(</span><span class="nx">TreeNode</span><span class="o">*</span> <span class="nx">pRoot</span><span class="p">,</span> <span class="kr">int</span> <span class="nx">k</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">pRoot</span> <span class="o">==</span> <span class="nx">NULL</span><span class="p">)</span>
            <span class="k">return</span> <span class="nx">NULL</span><span class="p">;</span>
        <span class="nx">TreeNode</span> <span class="o">*</span><span class="nx">ret</span> <span class="o">=</span> <span class="nx">NULL</span><span class="p">;</span>
        <span class="k">if</span><span class="p">((</span><span class="nx">ret</span> <span class="o">=</span> <span class="nx">KthNode</span><span class="p">(</span><span class="nx">pRoot</span><span class="o">-&gt;</span><span class="nx">left</span><span class="p">,</span> <span class="nx">k</span><span class="p">))</span> <span class="o">!=</span> <span class="nx">NULL</span><span class="p">)</span>
            <span class="k">return</span> <span class="nx">ret</span><span class="p">;</span>
        <span class="o">++</span><span class="nx">count</span><span class="p">;</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">count</span> <span class="o">==</span> <span class="nx">k</span><span class="p">)</span>
            <span class="k">return</span> <span class="nx">pRoot</span><span class="p">;</span>
        <span class="k">if</span><span class="p">((</span><span class="nx">ret</span> <span class="o">=</span> <span class="nx">KthNode</span><span class="p">(</span><span class="nx">pRoot</span><span class="o">-&gt;</span><span class="nx">right</span><span class="p">,</span> <span class="nx">k</span><span class="p">))</span> <span class="o">!=</span> <span class="nx">NULL</span><span class="p">)</span>
            <span class="k">return</span> <span class="nx">ret</span><span class="p">;</span>
        <span class="k">return</span> <span class="nx">NULL</span><span class="p">;</span>
    <span class="p">}</span>  
<span class="p">};</span>
</pre></div>
<h2 id="33">33. 数据流中的中位数</h2>
<p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用 Insert() 方法读取数据流，使用 GetMedian() 方法获取当前读取数据的中位数。</p>
<div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">Solution</span> <span class="p">{</span>
<span class="kr">private</span><span class="o">:</span>
    <span class="nx">vector</span><span class="o">&lt;</span><span class="kr">int</span><span class="o">&gt;</span> <span class="nx">m_min</span><span class="p">;</span> <span class="c1">// 后半部分数据</span>
    <span class="nx">vector</span><span class="o">&lt;</span><span class="kr">int</span><span class="o">&gt;</span> <span class="nx">m_max</span><span class="p">;</span> <span class="c1">// 前半部分数据</span>
<span class="kr">protected</span><span class="o">:</span>
    <span class="k">void</span> <span class="nx">MakeHeapify</span><span class="p">(</span><span class="nx">vector</span><span class="o">&lt;</span><span class="kr">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="nx">a</span><span class="p">,</span> <span class="kr">int</span> <span class="nx">start</span><span class="p">,</span> <span class="kr">int</span> <span class="nx">end</span><span class="p">,</span> <span class="kr">int</span> <span class="nx">flag</span><span class="p">)</span> <span class="p">{</span>
        <span class="kr">int</span> <span class="nx">dad</span> <span class="o">=</span> <span class="nx">start</span><span class="p">;</span>
        <span class="kr">int</span> <span class="nx">son</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nx">dad</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="c1">// 最大堆</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">flag</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">while</span> <span class="p">(</span><span class="nx">son</span> <span class="o">&lt;=</span> <span class="nx">end</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="nx">son</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="nx">end</span> <span class="o">&amp;&amp;</span> <span class="nx">a</span><span class="p">[</span><span class="nx">son</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nx">a</span><span class="p">[</span><span class="nx">son</span><span class="p">])</span>
                    <span class="nx">son</span><span class="o">++</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="nx">a</span><span class="p">[</span><span class="nx">dad</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="nx">a</span><span class="p">[</span><span class="nx">son</span><span class="p">])</span> <span class="k">return</span><span class="p">;</span>
                <span class="k">else</span> <span class="p">{</span>
                    <span class="nx">swap</span><span class="p">(</span><span class="nx">a</span><span class="p">[</span><span class="nx">dad</span><span class="p">],</span> <span class="nx">a</span><span class="p">[</span><span class="nx">son</span><span class="p">]);</span>
                    <span class="nx">dad</span> <span class="o">=</span> <span class="nx">son</span><span class="p">;</span>
                    <span class="nx">son</span> <span class="o">=</span> <span class="nx">dad</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="c1">// 最小堆</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">flag</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">while</span> <span class="p">(</span><span class="nx">son</span> <span class="o">&lt;=</span> <span class="nx">end</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="nx">son</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="nx">end</span> <span class="o">&amp;&amp;</span> <span class="nx">a</span><span class="p">[</span><span class="nx">son</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">a</span><span class="p">[</span><span class="nx">son</span><span class="p">])</span>
                    <span class="nx">son</span><span class="o">++</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="nx">a</span><span class="p">[</span><span class="nx">dad</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nx">a</span><span class="p">[</span><span class="nx">son</span><span class="p">])</span> <span class="k">return</span><span class="p">;</span>
                <span class="k">else</span> <span class="p">{</span>
                    <span class="nx">swap</span><span class="p">(</span><span class="nx">a</span><span class="p">[</span><span class="nx">dad</span><span class="p">],</span> <span class="nx">a</span><span class="p">[</span><span class="nx">son</span><span class="p">]);</span>
                    <span class="nx">dad</span> <span class="o">=</span> <span class="nx">son</span><span class="p">;</span>
                    <span class="nx">son</span> <span class="o">=</span> <span class="nx">dad</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">void</span> <span class="nx">swap</span><span class="p">(</span><span class="kr">int</span> <span class="o">&amp;</span><span class="nx">a</span><span class="p">,</span> <span class="kr">int</span> <span class="o">&amp;</span><span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">a</span> <span class="o">!=</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">a</span> <span class="o">^=</span> <span class="nx">b</span><span class="p">;</span>
            <span class="nx">b</span> <span class="o">^=</span> <span class="nx">a</span><span class="p">;</span>
            <span class="nx">a</span> <span class="o">^=</span> <span class="nx">b</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="kr">public</span><span class="o">:</span>
    <span class="k">void</span> <span class="nx">Insert</span><span class="p">(</span><span class="kr">int</span> <span class="nx">num</span><span class="p">)</span> <span class="p">{</span>
        <span class="kr">int</span> <span class="nx">temp</span> <span class="o">=</span> <span class="nx">num</span><span class="p">;</span>
        <span class="c1">// 偶数时，假设最大堆比最小堆少1 关系 &gt; 逐位运算</span>
        <span class="k">if</span> <span class="p">(((</span><span class="nx">m_min</span><span class="p">.</span><span class="nx">size</span><span class="p">()</span> <span class="o">+</span> <span class="nx">m_max</span><span class="p">.</span><span class="nx">size</span><span class="p">())</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">m_max</span><span class="p">.</span><span class="nx">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">num</span> <span class="o">&lt;</span> <span class="nx">m_max</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
                <span class="nx">swap</span><span class="p">(</span><span class="nx">m_max</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">temp</span><span class="p">);</span>
                <span class="nx">MakeHeapify</span><span class="p">(</span><span class="nx">m_max</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">m_max</span><span class="p">.</span><span class="nx">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="nx">m_min</span><span class="p">.</span><span class="nx">push_back</span><span class="p">(</span><span class="nx">temp</span><span class="p">);</span>
            <span class="nx">MakeHeapify</span><span class="p">(</span><span class="nx">m_min</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">m_min</span><span class="p">.</span><span class="nx">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">m_min</span><span class="p">.</span><span class="nx">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">num</span> <span class="o">&gt;</span> <span class="nx">m_min</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
                <span class="nx">swap</span><span class="p">(</span><span class="nx">m_min</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">temp</span><span class="p">);</span>
                <span class="nx">MakeHeapify</span><span class="p">(</span><span class="nx">m_min</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">m_min</span><span class="p">.</span><span class="nx">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="nx">m_max</span><span class="p">.</span><span class="nx">push_back</span><span class="p">(</span><span class="nx">temp</span><span class="p">);</span>
            <span class="nx">MakeHeapify</span><span class="p">(</span><span class="nx">m_max</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">m_max</span><span class="p">.</span><span class="nx">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kr">double</span> <span class="nx">GetMedian() {</span>
        <span class="kr">int</span> <span class="nx">size</span> <span class="o">=</span> <span class="nx">m_min</span><span class="p">.</span><span class="nx">size</span><span class="p">()</span> <span class="o">+</span> <span class="nx">m_max</span><span class="p">.</span><span class="nx">size</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="kr">double</span> <span class="nx">median</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">if</span><span class="p">((</span><span class="nx">size</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="nx">median</span> <span class="o">=</span> <span class="p">(</span><span class="kr">double</span><span class="p">)</span> <span class="nx">m_min</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="k">else</span>
            <span class="nx">median</span> <span class="o">=</span> <span class="p">(</span><span class="kr">double</span><span class="p">)</span> <span class="p">(</span><span class="nx">m_max</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nx">m_min</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
        <span class="k">return</span> <span class="nx">median</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
<h2 id="34">34. 滑动窗口的最大值</h2>
<p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。</p>
<div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">Solution</span> <span class="p">{</span>
<span class="kr">public</span><span class="o">:</span>
    <span class="nx">vector</span><span class="o">&lt;</span><span class="kr">int</span><span class="o">&gt;</span> <span class="nx">maxInWindows</span><span class="p">(</span><span class="kr">const</span> <span class="nx">vector</span><span class="o">&lt;</span><span class="kr">int</span><span class="o">&gt;&amp;</span> <span class="nx">num</span><span class="p">,</span> <span class="nx">unsigned</span> <span class="kr">int</span> <span class="nx">size</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="nx">vector</span><span class="o">&lt;</span><span class="kr">int</span><span class="o">&gt;</span> <span class="nx">res</span><span class="p">;</span>
        <span class="nx">deque</span><span class="o">&lt;</span><span class="kr">int</span><span class="o">&gt;</span> <span class="nx">index</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="nx">unsigned</span> <span class="kr">int</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">num</span><span class="p">.</span><span class="nx">size</span><span class="p">();</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="cm">/*  从后面依次弹出队列中比当前num值小的元素，</span>
<span class="cm">             *  同时也能保证队列首元素为当前窗口最大值下标  */</span>
            <span class="k">while</span><span class="p">(</span><span class="nx">index</span><span class="p">.</span><span class="nx">size</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">num</span><span class="p">[</span><span class="nx">index</span><span class="p">.</span><span class="nx">back</span><span class="p">()]</span> <span class="o">&lt;=</span> <span class="nx">num</span><span class="p">[</span><span class="nx">i</span><span class="p">])</span>
                <span class="nx">index</span><span class="p">.</span><span class="nx">pop_back</span><span class="p">();</span>
            <span class="cm">/*  当前窗口移出队首元素所在的位置</span>
<span class="cm">                即队首元素坐标对应的num不在窗口中，需要弹出  */</span>
            <span class="k">while</span><span class="p">(</span><span class="nx">index</span><span class="p">.</span><span class="nx">size</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nx">i</span> <span class="o">-</span> <span class="nx">index</span><span class="p">.</span><span class="nx">front</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="nx">size</span><span class="p">)</span>
                <span class="nx">index</span><span class="p">.</span><span class="nx">pop_front</span><span class="p">(</span> <span class="p">);</span>
            <span class="cm">/*  把每次滑动的num下标加入队列  */</span>
            <span class="nx">index</span><span class="p">.</span><span class="nx">push_back</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span>
            <span class="cm">/*  当滑动窗口首地址i大于等于size时才开始写入窗口最大值  */</span>
            <span class="k">if</span><span class="p">(</span><span class="nx">size</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="nx">size</span><span class="p">)</span>
                <span class="nx">res</span><span class="p">.</span><span class="nx">push_back</span><span class="p">(</span><span class="nx">num</span><span class="p">[</span><span class="nx">index</span><span class="p">.</span><span class="nx">front</span><span class="p">()]);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">res</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
<h2 id="35">35. 矩阵中的路径</h2>
<p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。 例如 a b c e s f c s a d e e 这样的3 X 4 矩阵中包含一条字符串"bcced"的路径，但是矩阵中不包含"abcb"路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</p>
<div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">Solution</span> <span class="p">{</span>
<span class="kr">public</span><span class="o">:</span>
    <span class="kt">bool</span> <span class="nx">hasPath</span><span class="p">(</span><span class="kr">char</span><span class="o">*</span> <span class="nx">matrix</span><span class="p">,</span> <span class="kr">int</span> <span class="nx">rows</span><span class="p">,</span> <span class="kr">int</span> <span class="nx">cols</span><span class="p">,</span> <span class="kr">char</span><span class="o">*</span> <span class="nx">str</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">matrix</span> <span class="o">==</span> <span class="nx">NULL</span> <span class="o">||</span> <span class="nx">rows</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="nx">cols</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="nx">str</span> <span class="o">==</span> <span class="nx">NULL</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
        <span class="c1">//定义一个辅助矩阵，用来标记路径是否已经进入了每个格子</span>
        <span class="kt">bool</span><span class="o">*</span> <span class="nx">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">bool</span><span class="p">[</span><span class="nx">rows</span> <span class="o">*</span> <span class="nx">cols</span><span class="p">];</span>
        <span class="nx">memset</span><span class="p">(</span><span class="nx">visited</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">rows</span> <span class="o">*</span> <span class="nx">cols</span><span class="p">);</span>
        <span class="kr">int</span> <span class="nx">pathLength</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="c1">//该循环是为了实现从任何一个位置出发，寻找路径</span>
        <span class="k">for</span> <span class="p">(</span><span class="kr">int</span> <span class="nx">row</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">row</span> <span class="o">&lt;</span> <span class="nx">rows</span><span class="p">;</span> <span class="o">++</span><span class="nx">row</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kr">int</span> <span class="nx">col</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">col</span> <span class="o">&lt;</span> <span class="nx">cols</span><span class="p">;</span> <span class="o">++</span><span class="nx">col</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="nx">hasPathCore</span><span class="p">(</span><span class="nx">matrix</span><span class="p">,</span> <span class="nx">rows</span><span class="p">,</span> <span class="nx">cols</span><span class="p">,</span> <span class="nx">row</span><span class="p">,</span>
                                <span class="nx">col</span><span class="p">,</span> <span class="nx">str</span><span class="p">,</span> <span class="nx">pathLength</span><span class="p">,</span> <span class="nx">visited</span><span class="p">))</span>
                    <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">delete</span><span class="p">[]</span> <span class="nx">visited</span><span class="p">;</span>
        <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="cm">/*此函数用来判断在当前路径满足条件下，相邻格子中是否存在一个格子满足条件*/</span>
    <span class="kt">bool</span> <span class="nx">hasPathCore</span><span class="p">(</span><span class="kr">char</span><span class="o">*</span> <span class="nx">matrix</span><span class="p">,</span> <span class="kr">int</span> <span class="nx">rows</span><span class="p">,</span> <span class="kr">int</span> <span class="nx">cols</span><span class="p">,</span> <span class="kr">int</span> <span class="nx">row</span><span class="p">,</span>
                     <span class="kr">int</span> <span class="nx">col</span><span class="p">,</span> <span class="kr">char</span><span class="o">*</span> <span class="nx">str</span><span class="p">,</span> <span class="kr">int</span><span class="o">&amp;</span> <span class="nx">pathLength</span><span class="p">,</span> <span class="kt">bool</span><span class="o">*</span> <span class="nx">visited</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">str</span><span class="p">[</span><span class="nx">pathLength</span><span class="p">]</span> <span class="o">==</span> <span class="s1">'\0'</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="nx">hasPath</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">row</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">row</span> <span class="o">&lt;</span> <span class="nx">rows</span> <span class="o">&amp;&amp;</span> <span class="nx">col</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">col</span> <span class="o">&lt;</span> <span class="nx">cols</span>
            <span class="o">&amp;&amp;</span> <span class="nx">matrix</span><span class="p">[</span><span class="nx">row</span> <span class="o">*</span> <span class="nx">cols</span> <span class="o">+</span> <span class="nx">col</span><span class="p">]</span> <span class="o">==</span> <span class="nx">str</span><span class="p">[</span><span class="nx">pathLength</span><span class="p">]</span>
            <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">visited</span><span class="p">[</span><span class="nx">row</span> <span class="o">*</span> <span class="nx">cols</span> <span class="o">+</span> <span class="nx">col</span><span class="p">])</span> <span class="p">{</span>
            <span class="o">++</span><span class="nx">pathLength</span><span class="p">;</span>
            <span class="nx">visited</span><span class="p">[</span><span class="nx">row</span> <span class="o">*</span> <span class="nx">cols</span> <span class="o">+</span> <span class="nx">col</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
            <span class="cm">/*如果矩阵格子(row,col)与路径字符串中下标为pathLength的字符一样时，</span>
<span class="cm">            从它的4个相邻格子中寻找与路径字符串下标为pathLength+1的字符相等的格子*/</span>
            <span class="nx">hasPath</span> <span class="o">=</span> <span class="nx">hasPathCore</span><span class="p">(</span><span class="nx">matrix</span><span class="p">,</span> <span class="nx">rows</span><span class="p">,</span> <span class="nx">cols</span><span class="p">,</span> <span class="nx">row</span><span class="p">,</span> <span class="nx">col</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">str</span><span class="p">,</span> <span class="nx">pathLength</span><span class="p">,</span> <span class="nx">visited</span><span class="p">)</span> <span class="o">||</span>
                <span class="nx">hasPathCore</span><span class="p">(</span><span class="nx">matrix</span><span class="p">,</span> <span class="nx">rows</span><span class="p">,</span> <span class="nx">cols</span><span class="p">,</span> <span class="nx">row</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">col</span><span class="p">,</span> <span class="nx">str</span><span class="p">,</span> <span class="nx">pathLength</span><span class="p">,</span> <span class="nx">visited</span><span class="p">)</span> <span class="o">||</span>
                <span class="nx">hasPathCore</span><span class="p">(</span><span class="nx">matrix</span><span class="p">,</span> <span class="nx">rows</span><span class="p">,</span> <span class="nx">cols</span><span class="p">,</span> <span class="nx">row</span><span class="p">,</span> <span class="nx">col</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">str</span><span class="p">,</span> <span class="nx">pathLength</span><span class="p">,</span> <span class="nx">visited</span><span class="p">)</span> <span class="o">||</span>
                <span class="nx">hasPathCore</span><span class="p">(</span><span class="nx">matrix</span><span class="p">,</span> <span class="nx">rows</span><span class="p">,</span> <span class="nx">cols</span><span class="p">,</span> <span class="nx">row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">col</span><span class="p">,</span> <span class="nx">str</span><span class="p">,</span> <span class="nx">pathLength</span><span class="p">,</span> <span class="nx">visited</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">hasPath</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">//如果没找到，则说明当前第pathLength个字符定位不正确，返回上一个位置重新定位</span>
                <span class="o">--</span><span class="nx">pathLength</span><span class="p">;</span>
                <span class="nx">visited</span><span class="p">[</span><span class="nx">row</span> <span class="o">*</span> <span class="nx">cols</span> <span class="o">+</span> <span class="nx">col</span><span class="p">]</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">hasPath</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
<h2 id="37">37. 机器人的运动范围</h2>
<p>地上有一个 <span class="math">\(m\)</span> 行和 <span class="math">\(n\)</span> 列的方格。一个机器人从坐标 (0,0) 的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于 <span class="math">\(k\)</span> 的格子。 例如，当 <span class="math">\(k\)</span> 为 18 时，机器人能够进入方格（35,37），因为 3+5+3+7 = 18。但是，它不能进入方格（35,38），因为 3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p>
<div class="highlight"><pre><span></span><span class="kr">class</span> <span class="nx">Solution</span> <span class="p">{</span>
<span class="kr">public</span><span class="o">:</span>
    <span class="kr">int</span> <span class="nx">movingCount</span><span class="p">(</span><span class="kr">int</span> <span class="nx">threshold</span><span class="p">,</span> <span class="kr">int</span> <span class="nx">rows</span><span class="p">,</span> <span class="kr">int</span> <span class="nx">cols</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">bool</span><span class="o">*</span> <span class="nx">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">bool</span><span class="p">[</span><span class="nx">rows</span> <span class="o">*</span> <span class="nx">cols</span><span class="p">];</span>
        <span class="nx">memset</span><span class="p">(</span><span class="nx">visited</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">rows</span> <span class="o">*</span> <span class="nx">cols</span><span class="p">);</span>
        <span class="kr">int</span> <span class="nx">count</span> <span class="o">=</span> <span class="nx">movingCountCore</span><span class="p">(</span><span class="nx">threshold</span><span class="p">,</span> <span class="nx">rows</span><span class="p">,</span> <span class="nx">cols</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">visited</span><span class="p">);</span>
        <span class="k">delete</span><span class="p">[]</span> <span class="nx">visited</span><span class="p">;</span>
        <span class="k">return</span> <span class="nx">count</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kr">int</span> <span class="nx">movingCountCore</span><span class="p">(</span><span class="kr">int</span> <span class="nx">threshold</span><span class="p">,</span> <span class="kr">int</span> <span class="nx">rows</span><span class="p">,</span> <span class="kr">int</span> <span class="nx">cols</span><span class="p">,</span>
                        <span class="kr">int</span> <span class="nx">row</span><span class="p">,</span> <span class="kr">int</span> <span class="nx">col</span><span class="p">,</span> <span class="kt">bool</span><span class="o">*</span> <span class="nx">visited</span><span class="p">)</span> <span class="p">{</span>
        <span class="kr">int</span> <span class="nx">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">check</span><span class="p">(</span><span class="nx">threshold</span><span class="p">,</span> <span class="nx">rows</span><span class="p">,</span> <span class="nx">cols</span><span class="p">,</span> <span class="nx">row</span><span class="p">,</span> <span class="nx">col</span><span class="p">,</span> <span class="nx">visited</span><span class="p">))</span> <span class="p">{</span>
            <span class="nx">visited</span><span class="p">[</span><span class="nx">row</span> <span class="o">*</span> <span class="nx">cols</span> <span class="o">+</span> <span class="nx">col</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
            <span class="nx">count</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span>
                <span class="nx">movingCountCore</span><span class="p">(</span><span class="nx">threshold</span><span class="p">,</span> <span class="nx">rows</span><span class="p">,</span> <span class="nx">cols</span><span class="p">,</span> <span class="nx">row</span><span class="p">,</span> <span class="nx">col</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">visited</span><span class="p">)</span> <span class="o">+</span>
                <span class="nx">movingCountCore</span><span class="p">(</span><span class="nx">threshold</span><span class="p">,</span> <span class="nx">rows</span><span class="p">,</span> <span class="nx">cols</span><span class="p">,</span> <span class="nx">row</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">col</span><span class="p">,</span> <span class="nx">visited</span><span class="p">)</span> <span class="o">+</span>
                <span class="nx">movingCountCore</span><span class="p">(</span><span class="nx">threshold</span><span class="p">,</span> <span class="nx">rows</span><span class="p">,</span> <span class="nx">cols</span><span class="p">,</span> <span class="nx">row</span><span class="p">,</span> <span class="nx">col</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">visited</span><span class="p">)</span> <span class="o">+</span>
                <span class="nx">movingCountCore</span><span class="p">(</span><span class="nx">threshold</span><span class="p">,</span> <span class="nx">rows</span><span class="p">,</span> <span class="nx">cols</span><span class="p">,</span> <span class="nx">row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">col</span><span class="p">,</span> <span class="nx">visited</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">count</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="cm">/*该函数检查坐标为(row,col)的方格能够进入*/</span>
    <span class="kt">bool</span> <span class="nx">check</span><span class="p">(</span><span class="kr">int</span> <span class="nx">threshold</span><span class="p">,</span> <span class="kr">int</span> <span class="nx">rows</span><span class="p">,</span> <span class="kr">int</span> <span class="nx">cols</span><span class="p">,</span> <span class="kr">int</span> <span class="nx">row</span><span class="p">,</span> <span class="kr">int</span> <span class="nx">col</span><span class="p">,</span> <span class="kt">bool</span><span class="o">*</span><span class="nx">visited</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">row</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">row</span> <span class="o">&lt;</span> <span class="nx">rows</span> <span class="o">&amp;&amp;</span> <span class="nx">col</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">col</span> <span class="o">&lt;</span> <span class="nx">cols</span>
            <span class="o">&amp;&amp;</span> <span class="nx">getDigitSum</span><span class="p">(</span><span class="nx">row</span><span class="p">)</span> <span class="o">+</span> <span class="nx">getDigitSum</span><span class="p">(</span><span class="nx">col</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nx">threshold</span>
            <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">visited</span><span class="p">[</span><span class="nx">row</span><span class="o">*</span><span class="nx">cols</span> <span class="o">+</span> <span class="nx">col</span><span class="p">])</span>
            <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
        <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="cm">/*计算一个数的所有位数之和*/</span>
    <span class="kr">int</span> <span class="nx">getDigitSum</span><span class="p">(</span><span class="kr">int</span> <span class="kt">number</span><span class="p">)</span> <span class="p">{</span>
        <span class="kr">int</span> <span class="nx">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="kt">number</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="nx">sum</span> <span class="o">+=</span> <span class="kt">number</span> <span class="o">%</span> <span class="mi">10</span><span class="p">;</span>
            <span class="kt">number</span> <span class="o">=</span> <span class="kt">number</span> <span class="o">/</span> <span class="mi">10</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nx">sum</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
<script type="text/javascript">if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (false) {
        align = (screen.width < 768) ? "left" : align;
        indent = (screen.width < 768) ? "0em" : indent;
        linebreak = (screen.width < 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';
    mathjaxscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
</script>
                <aside>
                    <hr />
                    <nav class="related">
                        <h1>
                            <font color="#771515"><em>RELATED</em></font>
                        </h1>
                        <ul>
                            <li>
                                <a href="https://xutree.github.io/pages/2018/10/07/jzoffer1/">剑指 offer (1)</a>
                            </li>
                            <li>
                                <a href="https://xutree.github.io/pages/2019/08/21/note/">算法笔记</a>
                            </li>
                            <li>
                                <a href="https://xutree.github.io/pages/2018/10/27/find_maximum_subarray/">最大子数组问题</a>
                            </li>
                            <li>
                                <a href="https://xutree.github.io/pages/2018/10/26/sort/">排序算法</a>
                            </li>
                        </ul>
                    </nav>
                    <nav class="older">
                        <h1>
                            <font color="#771515"><em>OLDER</em></font>
                        </h1>
                        <ul>
                            <li>
                                <a href="https://xutree.github.io/pages/2018/10/08/linux中的扩展和引用/">
                                    Linux 中的扩展和引用
                                </a>
                            </li>
                            <li>
                                <a href="https://xutree.github.io/pages/2018/10/07/jzoffer1/">
                                    剑指 offer (1)
                                </a>
                            </li>
                            <li>
                                <a href="https://xutree.github.io/pages/2018/10/07/css_overview/">
                                    CSS 入门
                                </a>
                            </li>
                            <li>
                                <a href="https://xutree.github.io/pages/2018/10/07/C++_Primer_Chapter_4/">
                                    C++ Primer 第四章 表达式
                                </a>
                            </li>
                            <li>
                                <a href="https://xutree.github.io/pages/2018/10/06/C++_Primer_Chapter_3/">
                                    C++ Primer 第三章 字符串、向量和数组
                                </a>
                            </li>
                        </ul>
                    </nav>
                    <nav class="newer">
                        <h1>
                            <font color="#771515"><em>NEWER</em></font>
                        </h1>
                        <ul>
                            <li>
                                <a href="https://xutree.github.io/pages/2018/10/08/几个奇葩的Linux命令/">
                                    几个奇葩的 Linux 命令
                                </a>
                            </li>
                            <li>
                                <a href="https://xutree.github.io/pages/2018/10/09/C++_Primer_Chapter_5/">
                                    C++ Primer 第五章 语句
                                </a>
                            </li>
                            <li>
                                <a href="https://xutree.github.io/pages/2018/10/09/回车与换行的区别/">
                                    回车与换行的区别
                                </a>
                            </li>
                            <li>
                                <a href="https://xutree.github.io/pages/2018/10/09/C++_Primer_Chapter_6/">
                                    C++ Primer 第六章 函数
                                </a>
                            </li>
                            <li>
                                <a href="https://xutree.github.io/pages/2018/10/09/C++_Primer_Chapter_7/">
                                    C++ Primer 第七章 类
                                </a>
                            </li>
                        </ul>
                    </nav>
                    <!-- Gitalk 评论 start  -->

                    <!-- Link Gitalk 的支持文件  -->
                    <!-- <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
                    <script src="https://unpkg.com/gitalk@latest/dist/gitalk.min.js"></script>
                    <div id="gitalk-container"></div>
                    <script type="text/javascript">
                        var dateTime = Date.now();
                        var timestamp = Math.floor(dateTime / 1000);
                        var gitalk = new Gitalk({

                            // gitalk的主要参数
                            clientID: '93f43349e9fd3154bfad',
                            clientSecret: 'd6d09d1d7261f6b62f46b39e5fcace85b81c3cd7',
                            repo: 'xutree.github.io',
                            owner: 'xutree',
                            admin: ['xutree'],
                            id: String(timestamp)

                        });
                        gitalk.render('gitalk-container');
                    </script> -->
                    <!-- Gitalk end -->
                </aside>
            </div>
            <section>
                <div class="span2" style="float:right;font-size:0.9em;">
                    <h4>发布日期</h4>
                    <time pubdate="pubdate" datetime="2018-10-08T19:37:12+08:00">2018-10-08 19:37:12</time>
                    <h4>最后更新</h4>
                    <div class="last_updated">2018-11-26 22:42:52</div>
                    <h4>分类</h4>
                    <a class="category-link" href="/categories.html#读书笔记-ref">读书笔记</a>
                    <h4>标签</h4>
                    <ul class="list-of-tags tags-in-article">
                        <li><a href="/tags.html#剑指offer-ref">剑指offer
                                <span>2</span>
</a></li>
                        <li><a href="/tags.html#面试-ref">面试
                                <span>2</span>
</a></li>
                        <li><a href="/tags.html#算法-ref">算法
                                <span>5</span>
</a></li>
                    </ul>

                </div>
            </section>
        </div>
</article>
                </div>
                <div class="span1"></div>
            </div>
        </div>
    </div>
<footer>
<div id="footer">
    <ul class="footer-content">
        <li class="elegant-power">Powered by <a href="http://getpelican.com/" title="Pelican Home Page">Pelican</a>. Theme: <a href="http://oncrashreboot.com/pelican-elegant" title="Theme Elegant Home Page">Elegant</a> by <a href="http://oncrashreboot.com" title="Talha Mansoor Home Page">Talha Mansoor</a></li>
    </ul>
</div>
</footer>    <script src="https://code.jquery.com/jquery.min.js"></script>
    <script src="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.1/js/bootstrap.min.js"></script>
    <script>
        function validateForm(query) {
            return (query.length > 0);
        }
    </script>
</body>

</html>