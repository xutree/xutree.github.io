{"pages":[{"title":"Search · You Know Nothing\n","text":"\n\n\n\n\n\n\nSearch · You Know Nothing\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nYou Know Nothing\n\n\n主页\n分类\n标签\n归档\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPowered by Pelican. Theme: Elegant by Talha Mansoor\n\n\n\n\n\n\n    $(document).ready(function() {\n        $('#tipue_search_input').tipuesearch({\n            'mode': 'json',\n            'show': 10,\n            'newWindow': false,\n            'contentLocation': 'tipuesearch_content.json'\n        });\n    });\n\n\n","tags":"","url":"https://xutree.github.io/search.html"},{"title":"Page not found · You Know Nothing\n","text":"\n\n\n\n\n\n\nPage not found · You Know Nothing\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nYou Know Nothing\n\n\n主页\n分类\n标签\n归档\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n该页面不存在！\n\n\n\n\n抱歉，找不到您要查找的页面。 您尝试访问的页面似乎不存在，或者可能刚刚移动，或者它已不再存在。\n或许你想从主页重新开始。\n\n\n\n\n\n\n\n\n\n\nPowered by Pelican. Theme: Elegant by Talha Mansoor\n\n\n \n\n\n        function validateForm(query) {\n            return (query.length > 0);\n        }\n    \n\n","tags":"","url":"https://xutree.github.io/404.html"},{"title":"Linux 中的扩展和引用","text":"扩展 当我们每次在命令行按下 Enter 键时，bash 会在执行命令之前对文本进行多重处理。产生这个结果的处理过程称为扩展（expansion）。 一个 🌰 : echo * 会将当前目录下所有的非隐藏文件名打印出来。 路径名扩展 通过使用通配符来实现扩展的\b机制称为路径名扩展（pathname expansion）。 波浪线扩展（~） 如果把它用在一个单词的开头，那么它将被扩展为指定用户的主目录名；如果没有指定用户名，则扩展为当前用户的主目录： [me@linuxbox ~]$ ech ~ /home/me [me@linuxbox ~]$ ech ~foo /home/foo 算术扩展 shell 支持通过扩展来运行算术表达式。这允许我们把 shell 提示符当做计算器来使用： [me@linuxbox ~]$ echo $((2+2)) 4 算术扩展使用形式： $((expression)) ，其中 expression 是包含数\b值和算术操作符的算术表达式。算术扩展 只支持整数 。 运算符 描述 + 加 - 减 * 乘 / 除（结果为整数） % 取余 ** 取幂 空格在算术表达式中无意义，表达式可以嵌套： [me@linuxbox ~]$ echo $(($((5**2)) * 3)) 75 还可以使用\b一对括号来组合多个子表达式： [me@linuxbox ~]$ echo $(((5**2) * 3)) 75 花括号扩展 花括号扩展可以用于创建多种文本字符串，例如 [me@linuxbox ~]$ echo Front-{A,B,C}-Back Front-A-Back Front-B-Back Front-C-Back 用于花括号扩展的模式信息可以包含一个称为 前导字符 的开头部分和一个称为 附言 的结尾部分。花括号表达式本身可以包含一些列逗号分隔的字符串，也可以包含一系列整数或者单个字符。 模式信息不能包含内嵌的\b空白。 花括号扩展最普遍的应用是创建一系列的文件或者目录： [me@linuxbox ~]$ mkdir {2009..2011}-0{1..9} {2009..2010}-{10..12} 参数扩展 shell 提供了多种参数扩展的形式。 基本参数 参数扩展的最简单形式体现在平时对变量的使用中。举例来说， $a 扩展后成为变量 a 所包含的内容，无论 a 包含什么。 简单参数可以被括号包围，如 ${a} ，当变量相邻与其他文本时，必须使用括号，否则可能让 shell 混淆。 [me@linuxbox ~]$ a=\"foo\" [me@linuxbox ~]$ echo \" $a_file \" [me@linuxbox ~]$ echo \" ${ a } _file\" foo_file 因为不存在 a_file 变量，所以 shell 输出空。 同样，对于大于9的位置参数可以通过给相应数字加上括号来访问，例如访问第11个位置参数： ${11} 空变量扩展的管理 有的参数扩展用于处理不存在的变量和空变量。这些参数扩展在处理缺失的位置参数和给参数赋默认值时很有用。 ${parameter:-word} ：如果 parameter 未被设定或者是空参数，则其扩展为 word 的值。如果\b parameter 非空，则扩展为 parameter 的值。 [ me@linuxbox ~ ] $ foo = [ me@linuxbox ~ ] $ echo $ { foo : - \"substitute value if unset\" } substitute value if unset [ me@linuxbox ~ ] $ echo $ foo [ me@linuxbox ~ ] $ foo = bar [ me@linuxbox ~ ] $ echo $ { foo : - \"substitute value if unset\" } bar [ me@linuxbox ~ ] $ echo $ foo bar ${parameter:=word} ：如果 parameter 未被设定或者是空参数，则其扩展为 word 的值；此外，word 的值也将赋给 parameter。如果\b parameter 非空，则扩展为 parameter 的值。注意：位置参数和其他特殊参数不能以这种方式赋值。 [ me@linuxbox ~ ] $ foo = [ me@linuxbox ~ ] $ echo $ { foo : = \"deafult value if unset\" } deafult value if unset [ me@linuxbox ~ ] $ echo $ foo deafult value if unset [ me@linuxbox ~ ] $ foo = bar [ me@linuxbox ~ ] $ echo $ { foo : - \"deafult value if unset\" } bar [ me@linuxbox ~ ] $ echo $ foo bar ${parameter:？word} ：如果 parameter 未被设定或者是空参数，这样扩展会致使脚本\b出错而退出，并且 word 的内容输出到标准错误。如果 parameter 非空，则扩展为 parameter 的值。 [me@linuxbox ~]$ foo= [me@linuxbox ~]$ echo ${ foo : ? \"parameter is empty\" } bash: foo: parameter is empty [me@linuxbox ~]$ echo $? 1 [me@linuxbox ~]$ foo=bar [me@linuxbox ~]$ echo ${ foo : ? \"parameter is empty\" } bar [me@linuxbox ~]$ echo $? 0 ${parameter:+word} ：如果 parameter 未被设定或者是空参数，则不产生任何扩展。若 parameter 非空，word 的值将取代 parameter 的值产生扩展；然而，parameter 的值并不发生变化。 [me@linuxbox ~]$ foo= [me@linuxbox ~]$ echo ${ foo : + \"substitute value if unset\" } [me@linuxbox ~]$ foo=bar [me@linuxbox ~]$ echo ${ foo : + \"substitute value if unset\" } substitute value if unset [me@linuxbox ~]$ echo $foo bar 返回变量名的扩展 shell 具有返回变量名的扩展。这种功能在相当特殊的情况下才会使用。 ${ ! prefix * } ${ ! prefix @ } 该扩展返回当前以 prefix 开通的变量名。根据 bash 文档，这两种形式的扩展形式执行的效果一模一样。 字符串操作 ${#parameter} ：扩展为 parameter 内包含的字符串的长度。如果 parameter 是 \"@\" 或 \"*\"，那么扩展的结果就是位置参数的个数。 [me@linuxbox ~]$ foo=\"This string is long.\" [me@linuxbox ~]$ echo \"' $foo ' is ${ #foo } characters long.\" 'This string is long.' is 20 characters long. {parameter:offset} 和 {parameter:offset:length} ：这个扩展提取一部分字符串。扩展以 offset 字符开始，直到字符串末尾，除非 length 特别指定它。 [me@linuxbox ~]$ foo=\"This string is long.\" [me@linuxbox ~]$ echo ${ foo : 5 } string is long. [me@linuxbox ~]$ echo ${ foo : 5 : 6 } string 如果 offset 为负，默认表示从字符串末尾开始。 注意，负值前必须有一个空格 ，以防和 ${parameter:-word} 扩展混淆。length 不能小于0。 [me@linuxbox ~]$ foo=\"This string is long.\" [me@linuxbox ~]$ echo ${ foo : - 5 } long. [me@linuxbox ~]$ echo ${ foo : - 5 : 2 } lo 如果参数是 \"@\"，扩展的结果则是从 offset 开始，length 为位置参数。 ${parameter#pattern} 和 ${parameter##pattern} ：pattern 是一个通配符模式，\"#\" 去除最短匹配，\"##\" 去除最长匹配。 [me@linuxbox ~]$ foo=file.txt.zip [me@linuxbox ~]$ echo ${ foo #*. } txt.zip [me@linuxbox ~]$ echo ${ foo ##*. } zip ${parameter%pattern} 和 ${parameter%%pattern} ：从尾部去除。pattern 是一个通配符模式，\"%\" 去除最短匹配，\"%%\" 去除最长匹配。 [me@linuxbox ~]$ foo=file.txt.zip [me@linuxbox ~]$ echo ${ foo %*. } file.txt [me@linuxbox ~]$ echo ${ foo %%*. } file ${parameter/pattern/string} ：查找替换，只替换第一个出现的 ${parameter//pattern/string} ：替换所有的 ${parameter/#pattern/string} ：要求匹配出现在字符串开头 ${parameter/%pattern/string} ：要求匹配出现在字符串末尾 /string 可以省略，此时匹配到的字符被删除 [me@linuxbox ~]$ foo=JPG.JPG [me@linuxbox ~]$ echo ${ foo / JPG / jpg } jpg.JPG [me@linuxbox ~]$ echo ${ foo // JPG / jpg } jpg.jpg [me@linuxbox ~]$ echo ${ foo / #JPG/jpg } jpg.JPG [me@linuxbox ~]$ echo ${ foo /% JPG / jpg } JPG.jpg","tags":"Linux","url":"https://xutree.github.io/pages/2018/10/08/linux中的扩展和引用/"},{"title":"CSS 入门","text":"什么是 CSS CSS（ C ascading S tyle S heets），即层叠样式表。 层叠是指 CSS 将一种样式应用于另一种样式的方式。样式表控制 Web 文档的外观。 为什么使用 CSS CSS 允许你将特定样式应用于特定 HTML 元素 CSS 的主要好处是它允许您将样式与内容分开 仅使用 HTML，所有样式和格式都在同一个地方，随着页面的增长，这变得相当难以维护 CSS 三种形式 内联 CSS：inline CSS 使用内联样式是插入样式表的方法之一。 使用内联样式，将独特的样式应用于单个元素。 要使用内联样式，请将style属性添加到相关标记。 <p style= \"color:white; background-color:gray;\" > This is an example of inline styling. </p> 嵌入式/内部 CSS：Embedded/Internal CSS 内部样式在 HTML 页面的 head 部分内的 <style> 元素中定义。 <html> <head> <style> p { color:white; background-color:gray; } </style> </head> <body> <p> This is my first paragraph. </p> <p> This is my second paragraph. </p> </body> </html> 外部 CSS：External CSS 使用此方法，所有样式规则都包含在单个文本文件中，该文件以 .css 扩展名保存。 然后使用 <link> 标记在 HTML 中引用此 CSS 文件。 <link> 元素位于 head 部分内部。 <head> <link rel= \"stylesheet\" href= \"example.css\" > </head> <body> <p> This is my first paragraph. </p> <p> This is my second paragraph. </p> <p> This is my third paragraph. </p> </body> CSS 语法 CSS 由浏览器解释的样式规则组成，然后应用于文档中的相应元素。样式规则有三个部分： selector ， property 和 value 。 例如，标题颜色可以定义为： h1 { color: orange; } 选择器指向要设置样式的HTML元素。声明块包含一个或多个声明，以分号分隔。每个声明都包含一个属性名称和一个以冒号分隔的值。CSS 声明始终以分号结尾，声明组由大括号括起。 类型选择器 最常见且易于理解的选择器是类型选择器。 此选择器针对页面上的元素类型。 例如，要定位页面上的所有段落： p { color : red ; font-size : 130 % ; } id 和 clss 选择器 id 选择器允许您设置具有 id 属性的 HTML 元素的样式，而不管它们在文档树中的位置如何。 以下是 id 选择器的示例： HTML 文件： <div id= \"intro\" > <p> This paragraph is in the intro section. </p> </div> <p> This paragraph is not in the intro section. </p> CSS 文件: # intro { color : white ; background-color : gray ; } 要选择具有特定 id 的元素，请使用井号 # 字符，然后使用元素的 id 跟随它。 类选择器以类似的方式工作。 主要区别在于 id 每页只能应用一次，而类可以根据需要在页面上多次使用。 在下面的示例中，具有\"first\"类的两个段落都将受到 CSS 的影响： HTML 文件： <div> <p class= \"first\" > This is a paragraph </p> <p> This is the second paragraph. </p> </div> <p class= \"first\" > This is not in the intro section </p> <p> The second paragraph is not in the intro section. </p> CSS 文件： .first { font-size : 200 % ;} 要选择具有特定类的元素，请使用句点 . 字符，后跟类的名称。不要用数字开始一个类或 id 名称。 后代选择器 这些选择器用于选择作为另一个元素的后代的元素。 选择级别时，您可以根据需要选择多个级别。 例如，要仅定位\"intro\"部分第一段中的 <em> 元素： HTML 文件： <div id= \"intro\" > <p class= \"first\" > This is a <em> paragraph. </em></p> <p> This is the second paragraph. </p> </div> <p class= \"first\" > This is not in the intro section. </p> <p> The second paragraph is not in the intro section. </p> CSS 文件： # intro . first em { color : pink ; background-color : gray ; } 后代选择器匹配作为指定元素后代的所有元素。 注释 注释用于解释你的代码，浏览器会忽略。 /* Comment goes here */ 层叠 网页的最终外观是不同样式规则的结果。形成层叠的三种主要风格来源是： 页面作者创建的样式表 浏览器的默认样式 用户指定的样式 继承是指属性在页面中流动的方式。 除非另有定义，否则子元素通常会采用父元素的特征。","tags":"CSS","url":"https://xutree.github.io/pages/2018/10/07/css_overview/"},{"title":"C++ Primer 第四章 表达式","text":"重载运算符时，其包括运算对象的类型和返回值的类型，都是由该运算符定义的；但是运算对象的个数、运算符的优先级和结合律都是无法改变的。 左值和右值 当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。 一个重要的原则：在需要右值的地方可以用左值来代替，但是不能把右值当成左值（也就是位置）使用。当一个左值被当成右值使用时，实际使用的是它的内容（值）。 要用到左值的运算符： 赋值运算符需要一个左值作为其左侧运算对象，得到的结果也仍然是一个左值 取地址符作用于一个左值运算对象，返回一个指向该运算对象的指针，这个指针是一个右值 内置解引用运算符、下标运算符、迭代器解引用运算符、 string 和 vector 的下标运算符的求值结果都是左值 内置类型和迭代器的递增递减运算符作用于左值运算对象 求值顺序 优先级规定了运算对象的组合方式，但是没有说明运算对象按照什么顺序求值。对于那些没有指定执行顺序的运算符来说，如果表达式指向并修改了同一个对象，将会引发错误并产生未定义的行为。 例如，下面的输出表达式是未定义的，我们无法推测编译器是先求 ++i 还是先输出： int i = 0; cout << i << \" \" << ++i << endl; //未定义的 有4种运算符明确规定了运算对象的求值顺序。&&、||、?:、和逗号（，）运算符。 对于f()+g()*h()+j()的表达式： 优先级规定，g() 的返回值和 h() 的返回值相乘 结合律规定，f() 的返回值先与 g() 和 h() 的乘积相加，所得结果再与 j() 的返回值相加 对于这些函数的调用顺序没有明确规定 如果 f、g、h 和 j 是无关函数，它们既不会改变同一对象的状态也不执行 IO 任务，那么函数的调用顺序不受限制。反之，如果其中某几个函数影响同一对象，则它是一条错误的表达式，将产生未定义的行为 算术运算符 +(正号)、-(负号)、*(乘)、/(除),%(求余)，+(加)、-(减) 算术运算符的运算对象和求值结果都是右值。 一元正号负号运算符对运算对象作用后，返回一个（提升后的）副本： int i = 1024; int k = -i; bool b = true; bool b2 = -b; //b2 是 true 对大多数运算符来说，布尔类型的运算对象将被提升为 int 类型。如上，b 参与运算时被提升成整数值1，对它求负-1，转换为布尔值将其作为 b2 的初始值。 在除法运算中，如果两个运算对象的符号相同则商为正，否则商为负。C++ 语言的早期版本允许结果为负值的商向上或向下取整，C++11 新标准则规定商一律向0取整（即直接切除小数部分）。 逻辑和关系运算符 运算对象和求值结果都是右值；短路求值；进行比较运算符时，除非比较的对象是布尔类型，否则不要使用布尔字面值 true 和 false 作为运算对象 赋值运算符 赋值运算符的左侧运算对象必须是一个可修改的左值 赋值运算的结果是它的左侧运算对象，并且是一个左值，结果的类型就是左侧运算对象的类型 如果赋值运算符的左右两个运算对象类型不同，则右侧运算对象将转换成左侧运算对象的类型 赋值运算满足右结合律：ival = jval = 0； ++ 和 -- 运算符 前置版本将对象本身作为左值返回，后置版本则将对象原始值的副本作为右值返回 建议：除非必须，否则不用递增递减算符的后置版本 后置递增运算符的优先级高于解引用运算符，因此 *pbeg++ 等价于 *(pbeg++)，pbeg++ 把 pbeg 的值加1，然后返回 pbeg 的初始值的副本作为其求值结果 成员访问运算符 由于解引用运算符的优先级低于逗号运算符，因此要对解引用运算符加括号 箭头运算符作用于一个指针类型的运算对象，结果是一个左值 点运算符分成两种情况：如果成员所属的对象是左值，那么结果就是左值；反之，如果成员所属的对象是右值，那么结果是右值 条件运算符 当条件运算符的两个表达式都是左值或者能转换成同一种左值类型时，运算的结果是左值；否则运算的结果是右值 条件运算符满足右结合律 位运算符 位运算符作用于整数类型的运算对象 关于符号位如何处理没有明确的规定，所以强烈建议仅将位运算符作用于处理无符号类型 移位运算符 首先令左侧运算对象的内容按照右侧运算对象的要求移动指定位数，然后将经过移动的（可能还进行了提升）左侧运算对象的拷贝作为求值结果。其中，右侧的运算对象一定不能为负，而且值必须严格小于结果的位数，否则就会产生未定义的行为。移出边界之外的位就被舍弃掉了 移位运算符满足左结合律 移位运算符的优先级比算术运算符低，比关系运算符、赋值运算符和条件运算符高 sizeof运算符 sizeof 运算符返回一条表达式或一个类型名字所占的字节数。 sizeof 运算符满足右结合律，其所得的值是一个 size_t 类型的常量表达式 两种形式 sizeof (type) sizeof expr sizeof 并不直接计算其运算对象的值。 对于 sizeof *p ： 因为 sizeof 满足右结合律并且与 * 的运算符的优先级一样，所以表达式按照从右到左的顺序结合，等价于： sizeof (*p) 其次，因为 sizeof 不实际求运算对象的值，所以即使 p 是一个无效（即未初始化）的指针也不会有什么影响 在 sizeof 的运算对象中解引用一个无效的指针仍然是一种安全的行为，因为指针实际上并没有被真正使用 sizeof 运算符的结果部分地依赖于其作用的类型： 对 char 或者类型为 char 的表达式执行 sizeof 运算，结果得1 对引用类型执行 sizeof 运算得到被引用对象所占空间的大小 对指针执行 sizeof 运算得到指针本身所占空间的大小 对解引用指针执行 sizeof 运算得到指针指向的对象所占空间的大小，指针不需有效 对数值执行 sizeof 运算符得到整个数组所占空间的大小。 sizeof 运算不会把数组转换成指针来处理 对 string 对象或者 vector 对象执行 sizeof 运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。即只取决于里面存放的数据类型，与元素的个数无关，是个编译器相关的值 逗号运算符 首先对左侧的表达式求值，然后将求值结果丢弃掉。逗号表达式真正的结果是右侧表达式的值。如果右侧运算对象是左值，那么最终的求值结果也是左值。 类型转换 何时发生隐式类型转换 在大多数表达式中，比 int 类型小的整数值首先提升为较大的整数类型 在条件中，非布尔值转换成布尔类型 初始化过程中，初始值转换成变量的类型；在赋值语句中，右侧运算对象装换成左侧运算对象的类型 如果算术运算或关系运算的运算对象有多种类型，需要转换成同一种类型 函数调用时也会发生类型转换 数组转换成指针（当数组被用作 decltype 关键字的参数，或者作为取地址符、 sizeof 即 typeid 等运算符的运算对象时，上述转换不会发生，如果用一个引用来初始化数组，上述转换也不会发生） 指针的转换 常量整数值0或者字面值 nullptr 能转换成任意指针类型 指向任意非常量的指针能转换成 void * 指向任意对象的指针能转换成 const void * 转换成常量：允许将指向非常量类型的指针转换成指向相应的常量类型的指针，对于引用也是这样。相反的转换并不存在，因为它试图删掉底层 const 类类型定义的转换 类类型能定义由编译器自动执行的转换，不过编译器每次只能执行一种类类型的转换，如果同时提出多个转换请求，这些请求将被拒绝 之前遇到过的类类型转换 string s, t = \"a value\"; //字符串字面值转换成 string 类型 wile( cin >> s) //while 的条件部分把 cin 转换成布尔值 显示转换 虽然有时不得不使用强制类型转换，但这种方法本质上是非常危险的。 命名的强制类型转换 一个命名的强制类型转换具有如下格式： cast-name<type>(expression); type 是转换的目标类型。如果 type 是引用类型，则结果是左值；expression 是要转换的值；cast-name 是 static_cast 、 dynamic_cast 、 const_cast 和 reinterpret_cast 中的一种。 dynamic_cast 支持运行时类型识别。 static_cast 任何具有明确定义的类型转换，只要不包含底层 const ，都可以使用 static_cast 。当需要把一个较大的算术类型赋给较小的类型时， static_cast 非常有用。此时，强制类型转换告诉程序的读者和编译器：我们知道并且不在乎潜在的精度损失。 static_cast 对于编译器无法自动执行的类型转换也非常有用。例如，我们可以使用它找回 void * 指针中的值: void *p = &d; double *dp = static_cast<double *>(p); const_cast const_cast 只能改变运算对象的底层 const : const char *pc; char *p = const_cast<char*>(pc);//正确，但通过p写值是未定义的行为 只有 const_cast 能改变表达式的常量属性。 reinterpret_cast einterpret_cast 通常为运算对象的位模式提供较低层次上的重新解释。 假如有以下转换： int *ip; char *pc = reinterpret_cast<char*>(ip); 我们必须牢记 pc 所指的真实对象是一个 int 而非字符，如果把 pc 当成普通的字符指针使用就可能在运行时发生错误。 string str(pc); //可能导致异常的运行时行为 reinterpret_cast 本质上依赖于机器。要想安全地使用 reinterpret_cast 必须对涉及的类型和编译器实现转换的过程都非常了解。 强制类型转换干扰了正常的类型检查，因此强烈建议避免使用强制类型转换。 旧式的强制类型转换 在早期版本的 C++ 语言中，显示地进行强制类型转换包含两种形式： type (expr); //函数形式的强制类型转换 (type) expr; //C 语言风格的强制类型转换 根据所设计的类型不同，旧式的强制类型转换分别具有与 const_cast ， static_cast 或 reinterpret_cast 相似的行为。当我们在某处执行旧式的强制类型转换时，如果换成 const_cast 和 static_cast 也合法，则其行为与相应的命名转换一致。如果替换后不合法，则旧式强制类型转换执行与 reinterpret_cast 类似的功能。 char *pc = (char*) ip; //ip是指向整数的指针 上述代码的效果与 reinterpret_cast 一样。","tags":"读书笔记","url":"https://xutree.github.io/pages/2018/10/07/C++_Primer_Chapter_4/"},{"title":"C++ Primer 第三章 字符串、向量和数组","text":"string 表示可变长的字符数组。 vector 存放的是某种给定类型对象的可变长序列。 数组和其他内置类型一样，实现与硬件密切相关，在灵活性上稍显不足。 命名空间 using 声明： using namespace::name; 例如： using std::cin; 。 头文件不应包含 using 声明，防止名字冲突。 标准库类型 string 头文件和声明 #include <string> using std :: string ; 定义和初始化 string s1; //默认初始化，空字符串 string s2 = s1; //s2是s1的副本，等价于 s2(s1) string s3 = \"hiya\"; //s3是字符串字面值的副本，等价于s3(\"hiya\") string s4(10, 'c'); //s4的内容是cccccccccc string 对象上的操作 操作 意义 os << s 将 s 写到输出流 os 中，返回 os is >> s 从 is 中读取字符串赋给 s，字符串以空白分隔，返回 is getline(is, s) 从 is 中读取一行赋给 s，返回 is s.empty() s 为空返回 true，否则返回 false s.size() 返回 s 中字符的个数 s[n] 返回 s 中第 n 个字符的引用，位置 n 从0记起 s1 + s2 返回连接后的结果 s1 = s2 用 s2 的副本代替 s1 s1 == s2 如果 s1 和 s2 中所含的字符完全一样，则他们相等 s1 != s2 string 对象的相等性判断对大小写敏感 <, <=, >, >= 利用字符在字典里的顺序进行比较，大小写敏感 读取未知数量的 string 对象 int main() { string word; while (cin >> word) cout << word << endl; return 0; } 直到遇到结束标记或者非法输入才会停止 使用 getline 读取一整行 int main() { string line; while (getline(cin,line)) cout << line << endl; return 0; } getline 函数的参数是一个输入流和一个 string 对象， getline 从给定的输入流中读入内容，直到遇到换行符为止（注意换行符也被读进来了），然后把所读的内容存入 string 对象中（注意不存换行符）。如果输入一开始就是换行符，那么所得的结果是个空 string 。 string::size_type 类型 是一个无符号类型的值。如果一个表达式中已经有 size 函数就不要再使用 int 了，这样可以避免混用 int 和 unsigned 可能带来的问题。 string 对象可以和字符字符串字面值相加，只要保证 + 号两侧的运算对象至少有一个 string 对象即可。 由于某些历史原因，也为了和 C 兼容，所以 C++ 中的字符串字面值并不是标准库 string 类型。 处理 string 对象里的字符 包含在 cctype 头文件中： 函数 意义 isalunm(c) 当 c 是字母或数字时为真 isalpha(c) 当 c 是字母时为真 iscntrl(c) 当 c 是控制字符时为真 isdigit(c) 当 c 是数字时为真 isgraph(c) 当 c 不是空格但可打印时为真 islower(c) 当 c 是小写字母时为真 isprint(c) 当 c 是可打印字符时为真（即 c 是空格或 c 具有可视形式） ispunct(c) 当 c 是标点符号时为真（即 c 不是控制字符、数字、字母、可打印空白中的一种） isspace(c) 当 c 是空白时为真（即 c 是空格、横向制表符、纵向制表符、回车符、换行符、进纸符中的一种） isupper(c) 当 c 是大写字母时为真 isxdigit(c) 当 c 是十六进制数字时为真 tolower(c) 输出 c 的小写 toupper(c) 输出 c 的大写 C++ 标准库除了定义 C++ 语言特有的功能外，也兼容了 C 语言的标准库。C 语言的头文件形如 name.h，C++ 则将这些文件命名为 cname。因此 cctype 头文件和 ctype.h 头文件的内容是一样的，只不过从命名规范上来讲更符合 C++ 语言的要求。特别地，在名为 cname 的头文件中定义的名字从属于命名空间 std 。 范围 for for (declaration: expression) statement expression 是一个对象，用于表示一个序列；declaration 负责定义一个变量，该变量将被用于访问序列中的基础元素，每次迭代，declaration 部分的变量会被初始化为 expression 部分的下一个元素值。 使用范围for输出 string str(\"some string\"); for (auto c : str) cout << c << endl; 使用范围for修改 string s(\"Hello World!\"); for (auto &c : s) c = toupper(c); cout << s << endl; 下标运算符 [ ] [ ]接收的输入参数是 string:size_type 类型的值，这个参数表示要访问的字符的位置，返回值是该位置上字符的引用。 string 对象的下标必须大于等于0而小于 s.size() 。 标准库类型 vector vector 表示对象的集合，其中所有对象的类型都相同，也常被称作容器，是一种类模板 #include <vector> using std :: vector ; 编译器根据模板创建类或函数的过程称为实例化，对于类模板，我们通过提供一些额外信息来指定模板到底实例化成什么样的类：在模板名字后面跟一对尖括号，在括号内放上信息 vector<int> ivec; vector<Sales_item> Sales_vec; vector<vector<string>> file; 在早期版本的 C++ 标准中如果 vector 的元素还是 vector （或者其他模板类型），则其定义的形式与现在的 C++11 新标准略有不同。过去，必须在外层 vector 对象的右尖括号和其元素类型之间添加一个空格，如应写成 vector<vector<int> > 初始化 默认初始化。 列表初始化。 值初始化：通常情况下，可以只提供vector对象容纳的元素数量而略去初始值。此时库会创建一个值初始化的元素初值，并把它赋给容器中的所有元素。这个初值由vector对象中元素的类型决定。内置类型：0；类类型：由类默认初始化。 添加元素 push_back ：负责把一个值当成 vector 对象的尾元素压到 vector 对象的尾端 vector<int> v2; for (int i = 0; i != 100; ++i) v2.push_back(i); 如果循环内部包含有向 vector 对象添加元素的语句，则不能使用范围 for 循环。 其他vector操作 函数 含义 v.empty() 如果 v 不含有任何元素，返回真；否则返回假 v.size() 返回 v 中元素的个数 v.push_back(t) 向 v 的尾端添加一个值为 t 的元素 v[n] 返回 v 中第 n 个位置上元素的引用 v1 = v2 用 v2 中的元素拷贝替换 v1 中的元素 v1 = 用列表中元素的拷贝替换 v1 中的元素 v1 == v2 v1 和 v2 相等当且仅当它们的元素数量相同且对应位置的元素值都相同 v1 != v2 <,<=,>,>= 以字典顺序进行比较 vector 的 size_type vector<int>::size_type //正确 vector::size_type //错误 和 string 一样， vector 对象的下标也是从0开始计算， vector 对象（以及 string 对象）的下标运算符可用于访问已存在的元素，而不能用于添加元素。 迭代器 所有标准库容器都可以使用迭代器，但只有少数的几种才同时支持下标运算符。 严格来讲， string 不属于容器类型，但是 string 支持很多与容器类型相似的操作。 vector 支持下标运算符，这点和 string 一样。 和指针不一样，获取迭代器不是使用取地址符，有迭代器的类型同时拥有返回迭代器的成员。 begin 和 end ： auto b = v.begin(), e = v.end(); 。 end 成员负责返回指向容器\"尾元素的下一位置\"的迭代器。常被称作尾后迭代器或尾迭代器。 如果容器为空，则 begin 和 end 返回的是同一个迭代器，都是尾后迭代器。 标准容器迭代器的运算符 符号 含义 *iter 返回迭代器 iter 所指元素的引用 iter->mem 解引用 iter 并获取该元素的名为 mem 的成员，等价于(*iter).mem ++iter 令 iter 指向容器中的下一个元素 --iter 令 iter 指向容器中的上一个元素 iter1 == iter2 判断两个迭代器是否相等 iter1 != iter2 如果指向同一元素或者他们是同一容器的尾后迭代器 因为 end 返回的迭代器并不实际指向某个元素，所以不能对其进行递增或解引用操作。C++ 程序员习惯性地使用 != ，其原因和他们更愿意使用迭代器而非下标的原因一样：这种编程风格在标准库提供的所有容器上都有效，因为所有标准库容器都定义了 == 和 != 。 迭代器类型 拥有迭代器的标准库类型使用 iterator 和 const_iterator 来表示迭代器的类型 vector < int > :: iterator it ; // it 能读写 vector < int > 的元素 string :: iterator it2 ; // it2 能读写 string 对象中的元素 vector < int > const_iterator it3 ; // it3 只能读元素 ， 不能写元素 string :: const_iterator it4 ; // it4 只能读字符 ， 不能写字符 begin 和 end 返回的具体类型由对象是否是常量决定，如果对象是常量， begin 和 end 返回 const_iterator ；如果对象不是常量，返回 iterator 。如果对象只需读操作而无需写操作的话最好使用常量类型迭代器。为了专门得到 const_iterator ，C++11 标准引入两个新函数： cbegin 和 cend 。任何一种可能改变容器容量的操作，都会是迭代器失效。 迭代器运算 string 和 vector 的迭代器提供了更多额外的运算符： iter + n ：迭代器加上一个整数值仍得到一个迭代器，迭代器指示的新位置与原来相比向前移动了若干个元素。结果迭代器或者指示容器内的一个元素，或者指示容器尾元素的下一位置。 iter - n ：迭代器减去一个整数值仍得一个迭代器，迭代器指示的新位置与原来相比向后移动了若干位置。结果迭代器或者指示容器内的一个元素，或者指示容器尾元素的下一位置。 iter1 - iter2 ：两个迭代器相减的结果是它们之间的距离，也就是说，将运算符右侧的迭代器向前移动差值个元素后将得到左侧的迭代器。参与运算的两个迭代器必须指向的是同一容器中的元素或者尾元素的下一位置。 >, >=, <, <= ：迭代器的关系运算符，如果迭代器指向的容器位置在另一个迭代器所指位置之前，则说前者小于后者。 数组 因为数组的大小固定，因此在对某些特殊的应用来说程序的运行时性能较好，但是相应的也损失了一些灵活性。 数组的维度必须是一个常量表达式。 默认情况下数组的元素被默认初始化。 和内置类型的变量一样，如果在函数内部定义了某种内置类型的数组，那么默认初始化会令数组含有未定义的值。 定义数组的时候必须指定数组的类型，不允许用auto关键字由初始值的列表推断类型。 字符数组可以利用字符串字面值初始化，此时注意字符串字面值末尾的空字符，也会被拷贝到字符数组中。 不允许拷贝和赋值。一些编译器支持数组的赋值，这就是所谓的编译器扩展，但一般来说，最好避免使用非标准特性，因为可能在其他编译器上无法正常工作。 理解复杂的数组声明：由内向外阅读 int *ptrs[10]; //ptrs 是含有10个整型指针的数组 int (*Parray)[10] = &arr; //Parray 是指针，指向一个含有10个整数的数组 int (&arrRef)[10] = arr; //arrRef 是引用，引用一个含有10个整数的数组 int *(&arry)[10] = ptrs; //arry 是引用，引用一个含有10个整型指针的数组 访问数组元素 数组的索引从0开始。 在使用数组下标的时候，通常将其定义为 size_t 类型。 size_t 是一种机器相关的无符号类型，它被设计的足够大以便能表示内存中任意对象的大小。 在 cstddef 头文件中定义了 size_t 类型，这个文件是 C 标准库 stddef.h 头文件的 C++ 版本。 使用数组的时候编译器一般会把它转换成指针。 通常情况下，使用取地址符来获取指向某个对象的指针，取地址符可以用于任何对象。数组的元素也是对象，对数组使用下标运算符得到该数组指定位置的元素，对数组元素应用取地址符就能得到指向该元素的指针。 数组还有一个特性：在很多时候用到数组名字的地方，编译器都会自动地将其替换为一个指向数组首元素的指针 string *p2 = nums; //等价于 p2 = &nums[0] 所以如果使用数组作为一个auto变量的初始值时，推断的类型是指针而非数组 int ia[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9,}; auto ia2(ia); // ia2 是一个整型指针，指向 ia 的第一个元素 ia2 = 42; //错误，ia2 是一个指针，不能用 int 赋值 当使用 decltype 关键字时上述转换不会发生， decltype(ia) 返回的类型是由10个整数构成的数组 decltype(ia) ia3 = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; ia3 = p; //错误，不能用整型指针给数组赋值 ia3[4] = i; //正确：把 i 的值赋给 ia3 的一个元素 为了让指针的使用更简单、更安全，C++11 新标准引入两个名为 begin 和 end 的函数，不过数组毕竟不是类类型，因此这两个函数不是成员函数。正确的使用形式是将数组作为它们的参数 int ia[] = {1, 2, 3, 4, 5, 6, 7, 8, 9}; int *beg = begin(ia); int *last = end(ia); begin 函数返回指向 ia 首元素的指针， end 函数返回指向 ia 尾元素下一位置的指针，这两个函数定义在 iterator 头文件中 两个指针相减结果的类型是一种名为 ptrdiff_t 的类型，和 size_t 一样，它也是定义在 cstddef 头文件中的机器相关的类型。因为差值可能是负值，所以它是一种带符号类型。 内置的下标运算符所用的索引值不是无符号类型，这一点和 vector 和 string 不一样 int *p = &ia[2]; int k = p[-2]; //k 是 ia[0] 那个元素 C 风格字符串 按此习惯书写的字符串存放在字符数组中并以空字符结束。 C 语言标准库提供了一组函数用于操作 C 风格字符串，它们定义在 cstring 头文件中，cstring 是 C 语言头文件 string.h 的 C++ 版本。 与旧代码的接口 任何出现字符串字面值的地方都可以用空字符结尾的字符数组来代替。不能用string对象直接初始化指向字符的指针，为了完成该功能，string专门提供了一个名为c_str的成员函数 char *str = s; //错误，不能用 string 对象初始化 char* const char *str = s.c_str(); //正确 我们无法保证 c_str 函数返回的数组一直有效，事实上，如果后续的操作改变了 s 的值就可能让之前返回的数组失去效用 使用数组初始化 vector 对象 int int_arr[] = {0, 1, 2, 3, 4, 5}; vector<int> ivec(begin(int_arr),end(int_arr)); 现代的 C++ 程序员应当尽量使用 vector 和迭代器，避免使用内置的数组和指针，应该尽量使用 string ，避免使用 C 风格的基于数组的字符串。 多维数组：要使用范围 for 语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型。 缓冲区溢出：主要原因是试图通过一个越界的索引访问容器内容。 difference_type ：由 string 和 vector 定义的一种带符号整数类型，表示两个迭代器之间的距离。","tags":"读书笔记","url":"https://xutree.github.io/pages/2018/10/06/C++_Primer_Chapter_3/"},{"title":"C++ Primer 第二章 变量和基本类型","text":"类型 下表列出了 C++ 标准规定的数据类型尺寸的最小值，同时允许编译器赋予这些类型更大的尺寸 类型 含义 最小尺寸 bool 布尔类型 未定义 char 字符 8位 wchar_t 宽字符 16位 char16_t Unicode 字符 16位 char32_t Unicode 字符 32位 short 短整型 16位 int 整型 16位 long 长整型 32位 long long 长整型 64位 float 单精度浮点数 6位有效数字 double 双精度浮点数 10位有效数字 long double 扩展精度浮点数 10位有效数字 一个 char 的空间应确保可以存放机器基本字符集中任意字符对应的数字值。也就是说，一个 char 的大小和一个机器字节一样。 wchar_t 类型用于确保可以存放机器最大扩展字符集中的任意一个字符。 C++ 语言规定，一个 int 至少和一个 short 一样大，一个 long 至少和一个 int 一样大，一个 long long 至少和一个 long 一样大。 可寻址的最小内存块成称为\"字节（byte）\"，存储的基本单元称为\"字（word）\"，它通常有几个字节组成。 在 C++ 语言中，一个字节至少能容纳机器基本字符串中的字符。大多数机器的字节由8比特构成，字则由32或64比特构成，也就是4字节或8字节。 C++ 标准指定了一个浮点数有效位数的最小值，然而大多数编译器都实现了更高的精度。通常， float 以1个字（32比特）来表示， double 以2个字（64位）来表示， long double 以3或4个字（96或128比特）来表示。一般来说， float 和 double 分别有7和16个有效位；类型 long double 则常常被用于有特殊浮点要求的硬件，它的具体实现不同，精度也各不相同。 类型 int 、 short 、 long 和 long long 都是带符号的，通过在这些类型名前添加 unsigned 就可以得到无符号类型。 char 、 signed char 和 unsigned char ， char 是否等于 signed char 由编译器决定。 C++ 标准并没有规定带符号类型应如何表示，但是约定了在表示范围内正值和负值的量应该平衡。因此，8比特的 signed char 理论上可以表示-127至127区间内的值，大多数现代计算机将实际的表示范围定为-128至127。 如何选择类型 明知数值不可能为负数，选用无符号类型。 如果数值超过了 int 的表示范围，选用 long long ，因为 long 一般和 int 有一样的尺寸。 算术表达式中不要使用 bool 或 char 。 执行浮点数运算选用 double 。因为 float 通常精度不够而且计算代价相差无几。 long double 提供的精度一般情况下是没有必要的而且计算代价大。 类型转换 非布尔 -> 布尔：0 -> false ，其他 -> ture 。 布尔 -> 非布尔： false -> 0， ture -> 1。 浮点 -> 整型：仅保留小数点前。 整型 -> 浮点：小数部分记为0，如果该整数所占的空间超过浮点类型的容量，精度可能损失。 当我们赋给无符号类型一个超过它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。 当我们赋给带符号类型一个超出它表示范围的值时，结果是未定义的。此时，程序可能继续工作、可能崩溃，也可能生成垃圾数据。 当一个算术表达式中既有无符号数又有 int 值时，那个 int 会转换成无符号数。把 int 转换成无符号数的过程和把 int 赋值给无符号变量一样。 当从一个无符号数中减去一个值时，我们必须确保结果不是负值，否则实际结果会是取模后的值。 字面值常量 整型和浮点型字面值。 字符和字符串字面值： ‘a' 和\"a\"，字符串字面值最后补'\\0' 如果两个字符串字面值位置紧邻且仅由空格、缩进和换行分隔，则它们是一个整体 布尔字面值： true 、 false 。 指针字面值： nullptr 。 指定字面值的类型 字符和字符串字面值 前缀 类型 u char16_t U char32_t L wchar_t u8 char 整型字面值 后缀 最小匹配类型 u 或 U unsigned l 或 L long ll 或 LL long long 浮点型字面值 后缀 类型 f 或 F float l 或 L long double 列表初始化 int units_sold{0} 列表初始化的重要特点：如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将报错。 默认初始化 内置类型变量 定义于任何函数之外，初始化为0 定义于函数体内的局部静态变量，初始化为0 定义于函数体内的非局部静态变量，不被初始化，试图拷贝或以其他方式访问此类值将引发错误 每个类各自决定其初始化对象的方式。 分离式编译 将程序分割为若干个文件，每个文件可被独立编译 声明 extern int i; extern 语句如果包含初始值就不再是声明，而变成定义了： extern int i = 0; 在函数体内部，试图初始化一个由 extern 关键字标记的变量将引发错误。 静态类型语言：在编译阶段执行类型检查 C++ 标识符 字母、数字、下划线，必须以字母或下划线开头，长度无限制，大小写敏感。 C++ 为标准库保留了一些名字 自定义标识符中不能连续出现两个下划线 不能以下划线紧接大写字母开头 定义在函数体外的函数不能以下划线开头 作用域操作符 :: 若左侧为空，则指代全局作用域 复合类型 引用 int &b = a; b指向a。 引用必须初始化。 引用本身不是一个对象，不能定义引用的引用。 引用必须绑定到对象上，不能绑定到字面值或者某个表达式的计算结果上。 除了两种例外，所有引用的类型都要和它所绑定的对象严格匹配： 初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可 允许将基类的引用绑定到派生类上 指针 int *b = &a; 。 指针是一个对象。 在块作用域内定义的指针如果未初始化，将拥有一个不确定的值。 除了两种例外，所有指针的类型都要和它所指向的对象严格匹配： 允许一个指向常量的指针指向一个非常量对象 允许将基类的指针绑定到派生类上 试图拷贝或以其他方式访问无效指针的值将引起错误，编译器不负责检查此类错误。 任何非零的指针对应的条件值都是true。 合法指针可以比较大小：== 或 !=。 void * 是一个特殊的指针类型，可用于存放任意对象的地址，只支持有限的操作： 拿它和别的指针比较 作为函数的输入或输出 赋给另外一个 void * 指针 理解复合类型的声明 变量的定义包括一个基本数据类型和一组声明符。 一条定义语句可能定义出不同类型的变量： int i = 1024, *p = &i, &r =i; 。 面对一条比较复杂的指针或者引用的声明语句时，从右往左阅读有助于弄清楚它的真实含义，例如： int \\*&r; 首先 r 是一个引用，其次 r 是一个指针的引用，再次 r 是一个指向整型指针的引用。 const 限定符 因为 const 对象一旦创建就无法改变其值，所以必须初始化。 当用一个对象去初始化另外一个对象，它们是不是 const 都无关紧要，常量的特性仅仅在执行改变其值的操作时才会发挥作用。 默认情况下， const 对象仅在文件内有效。 如果想在多个文件之间共享 const 对象，必须在变量的定义之前添加 extern 关键字。 const 的引用，常量引用的初始化：初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。尤其，允许为一个常量引用绑定非常量的对象、字面值甚至是一个表达式。实际上是通过绑定到一个临时量对象上实现的。 对 const 的引用可能引用一个并非 const 的对象，常量引用仅对引用可参与的操作做了限制，对于引用的对象本身是不是常量未做限制。 指针和 const 指向常量的指针 允许一个指向常量的指针指向一个非常量对象。 仅对指向常量的指针可参与的操作做了限制，对于指向的对象本身是不是常量未做限制。 const 指针 指针是对象，可以把指针本身定为常量。 常量指针必须初始化，一经初始化就不能再改变。 把*放在 const 关键字之前说明指针是一个常量。 顶层和底层 const 顶层 const ：指针本身是个常量。 底层 const ：指针所值的对象是一个常量。 更一般的，顶层 const 可以表示任意的对象是常量，这一点对任意数据类型都适用。底层 const 则与指针和引用等复合类型的基本类型部分有关。 执行对象的拷贝操作时，顶层 const 不受影响；拷入和拷出的对象必须具有相同的底层 const 资格，或者两个对象的数据类型必须能够转换。一般来说，非常量可以转换成常量，反之不行。 constexpr 和常量表达式 常量表达式：值不会改变并且在编译过程就能得到计算结果的表达式。 constexpr 变量：由编译器来验证变量的值是否是一个常量表达式，声明为 constexpr 的变量一定是一个常量，并且必须用常量表达式初始化。 字面值类型：算术类型、引用、指针、字面值常量类、枚举。 声明 constexpr 用到的类型为字面值类型。 一个 constexpr 指针的初始值必须是 nullptr 或者0，或者是存储于某个固定地址中的对象： 函数体内定义的变量一般并非存放在固定地址中， constexpr 指针不能指向这样的变量（局部静态对象除外） 定义于所有函数体之外的对象地址固定不变，能用来初始化 constexpr 指针 在 constexpr 声明中如果定义了一个指针，限定符 constexpr 仅对指针有效，与指针所指的对象无关。 constexpr 把它所定义的对象置为顶层 const 。 处理类型 类型别名 typedef double wages; using SI = Sales_item; auto 类型说明符 让编译器自己去分析表达式所属的类型。 auto 也能在一条语句中声明多个变量。因为一条声明语句只能有一个基本数据类型，所以该语句中所有变量的基本数据类型都必须一样。 当引用被用作初始化 auto 变量时，编译器以引用所引用对象的类型作为 auto 的类型。 auto 一般会忽略顶层 const ，同时底层 const 会保留下来。 如果希望推断出的 auto 类型是一个顶层 const ，需要明确指出。 auto 引用 auto &b = a; 初始值 a 的顶层 const 会保留。 decltype 类型指示符 选择并返回操作数的数据类型，编译器分析表达式得到它的类型，却不实际计算表达式的值，编译器并不实际调用f。 如果 decltype 使用的表达式是一个变量，则 decltype 返回该变量的类型（包括顶层 const 和引用在内），需要指出的是，引用从来都作为其所指对象的同义词出现，只有在 decltype 处是一个例外。 如果 decltype 使用的表达式不是一个变量，则 decltype 返回该表达式的结果对应的类型： 因为 r 是一个引用， decltype(r) 的结果是引用类型，如果想让结果类型是 r 所指的类型，可以把 r 作为表达式的一部分，显然这个表达式的结果是一个具体的值而非一个引用 如果表达式的内容是解引用操作，则 decltype 将得到引用类型 如果 decltype 使用的表达式是一个变量： 不加括号，得到该变量的类型 加括号，得到引用类型 自定义数据结构：结构体和类 记得定义末尾的分号。可以类内初始化。 头文件保护符 头文件保护符依赖于预处理变量。 预处理变量由两个状态：已定义和未定义。 #define 指令把一个名字设定为预处理变量。 #ifdef 当且仅当变量已定义时为真。 #ifndef 当且仅当变量未定义时为真。 一旦检查结果为真，则执行后续操作直到遇到 #endif 指令为止","tags":"读书笔记","url":"https://xutree.github.io/pages/2018/10/06/C++_Primer_Chapter_2/"},{"title":"利用 Mac stat 添加文件创建时间、最后修改时间","text":"Pelican 根据 .md 文件生成网页的时候需要 metadata，所以写个命令行自动添加文件创建时间、最后修改时间，这样写博客的时候只需要把 title、category 和 tags 标签填上就行了，其中用了 stat 命令。 自动添加文件创建时间、最后修改时间 stat 命令的 a, m, c, B 参数分别代表上次访问或修改时间文件，上次更改 inode 的时间或 inode 的生成时间（ UNIX 时间戳），所以我们可以通过提取这些信息实现想要的功能。唯一需要注意的是，结果是UNIX时间戳，我们需要将其转换为普通时间。 UNIX 时间，或称 POSIX 时间是 UNIX 或类 UNIX 系统使用的时间表示方式：从协调世界时1970年1月1日0时0分0秒起至现在的总秒数，不考虑闰秒。在多数 UNIX 系统上 UNIX 时间可以通过 date +%s 指令来检查。 在 Mac 系统是由 UNIX 时间戳转化为普通时间的指令为： 所以我们\b先根据 stat 获得文件的创建时间： 然后转化为普通时间： \b以下为脚本： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #! /bin/bash # 输入：需要修改的文件 filename = $1 # 提取创建时间 create_time = $( date -r $( stat -f \"%B\" $filename ) \"+%Y-%m-%d %H:%M:%S\" ) # 提取修改时间 modify_time = $( date -r $( stat -f \"%m\" $filename ) \"+%Y-%m-%d %H:%M:%S\" ) # 查找Date标签的行号 num1 = $( head -5 $filename | grep -n 'Date' | cut -d \":\" -f 1 ) # 查找Modified标签的行号 num2 = $( head -5 $filename | grep -n 'Modified' | cut -d \":\" -f 1 ) # 如果Date标签行号为空，说明不存在Date标签，则插入Date if [ -z \" $num1 \" ] ; then sed -i '' -e \"2s/&#94;//p; 2s/&#94;.*/Date: $create_time /\" $filename fi # 如果Modified标签行号为空，插入Modified if [ -z \" $num2 \" ] ; then sed -i '' -e \"3s/&#94;//p; 3s/&#94;.*/Modified: $modify_time /\" $filename else # 否则，替换Modified标签到最新时间 sed -i '' ${ num2 } d $filename sed -i '' -e \"3s/&#94;//p; 3s/&#94;.*/Modified: $modify_time /\" $filename fi 附：stat 命令详情 stat 显示有关文件的信息。 不需要读取，写入或执行指定文件的权限，但必须可搜索通向该文件的路径名中列出的所有目录。 如果没有给出参数， stat 将显示有关标准输入的文件描述符（stdin）的信息。 当作为 readlink 调用时，仅打印符号链接的目标。 如果给定的参数不是符号链接，则 readlink 将不打印任何内容并退出并显示错误。 显示的信息是通过使用给定参数调用 lstat 系统调用并解释返回的结构来获得的。 参数 -F 与 ls 命令\b的 -F 参数一样，在作为目录的每个路径名之后显示斜杠（'/'），在每个可执行的路径名后面显示星号（'*'），在每个符号链接后显示at符号（'@'）， 在每个without文件后面显示百分号（'％'），每个套接字后显示等号（'='），以及在每个FIFO文件后面显示一个垂直条（'|'）。 -F 的使用意味着 -l -f format 使用指定的格式显示信息 -L 使用 stat 而不是 lstat 。 如果文件是符号链接，则stat给出的信息是链接文件目标文件的信息，而不是链接\b文件本身 -l 将输出以 ls -lT 格式显示，即显示文件的完整时间信息，包括月，日，小时，分钟，秒和年 -n 输出不强制换行 -q 如果对 stat 或 lstat 的调用失败，则不\b显示失败消息。以 readlink 方式运行时，会自动禁止错误消息 -r 显示原始信息。即，对于stat结构（UNIX/Linux系统中定义的结构体）中的所有字段，显示原始数值（例如，自纪元以来的秒数等） -s 在\"shell输出\"中显示信息，适用于初始化变量 -t timefmt 使用指定的格式显示时间戳。 此格式直接传递给 strftime 命令 -x 从某些Linux发行版中以更详细的方式显示信息 格式 格式字符串类似于 printf 格式，因为它们以 ％ 开头，然后是一系列格式化字符，最后是一个字符，用于选择要格式化的 struct stat 字段。 如果 ％ 后面紧跟 n，t，％ 或 @ 之一，则会打印换行符，制表符，百分号或当前文件号，否则将检查字符串是否包含以下内容： 以下是任何可选标志： # 为八进制和十六进制输出选择备用输出形式。 非零八进制输出将具有前导零，并且非零十六进制输出将具有前缀\"0x\" + 断言应始终打印指示数字是正数还是负数的符号。 非负数通常不打印带符号 - 将字符串输出对齐到字段的左侧，而不是右侧 0 将左边距的填充字\b符设置为\"0\"字符，而不是空格 space 在非负有符号输出字段的前面保留一个空格。 如果同时使用 ‘+' ，则 ‘+' 将覆盖空格 以下是任何可选字段： size 可选的十进制数字字符串，指定最小字段宽度 prec 由小数点'.'和十进制数字字符串组成的可选精度，指示最大字符串长度，浮点输出中小数点后出现的位数，或数字输出中显示的最小位数 fmt 可选的输出格式说明符，它是D，O，U，X，F 或 S 之一。它们分别表示带符号的十进制输出，八进制输出，无符号十进制输出，十六进制输出，浮点输出和字符串输出。 某些输出格式不适用于所有字段。 浮点输出仅适用于 timespec 字段（a，m 和 c 字段）。 特殊输出说明符S可用于指示输出（如果适用）应为字符串格式。 可与以下标志结合使用： amc 以 strftime 格式显示日期 dr 显示实际设备名称 gu 显示组或用户名 p 以 ls -lTd 显示文件模式 N 显示文件名 T 显示文件类型 Y 在输出中插入\" -> \"。 请注意， Y 的默认输出格式是字符串，但如果明确指定，则会预先添加这四个字符 sub 可选的子字段说明符（高，中，低）。仅适用于 p，d，r 和 T 输出格式。 它可以是以下之一： H \"高\"，指定来自 r 或 d 的设备的主要编号，来自 p 的字符串形式的权限的\"用户\"位，来自 p 的数字形式的文件\"type\"位，以及 T 的长输出形式 L \"低\"，指定来自 r 或 d 的设备的次要编号，来自 p 的字符串形式的权限的\"其他\"位，来自 p 的数字形式的\"用户\"，\"组\"和\"其他\"位， 当与 T 一起使用时，文件类型的 ls -F 样式输出字符（对此使用 L 是可选的） M \"中\"，指定 p 的字符串输出形式的权限的\"组\"位，或 p 的数字形式的 \"suid\"，\"sgid\" 和 \"sticky\" 位 datum 必填字段说明符，是以下之一： d 文件所在的设备 i 文件的inode编号 p 文件类型和权限 l 文件的硬链接数 u, g 文件所有者的用户ID和组ID r 字符和块设备专用文件的设备编号 a, m, c, B 上次访问或修改时间文件，上次更改 inode 的时间或 inode 的生成时间（UNIX时间戳） z 文件大小（以字节为单位） b 分配给文件的块数 k 最佳文件系统I / O操作块大小 f 用户定义的文件标志 v Inode 生成号 以下四个字段说明符不是直接从struct stat中的数据中提取的，而是： N 文件的名称 T 文件类型，类似 ls -F ，如果给出子字段说明符H，则采用更具描述性的形式。 Y 符号链接的目标 Z 从字符或块特殊设备的rdev字段扩展为\"major，minor\"，并为所有其他设备提供大小输出 只有 ％ 和字段说明符是必需的。大多数字段说明符默认为 U 作为输出形式；p 默认输出形式是 O；a、m、c 默认输出形式是 D，Y、T、N 默认输出形式是 S。","tags":"Mac","url":"https://xutree.github.io/pages/2018/10/06/mac-stat/"},{"title":"C++ Primer 第一章 开始","text":"g++ -std=c++14 -Wall -o test test.cpp iostream cin cout cerr clog << 运算符返回其左侧的运算对象 写入 endl 的效果是结束当前行，并将与设备关联的缓冲区中的内容刷到设备中。缓冲刷新操作可以保证到目前为止程序所产生的所有输出都真正写入到输出流中，而不是仅停留在内存中等待写入流 小心程序崩溃，输出可能还留在缓冲区的情况，利用 endl 标准库定义的所有名字都在命名空间 std 中 当我们使用一个 istream 对象作为条件时，其效果是检测流的状态。流有效，即流未遇到错误，那么检测成功。当遇到文件结束符（end of file），或遇到一个无效输入时， istream 对象的状态会变为无效。无效的 istream 对象会使条件为假 文件结束符：Windows 先Ctrl + Z，后Enter 或 Return；UNIX：Ctrl +D 标准库文件通常不带后缀。编译器一般不关心头文件名的形式，但有的IDE对此有特定要求 头文件包含：标准库头文件 <> 非标准库头文件 \"\" 文件重定向：从文件读入\\<infile，输出到文件>outfile cerr (无缓冲标准错误) 没有缓冲，发送给它的内容立即被输出 clog (缓冲标准错误) 有缓冲，缓冲区满时输出 cout 标准输出 cout 是在终端显示器输出， cout 流在内存中对应开辟了一个缓冲区，用来存放流中的数据，当向 cout 流插入一个 endl ，不论缓冲区是否满了，都立即输出流中所有数据，然后插入一个换行符 cerr 流对象是标准错误流，指定为和显示器关联，和 cout 作用差不多，有点不同就是 cout 通常是传到显示器输出，但可以被重定向输出到文件，而 cerr 流中的信息只能在显示器输出 clog 流也是标准错误流，作用和 cerr 一样，区别在于 cerr 不经过缓冲区，直接向显示器输出信息，而 clog 中的信息存放在缓冲区，缓冲区满或者遇到 endl 时才输出 对于为什么有 cerr 和 clog ？比如，你的程序遇到调用栈用完了的威胁（无限，没有出口的递归。你说，你到什么地方借内存，存放你的错误信息？所以有了 cerr 。其目的，就是在你最需要它的紧急情况下，还能得到输出功能的支持 缓冲区的目的，就是减少刷屏的次数——比如，你的程序输出圣经中的一篇文章。不带缓冲的话，就会每写一个字母，就输出一个字母，然后刷屏。有了缓冲，你将看到若干句子\"同时\"就出现在了屏幕上（由内存翻新到显存，然后刷新屏幕）","tags":"读书笔记","url":"https://xutree.github.io/pages/2018/10/05/C++_Primer_Chapter_1/"},{"title":"HTML 入门","text":"HTML ，即超文本标记语言（ H yper T ext M arkup L anguage）。与脚本或编程语言不同，标记语言使用标记（ tag ）来标识内容。 下面是一个 HTML tag 的例子： <p> 这是一个段落。</p> <p> 称为开始标签， </p> 称为结束标签。 网页的结构 HTML：结构 CSS：样式 JavaScript：行为 PHP 或类似语言：后端 CMS：内容管理 基本 HTML 文件结构 标签 解释 <html></html> HTML文件的所有内容都包含在其中 <head></head> HTML文件的头部包含有助于使页面工作的所有非可视元素 <body></body> 所有可视化元素都包含在body标签中 <title></title> 包含网页选项卡上现实的标题内容 下面是 HTML 版本的\"Hello, World！\"程序： <html> <head> </head> <body> Hello World! </body> </html> 字体标签 标签 解释 <p></p> 段落标签（浏览器会在段落前后自动添加空行） <br /> 换行而不开启新段落（它没有结束标记） <b></b> 粗体 <big></big> 大号文本 <i></i> 斜体 <small></small> 小号文本 <strong></strong> 强调（一种phrase tag） <sub></sub> 下标 <sup></sup> 上标 <ins></ins> 插入线 <del></del> 删除线 浏览器将 <strong> 显示为 <b> ，将 <em> 显示为 <i> 。但是，这些标记的含义不同： <b> 和 <i> 分别定义粗体和斜体文本，而 <strong> 和 <em> 表示文本\"重要\"。 标题标签 <h1></h1> ， <h2></h2> ， <h3></h3> ， <h4></h4> ， <h5></h5> ， <h6></h6> 六种标题， <h1></h1> 字号最大。 标签属性\b 属性提供有关元素或标记的附加信息，同时还可以修改它们。例如 <p align= \"center\" > This text is aligned to center </p> 会将段落居中显示（\b <p> 标签的align属性在HTML5中不再支持）。\b 属性的数值可以通过像素或百分比指定，如 <hr width=\"50px\" /> <hr width=\"50%\" /> 图像标签 <img src=\"\" height=\"\" width=\"\" border=\"\" alt=\"\"/> src：图像名称 height：图像高 width：图像宽 border：边界宽度 alt：如果无法显示图像，则alt属性指定以单词形式描述图像的替代文本 链接标签 <a href=\"\" target=\"\"></a> href：目标网址 target：指定打开链接文档的位置，\b_blank值将在新窗口或新标签中打开链接 列表标签 有序列表 <html> <head> <title> first page </title> </head> <body> <ol> <li> Red </li> <li> Blue </li> <li> Green </li> </ol> </body> </html> 无序列表 <html> <head> <title> first page </title> </head> <body> <ul> <li> Red </li> <li> Blue </li> <li> Green </li> </ul> </body> </html> 表格标签 <table border= \"\" align= \"\" > <tr> <td bgcolor= \"red\" > Red </td> <td> Blue </td> <td> Green </td> </tr> <tr> <td> Yellow </td> <td colspan= \"2\" > Orange </td> </tr> </table> 其他 标签 解释 <hr /> 水平线 <!--...--> 注释 HTML 元素类型\b 在 HTML 中，大多数元素被定义为块级或内联元素。 块级元素从新行开始，如 <h1>, <form>, <li>, <ol>, <ul>, <p>, <pre>, <table>, <div> 等 内联元素通常显示没有换行符，如 <b>, <a>, <strong>, <img>, <input>, <em>, <span> 等 <div> 元素是一个块级元素，通常用作其他 HTML 元素的容器。与一些 CSS 样式一起使用时， <div> 元素可用于设置内容块的样式。 同样， <span> 元素是一个内联元素，通常用作\b某些文本的容器。与 CSS 一起使用时， <span> 元素可用于设置文本的部分样式。 其他元素可以用作块级元素或内联元素。 这包括以下这些： APPLET - 嵌入式 Java 小程序 IFRAME - 内联框架 INS - 插入文本 MAP - 图像映射 OBJECT - 嵌入对象 SCRIPT - HTML 文档中的脚本 你可以在块元素内插入内联元素。 例如，可以在 <div> 元素中包含多个 <span> 元素。反之不行。 表单标签 HTML 表单用于从用户收集信息。使用 <form> 元素及其开始和结束标记定义表单，使用 action 属性指向将在用户提交表单后加载的网页： <body> <form action= \"\" method= \"\" > … </form> </body> method 属性指定在提交表单时使用的 HTTP 方法（GET 或 POST）： 使用 GET 时，表单数据将显示在页面地址中 如果表单正在更新数据，请使用 POST，或者包含敏感信息（密码）。POST 提供了更好的安全性，因为提交的数据在页面地址中不可见 要接受用户输入，需要相应的表单元素，例如文本字段。 <input> 元素有许多变体，具体取决于 type 属性。 它可以是文本，密码，广播，URL，提交等。 <form> <input type= \"text\" name= \"username\" /><br /> <input type= \"password\" name= \"password\" /> </form> <frame> 标签 可以使用特殊帧文档将页面划分为帧。 <frame> 标签定义 <frameset> 中的一个特定窗口（框架）。 <frameset> 中的每个 <frame> 可以具有不同的属性，例如边框，滚动，调整大小的能力等。 <frameset> 元素指定框架集中的列数或行数，以及每个框架占空间像素的百分比或数量。 <frameset cols= \"25%,50%,25%\" > <frame src= \"a.htm\" /> <frame src= \"b.htm\" /> <frame src= \"c.htm\" /> <noframes> Frames not supported! </noframes> </frameset> 使用 <noresize> 属性指定用户无法调整 <frame> 元素的大小： <frame noresize=\"noresize\"> HTML5 中不支持 <frame> 标签。 颜色 颜色值 HTML 颜色表示为十六进制值，0~\bF。零表示最低值，F表示最高值。 颜色模式 颜色以红色，绿色和蓝色光（RGB）的组合显示。 十六进制值使用＃标签符号，后跟六个十六进制字符。所有浏览器都支持 RGB 颜色值。","tags":"HTML","url":"https://xutree.github.io/pages/2018/10/05/html-overview/"},{"title":"X3DOM 图像和视频纹理","text":"本章你将知道哪些图像类型和视频格式可以用作 X3DOM 的纹理，以及纹理的特性和限制。 你可以使用 PNG ， LPEG 或者 GIF 来编码你的静态纹理数据。 JPG 图像需要的内存少但是存在压缩损失而且没有 alpha 通道。 PNG 图像属于无损压缩并且有 alpha 通道， GIF 也是无损压缩并且有 alpha 通道。一般来讲：如果你不需要 alpha 通道并且图像中不包含硬边界(例如：文本)，使用 JPG ，否则使用 PNG 。你应该避免使用 GIF 。 图像 利用 ImageTexture 节点把图像作为纹理： <x3d width= '500px' height= '400px' > <scene> <shape> <appearance> <ImageTexture url= \"myTexture.png\" ><ImageTexture/> </appearance> <box> </box> </shape> </scene> </x3d> 视频 利用 MovieTexture 节点可以把视频作为纹理。但是目前还没有哪一种视频格式支持所有的用户。可以使用 X3DOM 格式 示例 来确定你的浏览器支持的格式。目前最好的解决方法是将你的视频编码成 MP4 和 OGV 格式并在 MovieTexture 节点中提供这两个选项： <x3d width= '500px' height= '400px' > <scene> <shape> <appearance> <MovieTexture url= '\"foo.mp4″,\"foo.ogv\"' ><MovieTexture/> </appearance> <box> </box> </shape> </scene> </x3d>","tags":"X3DOM","url":"https://xutree.github.io/pages/2018/10/05/X3DOM图像和视频纹理/"},{"title":"X3DOM，HTML，CSS 和 JavaScript","text":"本节，你将学习关于 X3DOM, HTML 和 CSS的更多知识，以及怎么利用 HTML 和 CSS 技术构建出强大的 3D 应用。在本节最后，你讲学习怎么在你的应用中使用 JavaScript。我们将继续使用前一节的例子。拷贝 HelloX3DOM.html 文件并重命名为 HTMLEventsCSS.html。 X3DOM 和 CSS 我们首先来看下怎么通过 CSS 操控 X3DOM 元素。你可能已经注意到，在 HelloX3DOM.html 中，3D 内容位于一个被黑色边界包围的白色区域中。X3DOM 有一个单独的 css 文件，自从版本1.3以后，名字一直为 x3dom.css，在这个文件中可以找到关于 X3DOM 元素的所有 css 定义以及 debug 信息。假设你的页面使用灰色和橙色作为主要颜色。你可以通过许多方式改变 X3DOM 默认的 CSS 属性： 在 x3dom.css 后包含你自己的 CSS 文件(External Style Sheet) 在 x3dom.css 之后，利用 style 标签定制 css(Internal Style Sheet) 直接操纵相关元素的 style 属性(Inline Styles) 关于 CSS 有很多网上教程，例如 这里 。我们现在利用第二种方法改变 css，通常不推荐第三种方法。为了定制 x3d 代表的 X3DOM 边界，在你的 HTML 文件头部 x3dom.css 之后插入 style 标签： <html> <head> <title> My first X3DOM page </title> <script type= 'text/javascript' src= 'http://www.x3dom.org/download/x3dom.js' > </script> <link rel= 'stylesheet' type= 'text/css' href= 'http://www.x3dom.org/download/x3dom.css' ></link> <style> x3d { border:2px solid darkorange; } </style> </head> <body> <h1> Hello, X3DOM! </h1> <p> This is my first html page with some 3d objects. </p> <x3d width= '600px' height= '400px' > ... </x3d> </body> </html> 现在，X3DOM 的边界颜色已经改变了。假设你的网页已经有了橙色和灰色风格，使用 pattern.png 作为背景(背景图片在 这里 )。那么完整的 style sheet 如下所示： x3d { border : 2 px solid darkorange ; } body { font-size : 110 % ; font-family : verdana , sans-serif ; background-image : url ( 'pattern.png' ); margin : 3 em ; color : lightgray ; } h1 { color : darkorange ; } 现在你的网页看起来如下所示： 从图中可以看出，X3DOM 使用与网页相同的背景。这是一个很重要的行为：你的 X3DOM scene 是在 HTML 之上进行渲染的。让我们设置 x3d 元素为半透明背景： x3d { border : 2 px solid darkorange ; background : rgba ( 128 , 128 , 128 , 0.4 ); } 现在结果看起来如下所示： X3DOM, HTML 事件和 JavaScript 使用 HTML 和 JavaScript，你可以使用大量有用的回调函数来操纵大多数 DOM 元素。X3DOM 为 node 提供了相似的函数。例如，当我们点击红色立方体的时候，可以弹出一个文本信息，在 shape 里插入一个 onclick 函数就可以实现这个功能： <shape onclick= \"alert('Hello, click!');\" > <appearance> <material diffuseColor= '1 0 0' ></material> </appearance> <box></box> </shape> 目前，你可以对 X3DOM 使用 onmousemove ， onmousedown ， onmouseup ， onmouseover 和 onmouseout 事件。你不仅可以在 shape 节点插入事件，也可以在组节点，例如 transform 插入事件。这样你就可以使用一个回调函数捕捉多个节点的事件。 你可以在每个 DOM 元素上使用 JavaScript，所以你可以随心所欲的操纵 node 。你已经知道怎么使用 onclick 事件，让我们尝试当点击时，改变立方体的颜色。如果你从没使用过 JavaScript，这个 网站 或许可以帮助你。 首先，给你想操纵的节点一个 id ： <shape onclick= \"alert('Hello, click!');\" > <appearance> <material id= \"color\" diffuseColor= '1 0 0' ></material> </appearance> <box></box> </shape> 然后，你就可以通过下面这个函数改变颜色： <script> function changeColor() { if(document.getElementById(\"color\").getAttribute('diffuseColor')==\"1 0 0\") document.getElementById(\"color\").setAttribute('diffuseColor', '0 0 1'); else document.getElementById(\"color\").setAttribute('diffuseColor', '1 0 0'); } </script> <shape onclick=\"changeColor();\"> 下一步：自动创建 (X)HTML 如果你有大量的模型数据，你想把这些数据分配到不同的页面上。那么自动生成实际的页面而不是手动编写代码将更加有趣。你可以使用自动化工具，例如 XSLT，允许你直接将 X3DOM 文件转化为 XHTML 网页。 这里 是一个例子。","tags":"X3DOM","url":"https://xutree.github.io/pages/2018/10/05/X3DOMHTMLCSS和JavaScript/"},{"title":"Hello，X3DOM！","text":"本教程将教会你怎么配置和运行你的第一个 X3DOM 应用。你只需要一个相容于 WebGL 的浏览器和一个文本编辑器。整个 X3DOM 应用是常规网页的一部分，并且编写方式也与HTML很相似，所以如果你的编辑器支持HTML或者XML的语法高亮那将更好，像 WebStorm 这种 Web 编程 IDE 也是可以的。如果你手头有一个网页浏览器和一个文本编辑器，并且你知道怎么在浏览器中打开网页(参考 这里 )，那么你可以开始你的第一个 X3DOM 应用了。 首先，创建一个新文件 HelloX3DOM.html 。然后将下面的内容复制粘贴进这个空文件： <html> <head> <title> My first X3DOM page </title> <script type= 'text/javascript' src= 'http://www.x3dom.org/download/x3dom.js' > </script> <link rel= 'stylesheet' type= 'text/css' href= 'http://www.x3dom.org/download/x3dom.css' ></link> </head> <body> <h1> Hello, X3DOM! </h1> <p> This is my first html page with some 3d objects. </p> </body> </html> 如果你在浏览器中打开这个文件，你会看到一个包含一个文本信息的常规HTML页面。你可能已经注意到，我们已经在我们的网页中添加了一些 X3DOM 元素，因为我们已经包含 X3DOM 作为一个 JaveScript 库，还包含了 X3DOM CSS 文件，用于规则的显示 X3DOM 元素。在上面的 HTML 代码中，我们通过 script 和 link 标签是用了 development 版本的 X3DOM。 让我们继续添加一些 3D 内容。首先，我们需要一个 x3d 元素，用来描述 X3DOM 内容在哪个 scene 显示。和 HTML 元素 p 、 div 类似， x3d 在 HTML 里定义了一个矩形范围。整个 X3DOM 的 3D 内容用 scene 描述，所以我们在 x3d 标签里添加一个 scene 标签。这种结构是来自于X3D标准。一个 scene 可以包含很多不同的 node ，例如， lights 、 groups 、 viewpoint 和 objects 。在第一个例子里，我们通过 shape 简单地定义一个3D物体。我们用 box 定义这个物体的几何形状。现在，你可以将下面的代码添加在你的 HTML 文件闭合 p 标签之后： <x3d width= '600px' height= '400px' > <scene> <shape> <box></box> </shape> </scene> </x3d> 如果你现在在浏览器中打开这个文件，会像下面这样： 由于 box 目前没有颜色，所以无法看到它，为了看到它我们需要声明 material ，X3DOM 基于 X3D 标准选择了一个白色的 material ，由于网页的背景也是白色的，所以我们看不到它。为了改变 material 的颜色，我们首先需要在 shape 中插入 appearance 。在 appearance 里面，我们就可以插入 material ，利用 material 的 diffuseColor 我们可以定义 material 的颜色，我们现在将它定义为 RGB 颜色的红色： <shape> <appearance> <material diffuseColor= '1 0 0' ></material> </appearance> <box></box> </shape> 现在，在你的浏览器中，网页将变成： 现在，你可以利用鼠标进行交互了。按住鼠标左键并移动鼠标，你可以旋转视角，按住鼠标右键并移动鼠标，你可以放大和缩小。 我们继续在这个 scene 中添加两个物体：一个蓝色的球体和一个绿色的圆锥。这和我们添加 box 类似，但是，在 sphere 和 cone 节点处，我们需要移动球和圆锥以避免他们相互重叠，因为所有的 3D 物体都默认不进行任何的坐标转换，也就是说它们会重叠在一起。像X3D和其他的图像相关标准(例如，OpenGL)一样，X3DOM 的坐标系统 Y 轴指向上，X 轴指向右，Z 轴指向外： 在添加绿色圆锥之前，我们将坐标往左移动3个单位；在添加蓝色球之前，我们将坐标往右移动3个单位。如下所示： <shape> <appearance> <material diffuseColor= '1 0 0' ></material> </appearance> <box></box> </shape> <transform translation= '-3 0 0' > <shape> <appearance> <material diffuseColor= '0 1 0' ></material> </appearance> <cone></cone> </shape> </transform> <transform translation= '3 0 0' > <shape> <appearance> <material diffuseColor= '0 0 1' ></material> </appearance> <sphere></sphere> </shape> </transform> 现在，在你的浏览器中，你将看到如下内容： 如果你在浏览器中看到了上图的结果，恭喜你！你刚刚使用了一系列的 X3D node 创建了你的第一个 X3DOM scene 。","tags":"X3DOM","url":"https://xutree.github.io/pages/2018/10/04/X3DOM-hello/"},{"title":"X3DOM 第一课","text":"下面的指南可以作为 X3DOM 使用者和开发者的入门资料。本指南包括许多重要的内容，例如怎么配置你的环境去运行 X3DOM 的示例。如果你没有足够的时间阅读这篇入门文章，又或许你已经熟悉一点关于 X3D 的知识，你可以迅速的浏览下第3部分和第4部分的一些内容去设置你的环境，然后根据 tutorials 的指导去完成你的第一个 X3DOM 应用。 背景：什么是X3DOM，它可以用来做什么？ 无需插件即可在浏览器中显示的3D场景 X3DOM（发音：\"X-Freedom\"）是一个开源的 JaveScript 框架，用于在网页中创建 declarative 3D 场景。由于它基于标准的浏览器技术，你的浏览器不需要其他任何插件就可以显示 X3DOM 场景。概括地说，declarative 3D 意味着你可以使用结构化的文本表示去创建和显示 3D 场景，而不需要去编写代码。在 X3DOM 中，这种文本表示是表示网页的 HTML 文件的一部分。也就是说，3D 内容成为了网页元素的一部分，就像网页中的文本、链接、图片和视频一样。 X3DOM = X3D + DOM X3DOM 这个名字是由两个缩写组合而成。第一个缩写是 X3D （\"Extensible 3D Graphics\"），指代一个 3D 图形的免版税 ISO 标准。第二个缩写是 DOM （\"Document Object Model\"），描述与HTML文档的内容相关联的交互概念和分层表示。X3DOM 使用 X3D 的一个专门的子集（所谓的 HTML Profile ）来作为网页内 3D 内容的描述语言。X3D（OM)元素可以通过 DOM 操作，就像其他的 HTML 元素一样。例如，你可以动态地改变一个 3D 物体的颜色通过 JavaScript 调用相应 DOM 元素的 setAttribute(...) 函数，这就像你可以动态改变一个普通网页里一个标签的内容一样。 使用 X3DOM 的原因 使用 X3DOM 而不是其他的基于浏览器的库或者 X3D 播放器是因为 X3DOM 具有以下几个优势： 显示 X3DOM 场景不需要额外插件，因为 X3DOM 是完全基于标准浏览器技术，例如 HTML5 和 WebGL 基于 ISO 标准 X3D 的一种新的 HTML 配置，X3DOM 绝大部分都是标准一致的。这大大方便了 X3DOM 的学习 从2009年至今，X3DOM 已经具有了很大的使用者和开发者群体 如果你知道怎么创建简单的网页，你就可以利用你现有的关于 HTML 和 DOM 的知识，而不需要学习新的 API 怎么做？ 如果你想开发你的第一个 X3DOM 应用，你只需要一个浏览器和一个文本编辑器。当然，你也可以选择功能更多的 HTML 和 JavaScript 开发环境，比如 WebStorm 。 一些基本 X3D 概念：Nodes、Components 和 Profiles X3D Nodes X3D 定义每一个 3D 场景都是由一组 node 组成。每一个 node 代表 3D 场景中一个确定的部分：光线、物体、物体表面的材质等等。场景里的所用 node 排列成树结构或者图结构，整体结构被叫做 scene-graph 。每一个 node 的行为，比如材质的颜色，可以通过node的 fields 设置。例如，一个用来设置某物体表面颜色为红色（RGB编码 1 0 0）的node的 XML 描述为： <Material diffuseColor= '1 0 0' ></Material> 你可能已经意识到，描述 X3D node 的 XML 很像常规的 HTML 代码，属性值 diffuseColor 的设置也像 HTML 属性的设置一样。事实上，如果你熟悉 HTML，那么就很容易理解 X3DOM 中的 node 了。你可以在 tutorials 中学习怎样使用 node。如果你想了解更多 X3D 中 node 的概念，可以参考 external X3D documentation resources 。 X3D Components 一组具有相同功能的 node 称为 components。例如定义光线的 node， PointLight 和 SpotLight ，在 Lighting component 里。关于 Components 的全部信息可以在 这里 找到。 X3D Profiles 和 X3DOM HTML Profile X3D 标准定义了大量的 node，一些特殊用途的 node 对大多说用户来说并不重要。因此，X3D 引入了 profile 的概念，把许多组 node 放在一起成为一个包，每一个包代表一类特殊的应用。例如， CAD 包， Immersive 包是用于交互环境的。profile 是在 component 之上的一个概念。 X3DOM 使用的 X3D component 经过十分仔细的选择，以提供一个最合适的 X3D 子集来满足现代 HTML 应用的需要。X3DOM 通过定义一个特殊的 profile，即 HTML profile，来解决这一问题。这个 HTML profile 也包括一些处于试验阶段的 X3D 没有的 node 和 filed，这些 node 和 filed 是专门为 X3DOM 设计的。具体来说，有些 X3D node 在 X3DOM 里没有，而有些 node X3DOM 里有但是 X3D 里没有。你可以在 这里 找到每个 node 的起源。如果你想学习更多关于 HTML profile 的知识以及它与现有的 X3D component、profile 的关系，可以查看 这里 。 最后，X3DOM 也提供一些不在原始HTML profile 中的 X3D node。这些 node 不在 X3DOM 的标准发行版本中，只在 X3DOM-Full 版本中。 选择一个 X3DOM 版本 版本和 Components 有许多可供选择的 X3DOM 版本，你可能想知道对特殊的目的哪一个才是最好的。一般来讲，我们推荐最新的 release 版本。但是，如果你需要采用的新特性在 release 版中没有，那么 dev 版本可能更适合你。当你完成了网页应用的主要开发工作进而部署时，你可能需要用来开发的 X3DOM 的版本信息。你也可能，出于某种原因需要老版本的 X3DOM，比如你的网页应用包含了一些试验特性只在老版本出现，而在新版本中被移除了。 所有的 X3DOM release 版本，包括 dev 版本，都被打包好了，里面包括一个 JavaScript 文件（如 x3dom.js），一个 css文件（如 x3dom.css）和一个可选的 shockwave 文件（如 x3dom.swf，对于那些支持 flash 的版本），可在 这里 下载： 版本1.0到1.2的文件以 x3dom-v 标记，后面跟着版本号（如 http://x3dom.org/download/x3dom-v1.1.js ） 从版本1.3开始，x3dom.js, x3dom.css, x3dom.swf 和一个 .zip 存档文件b被放置在一个以版本号为名字的子文件夹里（如 http://x3dom.org/download/1.3/x3dom.js ） 从版本1.3开始，一些 HTML profile 之外的 component 出现了。这些 component 在文件 x3dom-full.js 中。如果你只需要使用其中一个 component，你也可以考虑仍使用 x3dom.js 然后包含所需的 component 的文件（如 http://x3dom.org/download/1.3/components/ ） 最新的稳定 release 版总是位于： http://x3dom.org/release/x3dom.js 目前的 development 版本总是位于 dec 子文件夹： http://x3dom.org/download/dev/x3dom.js 为使用最新版本 release X3DOM，你可以在你的HTML页面中包含下面的标签： <script src= \"http://www.x3dom.org/release/x3dom.js\" ></script> <link rel= \"stylesheet\" href= \"http://www.x3dom.org/release/x3dom.css\" > 为使用最新的 development 版本，使用下面的标签： <script src= \"http://www.x3dom.org/download/dev/x3dom.js\" ></script> <link rel= \"stylesheet\" href= \"http://www.x3dom.org/download/dev/x3dom.css\" > 为使用版本1.5的 X3DOM-Full 版本，使用下面的标签： <script src= \"http://www.x3dom.org/download/1.5/x3dom-full.js\" ></script> <link rel= \"stylesheet\" href= \"http://www.x3dom.org/download/1.5/x3dom.css\" > 最后，为使用1.3版本的 release X3DOM 和额外的 Geospatial component 和另外的 flash 支持，使用下面的标签： <script src= \"http://www.x3dom.org/download/1.3/x3dom.js\" ></script> <script src= \"http://www.x3dom.org/download/1.3/components/Geospatial.js\" ></script> <script src= \"http://www.x3dom.org/download/1.3/x3dom.swf\" ></script> <link rel= \"stylesheet\" href= \"http://www.x3dom.org/download/1.3/x3dom.css\" > Debugging 如果在 debug 你的应用的时候你想看到 X3DOM 的源码，只需将 x3dom.js 替换成 x3dom.debug.js 或者将 x3dom-full.js 替换成 x3dom-full.debug.js。其注意，此特性只适用于版本1.4以后的 X3DOM。相比于常规版本，debug 版本包含缩进和注释，所以比较大。所以，当你最终发布你的 Web 应用时，请不要使用 debug 版本的 js。 运行 X3DOM 应用 通过简单的 Python 服务器 一个简便的方法在服务器上来测试你的 Web 应用是使用 Python 的 HTTP 服务器模块。你只需要安装一个 Python 解释器。你可以在 这里 下载。你可以用 Python 做许多有趣的事情。首先，打开命令行窗口，定位到 X3DOM 文件夹。如果你的 Python 是2.X版本，你可以使用 SimpleHTTP 服务器模块如下所示： python -m SimpleHTTPServer 如果你的 Python 是3.x版本，如下所示： python3 -m http.server 默认情况下，服务器使用8000端口。如果你想改变端口，直接在命令后面加上端口号即可，例如： python -m SimpleHTTPServer 8023 然后，通过浏览器输入如下地址就可以到达你的服务器： http://localhost:8023 如果你在启动 Python 服务器的文件夹里放置了 index.html 文件，那么这个文件的内容就会显示在浏览器窗口里。否则，你会看到服务器所在文件夹内的文件列表。 在 Web 服务器上运行 X3DOM 通常，你会在Web服务器上运行你的 X3DOM 应用，本节针对一些普通的 Web 服务器，如 Apache 和 IIS，给出具体的方法。 Apache 是使用最多的 Web 服务器。它是开源的可以在 这里 下载。最新版本是2.4，但是版本2.2仍然被支持。 如果你的应用需要一整套 Web 服务器组件，我们推荐 XAMPP ，它包含 Apache、MySQL、PHP 和 Perl 的最新发行版。 互联网信息服务（IIS）被集成在微软的任何的最新版本的 Windows 当中。但是，对于非服务器操作系统，同时连接数会受到限制。","tags":"X3DOM","url":"https://xutree.github.io/pages/2018/10/04/X3DOM第一课/"},{"title":"安装 Pelican","text":"安装 Pelican Pelican 目前支持最好的是 Python 2.7 和 3.3+，早期版本的 Python 已经不支持了。有许多不同的方法可以安装 Pelican，最简单的方法是使用 pip，在终端输入： pip install pelican 上面是最简单的方法，官方更为推荐的方法是利用 virtualenv 为 Pelican 建立一个虚拟环境。假设你已经安装好了 virtualenv，下面打开终端，开始为 Pelican 新建一个虚拟环境： virtualenv ~/virtualenv/pelican cd ~/virtualenv/pelican source bin/activate 当虚拟环境被创建并激活以后，然后利用 pip install pelican 安装 Pelican。 当 Pelican 安装好以后，你可以在终端输入 pelican --help 查看使用选项。 可选的 Packages\b 如果你计划用 Markdown 来书写你的网页的话，你需要安装 Markdown： pip install Markdown 通过设置 Pelican 的 pelicanconf.py 文件，你可以对生成的 HTML 文件启用增强语法。但是首先你需要安装 Typogrify ： pip install typorify 更新 更新到最新的稳定版本，使用： pip install --upgrade pelican","tags":"教程","url":"https://xutree.github.io/pages/2018/10/04/在mac上安装Pelican/"}]}