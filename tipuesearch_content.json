{"pages":[{"title":"Search · You Know Nothing\n","text":"\n\n\n\n\n\n\nSearch · You Know Nothing\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nYou Know Nothing\n\n\n主页\n分类\n标签\n归档\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPowered by Pelican. Theme: Elegant by Talha Mansoor\n\n\n\n\n\n\n    $(document).ready(function() {\n        $('#tipue_search_input').tipuesearch({\n            'mode': 'json',\n            'show': 10,\n            'newWindow': false,\n            'contentLocation': 'tipuesearch_content.json'\n        });\n    });\n\n\n","tags":"","url":"https://xutree.github.io/search.html"},{"title":"Page not found · You Know Nothing\n","text":"\n\n\n\n\n\n\nPage not found · You Know Nothing\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nYou Know Nothing\n\n\n主页\n分类\n标签\n归档\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n该页面不存在！\n\n\n\n\n抱歉，找不到您要查找的页面。 您尝试访问的页面似乎不存在，或者可能刚刚移动，或者它已不再存在。\n或许你想从主页重新开始。\n\n\n\n\n\n\n\n\n\n\nPowered by Pelican. Theme: Elegant by Talha Mansoor\n\n\n \n\n\n        function validateForm(query) {\n            return (query.length > 0);\n        }\n    \n\n","tags":"","url":"https://xutree.github.io/404.html"},{"title":"方向导数和梯度","text":"1. 方向导数 多元函数的偏导数反映了函数值沿着坐标轴方向的变化率，方向导数（directional derivative）则表示多元函数沿着某一方向的变化率 定义 1.1（方向导数）设 \\(f\\) 是定义于 \\(\\mathbb{R}&#94;n\\) 中某区域 \\(D\\) 上的函数，点 \\(P_0\\in D\\) ， \\(l\\) 为一给定的非零向量， \\(P\\) 为一动点，向量 \\(\\vec{P_0P}\\) 与 \\(l\\) 的方向始终一致。如果极限 $$\\lim_{\\|P_0P\\|\\to0}\\frac{f(P)-f(P_0}{\\|\\vec{P_0P}\\|}$$ 存在，则称此极限为函数 \\(f\\) 在 \\(P_0\\) 处沿 \\(l\\) 方向的方向导数，记作 \\(\\frac{\\partial f}{\\partial l}\\) 。 定义 1.2（方向余弦）设 \\(l\\) 是一个 \\(n\\) 维非零向量， \\(l_0=\\frac{l}{\\|l\\|}，即 $l_0\\) 是与 \\(l\\) 同向的单位向量。取 \\(0\\leq\\alpha_i\\leq\\pi\\) ，使 $$l_0=(\\cos\\alpha_1,\\cos\\alpha_2,\\cdots,\\cos\\alpha_n)$$ 称 $$\\cos\\alpha_1,\\cos\\alpha_2,\\cdots,\\cos\\alpha_n$$ 为向量 \\(l\\) 的方向余弦。 定理 1.1（方向导数计算公式）若函数 \\(f\\) 在点 \\(P_0\\) 处可微，向量 \\(l\\) 的方向余弦为 \\(\\cos\\alpha_1,\\cos\\alpha_2,\\cdots,\\cos\\alpha_n\\) ，则函数 \\(f\\) 在点 \\(P_0\\) 处沿 \\(l\\) 方向的方向导数存在，且 $$\\frac{\\partial f}{\\partial l}\\bigg\\rvert_{P_0}=\\frac{\\partial f}{\\partial x_1}\\bigg\\rvert_{P_0}\\cos\\alpha_1+\\frac{\\partial f}{\\partial x_2}\\bigg\\rvert_{P_0}\\cos\\alpha_2+\\cdots+\\frac{\\partial f}{\\partial x_n}\\bigg\\rvert_{P_0}\\cos\\alpha_n$$ 证：因为 \\(f\\) 在 \\(P_0\\) 处可微，向量 \\(\\vec{P_0P}=(\\Delta x_1,\\Delta x_2,\\cdots,\\Delta x_n)\\) 与 \\(l\\) 同向，故 $$f(P)-f(P_0)=\\frac{\\partial f}{\\partial x_1}\\bigg\\rvert_{P_0}\\Delta x_1+\\frac{\\partial f}{\\partial x_2}\\bigg\\rvert_{P_0}\\Delta x_2+\\cdots+\\frac{\\partial f}{\\partial x_n}\\bigg\\rvert_{P_0}\\Delta x_n+o(\\|\\vec{P_0P}\\|)$$ 故 $$\\lim_{\\|\\vec{P_0P}\\|\\to0}\\frac{f(P)-f(P_0)}{\\|\\vec{P_0P}\\|}=\\lim_{\\|\\vec{P_0P}\\|\\to0}\\left[\\frac{\\partial f}{\\partial x_1}\\bigg\\rvert_{P_0}\\frac{\\Delta x_1}{\\|\\vec{P_0P}\\|}+\\frac{\\partial f}{\\partial x_2}\\bigg\\rvert_{P_0}\\frac{\\Delta x_2}{\\|\\vec{P_0P}\\|}+\\cdots+\\frac{\\partial f}{\\partial x_n}\\bigg\\rvert_{P_0}\\frac{\\Delta x_n}{\\|\\vec{P_0P}\\|}+\\frac{o(\\|\\vec{P_0P}\\|)}{\\|\\vec{P_0P}\\|}\\right] \\\\ =\\frac{\\partial f}{\\partial l}\\bigg\\rvert_{P_0}=\\frac{\\partial f}{\\partial x_1}\\bigg\\rvert_{P_0}\\cos\\alpha_1+\\frac{\\partial f}{\\partial x_2}\\bigg\\rvert_{P_0}\\cos\\alpha_2+\\cdots+\\frac{\\partial f}{\\partial x_n}\\bigg\\rvert_{P_0}\\cos\\alpha_n$$ 因为 \\(\\frac{\\partial f}{\\partial l}\\bigg\\rvert_{P_0}\\) 存在，所以 $$\\frac{\\partial f}{\\partial l}\\bigg\\rvert_{P_0}=\\frac{\\partial f}{\\partial x_1}\\bigg\\rvert_{P_0}\\cos\\alpha_1+\\frac{\\partial f}{\\partial x_2}\\bigg\\rvert_{P_0}\\cos\\alpha_2+\\cdots+\\frac{\\partial f}{\\partial x_n}\\bigg\\rvert_{P_0}\\cos\\alpha_n$$ 注意：一个函数即使在某一点处连续，可偏导，且沿所有方向的方向导 数都存在，也不一定在该点可微。所以定义中的可微条件是必须的。 2. 梯\b度 设函数 \\(f\\) 定义于 \\(\\mathbb{R}&#94;n\\) 的区域 \\(D\\) 上，或者说 \\(f\\) 是区域 \\(D\\) 上的一个数量场。我们的问题是在点 \\(P\\in D\\) 处 \\(f\\) 的方向导数沿哪个方向取得最大值，即沿哪个方向数量场的变化率最大？\b这就是梯度（gradient）问题。 如果向量 \\(l\\) 的方向余弦为 $$\\cos\\alpha_1,\\cos\\alpha_2,\\cdots,\\cos\\alpha_n$$ 那么 \\(f\\) 在点 \\(P\\) 处沿 \\(l\\) 方向的方向导数为 $$\\frac{\\partial f}{\\partial l}=\\frac{\\partial f}{\\partial x_1}\\cos\\alpha_1+\\cdots+\\frac{\\partial f}{\\partial x_n}\\cos\\alpha_n$$ 记 \\(n\\) 维\b向量 $$\\boldsymbol{g}=\\left(\\frac{\\partial f}{\\partial x_1},\\cdots,\\frac{\\partial f}{\\partial x_n}\\right)$$ 又记 \\(l\\) 方向的单位向量为 \\(\\boldsymbol{l_0}\\) ，则 $$\\boldsymbol{l_0}=\\left(\\cos\\alpha_1,\\cdots,\\cos\\alpha_n\\right)$$ 故 $$\\frac{\\partial f}{\\partial l}=(\\boldsymbol{g},\\boldsymbol{l_0})$$ 上式右端表示向量内积，由施瓦兹不等式 $$\\left|\\frac{\\partial f}{\\partial l}\\right|=|(\\boldsymbol{g},\\boldsymbol{l_0})|\\leq\\|\\boldsymbol{g}\\|\\|\\boldsymbol{l_0}\\|=\\|\\boldsymbol{g}\\|$$ 当且仅当 \\(\\boldsymbol{g}\\) 与 \\(\\boldsymbol{l_0}\\) 同向时，等号成立。而且 $$\\max\\frac{\\partial f}{\\partial l}=\\|\\boldsymbol{g}\\|=\\left[\\sum_{i=1}&#94;n\\left(\\frac{\\partial f}{\\partial x_i}\\right)&#94;2\\right]&#94;{\\frac{1}{2}}$$ 定义 2.1（梯度）设 \\(f\\) 是 \\(\\mathbb{R}&#94;n\\) 中区域 \\(D\\) 上的数量场，如果 \\(f\\) 在 \\(P_0\\in D\\) 处可微，称向量 $$\\left(\\frac{\\partial f}{\\partial x_1},\\frac{\\partial f}{\\partial x_2},\\cdots,\\frac{\\partial f}{\\partial x_n}\\right)\\bigg\\rvert_{P_0}$$ \b为 \\(f\\) 在 \\(P_0\\) 处的梯度，记作 \\({\\bf grad}f(P_0)\\) 。 沿梯度方向，函数值增加最快。同样可知，方向导数的最小值在梯度的相反方向取得。 if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"基础知识","url":"https://xutree.github.io/pages/2018/11/10/directional_derivative-gradient/"},{"title":"梯度下降法","text":"","tags":"\b基础知识","url":"https://xutree.github.io/pages/2018/11/10/gradient_descent/"},{"title":"拉格朗日对偶性","text":"1. 原始问题 假设 \\(f(x)\\) ， \\(c_i(x)\\) ， \\(h_j(x)\\) 是定义在 \\(\\mathbb{R}&#94;n\\) 上的连续可微函数。考虑约束最优化问题： $$\\min_{x\\in\\mathbb{R}&#94;n}f(x) \\\\ \\text{s.t.}\\ \\ \\ \\ \\ \\begin{eqnarray} c_i(x) &\\leq& 0,i=1,2,\\cdots,k \\\\ h_j(x) &=& 0,j=1,2,\\cdots,l \\end{eqnarray}$$ 称此优化约束问题为\b原始最优化问题或原始问题。 首先，引进广义拉格朗日函数： $$L(x,\\alpha,\\beta)=f(x)+\\sum_{i=1}&#94;k\\alpha_ic_i(x)+\\sum_{j=1}&#94;l\\beta_jh_j(x)$$ 这里， \\(x=\\left(x&#94;{(1)},x&#94;{(2)},\\cdots,x&#94;{(n)}\\right)&#94;\\text{T}\\in\\mathbb{R}&#94;n\\) ， \\(\\alpha_i\\) ， \\(\\beta_j\\) 是拉格朗日乘子， \\(\\alpha_i\\geq0\\) ，考虑 \\(x\\) 的函数： $$\\theta_P(x)=\\max_{\\alpha,\\beta:\\alpha\\geq0}L(x,\\alpha,\\beta)$$ 这里，下标 \\(P\\) 表示原始问题。 易知： $$\\theta_P(x)=\\begin{cases} f(x), & x\\ 满足原始问题约束 \\\\ +\\infty, & 其他 \\end{cases}$$ 所以如果考虑极小化问题 $$\\min_x\\theta_P(x)=\\min_x\\max_{\\alpha,\\beta:\\alpha_i\\geq0}L(x,\\alpha,\\beta)$$ 它是与原始最优化问题等价的问题。 为了方便，定义原始问题的最优值 $$p&#94;{\\star}=\\min_x\\theta_P(x)$$ 称为原始问题的值。 2. 对偶问题 定义 $$\\theta_D(\\alpha,\\beta)=\\min_xL(x,\\alpha,\\beta)$$ 再考虑极大化，即 $$\\max_{\\alpha,\\beta:\\alpha_i\\geq0}\\theta_D(\\alpha,\\beta)=\\max_{\\alpha,\\beta:\\alpha_i\\geq0}\\min_xL(x,\\alpha,\\beta)$$ 上述问题称为广义拉格朗日函数的极大极小问题。 可以将广义拉格朗日函数的极大极小问题表示为\b约束最优化问题： $$\\max_{\\alpha,\\beta}\\theta_D(\\alpha,\\beta)=\\max_{\\alpha,\\beta}\\min_xL(x,\\alpha,\\beta) \\\\ \\text{s.t.}\\ \\ \\ \\alpha_i\\geq0,i=1,2,\\cdots,k$$ 称为原始问题的对偶问题。定义对偶问题的最优值： $$d&#94;\\star=\\max_{\\alpha,\\beta:\\alpha_i\\geq0}\\theta_D(\\alpha,\\beta)$$ 称为对偶问题的值。 3. 原始问题和对偶问题的关系 定理 1 若原始问题和对偶问题都有最优值，则 $$d&#94;\\star=\\max_{\\alpha,\\beta:\\alpha_i\\geq0}\\min_xL(x,\\alpha,\\beta)\\leq\\min_x\\max_{\\alpha,\\beta:\\alpha_i\\geq0}L(x,\\alpha,\\beta)=p&#94;\\star$$ 推论 1 设 \\(x&#94;\\star\\) 是原始问题的可行解， \\(\\alpha&#94;\\star\\) ， \\(\\beta&#94;\\star\\) 是对偶问题的可行解，并且 \\(d&#94;\\star=p&#94;\\star\\) ，则它们分别是原始问题和对偶问题的最优解。 \b 定理 2 考虑原始问题和对偶问题。\b假设函数 \\(f(x)\\) 和 \\(c_i(x)\\) 是凸函数， \\(h_j(x)\\) 是仿射函数；并且假设不等式约束 \\(c_i(x)\\) 是严格可行的，即存在 \\(x\\) ，对所有 \\(i\\) ，有 \\(c_i<0\\) ，则存在 \\(x&#94;\\star\\) ， \\(\\alpha&#94;\\star\\) ， \\(\\beta&#94;\\star\\) ，使 \\(x&#94;\\star\\) 是原始问题的解， \\(\\alpha&#94;\\star\\) ， \\(\\beta&#94;\\star\\) 是对偶问题的解，并且 $$p&#94;\\star=d&#94;\\star=L(x&#94;\\star,\\alpha&#94;\\star,\\beta&#94;\\star)$$ 定理 3 对原始问题和对偶问题，假设函数 \\(f(x)\\) 和 \\(c_i(x)\\) 是凸函数， \\(h_j(x)\\) 是仿射函数，并且假设不等式约束 \\(c_i(x)\\) 是严格可行的，则 \\(x&#94;\\star\\) ， \\(\\alpha&#94;\\star\\) ， \\(\\beta&#94;\\star\\) 分别是原始问题和对偶问题的解的充要条件是 \\(x&#94;\\star\\) ， \\(\\alpha&#94;\\star\\) ， \\(\\beta&#94;\\star\\) 满足下面的 Karush-Kuhn-Tucker（KKT）条件 $$\\nabla_xL(x&#94;\\star,\\alpha&#94;\\star,\\beta&#94;\\star)=0 \\\\ \\alpha_i&#94;\\star c_i(x&#94;\\star)=0,i=1,2,\\cdots,k \\\\ c_i(x&#94;\\star)\\leq0,i=1,2,\\cdots,k \\\\ \\alpha_i&#94;\\star\\geq0,i=1,2,\\cdots,k \\\\ h_j(x&#94;\\star)=0,j=1,2,\\cdots,l$$ if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"基础知\b识","url":"https://xutree.github.io/pages/2018/11/10/lagrange_duality/"},{"title":"统计学习方法 第六章 逻辑回归与最大熵模型","text":"逻辑回归（logistic regression）是统计学习中的经典分类方法。最大熵是概率模型学习的一个准则，将其推广到分类问题得到最大熵模型（maximum entropy model）。 逻辑回归模型和最大熵模型都属于对数线性模型。 6.1 逻辑回归模型 6.1.1 逻辑分布 定义 6.1（逻辑分布）设 \\(X\\) 是连续随机变量， \\(X\\) 服从\b逻辑分布是指 \\(X\\) 具有下列分布函数和密度函数： $$\\begin{eqnarray} F(x) &=& P(X\\leq x)=\\frac{1}{1+\\text{e}&#94;{-(x-\\mu)/\\gamma}} \\\\ f(x) &=& F'(x)=\\frac{\\text{e}&#94;{-(x-\\mu)/\\gamma}}{\\gamma(1+\\text{e}&#94;{-(x-\\mu)/\\gamma})&#94;2} \\end{eqnarray}$$ 式中， \\(\\mu\\) 为位置参数， \\(\\gamma>0\\) 为形状参数。 下图中绘制了对于不用 \\(\\gamma\\) 逻辑分布函数和概率密度函数。分布函数是一条 S 形曲线（sigmoid curve）。该曲线以点 \\(\\left(\\mu,\\frac{1}{2}\\right)\\) 为中心对称，即满足 $$F(-x+\\mu)+F(x+\\mu)=1$$ 曲线在中心附近增长速度较快，在两端增长速度较慢。\b 6.1.2 二项逻辑回归模型 二项逻辑回归模型（binomial logistic regression model）是一种\b分类模型，由条件概率 \\(P(Y|X)\\) 表示，形式为参数化的逻辑分布。这里，随机变量 \\(X\\) 取值为实数，随机变量 \\(Y\\) 取值为 1 或 0，我们通过监督学习的方法来估计模型参数。 定义 6.2 （逻辑回归模型）二项逻辑回归模型是如下的条件概率分布： $$\\begin{eqnarray} P(Y=1|x) &=& \\frac{\\exp(w\\cdot x+b)}{1+\\exp(w\\cdot x+b)} \\\\ P(Y=0|x) &=& \\frac{1}{1+\\exp(w\\cdot x+b)} \\end{eqnarray}$$ 这里， \\(x\\in\\mathbb{R}&#94;n\\) 是输入， \\(Y\\in\\{0,1\\}\\) 是输出， \\(w\\in\\mathbb{R}&#94;n\\) 和 \\(b\\in\\mathbb{R}\\) 是参数（分别称为权重向量和偏置）， \\(w\\cdot x\\) 是内积。 对于\b给定的输入实例 \\(x\\) ，按照定义 6.2 可以求得 \\(P(Y=1|x)\\) 和 \\(P(Y=0|x)\\) 。逻辑回归比较两个概率值的大小，将实例 \\(x\\) 分到概率值较大的那一类。 有时为了方便，将权重向量和输入向量加以扩充，即 $$w=\\left(w&#94;{(1)},w&#94;{(2)},\\cdots,w&#94;{(n)},1\\right)&#94;\\text{T}\\\\ x=\\left(x&#94;{(1)},x&#94;{(2)},\\cdots,x&#94;{(n)},1\\right)&#94;\\text{T}$$ 这时，逻辑回归模型如下： $$\\begin{eqnarray} P(Y=1|x) &=& \\frac{\\exp(w\\cdot x)}{1+\\exp(w\\cdot x)} \\\\ P(Y=0|x) &=& \\frac{1}{1+\\exp(w\\cdot x)} \\end{eqnarray}$$ 一个事件的几率（odds）是指该事件发生的概率与该事件不发生的概率的比值，该事件的对数几率（log odds）或 logit 函数是 $$\\text{logit}(p)=\\log\\frac{p}{1-p}$$ 对逻辑回归而言，由扩充后的回归模型得 $$\\text{logit}\\left(P(Y=1|x)\\right)=\\log\\frac{P(Y=1|x)}{1-P(Y=1|x)}=w\\cdot x$$ 也就是说，输出 \\(Y=1\\) 的对数几率是输入 \\(x\\) 的线性函数，或者说，输出 \\(Y=1\\) 的对数几率是由输入 \\(x\\) 的线性函数表示的模型，即逻辑回归模型。 换一个角度看，考虑对输入 \\(x\\) 进行分类的线性函数 \\(w\\cdot x\\) （扩充后的），其值域为实数域。通过逻辑回归模型定义式可以将线性函数 \\(w\\cdot x\\) 转换为概率 $$P(Y=1|x)=\\frac{\\exp(w\\cdot x)}{1+\\exp(w\\cdot x)}$$ 上面的分布实际上是逻辑分布。这是，线性函数的值越接近 \\(+\\infty\\) ，概率值就越接近 1；线性函数的值越接近\b \\(-\\infty\\) ，概率在就越接近 0。这样的模型就是逻辑回归模型。 6.1.3 模型参数估计 逻辑回归模型学习时，对于给定的训练数据集 $$T=\\{(x_1,y_1),(x_2,y_2),\\cdots,(x_N,y_N)\\}$$ 其中 \\(x_i\\in\\mathbb{R}&#94;n\\) ， \\(y_i\\in\\{0,1\\}\\) ，可以应用极大似然估计法估计模型参数，从而得到逻辑回归模型。 设 $$P(Y=1|x) = \\pi(x) \\\\ P(Y=0|x) = 1-\\pi(x)$$ 似然函数为 $$\\prod_{i=1}&#94;N\\left[\\pi(x_i)\\right]&#94;{y_i}\\left[1-\\pi(x_i)\\right]&#94;{1-y_i}$$ 对数似然函数为 $$\\begin{eqnarray} L(w) &=& \\sum_{i=1}&#94;N\\left[y_i\\log\\pi(x_i)+(1-y_i)\\log(1-\\pi(x_i))\\right] \\\\ &=& \\sum_{i=1}&#94;N\\left[y_i\\log\\frac{\\pi(x_i)}{1-\\pi(x_i)}+\\log(1-\\pi(x_i))\\right] \\\\ &=& \\sum_{i=1}&#94;N[y_i(w\\cdot x_i)-\\log(1+\\exp(w\\cdot x_i))] \\end{eqnarray}$$ 对 \\(L(w)\\) 求极大值，得到 \\(w\\) 的估计值。 这样，问题就变成以对数似然函数为目标函数的最优化问题。逻辑回归\b学习中通常采用的方法是梯度下降法和拟牛顿法。 假设 \\(w\\) 的极大似然估计值是 \\(\\hat{w}\\) ，那么学到的逻辑回归模型为 $$P(Y=1|x)=\\frac{\\exp(\\hat{w}\\cdot x)}{1+\\exp(\\hat{w}\\cdot x)} \\\\ P(Y=0|x)=\\frac{1}{1+\\exp(\\hat{w}\\cdot x)}$$ 6.1.4 多项逻辑回归 可以将二项回归模型推广到多项逻辑回归模型（multi-nominal logistic regression \bmodel），用于多类分类。 假设离散型随机变量 \\(Y\\) 的取值集合是 \\(\\{1,2,\\cdots,K\\}\\) ，那么多项逻辑回归模型是 $$P(Y=k|x)=\\frac{\\exp(w_k\\cdot x)}{1+\\sum_{k=1}&#94;{K-1}\\exp(w_k\\cdot x)},k=1,2,\\cdots,K-1 \\\\ P(Y=K|x)=\\frac{1}{1+\\sum_{k=1}&#94;{K-1}\\exp(w_k\\cdot x)}$$ 这里， \\(x\\in\\mathbb{R}&#94;{n+1}\\) ， \\(w_k\\in\\mathbb{R}&#94;{n+1}\\) 二项逻辑回归的参数估计法也可以推广到多项逻\b辑回归。 6.2 最大熵模型 最大熵模型（maximum entropy model）由最大熵原理推导实现。 6.2.1 最大熵原理 最大熵原理是概率模型学习的一个准则。最大熵原理认为：学习概率模型时，在所\b有可能的概率模型（分布）中，熵最大的模型时最好的模型。 通常用约束条件来确定概率模型的集合，所以，最大熵原理也可以表述为在\b满足约束条件的模型集合中选取熵最大的模型。 假设离散随机变量 \\(X\\) 的\b概率分布是 \\(P(X)\\) ，则其熵是 $$H(P)=-\\sum_xP(x)\\log P(x)$$ 熵满足下列不等式 $$0\\leq H(P)\\leq\\log |X|$$ 式中， \\(|X|\\) 是 \\(X\\) 取值个数，当且仅当 \\(X\\) 的分布是均匀分布时右边的等号成立。也就是说，当 \\(X\\) 服从均匀分布时，熵最大。 6.2.2 最大熵模型的定义 最大熵原理是统计学习的一般原理，将它应用到分类得到最大熵模型。 if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"读书笔记","url":"https://xutree.github.io/pages/2018/11/09/6/"},{"title":"统计学习方法 第五章 决策树","text":"决策树（decision tree）是一种基本的分类与回归方法。其主要优点是模型具有可读性，\b分类速度快。决策树学习通常包括三个步骤：特征选择、决策树的生成和决策树的修剪。 5.1 决策树模型与学习 5.1.1 决策树模型 定义 5.1 （决策树）分类决策树模型是一种描述对实例进行分类的树形结构。决策树由节点（node）和有向边（directed edge）组成。节点有两种类型：内部节点（internal node）和叶节点（leaf node）。内部节点表示一个特征或属性，叶节点表示一个类。 5.1.2 决策树学习 假设给定训练数据集 $$T=\\{(x_1,y_1),(x_2,y_2),\\cdots,(x_N,y_N)\\}$$ 其中输入实例（向量）为 $$x_i=\\left(x_i&#94;{(1)},x_i&#94;{(2)},\\cdots,x_i&#94;{(n)},\\right)$$ \\(n\\) 为特征个数。类标记为 $$y_i\\in\\{c_1,c_2,\\cdots,c_K\\}$$ 其中 \\(i\\in\\{1,2,\\cdots,N\\}\\) ， \\(N\\) 为样本容量。 学习的目的是根据给定的训练数据集构建一个决策树模型，使它能够对实例进行正确的分类。 决策树\b学习本质上是从训练数据集中归纳出一组分类\b规则。与训练集不相矛盾的决策树可能有多个也可能一个也没有，我们需要的是一个与训练集矛盾较小的决策树，同时具有很好的泛化能力。 决策树学习的损失函数通常是正则化的极大似然函数。决策树学习的策略是以损失函数为目标函数的最小化。 当损失函数确定以后，学习问题变成在损失函数意义下选择最有决策树的问题，因为从所有可能的决策树中选取最优决策树是 NP 完全问题，所以现实中决策树学习算法通常采用启发式方法，近似求解这一最优化问题。这样得到的决策树\b是次最优（sub-optimal）的。 5.2 特征选择 5.2.1 特征选择的问题 特征选择在于选取对训练数据具有分类能力的特征。这样就可以提高决策树学习的效率。如果利用一个特征进行分类的结果与随机分类的结果没有很大差别，则称这个特征是\b没有分类能力的。通常特征选取的准则是信息增益或信息增益比。 5.2.2 信息\b增益 \b为了便于说明，首先给出熵与条件熵的定义。 熵（entropy）是表示随机变量不确定性的度量。 设 \\(X\\) 是一个离散随机变量，其概率分布为 $$P(X=x_i)=p_i,i=1,2,\\cdots,n$$ 则，随机变\b量 \\(X\\) 的熵定义为 $$H(X)=-\\sum_{i=1}&#94;np_i\\log p_i$$ 若 \\(p_i=0\\) ，定义 \\(0\\log0=0\\) 。通常，上式中对数的底为 2 或自然对数 e，这是熵的单位分别为比特（bit）或纳特（nat）。 设有随机变量 \\((X,Y)\\) ，其联合概率分布为 $$P(X=x_i,Y=y_j)=p_{ij},i=1,2,\\cdots,n;j=1,2,\\cdots,m$$ 条件熵（conditional entropy） \\(H(Y|X)\\) \b\b表示在已知随机变量 \\(X\\) 的条件下随机变量 \\(Y\\) 的不确定性，定义为 \\(X\\) 给定条件下 \\(Y\\) 的条件概率分布的熵对 \\(X\\) 的数学期望 $$H(Y|X)=\\sum_{i=1}&#94;np_iH(Y|X=x_i)$$ 这里 \\(p_i=P(X=x_i),i=1,2,\\cdots,n\\) 当熵和条件熵中的概率由数据估计（特别是极大似然估计）得到时，所对应的熵和条件熵分别称为经验熵（empirical entropy）和经验条件熵（empirical conditional \bentropy）。 信息增益（\binformation gain）表示得知特征 \\(X\\) 的信息而使类 \\(Y\\) 的信息的不确定度减少的程度。 定义 5.2 （信息增益）特征 \\(A\\) 对训练数据集 \\(D\\) 的信息增益 \\(g(D,A)\\) ，定义为集合 \\(D\\) 的经验熵 \\(H(D)\\) 与特征 \\(A\\) 给定条件下 \\(D\\) 的\b经验条件熵 \\(H(D|A）\\) 只差 $$g(D,A)=H(D)-H(D|A)$$ 一般的，熵与条件熵只差称为互信息（mutual information）。决策树\b学习中的信息增益等价于训练数据集中类和特征的互信息。 根据信息增益准则的特征选择方法是：对训练数据集（或子集） \\(D\\) ，计算其每个特征的信息增益，选择信息增益最大的特征。 设训练数据集为 \\(D\\) ， \\(|D|\\) 表示其样本容量。设有 \\(K\\) 个类 \\(C_k\\) ， \\(k=1,2\\cdots,K\\) ， \\(|C_k|\\) 为属于类 \\(C_k\\) 的样本个数。设特征 \\(A\\) 有 \\(n\\) 个不同的取值 ，根据特征 \\(A\\) 的取值将 \\(D\\) 划分为 \\(n\\) 个子集， \\(|D_i|\\) 为 \\(D_i\\) 的样本个数。记子集 \\(D_i\\) 中属于类 \\(C_k\\) 的样本的集合为 \\(D_{ik}\\) ， \\(|D_{ik}|\\) 为 \\(D_{ik}\\) 的样本个数，于是信息增益的算法如下 算法 5.1 （信息增益的\b算法） 输入：训练数据集 \\(D\\) 和特征 \\(A\\) 输出：特征 \\(A\\) 对训练数据集 \\(D\\) 的信息增益 \\(g(D,A)\\) (1) 计算数据集 \\(D\\) 的经验熵 \\(H(D)\\) $$H(D)=-\\sum_{k=1}&#94;K\\frac{|C_k|}{|D|}\\log_2\\frac{|C_k|}{|D|}$$ (2) 计算特征 \\(A\\) 对数据集 \\(D\\) 的经验条件熵 \\(H(D|A)\\) $$H(D|A)=\\sum_{i=1}&#94;n\\frac{|D_i|}{|D|}H(D_i)=-\\sum_{i=1}&#94;n\\frac{|D_i|}{|D|}\\sum_{k=1}&#94;K\\frac{|D_{ik}|}{|D_i|}\\log_2\\frac{|D_{ik}|}{|D_i|}$$ (3) 计算信息增益 $$g(D,A)=H(D)-H(D|A)$$ 5.2.3 信息增益比 以信息增益作为划分训练集的特征，存在偏向于选择取值较多的特征的问题。使用信息增益比（information gain ratio）可以对这一问题进行校正。这是特征选择的\b另一准则。 首先说明下为何信息增益会偏向选择取值较多的特性：假设特征 \\(A\\) 有 \\(N\\) 个不同取值（意味着每一个样本的\b特征 \\(A\\) 都有一个不同的值），则易知 \\(H(D|A)=0\\) ，故一定会选取这个特性\b，但是这个特性（例如仅仅是不同训练数据的标号）可能对分类无用。 定义 5.3 （信息增益比）特征 \\(A\\) 对训练数据集 \\(D\\) 的信息增益比 \\(g_R(D,A)\\) 定义为其信息增益 \\(\bg(D,A)\\) 与训练数据集 \\(D\\) 关于特征 \\(A\\) 的值的熵 \\(H_A(D)\\) 之比 $$g_R(D,A)=\\frac{g(D,A)}{H_A{(D)}}$$ 其中 $$H_A(D)=-\\sum_{i=1}&#94;n\\frac{|D_i|}{|D|}\\log_2\\frac{|D_i|}{|D|}$$ \\(n\\) 是特征 \\(A\\) 取值的个数。 5.3 决策树的生成 5.3.1 ID3 \b算法 ID3 算法的核心是在决策树各个节点上应用信息增益准则选择特征，递归的构建\b决策树，直到所有特征的信息增益均很小或\b没有特征可以选择为止。 算法 5.2 （ID3 算法） 输入：训练数据集 \\(D\\) ，特征集 \\(A\\) ，阈值 \\(\\epsilon\\) 输出：决策树 \\(T\\) (1) 若 \\(D\\) 中所有实例属于同一类 \\(C_k\\) ，则 \\(T\\) 为单节点树，并将类 \\(C_k\\) 作为该节点的类标记，返回 \\(T\\) (2) 若 \\(A=\\varnothing\\) ，则 \\(T\\) 为单节点树，并将 \\(\bD\\) 中实例数最大的类 \\(C_k\\) 作为该节点的类标记，返回 \\(T\\) (3) 否则，按算法 5.1 计算 \\(A\\) 中哥特征对 \\(D\\) 的信息增益，选择信息增益最大的特征 \\(A_g\\) (4) 如果 \\(A_g\\) 的信息增益小于阈值 \\(\\epsilon\\) ，则置 \\(T\\) 为单节点树，并将 \\(D\\) 中实例数最大的类 \\(C_k\\) 作为该节点的类标记，返回 \\(T\\) (5) 否则，对 \\(A_g\\) 的每一个可能值 \\(a_i\\) ，依 \\(A_g=a_i\\) 将 \\(D\\) 分割为若干非空子集 \\(D_i\\) ，将 \\(D_i\\) 中实例数最大的类作为标记，构建子节点，由节点及其子节点构成数 \\(T\\) ，返回 \\(T\\) (6) 对第 \\(i\\) 个子节点，以 \\(D_i\\) 为训练集，以 \\(A-\\{A_g\\}\\) 为特征集递归的调用步骤 (1)~(5)，得到子树 \\(T_i\\) ，返回 \\(T_i\\) ID3 算法只有树的生成。所以该算法生成的树容易产生过拟合。 5.3.2 C4.5 的生成算法 C4.5 算法与 ID3 算法相似，C4.5 算法对 ID3 算法进行了改进，用信息增益比选择特征。其他步骤相同。 5.4 决策树的剪枝 决策树生成算法递归的产生决策树，直到不能继续下去为止。这样产生的树往往对训练数据的分类很准确，但对未知的测试数据的分类却没有那么准确，即出现过拟合现象。 过拟合产生的\b\b原因是学习时过多的考虑如何提高对训练数据的正确分类，从而构建出过于复杂的决策树。 解决这个问题的办法是\b对\b已生成的决策树进行简化——剪枝（pruning）。也就是从生成的决策树上剪掉一些子树或者叶节点。 决策树的剪枝往往通过极小化决策树整体的损失函数或代价函数来实现。 设树 \\(T\\) 的叶节点个数为 \\(|T|\\) ， \\(t\\) 是树 \\(T\\) 的叶节点，该叶节点有 \\(N_t\\) 个样本点，其中 \\(k\\) 类的样本点有 \\(N_{tk}\\) 个， \\(k=1,2,\\cdots,K\\) ， \\(H_t(T)\\) 为叶节点 \\(t\\) 上的经验熵， \\(\\alpha\\geq0\\) 为参数，则决策树学习的损失函数可以定义为 $$C_{\\alpha}(T)=\\sum_{t=1}&#94;{|T|}N_tH_t(T)+\\alpha|T|$$ 其中经验熵为 $$H_t(T)=-\\sum_{k=1}&#94;K\\frac{N_{tk}}{N_t}\\log\\frac{N_{tk}}{N_t}$$ 令 $$C(T)=\\sum_{t=1}&#94;{|T|}N_tH_t(T)=-\\sum_{t=1}&#94;{|T|}\\sum_{k=1}&#94;KN_{tk}\\log\\frac{N_{tk}}{N_t}$$ 则 $$C_\\alpha(T)=C(T)+\\alpha|T|$$ 上式中， \\(C(T)\\) 表示模型对训练数据的预测误差， \\(|T|\\) 表示模型复杂度，参数 \\(\\alpha\\geq0\\) 控制两者之间的影响。 剪枝，就是当 \\(\\alpha\\) 确定时，选择损失函数最小的模型。 决策树生成学习局部的模型，而决策树剪枝学习整体的模型。 上式中定义的损失函数的极小化等价于正则化的极大似然估计。所以，利用损失函数最小原则进行剪枝就是用正则化的最大似然估计进行模型选择。 算法 5.4 （树的剪枝算法） 输入：生成算法产生的整个树 \\(T\\) ，参数 \\(\\alpha\\) 输出：修剪后的子树 \\(T_\\alpha\\) (1) 计算每个节点的经验熵 (2) 递归的从树的叶节点向上回缩：设一组叶节点回缩到其父节点之前与之后的整体树分别为 \\(T_B\\) 和 \\(T_A\\) ，其对应的损失函数分别是 \\(C_\\alpha(T_B)\\) 和 \\(C_\\alpha(T_A)\\) ，如果 $$C_\\alpha(T_A)\\leq C_\\alpha(T_B)$$ 则进行剪枝，即将父节点变为新的叶节点 (3) 返回 (2)，直至不能继续为止，得到损失函数最小的子树 \\(T_\\alpha\\) 因为步骤 (2) 中只考虑两个树的损失函数的差，其计算可以在局部进行，所以可以用动态规划算法实现。 5.5 CRAT 算法 分类与回归树（classification and regression tree）模型是应用广泛的决策树学习方法，既可以用于分类也可以用于回归。 CART 是在给定输入随机变量 \\(X\\) 条件下输出随机变量 \\(Y\\) 的条件概率分布的\b学习方法。CART 假设决策树是二叉树，内部\b节点特征的取值为\"是\"和\"否\"。左分的取值是\"是\"，右分支的取值是\"否\"。 CRAT 算法由以下两步组成： 决策树生成：基于训练数据集生成决策树，生成的决策树要\b尽量大 决策树剪枝：用验证数据集\b对已生成的树进行剪枝并选择最优子树，这时用损失函数最小作为剪枝的标准 5.5.1 CART 生成 决策树的生成就是递归的构建二叉决策树的过程，对回归树用平方误差最小化准则，对分类树用基尼指数（Gini index）最小化准则，进行特征选择，生成二叉树。 回归树的生成 假设 \\(X\\) 和 \\(Y\\) 分别为输入和输出变量，并且 \\(Y\\) 是连续变量，给定训练数据集 $$D=\\{(x_1,y_1),(x_2,y_2),\\cdots,(x_N,y_N)\\}$$ 一个回归树对应着输入空间（特征空间）的一个划分以及在划分的单元上的输出值。假设已经将输入空间划分为 \\(M\\) 个单元 \\(R_1,R_2,\\cdots,R_M\\) ，并且每个单元 \\(R_m\\) 上有一个固定的输出值 \\(c_m\\) ，于是，回归树模型可表示为 $$f(x)=\\sum_{m=1}&#94;Mc_m\\mathbb{I}(x\\in R_m)$$ 当输入空间的划分确定时，可以用平方误差 $$\\sum_{x_i\\in R_m}\\left(y_i-f(x_i)\\right)&#94;2$$ 来表示回归树对于训练数据集的预测误差，用平方误差最下的准则求解每个单元上的\b最优输出值。 易知，单元 \\(R_m\\) 上的 \\(c_m\\) 的最优值 \\(\\hat{c}_m\\) 是 \\(R_m\\) 上所有输入实例 \\(x_i\\) 对于的输出 \\(y_i\\) 的均值，即 $$\\hat{c}_m=\\text{ave}(y_i|x_i\\in R_m)$$ 问题是怎么对输入空间进行划分。 这里采用启发式的方法，选择第 \\(j\\) 个特征 \\(x&#94;{(i)}\\) 和它的取值 \\(s\\) ，作为切分变量（splitting variable）和切分点（splitting point），并定义两个区域 $$\\begin{eqnarray} R_1(j,s) &=& \\{x|x&#94;{(j)}\\leq s\\} \\\\ R_2(j,s) &=& \\{x|x&#94;{(j)}>s\\} \\end{eqnarray}$$ 然后对于固定的 \\(j\\) 可以找到最优\b切分的 \\(s\\) ，具体的，求解 $$\\min_{j,s}\\left[\\min_{c_1}\\sum_{x_i\\in R_1(j,s)}(y_i-c_1)&#94;2+\\min_{c_2}\\sum_{x_i\\in R_2(j,s)}(y_i-c_2)&#94;2\\right]$$ 历遍所有输入变量，找到最优的切分变量 \\(j\\) ，构成一个对 \\((j,s)\\) 。依次将输入空间划分为两个区域。接着，对每个区域重复上述划分过程，直到满足停止条件为止。这种方法生成的回归树通常称为最小二乘回归树（least squares regression tree）。 算法 5.5 （最小二乘回归树生成算法） 输入：训练数据集 \\(D\\) 输出：回归树 \\(f(x)\\) 在训练数据集所在的输入空间中，递归的将每个区域划分为两个子区域并决定每个子区域的输出值，构建二叉决策树 (1) 选择最优切分变量 \\(j\\) 和切分点 \\(s\\) ，求解 $$\\min_{j,s}\\left[\\min_{c_1}\\sum_{x_i\\in R_1(j,s)}(y_i-c_1)&#94;2+\\min_{c_2}\\sum_{x_i\\in R_2(j,s)}(y_i-c_2)&#94;2\\right]$$ 遍历 \\(j\\) ，对固定的切分变量 \\(j\\) 扫描切分点 \\(s\\) ，选择使上式最小的对 \\((j,s)\\) (2) 用选定的对 \\((j,s)\\) 划分区域并决定相应的输出值 $$\\begin{eqnarray} R_1(j,s) &=& \\{x|x&#94;{(j)}\\leq s\\} \\\\ R_2(j,s) &=& \\{x|x&#94;{(j)}>s\\} \\end{eqnarray}\\\\ \\hat{c}_m=\\frac{1}{N_m}\\sum_{x_i\\in R_m(j,s)}y_i,x\\in R_m,m=1,2$$ (3) 继续对两个子区域调用步骤 (1)，(2)，直到满足停止条件 (4) 将输入空间划分为 \\(M\\) 个区域 \\(R_1,R_2,\\cdots,R_M\\) ，生成决策树 $$f(x)=\\sum_{m=1}&#94;M\\hat{c}_m\\mathbb{I}(x\\in R_m)$$ 分类树的生成 分类树用基尼指数选择最优特征，同时决定该特征的最优二值切分点。 定义 5.4 （基尼指数）分类问题中，假设有 \\(K\\) 个类，样本点属于第 \\(k\\) 类的概率为 \\(p_k\\) ，则概率分布的基尼指数定义为 $$\\text{Gini}(p)=\\sum_{k=1}&#94;Kp_k(1-p_k)=1-\\sum_{k=1}&#94;Kp_k&#94;2$$ 对于二分类问题，若样本点属于第一个类的概率是 \\(p\\) ，则概率分布的基尼指数为 $$\\text{Gini}(p)=2p(1-p)$$ 对于给定的样本集合 \\(D\\) ，其基尼指数为 $$\\text{Gini}(D)=1-\\sum_{k=1}&#94;K\\left(\\frac{|C_k|}{|D|}\\right)&#94;2$$ 这里， \\(C_k\\) 是属于第 \\(k\\) 类的样本子集， \\(K\\) 是类的个数。 如果样本集合 \\(D\\) 根据特征 \\(A\\) 是否取某一可能值 \\(a\\) 被分割成 \\(D_1\\) 和 \\(D_2\\) 两部分，\b即 \b $$D_1=\\{(x,y)\\in D|A(x)=a\\},D_2=D-D_1$$ 则在特征 A 的条件下，集合 D 的基尼指数定义为 $$\\text{Gini}(D,A)=\\frac{|D_1|}{|D|}\\text{Gini}(D_1)+\\frac{|D_2|}{|D|}\\text{Gini}(D_2)$$ 基尼指数 \\(\\text{Gini}(D)\\) 表示集合 \\(D\\) 的不确定性，基尼指数 \\(\\text{Gini}(D,A)\\) 表示经 \\(A=a\\) 分割后集合 \\(D\\) 的不确定性。基尼指数\b数值越大，样本集合的不确定性也就越大，这一点与熵类似。 \b 算法 5.6 （CART 生成算法） 输入：训练数据集 \\(D\\) ，停止计算的条件 输出：CART 决策树 根据训练数据集，从根节点开始，递归的对每\b个节点进行以下操作，构建二叉决策树： (1) 设节点的训练数据集为 \\(D\\) ，计算现有\b特征对该数据集的基尼指数。此时，对每一个特征 \\(A\\) ，对其可能取的每个值 \\(a\\) ，根据样本点对 \\(A=a\\) 的测试为\"是\"或\"否\"将 \\(D\\) 分割为两部分，计算 \\(A=a\\) 时的基尼指数 (2) 在所有\b可能的特征 \\(A\\) 以及它们所有可能的切分点 \\(a\\) 中，选择基尼指数最小的特征及其对应的切分点作为最优特征和最优切分点。依最优特征和最优切分点，从现节点生成两个子节点，将训练数据集依特征分配到两个子节点去 (3) 对两个子节点递归的调用 (1)、(2)，直至满足停止条件 (4) 生成 CART 决策树 算法停止的条件是节点中的样本个数少于预定阈值，或样本集的基尼指数小于预定阈值（样本基本属于同一类），或者没有更多特征。 5.5.2 CART 剪枝 CART 剪枝算法从\"完全生长\"的决策树的底端剪去一些子树，使决策树变小（模型变简单），从而能够对未知数据有更准确的预测。 CART 剪枝算法由两步组成： 从生成算法产生的\b决策树\b \\(T_0\\) 底部开始不断剪枝，直到 \\(T_0\\) 的根节点，行成一个子树序列 $$\\{T_0,T_1,\\cdots,T_n\\}$$ 通过交叉验证法在独立的验证数据集上对子树序列进行测试，从中选择最优子树 剪枝，形成一个子树序列 在剪枝过程中，计算子树的损失函数： $$C_\\alpha(T)=C(T)+\\alpha|T|$$ 其中， \\(T\\) 为任意子树， \\(C(T)\\) 为对训练数据的预测误差（如基尼指数）， \\(|T|\\) 为子树的叶节点个数， \\(\\alpha\\geq0\\) 为参数， \\(C_\\alpha(T)\\) 为参数是 \\(\\alpha\\) 时的子树 \\(T\\) 的整体损失。参数 \\(\\alpha\\) 权衡训练数据的拟合程度与模型的复杂度。 对固定的 \\(\\alpha\\) ，一定存在使损失函数 \\(C_\\alpha(T)\\) 最小的子树，将其表示为 \\(T_\\alpha\\) 。 \\(T_\\alpha\\) 在损失函数 \\(C_\\alpha(T)\\) 最小的意义下是最\b优的。容易验证这样的最优子树是唯一的。当 \\(\\alpha\\) 大的时候，最优子树 \\(T_\\alpha\\) 偏小；当 \\(\\alpha\\) 小的时候，最优子树 \\(T_\\alpha\\) 偏大。极端情况下，如果 \\(\\alpha=0\\) ，那么整体树是最优的。当 \\(\\alpha\\to+\\infty\\) 时，根节点组成的单节点树是最优的。 Breiman 等人证明：可以用递归的方法对树进行剪枝.将 \\(\\alpha\\) 从小增大： $$0=\\alpha_0<\\alpha_1<\\cdots<\\alpha_n<+\\infty$$ 产生一系列的区间： $$[\\alpha_i,\\alpha_{i+1}),i=0,1,\\cdots,n$$ 剪枝得到的子树序列对应着区间 \\(\\alpha\\in[\\alpha_i,\\alpha_{i+1}),i=0,1,\\cdots,n\\) 的最优子树序列： $$\\{T_0,T_1,\\cdots,T_n\\}$$ 序列中的子树是嵌套的。 具体的，从整体树 \\(T_0\\) 开始剪枝。对 \\(T_0\\) 的任意内部节点 \\(t\\) ，以 \\(t\\) 为单节点树的损失函数是 $$C_\\alpha(t)=C(t)+\\alpha$$ 以 \\(t\\) 为根节点的子树 \\(T_t\\) 的损失函数是 $$C_\\alpha(T_t)=C(T_t)+\\alpha|T_t|$$ 当 \\(\\alpha=0\\) 及 \\(\\alpha\\) 充分小时，有不等式 $$C_\\alpha(T_t)<C_\\alpha(t)$$ 当 \\(\\alpha\\) 增大时，在某一 \\(\\alpha\\) 有 $$C_\\alpha(T_t)=C_\\alpha(t)$$ 当 \\(\\alpha\\) 再增大时，有 $$C_\\alpha(T_t)>C_\\alpha(t)$$ 综上所述，只要 $$\\alpha=\\frac{C(t)-C(T_t)}{|T_t|-1}$$ 则 \\(T_t\\) 与 \\(t\\) 有相同的损失函数值，而 \\(t\\) 的节点少，对 \\(T_t\\) 进行剪枝。 所以，对 \\(T_0\\) 中每一内部节点 \\(t\\) ，计算 $$g(t)=\\frac{C(t)-C(T_t)}{|T_t|-1}$$ 它表示剪枝后整体损失函数减少的程度。在 \\(T_0\\) 中剪去 \\(g(t)\\) 最小的 \\(T_t\\) （这里我们是要得到一系列的 \\(\\alpha\\) 区间，所以是剪去最小的），将得到的子树作为 \\(T_1\\) ，同时将最小的 \\(g(t)\\) 设为 \\(\\alpha_1\\) 。 \\(T_1\\) 为区间 \\([\\alpha_1,\\alpha_2)\\) 的最优子树。 如此剪枝下去，直到得到根节点。在这一过程中，不断的增加 \\(\\alpha\\) 的值，产生新的区间。 在剪枝得到的子树序列中通过交叉验证选取最优子树 \\(T_\\alpha\\) 具体的，利用独立的\b验证数据集，测试子树序列中各棵子树的平方误差或基尼指数。平方误差或基尼指数小的决策树被认为是最优的决策树。 算法 5.7 （CART \b剪枝算法） 输入：CART 算法生成的决策树 \\(T_0\\) 输出：最优决策树 \\(T_\\alpha\\) (1) 设 \\(k=0,T=T_0\\) (2) 设 \\(\\alpha=+\\infty\\) (3) 自下而上的对各个内部节点 \\(t\\) 计算 \\(C(T_t)\\) ， \\(|T_t|\\) 以及 $$\\begin{eqnarray} g(t) &=& \\frac{C(t)-C(T_t)}{|T_t|-1} \\\\ \\alpha &=& \\min(\\alpha,g(t)) \\end{eqnarray}$$ 这里， \\(T_t\\) 表示以 \\(t\\) 为根节点的子树， \\(C(T_t)\\) 是对训练数据的预测误差， \\(|T_t|\\) 是 \\(T_t\\) 的叶节点个数 (4) 对 \\(g(t)=\\alpha\\) 的\b内部节点 \\(t\\) 进行剪枝，并对叶节点 \\(t\\) 以多数表决法决定其类，得到树 \\(T\\) (5) 设 \\(k=k+1.\\alpha_k=\\alpha,T_k=T\\) (6) 如果 \\(T_k\\) 不是由根节点及两个叶节点构成的树，则返回到步骤 (3)；否则，令 \\(T_k=T_n\\) (7) \b采用交叉验证法在\b子树序列 \\(T_0,T_1,\\cdots,T_n\\) 中选择最优子树 \\(T_\\alpha\\) if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"读书笔记","url":"https://xutree.github.io/pages/2018/11/07/5/"},{"title":"统计学习方法 第四章 朴素贝叶斯法","text":"朴素贝叶斯（naive Bayes）法是基于贝叶斯定理与特征条件独立假设的分类方法。朴素贝叶斯法实现简单，学习和预测效率都很高，是一种常用的方法。 4.1 朴素贝叶斯法的学习与分类 4.1.1 基本方法 设输入特征向量 $$x\\in{\\cal X}\\subseteq\\mathbb{R}&#94;n$$ 输出类标记 $$y\\in{\\cal Y}=\\{c_1,c_2,\\cdots,c_K\\}$$ \\(X\\) 是定义在输入空间 \\({\\cal X}\\) 上的随机变量， \\(Y\\) 是定义在输出空间 \\({\\cal Y}\\) 上的随机变量， \\(P(X,Y)\\) 是 \\(X\\) 和 \\(Y\\) 的联合概率分布。训练数据集 $$T=\\{(x_1,y_1),(x_2,y_2),\\cdots,(x_N,y_N)\\}$$ 由 \\(P(X,Y)\\) 独立同分布产生。 朴素贝叶斯法通过训练数据集学习联合概率分布 \\(P(X,Y)\\) 。具体地，学习以下先验概率分布及条件概率分布。先验概率分布 $$P(Y=c_k),k=1,2,\\cdots,K$$ 条件概率分布 $$P(X=x|Y=c_k)=P(X&#94;{(1)}=x&#94;{(1)},\\cdots,X&#94;{(n)}=x&#94;{(n)}|Y=c_k),k=1,2,\\cdots,K$$ 于是学习到联合概率分布 $$P(X,Y)=P(X=x|Y=c_k)P(Y=c_k)$$ 条件概率分布 \\(P(X=x|Y=c_k)\\) 由指数级数量的参数，其估计实际是不可行的。事实上，假设 \\(x&#94;{(i)}\\) 可取值有 \\(S_j\\) 个， \\(Y\\) 可取值有 \\(K\\) 个，那么参数个数为 \\(K\\prod_{j=1}&#94;nS_j\\) 。 朴素贝叶斯法对条件概率分布作了条件独立性的假设。这是一个较强的假设，朴素贝叶斯法也由此得名。具体的，条件独立性假设是 $$\\begin{eqnarray} P(X=x|Y=c_k) &=& P(X&#94;{(1)}=x&#94;{(1)},\\cdots,X&#94;{(n)}=x&#94;{(n)})|Y=c_k)\\\\ &=& \\prod_{j=1}&#94;nP(X&#94;{(j)}=x&#94;{(j)}|Y=c_k) \\end{eqnarray}$$ 朴素贝叶斯法实际上学习到生成数据的机制，所以属于生成模型。条件独立假设等于是说分类的特征在类确定的条件下都是条件独立的。这一假设使朴素贝叶斯法变得简单，但有时会牺牲一定的分类准确率。 利用朴素贝叶斯法对给定输入 \\(x\\) 分类是，将后验概率最大的类作为 \\(x\\) 的类输出，后验概率根据贝叶斯定理计算 $$P(Y=c_k|X=x)=\\frac{P(X=x|Y=c_k)P(Y=c_k)}{\\sum_kP(X=x|Y=c_k)P(Y=c_k)}$$ 利用条件独立假设 $$P(Y=c_k|X=x)=\\frac{P(Y=c_k)\\prod_jP(X&#94;{(j)}=x&#94;{(j)}|Y=c_k)}{\\sum_kP(Y=c_k)\\prod_jP(X&#94;{(j)}=x&#94;{(j)}|Y=c_k)}$$ 这是朴素贝叶斯法的基本公式，于是朴素贝叶斯分类器可表示为 $$y=f(x)=\\arg\\max_{c_k}\\frac{P(Y=c_k)\\prod_jP(X&#94;{(j)}=x&#94;{(j)}|Y=c_k)}{\\sum_kP(Y=c_k)\\prod_jP(X&#94;{(j)}=x&#94;{(j)}|Y=c_k)}$$ 注意到上式中分母对所有 \\(c_k\\) 都为 \\(P(X=x)\\) ，所以 $$y=f(x)=\\arg\\max_{c_k}P(Y=c_k)\\prod_jP(X&#94;{(j)}=x&#94;{(j)}|Y=c_k)$$ 4.1.2 后验概率最大化的含义 朴素贝叶斯法将实例分类到后验概率最大的类中，这等价于期望风险最小化。假设 0-1 损失函数 $$L(Y,f(X))=\\begin{cases}1,&Y\\neq f(X)\\\\0,& Y=f(X)\\end{cases}$$ 式中 \\(f(X)\\) 是分类决策函数。这时期望风险函数为 $$\\begin{eqnarray} R_\\text{exp}(f) &=& \\text{E}[L(Y,f(X))]=\\int_{{\\cal X}\\times{\\cal Y}}L(y,f(x))P(x,y)dxdy\\\\ &=& \\int_{\\cal X}\\int_{\\cal Y}L(y,f(x))P(y|x)P(x)dxdy\\\\ &=& \\int_{\\cal X} \\left[\\int_{\\cal Y}L(y,f(x))P(y|x)dy\\right] P(x)dx \\end{eqnarray}$$ 期望是对联合概率分布 \\(P(X,Y)\\) 取的。由此取条件期望 $$R_\\text{exp}(f)=\\text{E}_X\\sum_{k=1}&#94;K[L(c_k,f(X))]P(c_k|X)$$ 为了使期望风险最小化，只需对 \\(X=x\\) 逐个极小化，得 $$\\begin{eqnarray}f(x) &=& \\arg\\min_{y\\in{\\cal Y}}\\sum_{k=1}&#94;KL(c_k,y)P(c_k|X=x)\\\\&=&\\arg\\min_{y\\in\\cal Y}\\sum_{k=1}&#94;KP(y\\neq c_k|X=x)\\\\&=&\\arg\\min_{y\\in{\\cal Y}}(1-P(y=c_k|X=x))\\\\&=&\\arg\\max_{y\\in\\cal Y}P(y=c_k|X=x)\\end{eqnarray}$$ 这样一来，根据期望风险最小化准则就得到了后验概率最大化准则 $$f(x)=\\arg\\max_{c_k}P(c_k|X=x)$$ 即朴素贝叶斯法采用的原理。 4.2 朴素贝叶斯法的参数估计 4.2.1 极大似然估计 对于 $$y=f(x)=\\arg\\max_{c_k}P(Y=c_k)\\prod_jP(X&#94;{(j)}=x&#94;{(j)}|Y=c_k)$$ 朴素贝叶斯学习意味着估计 \\(P(Y=c_k)\\) 和 \\(P(X&#94;{(j)}=x&#94;{(j)}|Y=c_k)\\) 。可以应用极大似然估计法估计相应的概率。 先验概率 \\(P(Y=c_k)\\) 的极大似然估计是 $$P(Y=c_k)=\\frac{\\sum_{i=1}&#94;N\\mathbb{I}(y_i=c_k)}{N},k=1,2,\\cdots,K$$ 设第 \\(j\\) 个特征 \\(x&#94;{(j)}\\) 可能的取值集合为 \\(\\{a_{j1},a_{j2},\\cdots,a_{jS_j}\\}\\) ，条件概率的极大似然估计是 $$P(X&#94;{(j)}=a_{jl}|Y=c_k)=\\frac{\\sum_{i=1}&#94;N\\mathbb{I}(x_i&#94;{(j)}=a_{jl},y_i=c_k)}{\\sum_{i=1}&#94;N\\mathbb{I}(y_i=c_k)}\\\\ j=1,2,\\cdots,n; l=1,2,\\cdots,S_j; k=1,2,\\cdots,K$$ 4.2.2 学习与分类算法 算法 4.1 朴素贝叶斯法（naive Bayes algorithm）\b 输入： (a) 训练数据集 $$T=\\{(x_1,y_1),(x_2,y_2),\\cdots,(x_N,y_N)\\}$$ 其中 $$x_i=\\left(x_i&#94;{(1)},x_i&#94;{(2)},\\cdots,x_i&#94;{(n)}\\right)&#94;\\text{T}$$ \\(x_i&#94;{(j)}\\) 是第 \\(i\\) \b个样本的第 \\(j\\) 个特征，且 $$x_i&#94;{(j)}\\in\\{a_{j1},a_{j2},\\cdots,a_{jS_j}\\}$$ $$y_i\\in\\{c_1,c_2,\\cdots,c_K\\}$$ (b) 实例 \\(x\\) 输出：实例 \\(x\\) 的分类 (1) 计算先验概率及条件概率 $$\\begin{eqnarray} P(Y=c_k) &=& \\frac{\\sum_{i=1}&#94;N\\mathbb{I}(y_i=c_k)}{N} \\\\ P(X&#94;{(j)}=a_{jl}|Y=c_k) &=& \\frac{\\sum_{i=1}&#94;N\\mathbb{I}(x_i&#94;{(j)}=a_{jl},y_i=c_k)}{\\sum_{i=1}&#94;N\\mathbb{I}(y_i=c_k)} \\end{eqnarray}\\\\ j=1,2,\\cdots,n; l=1,2,\\cdots,S_j; k=1,2,\\cdots,K$$ (2) 对于给定的实例 \\(x=\\left(x&#94;{(1)},x&#94;{(2)},\\cdots,x&#94;{(n)}\\right)&#94;\\text{T}\\) ，计算 $$P(Y=c_k)\\prod_{j=1}P(X&#94;{(j)}=x&#94;{(j)}|Y=c_k),k=1,2,\\cdots,K$$ (3) 确定实例 \\(x\\) 的类 $$y=f(x)=\\arg\\max_{c_k}P(Y=c_k)\\prod_jP(X&#94;{(j)}=x&#94;{(j)}|Y=c_k)$$ 4.2.3 贝叶斯估计 用极大似然估计可能会出现所要估计的概率值为 0 的情况。这时会影响到后验概率的计算结果，使分类产生偏差。解决这一问题的方法是采用贝叶斯估计。 先验概率的贝叶斯估计是 $$P_\\lambda(Y=c_k)=\\frac{\\sum_{i=1}&#94;N\\mathbb{I}(y_i=c_k)+\\lambda}{N+K\\lambda},k=1,2,\\cdots,K$$ 条件概率的贝叶斯估计是 $$P_\\lambda(X&#94;{(j)}=a_{jl}|Y=c_k)=\\frac{\\sum_{i=1}&#94;N\\mathbb{I}(x_i&#94;{(j)}=a_{jl},y_i=c_k)+\\lambda}{\\sum_{i=1}&#94;N\\mathbb{I}(y_i=c_k)+S_j\\lambda}\\\\ j=1,2,\\cdots,n; l=1,2,\\cdots,S_j; k=1,2,\\cdots,K$$ 式中 \\(\\lambda\\geq0\\) ，等价于在随机变量各个取值的频数上赋予一个非负数。当 \\(\\lambda=0\\) 时，就是极大似然估计。常取 \\(\\lambda=1\\) ，这是称为拉普拉斯平滑（Laplace smoothing）。 显然 $$\\begin{eqnarray} P_\\lambda(X&#94;{(j)}=a_{jl}|Y=c_k) &\\geq& 0 \\\\ \\sum_{l=1}&#94;{S_j}P_\\lambda(X&#94;{(j)}=a_{jl}|Y=c_k) &=& 1 \\end{eqnarray}$$ 表明这的确是一种概率分布。 if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"读书笔记","url":"https://xutree.github.io/pages/2018/11/07/4/"},{"title":"贝叶斯定理","text":"贝叶斯定理是关于随机事件 \\(A\\) 和 \\(B\\) 的条件概率的一则定理。 $$P(A|B)=\\frac{P(A)\\times P(B|A)}{P(B)}$$ 其中 \\(P(A|B)\\) 是指在事件 \\(B\\) 发生的情况下事件 \\(A\\) 发生的概率。 在贝叶斯定理中，每个名词都有约定俗成的名称： \\(P(A|B)\\) 是已知 \\(B\\) 发生后 \\(A\\) 的条件概率，也由于得自 \\(B\\) 的取值而被称作 \\(A\\) 的后验概率 \\(P(A)\\) 是 \\(A\\) 的先验概率（或边缘概率），之所以称为\"先验\"是因为它不考虑任何 \\(B\\) 方面的因素 \\(P(B|A)\\) 是已知 \\(A\\) 发生后 \\(B\\) 的条件概率，也由于得自 \\(A\\) 的取值而被称作 \\(B\\) 的后验概率 \\(P(B)\\) 是 \\(B\\) 的先验概率或边缘概率 推导 根据条件概率的定义。在事件 \\(B\\) 发生的条件下事件A发生的概率是 $$P(A|B)={\\frac {P(A\\cap B)}{P(B)}}$$ 其中 \\(A\\) 与 \\(B\\) 的联合概率表示为 \\(P(A\\cap B)\\) 或者 \\(P(A,B)\\) 或者 \\(P(AB)\\) 。 同样地，在事件 \\(A\\) 发生的条件下事件 \\(B\\) 发生的概率 $$P(B|A)={\\frac {P(A\\cap B)}{P(A)}}$$ 整理与合并这两个方程式，我们可以得到 $$P(A|B)\\,P(B)=P(A\\cap B)=P(B|A)P(A)$$ 这个引理有时称作概率乘法规则。上式两边同除以 \\(P(B)\\) ，若 \\(P(B)\\) 是非零的，我们可以得到贝叶斯定理 $$P(A|B)=\\frac{P(B|A)P(A)}{P(B)}$$ 其他形式 $$P(A|B)={\\frac {P(B|A)\\,P(A)}{P(B|A)P(A)+P(B|A&#94;{C})P(A&#94;{C})}}$$ 其中 \\(A&#94;C\\) 是 \\(A\\) 的补集（即非 \\(A\\) ），因为 $$P(B)=P(A,B)+P(A&#94;{C},B)=P(B|A)P(A)+P(B|A&#94;{C})P(A&#94;{C})$$ 在更一般化的情况，假设 \\(A_i\\) 是事件集合里的部分集合，对于任意的 \\(A_i\\) ，贝叶斯定理可用下式表示 $$P(A_{i}|B)={\\frac {P(B|A_{i})\\,P(A_{i})}{\\sum_{j}P(B|A_{j})\\,P(A_{j})}}$$ if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"基础知识","url":"https://xutree.github.io/pages/2018/11/05/bayes/"},{"title":"统计学习方法 第三章 k 近邻法","text":"\\(k\\) 近邻法（ \\(k\\) -nearest neighbor， \\(k\\) -NN）是一种\b基本分类与回归方法。 \\(k\\) 近邻法的输入为实例的特征向量，输出为实例的类别，可以取多类。 \\(k\\) 近邻法假设给定一个训练集数据，其中的实例类别已定。分类时，对新的实例，根据其 \\(k\\) 个最近邻的训练实例的类别，通过多数表决等方式进行预测。因此， \\(k\\) 近邻法不具有显式的学习过程。 \\(k\\) 近邻法实际上利用训练数据集对特征向量空间进行划分，并\b作为其分类的模型。 \\(k\\) 值得选择、距离度量以及分类决策规则是 \\(k\\) 近邻法的三个基本要素。 3.1 \\(k\\) 近邻算法 算法 3.1 （ \\(k\\) 近邻法） 输入：训练数据集 $$T=\\{(x_1,y_1),(x_2,y_2),\\cdots,(x_N,y_N)\\}$$ 其中 $$x_i\\in{\\cal X}\\subseteq\\mathbb{R}&#94;n$$ 为实例的特征空间， $$y_i\\in{\\cal Y}=\\{c_1,c_2,\\cdots,c_K\\}$$ 为实例的类别； 实例特征向量 \\(x\\) 输出：实例 \\(x\\) 所属的类 \\(y\\) (1) 根据给定的距离度量，在训练集 \\(T\\) 中找出与 \\(x\\) 最邻近的 \\(k\\) 个点，涵盖这 \\(k\\) 个点的 \\(x\\) 的邻域记作 \\(N_k(x)\\) (2) 在 \\(N_k(x)\\) 中根据分类决策规则（如多数表决）决定 \b \\(x\\) 的类别 \\(y\\) $$y=\\arg\\max_{c_j}\\sum_{x_i\\in N_k(x)}\\mathbb{I}(y_i=c_j),i=1,2,\\cdots,N; j=1,2,\\cdots,K$$ 式中， \\(\\mathbb{I}\\) \b 为指示函数 \\(k\\) 近邻法的特殊情况是 \\(k=1\\) \b 的情形，称为最近邻算法。对于输入的实例点（特征向量） \\(x\\) ，最邻近法将数据集中与 \\(x\\) 最邻近点的类作为 \\(x\\) 的类。 3.2 \\(k\\) 近邻模型 \\(k\\) 近邻法使用的模型实际上对应于特征空间的划分。模型由三个基本要素——距离度量， \\(k\\) 值得选取和分类决策规则决定。 3.2.1 距离度量 特征空间中两个实例点的距离是两个实例点相似程度的反应。 \\(k\\) 近邻模型的特征空间一般是 \\(n\\) 维实数向量空间 \\(\\mathbb{R}&#94;n\\) 。使用的距离是欧氏距离，也可以使用其他距离，例如更一般的 \\(L_p\\) 距离或 Minkowski 距离。 设特征空间 \\({\\cal X}\\) 是 \\(n\\) 维实数向量空间 \\(\\mathbb{R}&#94;n\\) ， \\(x_i,x_j\\in{\\cal X}\\) ， \\(x_i=\\left(x_i&#94;{(1)},x_i&#94;{(2)},\\cdots,x_i&#94;{(n)}\\right)&#94;\\text{T}\\) ， \\(x_j=\\left(x_j&#94;{(1)},x_j&#94;{(2)},\\cdots,x_j&#94;{(n)}\\right)&#94;\\text{T}\\) ， \\(x_i,x_j\\) 的 \\(L_p\\) 距离定义为 $$L_p(x_i,x_j)=\\left(\\sum_{l=1}&#94;n\\left|x_i&#94;{(l)}-x_j&#94;{(l)}\\right|&#94;p\\right)&#94;\\frac{1}{p}$$ 3.2.2 \\(k\\) 值的选择 \\(k\\) 值得选择会对 \\(k\\) 近邻法的结果产生重大影响。 如果选择较小的 \\(k\\) 值，就相当于用较小的邻域中的训练实例进行预测。\"学习\"的近似误差（approximation error）会减小，只有与输入实例较近的（相似的）训练实例才会对预测结果起作用。但缺点是\"学习\"的估计误差（estimation error）会增大，预测结果会对近邻的实例点非常敏感。如果邻近的实例点恰巧是噪声点，预测就会出错。换句话说， \\(k\\) 值得减小就意味着整体模型变的复杂，容易发生过拟合。 如果 \\(k\\) 值选择过大，就相当于用较大邻域中的训练实例进行预测。其优点是可以减小学习的估计误差，但缺点是学习的近似误差会增大。这时与输入实例较远的（不相似的）训练实例也会对预测起作用，使预测发生错误。 \\(k\\) 值的增大意味着整体的模型变得简单。 如果 \\(k=N\\) ，那么无论输入的实例是什么，都将简单的预测它属于在训练实例中最多的类，这时，模型过于简单，是不可取的。 在应用中， \\(k\\) 值一般取一个比较小的数值，通常采用交叉验证法来选取最优的 \\(k\\) 值。 3.2.3 分类决策规则 \\(k\\) 近邻法中的分类决策规则往往是多数表决，即由输入实例的 \\(k\\) 个邻近的训练实例中的多数类决定输入实例的类。 多数表决规则（majority voting rule）有如下解释：如果分类的损失函数是 0-1 损失函数，分类函数为 $$f:\\mathbb{R}&#94;n\\longrightarrow\\{c_1,c_2,\\cdots,c_K\\}$$ 那么误分类的概率是 $$P(Y\\neq f(X))=1-P(Y=f(X))$$ 对于给定的实例 \\(x\\in{\\cal X}\\) ，其最邻近的 \\(k\\) 个训练实例点构成集合 \\(N_k(x)\\) 。如果涵盖 \\(N_k(x)\\) 的区域类别是 \\(c_j\\) ，那么误分类率是 $$\\frac{1}{k}\\sum_{x_i\\in N_k(x)}\\mathbb{I}(y_i\\neq c_j)=1-\\frac{1}{k}\\sum_{x_i\\in N_k(x)}\\mathbb{I}(y_i= c_j)$$ 要使误分类率最小即经验风险最小，就要使 \\(\\sum_{x_i\\in N_k(x)}\\mathbb{I}(y_i= c_j)\\) 最大，所以多数表决规则等价于经验风险最小化。 3.3 \\(k\\) 近邻法的实现： \\(kd\\) 树 为了对训练数据进行快速 \\(k\\) 近邻搜索，我可以采取 \\(kd\\) 树方法（此 \\(k\\) 是计算机科学中的叫法）。 \\(kd\\) 树是每个节点都为 \\(k\\) 维点的二叉树。所有非叶子节点可以视作用一个超平面把空间分割成两个半空间。节点左边的子树代表在超平面左边的点，节点右边的子树代表在超平面右边的点。选择超平面的方法如下：每个节点都与k维中垂直于超平面的那一维有关。因此，如果选择按照x轴划分，所有 \\(x\\) 值小于指定值的节点都会出现在左子树，所有 \\(x\\) 值大于指定值的节点都会出现在右子树。这样，超平面可以用该x值来确定，其法线为 \\(x\\) 轴的单位向量。 3.3.1 构造 \\(kd\\) 树 有很多种方法可以选择轴垂直分割面（axis-aligned splitting planes），所以有很多种创建 \\(kd\\) 树的方法。 最典型的方法如下： 随着树的深度轮流选择轴当作分割面。（例如：在三维空间中根节点是 \\(x\\) 轴垂直分割面，其子节点皆为 \\(y\\) 轴垂直分割面，其孙节点皆为 \\(z\\) 轴垂直分割面，其曾孙节点则皆为 \\(x\\) 轴垂直分割面，依此类推） 点由垂直分割面之轴座标的中位数区分并放入子树 这个方法产生一个平衡的 \\(kd\\) 树。每个叶节点的高度都十分接近。然而，平衡的树不一定对每个应用都是最佳的。 3.3.2 搜索 \\(kd\\) 树 最邻近搜索用来找出在树中与输入点最接近的点。 \\(kd\\) 树最邻近搜索的过程如下： 从根节点开始，递归的往下移。往左还是往右的决定方法与插入元素的方法一样(如果输入点在分区面的左边则进入左子节点，在右边则进入右子节点) 一旦移动到叶节点，将该节点当作\"目前最佳点\" 解开递归，并对每个经过的节点运行下列步骤： 如果目前所在点比目前最佳点更靠近输入点，则将其变为目前最佳点 检查另一边子树有没有更近的点，如果有则从该节点往下找 当根节点搜索完毕后完成最邻近搜索 如果实例点是随机分布的， \\(kd\\) 树搜索的平均计算复杂度是 \\(O(\\log N)\\) ，这里 \\(N\\) 是训练实例数。 \\(kd\\) 树更适用于训练实例数远大于空间维度时的 \\(k\\) 近邻搜索。当空间维度接近训练实例数时，它的效率会迅速下降，几乎接近线性扫描。 if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"读书笔记","url":"https://xutree.github.io/pages/2018/11/04/3/"},{"title":"统计学习方法 第二章 感知机","text":"感知机（perceptron）是二分类的线性分类模型，其输入是实例的特征向量，输出为实例的类别，取 +1 和 -1 二值。感知机对应于输入空间（特征空间）中将实例划分为正负类别的分离超平面，属于判别模型。 2.1 感知机模型 定义 2.1（感知机）假设输入空间（特征空间）是 \\({\\cal X}\\subseteq\\mathbb{R}&#94;n\\) ，输出空间是 \\({\\cal Y}=\\{+1,-1\\}\\) 。输入 \\(x\\in{\\cal X}\\) 表示实例的特征向量，对应于输入空间（特征空间）的点；输出 \\(y\\in{\\cal Y}\\) 表示实例的类别。由输入空间到输出空间的如下函数： $$f(x)=\\text{sign}(w\\cdot x+b)$$ 称为感知机。其中， \\(w\\) 和 \\(b\\) 为感知机模型参数， \\(w\\in\\mathbb{R}&#94;n\\) 叫做权值（weight）或权值向量（weight vector）， \\(b\\in\\mathbb{R}\\) 叫做偏置（bias）， \\(w\\cdot x\\) 表示 \\(w\\) 和 \\(x\\) 的内积。sign 是符号函数，即： $$\\text{sign}(x)=\\begin{cases}+1, & x\\geq0 \\\\ -1, & x<0\\end{cases}$$ 感知机是一种线性分类模型。感知机模型的假设空间是定义在特征空间中的所有线性分类模型（linear classification model）或线性分类器（linear classifier），即函数集合\b： \\(\\{f|f(x)=w\\cdot x+b\\}\\) 。 感知机的几何解释：对于线性方程 $$w\\cdot x+b=0$$ 对应于特征空间 \\(\\mathbb{R}&#94;n\\) 中的一个超平面 \\(S\\) ，称为分离超平面（separating hyperplane），其中 \\(w\\) 是超平面的法向量， \\(b\\) 是超平面的截距。这个超平面将特征空间划分为两个部分。 2.2 感知机学习策略 2.2.1 数据集的线性可分性 定义 2.2 （数据集的线性可分性）给定\b一个数据集 $$T=\\{(x_1,y_1),(x_2,y_2),\\cdots,(x_N,y_N)\\}$$ 其中， \\(x_i\\in{\\cal X}=\\mathbb{R}&#94;n\\) ， \\(y_i\\in{\\cal Y}=\\{+1,-1\\}\\) ， \\(i=1,2,\\cdots,N\\) ，如果存在某个超平面 \\(S\\) $$w\\cdot x+b=0$$ 能够将数据集的正负实例完全正确的划分到超平面的两侧，则称数据集 \\(T\\) 是线性可分数据集（linearly separable data set）\b；否则，则称数据集 \\(T\\) 线性不可分。\b 2.2.2 感知机学习策略 为了\b找出超平面，需要一个学习策略，即定义（经验）损失函数并将损失函数极小化。 损失函数的一个自然选择是误分类点的总数。但是，这样的损失函数不是参数 \\(w\\) 、 \\(b\\) \b 的连续可导函数，不易优化。损失函数的另一个选择是误分类点\b到超平面 \\(S\\) 的总距离，这是感知机所采用的。 \b首先，输入空间 \\(\\mathbb{R}&#94;n\\) 中任一点 \\(x_0\\) 到超平面 \\(S\\) 的距离为： $$\\frac{1}{||w||}|w\\cdot x+b|$$ 这里， \\(||w||\\) 是 \\(w\\) 的 \\(L_2\\) 范数。 其次，注意到对于误分类点数据 \\((x_i,y_i)\\) ，下式成立： $$-y_i(w\\cdot x_i+b)>0$$ 因此，误分类点到超平面的总距离为： $$-\\frac{1}{||w||}\\sum_{x_i\\in M}y_i(w\\cdot x_i+b)$$ 其中， \\(M\\) 是误分类点集合。不考虑 \\(\\frac{1}{||w||}\\) ，就得到感知机学习的损失函数。 \b给定训练数据集： $$T=\\{(x_1,y_1),(x_2,y_2),\\cdots,(x_N,y_N)\\}$$ 感知机 \\(\\text{sign}(w\\cdot x+b)\\) 学习的损失函数\b定义为： $$L(w,b)=-\\sum_{x_i\\in M}y_i(w\\cdot x_i+b)$$ 感知机学习的策略是在假设空间中选取使上面的损失函数最小的模型参数 \\(w\\) ， \\(b\\) ，即感知机模型。 2.3 感知机学习算法 \b为最优化上节的损失函数，采取随机梯度下降法（stochastic gradient descent）。 2.3.1 感知机学习算法的原始形式 感知机学习算法是对以下最优化问题的\b算法。给定训练数据集： $$T=\\{(x_1,y_1),(x_2,y_2),\\cdots,(x_N,y_N)\\}$$ 其中 \\(x_i\\in{\\cal X}=\\mathbb{R}&#94;n\\) ， \\(y_i\\in{\\cal Y}=\\{+1,-1\\}\\) ， \\(i=1,2,\\cdots,N\\) ，求参数 \\(w\\) ， \\(b\\) ，使其为以下损失函数极小化的一个解： $$\\min_{w,b} L(w,b)=-\\sum_{x_i\\in M}y_i(w\\cdot x_i+b)$$ 其中， \\(M\\) 是误分类点集合。 随机梯度下降法步骤如下：首先，任意选取一个超平面 \\(w_0\\) ， \\(b_0\\) ，然后用梯度下降法不断地极小化目标函数。极小化过程不是一次使 \\(M\\) 中所有误分类法的梯度下降，而是一次随机选取一个误分类点使其梯度下降。 假设误分类\b点集合 \\(M\\) 是固定的，那么损失函数 \\(L(w,b)\\) 的梯度为： $$\\begin{eqnarray} \\nabla_wL(w,b) &=& -\\sum_{x_i\\in M}y_ix_i \\\\ \\nabla_bL(w,b) &=& -\\sum_{x_i\\in M}y_i \\end{eqnarray}$$ 随机选取一个误分类点 \\((x_i,y_i)\\) 对 \\(w\\) ， \\(b\\) 进行更新： $$\\begin{eqnarray} w &\\longleftarrow& w+\\eta y_ix_i \\\\ b &\\longleftarrow& b+\\eta y_i \\end{eqnarray}$$ 式中 \\(\\eta\\ (0<\\eta\\leq 1)\\) 是步长，也称学习率（learning rate）。 算法 2.1 （感知机学习算法的原始形式) 输入：训练数据集 $$T=\\{(x_1,y_1),(x_2,y_2),\\cdots,(x_N,y_N)\\}$$ 其中 $$x_i\\in{\\cal X}=\\mathbb{R}&#94;n,y_i\\in{\\cal Y}=\\{+1,-1\\},i=1,2,\\cdots,N$$ 学习率 $$\\eta\\ (0<\\eta\\leq 1)$$ 输出：\b \\(w\\) ， \\(b\\) ； 感知机模型 $$f(x)=\\text{sign}(w\\cdot x+b)$$ (1) 选取初值 \\(w_0\\) ， \\(b_0\\) (2) 在训练集中选取数据 \\((x_i,y_i)\\) (3) 如果 \\(y_i(w\\cdot x_i+b)\\leq 0\\) $$\\begin{eqnarray} w &\\longleftarrow& w+\\eta y_ix_i \\\\ b &\\longleftarrow& b+\\eta y_i \\end{eqnarray}$$ (4) 转至 (2)，直至训练集中没有误分类点 2.3.2 算法的收敛性 为便于推导，将偏置并入权重向量，记为 \\(\\hat{w}=(w&#94;\\text{T},b)&#94;\\text{T}\\) ，同样也将输入向量加以扩充，加进常数 1，记作 \\(\\hat{x}=(x&#94;\\text{T},1)&#94;\\text{T}\\) 。这样， \\(\\hat{x}\\in\\mathbb{R}&#94;{n+1}\\) ， \\(\\hat{w}\\in\\mathbb{R}&#94;{n+1}\\) ，显然 \\(\\hat{w}\\cdot\\hat{x}=w\\cdot x+b\\) 。 定理 2.1 （Novikoff）设训练集 $$T=\\{(x_1,y_1),(x_2,y_2),\\cdots,(x_N,y_N)\\}$$ 线性可分，则 (1). 存在满足条件 \\(||\\hat{w}_\\text{opt}||=1\\) 的超平面 $$\\hat{w}_\\text{opt}\\cdot\\hat{x}=w_\\text{opt}\\cdot x_+b_\\text{opt}=0$$ 将训练数据集完全正确分开；切存在 \\(\\gamma>0\\) ，对所有 \\(i=1,2,\\cdots,N\\) $$y_i(\\hat{w}_\\text{opt}\\cdot\\hat{x}_i)=y_i(w_\\text{opt}\\cdot x_i+b_\\text{opt})\\geq\\gamma$$ (2). 令 $$R=\\max_{1\\leq i\\leq N}||\\hat{x}_i||$$ ，则感知机算法 2.1 在训练数据集上的误分类次数 \\(k\\) 满足不等式 $$k\\leq\\left(\\frac{R}{\\gamma}\\right)&#94;2$$ 证明：（1）由\b线性可分性的定义即可证明，其中： $$\\gamma=\\min_i\\{y_i(w_\\text{opt}\\cdot x_i+b_\\text{opt})\\}$$ （2）感知机算法从 \\(\\hat{w}_0\\) 开始，如果实例被误分类，则更新权重。令 \\(\\hat{w}_{k-1}\\) 是第 \\(k\\) 个误分类实例之前的扩充权重向量，即： $$\\hat{w}_{k-1}=(w_{k-1}&#94;\\text{T},b_{k-1})&#94;\\text{T}$$ 则第 \\(k\\) 个被误分类实例的条件是 $$y_i(\\hat{w}_{k-1}\\cdot\\hat{x}_i)=y_i(w_{k-1}\\cdot x_i+b_{k-1})\\leq0$$ 若 \\((x_i,y_i)\\) 是被 \\(\\hat{w}_{k-1}\\) 误分类的数据，则 \\(w\\) 和 \\(b\\) 的更新为 $$\\begin{eqnarray} w_k &\\longleftarrow& w_{k-1}+\\eta y_ix_i \\\\ b_k &\\longleftarrow& b_{k-1}+\\eta y_i \\end{eqnarray}$$ 即 $$\\hat{w}_k\\longleftarrow \\hat{w}_{k-1}+\\eta y_i\\hat{x}_i$$ 下面推导两个不等式： i. \\(\\hat{w}_k\\cdot\\hat{w}_\\text{opt}\\geq k\\eta\\gamma\\) $$\\hat{w}_k\\cdot\\hat{w}_\\text{opt}=(\\hat{w}_{k-1}+\\eta y_i\\hat{x}_i)\\cdot\\hat{w}_\\text{opt}\\geq\\hat{w}_{k-1}\\cdot\\hat{w}_\\text{opt}+\\eta\\gamma\\geq\\cdots\\geq k\\eta\\gamma$$ ii. \\(||\\hat{w}_k||&#94;2\\leq k\\eta&#94;2R&#94;2\\) $$ \\begin{eqnarray} ||\\hat{w}_k||&#94;2 &=& ||\\hat{w}_{k-1}+\\eta y_i\\hat{x}_i||&#94;2 \\\\ &=& ||\\hat{w}_{k-1}||&#94;2+2\\eta y_i\\hat{w}_{k-1}\\cdot\\hat{x}_i+\\eta&#94;2||\\hat{x}_i||&#94;2 \\\\ &\\leq& ||\\hat{w}_{k-1}||&#94;2+\\eta&#94;2||\\hat{x}_i||&#94;2 \\\\ &\\leq& ||\\hat{w}_{k-1}||&#94;2+\\eta&#94;2R&#94;2\\leq\\cdots\\leq k\\eta&#94;2R&#94;2 \\end{eqnarray}$$ 由上述两个不等式 $$k\\eta\\gamma\\leq\\hat{w}_k\\cdot\\hat{w}_\\text{opt}\\leq||\\hat{w}_k||\\ ||\\hat{w}_\\text{opt}||\\leq\\sqrt{k}\\eta R$$ 于是 $$k\\leq\\left(\\frac{R}{\\gamma}\\right)&#94;2$$ 定理表明，误分类次数是有上界的，经过有限次搜索可以找到将训练数据完全正确分开的分离超平面。 感知机学习算法存在许多解，这些解既依赖于初值的选择，也依赖于迭代过程中误分类点的选择顺序。 当训练集线性不可分时，感知机学习算法不收敛，迭代结果会发生震荡。 2.3.3 感知机学习算法的对偶形式 对偶形式的基本想法是，将 \\(w\\) 和 \\(b\\) 表示为实例 \\(x_i\\) 和\b标记 \\(y_i\\) 的线性组合的形式，通过求解其系数而求得 \\(w\\) 和 \\(b\\) 。不失一般性，在算法 2.1 中可以假设初始值 \\(w_0\\) 和 \\(b_0\\) 均为 0，对误分类点 \\((x_i,y_i)\\) 通过 $$\\begin{eqnarray} w &\\longleftarrow& w+\\eta y_ix_i \\\\ b &\\longleftarrow& b+\\eta y_i \\end{eqnarray}$$ 逐步修改 \\(w\\) ， \\(b\\) ，设修改 \\(n\\) 次（随机梯度下降，一个点可能被选择多次），则 \\(w\\) 和 \\(b\\) 关于 \\((x_i,y_i)\\) 的增量分别\b是 \\(\\alpha_iy_ix_i\\) 和 \\(\\alpha_iy_i\\) 这里 $$\\alpha_i=n_i\\eta$$ 这样，从学习\b过程不难看出，最后学习到的 \\(w\\) 和 \\(b\\) 可以分别表示为 $$\\begin{eqnarray} w &=& \\sum_{i=1}&#94;N\\alpha_iy_ix_i \\\\ b &=& \\sum_{i=1}&#94;N\\alpha_iy_i \\end{eqnarray}$$ 这里， \\(\\alpha_i\\geq0\\) ， \\(i=1,2,\\cdots,N\\) ，当 \\(\\eta=1\\) 时，表示第 \\(i\\) 个实例点由于误分类而进行更新的次数。实例点更新次数越多，意味着它\b距离分离超平面越近，也就越难正确分类。换句话说，这样的实例对学习结果影响很大。 算法 2.2 （感知机学习算法的对偶形式） 输入：训练数据集 $$T=\\{(x_1,y_1),(x_2,y_2),\\cdots,(x_N,y_N)\\}$$ 其中 $$x_i\\in{\\cal X}=\\mathbb{R}&#94;n,y_i\\in{\\cal Y}=\\{+1,-1\\},i=1,2,\\cdots,N$$ 学习率 $$\\eta\\ (0<\\eta\\leq 1)$$ 输出：\b \\(\\alpha\\) ， \\(b\\) ； 感知机模型 $$f(x)=\\text{sign}(\\sum_{j=1}&#94;N\\alpha_jy_jx_j\\cdot x+b)$$ 其中 \\(\\alpha=(\\alpha_1,\\alpha_2,\\cdots,\\alpha_N)&#94;\\text{T}\\) (1) \\(\\alpha\\longleftarrow0\\) ， \\(b\\longleftarrow0\\) (2) 在训练集中选取数据 \\((x_i,y_i)\\) (3) 如果 \\(y_i\\left(\\sum_{j=1}&#94;N\\alpha_jy_jx_j\\cdot x_i+b\\right)\\leq 0\\) $$\\begin{eqnarray} \\alpha_i &\\longleftarrow& \\alpha_i+\\eta \\\\ b &\\longleftarrow& b+\\eta y_i \\end{eqnarray}$$ (4) 转至 (2)，直至训练集中没有误分类点 对偶形式中\b训练实例仅以内积的形式出现。为了方便，可以预先将训练集中实例间的内积计算出来并以矩阵的形式存储，这个矩阵就是所谓的 Gram 矩阵（Gram matrix） $$G=[x_i\\cdot x_j]_{N\\times N}$$ if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"读书笔记","url":"https://xutree.github.io/pages/2018/11/04/2/"},{"title":"统计学习方法 第一章 统计学习方法概论","text":"1.1 统计学习 1.1.1 特点 统计学习（statistical learning）是关于计算机基于 数据 构建概率统计模型并运用模型对数据进行 预测与分析 的一门学科。 赫尔伯特·西蒙（Herbert A.Simon）对\"学习\"给出如下定义：如果一个系统能够通过执行某个过程改变它的性能，这就是学习。 1.1.2 对象 统计学习的对象是数据。 统计学习关于数据的基本假设是同类数据具有一定的统计规律性，这是统计学习的前提。 1.1.3 目的 统计学习用于对数据进行预测和分析，特别是对未知新数据进行预测与分析。 1.1.4 方法 监督学习（supervised learning） 非监督学习（unsupervised learning） 半监督学习（semi-supervised learning） 强化学习（reinforcement learning） 1.1.5 统计学习方法三要素 模型（model） ：即假设空间（hypothesis space），假设空间是一个集合，这个集合包含要学习的模型 策略（strategy） ：模型选择的准则 算法（algorithm） ：模型学习的算法 1.2 监督学习 监督学习（supervised learning）的任务是学习一个模型，使模型能够对任意给定的输入，对其相应的输出做出一个好的预测。 1.2.1 基本概念 输入空间（input space） ：输入的所有可能取值的集合，表示为 \\({\\cal X}\\) 输出空间（output space） ：输出的所有可能取值的集合，表示为 \\({\\cal Y}\\) 实例（instance） ：每个具体的输入，通常由特征向量（feature vector）表示 特征空间（feature space） ：所有特征向量存在的空间，每一维度对应一个特征 训练数据（training data） ：由输入（或特征向量）与输出对组成 联合概率分布（joint probability distribution） ：监督学习假设输入与输出的随机变量 \\(X\\) 和 \\(Y\\) 遵循联合概率分布 \\(P(X,Y)\\) 假设空间（hypothesis space） ：模型属于由输入空间到输出空间的映射的集合，这个集合就是假设空间。假设空间的确定意味着学习范围的确定 注1 ：输入和输出空间可以使有限集也可以是整个欧式空间；输入与输出空间可以使用一个空间，也可以是不同的空间；通常输出空间远小于输入空间。 注2 ：有时假设输入空间与特征空间为相同的空间，对它们不予区分；有时假设输入空间与特征空间为不同的空间，将实例从输入空间映射到特征空间。模型实际上都是定义在特征空间上的。 注3 ：在学习过程中，假设联合概率分布存在，但对于学习系统来说，联合概率分布的具体定义是未知的。训练数据与测试数据被看作是依联合概率分布 \\(P(X,Y)\\) 独立同分布（independent and identically distribution）产生的。统计学习假设数据存在一定的统计规律， \\(X\\) 和 \\(Y\\) 遵循联合概率分布 \\(P(X,Y)\\) 就是监督学习关于数据的基本假设。 在监督学习过程中，将输入和输出看做是定义在输入（特征）空间与输出空间上的随机变量的取值。输入、输出变量用大写字母表示，输入、输出变量所取的值用小写字母表示。 输入实例 \\(x\\) 的\b特征向量记作 $$x=\\left(x&#94;{(1)},x&#94;{(2)},\\dots,x&#94;{(n)}\\right)&#94;\\text{T}$$ \b \\(x&#94;{(i)}\\) 表示 \\(x\\) 的第 \\(i\\) 个特征。 多个输入变量的第 \\(i\\) 个记作 $$x_i=\\left(x_i&#94;{(1)},x_i&#94;{(2)},\\dots,x_i&#94;{(n)}\\right)&#94;\\text{T}$$ 训练集： \\(T=\\{(x_1,y_1),(x_2,y_2),\\dots,(x_N,y_N)\\}\\) 监督学习的模型可以是概率模型或非概率模型，由条件概率分布 \\(P(Y|X)\\) 或决策函数（decision function） \\(Y=f(X)\\) 表示。对具体的输入进行相应的输出预测时，写作 \\(P(y|x)\\) 或 \\(y=f(x)\\) 。 1.3 统计学习三要素 1.3.1 模型 统计学习首要考虑的问题是学习什么样的模型。模型的假设空间包含所有可能的条件概率分布或决策函数。假设空间中的模型一般有无穷多个。 假设空间用 \\(\\cal{F}\\) 表示。假设空间可以定义为决策函数或条件概率分布的集合 $${\\cal F}=\\{f|Y=f_\\theta(X),\\theta \\in \\mathbb R&#94;n\\}$$ 或 $${\\cal F}=\\{P|P_\\theta(Y|X),\\theta \\in \\mathbb R&#94;n\\}$$ \b 参数向量 \\(\\theta\\) 取值于 \\(n\\) 维欧式空间 \\(\\mathbb R&#94;n\\) ，称为参数空间（parameter space）。 1.3.2 策略 有了模型的假设空间，统计学习接着需要考虑的是按照什么样的准则学习或选择最优的模型。 损失函数和风险函数 \b损失函数（loss function）或代价函数（cost function）用来度量预测错误的程度。损失函数是 \\(f(X)\\) 和 \\(Y\\) 的非负实值函数，记作 \\(L(Y,f(X))\\) 。 统计学习常用的损失函数有以下几种： 0-1 损失函数（0-1 loss function） $$L(Y,f(X))=\\begin{cases} 1, & Y\\neq f(X) \\\\ 0, & Y=f(X) \\end{cases}$$ 平方损失函数（quadratic loss function） $$L(Y,f(X))=(Y-f(X))&#94;2$$ 绝对损失函数（absolute loss function） $$L(Y,f(X))=|Y-f(X)|$$ 对数损失函数（logarithmic loss function）或对数似然损失函数（log-likelihood loss function） $$L(Y,P(Y|X))=-\\log P(Y|X)$$ 风险函数（risk function）或期望损失（expected loss）：\b理论上模型 \\(f(X)\\) 关于联合分布 \\(P(X,Y)\\) 平均意义下的损失，记作 \\(R_\\text{exp}\\) 。 $$R_\\text{exp}(f)=\\text{E}_P[L(Y,f(X))]=\\int_{{\\cal X}\\times{\\cal Y}}L(y,f(x))P(x,y)dxdy$$ 经验风险（empirical risk）或经验损失（empirical loss）：模型 \\(f(X)\\) 关于训数据集的平均损失，记作 \\(R_\\text{emp}\\) 。 $$R_\\text{emp}(f)=\\frac{1}{N}\\sum_{i=1}&#94;NL\\left(y_i,f(x_i)\\right)$$ 经验风险最小化 \b经验风险最小化（empirical risk minimization，ERM）策略认为：经验风险最小的模型是最优的模型。即求解下面的最优化问题 $$ \\min_{f\\in {\\cal F}} \\frac{1}{N}\\sum_{i=1}&#94;NL\\left(y_i,f(x_i)\\right)$$ 其中 \\({\\cal F}\\) 是假设空间。 当样本容量足够大时，经验风险最小化能保证有很好的学习效果。例如，极大似然估计（maximum likelihood estimation）就是经验风险最小化的一个例子。当模型是条件概率分布，损失函数是对数损失函数时，经验风险最小化就等价于极大似然估计。 但是，当样本容量很小时，经验风险最小化学习的效果就未必很好，会产生\"过拟合（over-fitting）现象\"。 结构风险最小化 结构风险最小化（structural risk minimization，SRM）是为了防止过拟合而提出来的策略。结构风险最小化等价于正则化（regularization）。结构风险在经验风险上加上表示模型复杂度的正则化项（regularizer）或罚项（penalty term），定义如下 $$R_\\text{srm}=\\frac{1}{N}\\sum_{i=1}&#94;NL\\left(y_i,f(x_i)\\right)+\\lambda J(f)$$ 其中 \\(J(f)\\) 为模型的复杂度，是定义在假设空间 \\({\\cal F}\\) 上的泛函。模型 \\(f\\) 越复杂， \\(J(f)\\) 越大。也就是说，复杂度表示了对复杂模型的惩罚， \\(\\lambda\\geq 0\\) 是系数，用以权衡经验风险和模型复杂度。 结构风险小需要经验风险与模型复杂度同时小，结构风险小的模型往往对训练数据以及未知的测试数据都有较好的预测。结构化风险最小化策略认为：结构风险最小的模型是最优的模型。即求解下面的最优化问题 $$ \\min_{f\\in {\\cal F}} \\frac{1}{N}\\sum_{i=1}&#94;NL\\left(y_i,f(x_i)\\right)+\\lambda J(f)$$ 贝叶斯估计中的最大后验概率估计（maximum posterior probability estimation，MAP）就是结构化风险最小化的一个例子。当模型是条件概率分布，损失函数是对数损失函数，模型复杂度由模型的先验概率表示时，结构风险最小化就等价于最大后验概率估计。 1.3.3 算法 算法是指学习\b模型的具体计算方法。统计学习基于训练数据集，根据学习策略，从假设空间中选择最优模型，最后需要考虑用什么样的计算方法求解最优模型。 如果最优化问题有显式的解析解，这个最优化问题就比较简单，但通常解析解不存在，这就需要用数值方法求解。如何保证找到\b全局最优解，并使求解的过程非常高效，就成为一个重要问题。 1.4 模型评估与模型选择 1.4.1 训练误差 假设学习到的模型是 \\(Y=\\hat{f}(X)\\) ，训练误差（training error）是模型 \\(Y=\\hat{f}(X)\\) 关于训练数据集的平均损失 $$R_\\text{emp}(\\hat{f})=\\frac{1}{N}\\sum_{i=1}&#94;NL(y_i,\\hat{f}(x_i))$$ 其中 \\(N\\) 是训练样本容量。 1.4.2 测试误差 测试误差是模型 \\(Y=\\hat{f}(X)\\) 关于测试数据集的平均损失 $$e_\\text{test}(\\hat{f})=\\frac{1}{N'}\\sum_{i=1}&#94;{N'}L(y_i,\\hat{f}(x_i))$$ 其中 \\(N'\\) 是测试样本容量。 例如，当损失函数是 0-1 损失时，测试误差就变成了常见的测试数据集上的误差率（error rate） $$e_\\text{test}=\\frac{1}{N'}\\sum_{i=1}&#94;{N'}{\\mathbb I}(y_i\\neq \\hat{f}(x_i))$$ 这里 \\({\\mathbb I}\\) 是指示函数，即 \\(y_i\\neq \\hat{f}(x_i)\\) 时为 1，否则为 0。 相应的，常见的测试数据集上的准确率（accuracy）为 $$r_\\text{test}=\\frac{1}{N'}\\sum_{i=1}&#94;{N'}{\\mathbb I}(y_i=\\hat{f}(x_i))$$ 训练误差的大小，对判断给定的问题是不是一个\b容易学习的问题是有\b意义的，但本质上不重要。 测试误差反应了学习方法对未知的测试数据集的预测\b能力，是学习中的重要概念。 1.4.3 过拟合 当假设空间含有不同复杂度（例如，不同的参数个数）的模型时，就要面临模型选择（model selection）的问题。我们希望选择或学习一个合适的模型。 如果一味追求提高对训练数据的预测能力，所选模型的复杂度则往往会比真模型更高，这种现象称为过拟合。 过拟合是指学习时选择的模型所包含的参数过多，以致于出现这一模型对\b已知数据预测得很好，但对未知数据预测很差的现象。 训练误差与测试误差和模型复杂度关系如下： \b 1.5 正则化与交叉验证 正则化与交叉验证是两种常用的模型选择方法。 1.5.1 正则化 正则化是结构风险最小化策略的实现。正则化项一般是模型\b复杂度的单调递增函数，模型越复杂，正则化值就越大。 正则化一般形式形式 $$ \\min_{f\\in {\\cal F}} \\frac{1}{N}\\sum_{i=1}&#94;NL\\left(y_i,f(x_i)\\right)+\\lambda J(f)$$ \b其中，第一项是经验风险，第二项是正则化项， \\(\\lambda\\geq 0\\) 为调整两者关系之间的系数。 正则化项可以取不同的形式。例如：回归问题中，损失函数是平方损失，正则化项可以是参数向量的 \\(L_2\\) 范数 $$L(w)=\\frac{1}{N}\\sum_{i=1}&#94;N\\left(f(x_i;w)-y_i\\right)&#94;2+\\frac{\\lambda}{2}||w||&#94;2$$ 这里， \\(||w||\\) 表示参数向量 \\(w\\) 的 \\(L_2\\) 范数。 1.5.2 交叉验证 另一种常用的模型选择方法是交叉验证（cross validation）。 如果给定的样本数据充足，进行模型选择的一种简单方法是随机的将数据集切成三部分：训练集、验证集和测试集。训练集用来训练模型，验证集用于模型选择，测试集用于\b最终对学习方法的评估。 但是，在许多实际应用中数据是不充足的。为了选择好的模型，可以采用交叉验证的方法。 交叉验证的基本思想是重复的使用数据：把给定的数据进行切分，将切分的数据集组合\b为训练集与测试集，在此基础上反复进行训练、测试以及模型选择。 简单交叉验证 首先随机的将已给数据分成两部分：训练集、测试集。然后用训练集在各种条件下（例如，不同的参数个数）训练模型，从而得到不同的模型。然后，在测试集上评价各个模型的测试误差，选出测试误差最小的模型。 \\(S\\) 折交叉验证 应用最多的是 \\(S\\) 折交叉验证（S-fold cross validation），方法如下：首先随机的将已给数据切分\b为 \\(S\\) 个互不相交的大小相同的子集；然后利用 \\(S-1\\) 个子集的数据训练模型，利用余下的子集测试模型；将这一过程对可能的 \\(S\\) 种选择重复进行；最后选出 \\(S\\) 次评估中平均测试误差最小的模型。 留一交叉验证 \\(S\\) 折交叉验证的特殊情形是 \\(S=N\\) ，称为留一交叉验证（leave-one-out cross validation），往往在数据缺乏的情况下使用。这里 \\(N\\) 是给定数据集的容量。 1.6 泛化能力 1.6.1 泛化误差 学习方法的泛化能力（generalization ability）是指由该学习方法学到的模型对未知数据的预测能力。 泛化误差（generalization error）：如果学到的模型是 \\(\\hat{f}\\) ，那么用这个模型对未知数据预测的误差即为泛化误差。 $$R_\\text{exp}(\\hat{f})=\\text{E}_P[L(Y,f(X))]=\\int_{{\\cal X}\\times{\\cal Y}}L(y,\\hat{f}(x))P(x,y)dxdy$$ 实际上，泛化误差就是所学习到的模型的期望风险。 1.6.2 泛化误差上界 学习方法的泛化能力分析往往使用过研究泛化误差的概率上界进行的，简称为泛化误差上界（generalization error bound）。也就是说，可以通过比较两种学习方法的泛化误差上界的大小来比较它们的优劣。 泛化误差上界具有如下性质： 它是样本容量的函数，当样本容量增加时，泛化误差上界趋于 0 它是假设空间容量（capacity）的函数，假设空间容量越大，模型就越难学，泛化误差上界就越大 1.6.3 二分类问题的泛化误差上界 考虑二分类问题。已知训练数据集 \\(T=\\{(x_1,y_1),(x_2,y_2),\\dots,(x_N,y_N)\\}\\) ，它是从联合概率\b分布 \\(P(X,Y)\\) 独立同分布产生的， \\(X\\in \\mathbb R&#94;n\\) ， \\(Y\\in \\{-1,1\\}\\) 。假设空间是函数的有限集合 \\({\\cal F}=\\{f_1.f_2.\\dots,f_d\\}\\) ， \\(d\\) 是函数个数。设 \\(f\\) 是从 \\({\\cal F}\\) 中选取的函\b数。损失函数是 0-1 损失。关于 \\(f\\) 的期望风险和经验风险分别是 $$\\begin{eqnarray} R_\\text{exp}(f)&=&\\text{E}_P[L(Y,f(X))]\\\\ R_\\text{emp}(f)&=&\\frac{1}{N}\\sum_{i=1}&#94;NL(y_i,f(x_i)) \\end{eqnarray}$$ 经验风险最小化函数是 $$f_N=\\arg \\min_{f\\in{\\cal F}}R_\\text{emp}(f)$$ 人们更关心的是 \\(f_N\\) 的泛化能力 $$R(f_N)=\\text{E}_P[L(Y,f_N(X))]$$ 定理 1.1（泛化误差上界）对二分类问题，当假设空间是有限个函数的集合 \\({\\cal F}=\\{f_1.f_2.\\dots,f_d\\}\\) 时，对任意一个函数 \\(f\\in{\\cal F}\\) ，至少以概率 \\(1-\\delta\\) ，以下不等式成立 $$R(f)\\leq R_\\text{emp}(f)+\\epsilon(d,N,\\delta)$$ 其中， $$\\epsilon(d,N,\\delta)=\\sqrt{\\frac{1}{2N}\\left(\\log d+\\log \\frac{1}{\\delta}\\right)}$$ 上述定理表明：训练误差越小，泛化误差也越小；当 \\(N\\) 趋于无穷时，第二项为 0；假设空间包含的函数越多，泛化误差越大。 证明：在证明过程中要用到 Hoeffding 不等式，先叙述如下： Hoeffding 不等式适用于有界的随机变量。设有两两独立的一系列随机变量 \\(X_{1},\\dots ,X_{n}\\) 。假设对所有的 \\(1\\leq i\\leq n\\) ， \\(X_{i}\\) 都是几乎有界的变量，即满足 $$\\mathbb {P} (X_{i}\\in [a_{i},b_{i}])=1$$ 那么这 \\(n\\) 个随机变量的经验期望 $$\\overline {X}={\\frac {X_{1}+\\cdots +X_{n}}{n}}$$ 满足以下的不等式 $$\\begin{eqnarray} \\mathbb {P}({\\overline {X}}-\\mathbb {E} [{\\overline {X}}]\\geq t) &\\leq& \\exp \\left(-{\\frac {2t&#94;{2}n&#94;{2}}{\\sum_{i=1}&#94;{n}(b_{i}-a_{i})&#94;{2}}}\\right)\\\\ \\mathbb {P} (|{\\overline {X}}-\\mathbb {E} [{\\overline {X}}]|\\geq t)&\\leq& 2\\exp \\left(-{\\frac {2t&#94;{2}n&#94;{2}}{\\sum_{i=1}&#94;{n}(b_{i}-a_{i})&#94;{2}}}\\right) \\end{eqnarray}$$ 对任意函数 \\(f\\in{\\cal F}\\) ， \\(R_\\text{emp}(f)\\) 是 \\(N\\) 个随机变量 \\(L(Y,f(X))\\) 的样本均值， \\(R(f)\\) 是随机变量 \\(L(Y,f(X))\\) 的期望值。如果损失函数取值于区间 [0,1]，则由 Hoeffding 不等式得到，对 \\(\\epsilon>0\\) ，以下不等式成立 $$P(R(f)-R_\\text{emp}(f)\\geq\\epsilon)\\leq\\exp (-2N\\epsilon&#94;2)$$ 由于 \\({\\cal F}=\\{f_1;f_2,\\dots,f_d\\}\\) 是一个有限集合，故 $$\\begin{eqnarray} P\\left(\\exists f\\in{\\cal F}:R(f)-R_\\text{emp}(f\\right)\\geq\\epsilon)&=&P\\left(\\bigcup_{f\\in{\\cal F}}\\{R(f)-R_\\text{emp}(f)\\geq\\epsilon\\}\\right)\\\\ &\\leq&\\sum_{f\\in{\\cal F}}P(R(f)-R_\\text{emp}(f)\\geq\\epsilon)\\\\ &\\leq& d\\exp(-2N\\epsilon&#94;2) \\end{eqnarray}$$ 或者等价的，对任意的 \\(f\\in{\\cal F}\\) ，\b有 $$P(R(f)-R_\\text{emp}(f)\\geq\\epsilon))\\geq1-d\\exp(-2N\\epsilon&#94;2)$$ 令 $$\\delta=d \\exp(-2N\\epsilon&#94;2)$$ 则 $$P(R(f)<R_\\text{emp}(f)+\\epsilon)\\geq1-\\delta$$ \b证毕。 1.7 生成模型与判别模型 监督学习方法也可以分为生成方法（generative approach）和判别方法（discriminative approach）。所学到的模型分别称为生成模型（generative model）和判别模型（discriminative model）。 1.7.1 生成方法 生成方法由数据学习联合概率分布 \\(P(X,Y)\\) ，然后求出条件概率分布 \\(P(Y|X)\\) 作为预测的模型，即生成模型 $$P(Y|X)=\\frac{P(X,Y)}{P(X)}$$ 这样的方法之所以称为生成方法，是因为模型\b表示了给定输入 \\(X\\) 产生输出 \\(Y\\) 的\b生成关系。 典型的生成模型有：朴素贝叶斯法和隐马尔科夫模型。 1.7.2 判别方法 判别方法由数据直接学习策略函数 \\(f(X)\\) 或者条件概率分布 \\(P(Y|X)\\) 作为预测的模型。判别方法关心的是对给定的输入 \\(X\\) ，应该预测什么样的输出 \\(Y\\) 。 典型的判别模型有： \\(k\\) 近邻法，感知机，决策树，logistic 回归模型，最大熵模型，支持向量机，提升方法和条件随机场等。 1.7.3 \b不同方法的特点 生成方法： 生成方法可以还原出联合概率分布 \\(P(X,Y)\\) ，而判别方法则不能 生成方法的学习收敛速度更快，即当样本容量增加时，学到的模型可以更快的收敛到真实模型 当存在隐变量时，仍可以使用生成方法，\b此时判别方法就不能用了 判别方法： 判别方法直接学习的是条件概率 \\(P(Y|X)\\) 或决策函数 \\(f(X)\\) ，直接面对预测，往往学习的准确率更高 由于直接学习 \\(P(Y|X)\\) 或 \\(f(X)\\) ，可以对数据进行各种程度上的抽象、定义特征并使用特征，因此可以简化学习问题 1.8 分类问题 在监督学习中，当输出变量 \\(Y\\) 取有限个离散值时，预测问题便成为分类问题。 分类器（classifier） ：从数据中学习到的一个分类模型或分类决策函数。 评价分类器性能的指标一般是 分类准确率（accuracy） ：对于给定的测试数据集，分类器正确分类的样本数与总样本数之比。 对于二分类问题常用的评价指标是 精确率（precision） 和 召回率（recall） 。 通常以关注的类为正类，其他类为负类，分类器在测试数据集上的预测或\b正确或不正确，4 种情况出现的总数分别记为： TP：将正类预测为正类的数目 FN：将正类预测为负类的数目 FP：将负类预测为正类的数目 TN：将负类预测为负类的数目 精确率定义 $$P=\\frac{TP}{TP+FP}$$ 召回率定义 $$R=\\frac{TP}{TP+FN}$$ \\(F_1\\) 值 $$\\frac{2}{F_1}=\\frac{1}{P}+\\frac{1}{R}\\longrightarrow F_1=\\frac{2TP}{2TP+FP+FN}$$ 许多统计学习方法可以用于分类，包括 \\(k\\) 近邻法，感知机，朴素贝叶斯法，决策树，\b决策列表，logistic 回归模型，支持向量机，提升方法，贝叶斯网络，神经网络，Winnow 等。 一个分类应用的例子：垃圾邮件、非垃圾邮件分类。 1.9 标注问题 标注（tagging）也是一个监督学习问题，可以认为标注问题是分类问题的一个推广，标注问题又是更复杂的结构预测（structure prediction）问题的简单形式。 标注问题的输入是一个观测序列，输出是一个标记序列或状态序列。标注问题的\b目标在于学习一个模型，使它能够对观测序列给出标记序列作为预测。注意，可能的标记个数是有限的，但其组合所成的\b标记序列的个数是依序列长度呈指数级增长的。 评价标注模型的指标和分类模型一样，常用的有标注准确率、精确率和召回率。 标注常用的统计学习方法有：隐马尔科夫模型，条件随机场。 一个标注的例子：对英文文章进行标注，英文单词是一个观察，英文句子是一个观察序列，标记表示名词短语的\"开始\"、\"结束\"和\b\"其他\"。 1.10 回归问题 回归（regression）是监督学习的另一个重要问题。回归用于预测\b输入变量（自变量）和输出变量（因变量）之间的关系，特别是当输入变量的值发生变化时，输出变量的值随之发生的变化。回归问题等价于函数拟合：选择一条函数曲线使其很好的拟合已知数据且很好的预测未知数据。 回归问题按照输入变量的个数，分为一元回归和多元回归；按照输入变量和输出变量之间的关系分为线性回归和非线性回归。 回归学习中最常用的损失函数是平方损失函数，在此情况下，回归问题可以用最小二乘法（least squares）求解。 一个回归\b的例子\b：市场趋势预测。 if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"读书笔记","url":"https://xutree.github.io/pages/2018/11/04/1/"},{"title":"指示器随机变量","text":"指示器随机变量为概率和期望之间的转换提供了一个便利的方法。给定一个样本空间 \\(S\\) 和一个事件 \\(A\\) ，那么事件 \\(A\\) 对应的 指示器随机变量 \\(I\\{A\\}\\) 定义为： $$\\text{I}\\{A\\}=\\cases{ 1 & 如果 A 发生 \\\\ 0 & 如果 A 不发生 }$$ 指示器随机变量有如下性质： $$\\text{E}[X_A]=\\text{Pr}\\{A\\}$$ 就是说，指示器随机变量的期望等于它所指示事件发生的概率，指示器随机变量在分析重复随机试验时很有用。 例题1 ：连续抛硬币 \\(n\\) 次，求正面出现次数的期望。 解答 ：设指示器随机变量 \\(X_i\\) 对应第 \\(i\\) 次抛硬币时正面朝上的事件。设随机变量 \\(X\\) 表示 \\(n\\) 次抛硬币中出现正面的总次数，则： $$X=\\sum_{i=1}&#94;nX_i$$ 对上式取期望： $$\\text{E}[X]=\\text{E}\\left[\\sum_{i=1}&#94;nX_i\\right]=\\sum_{i=1}&#94;n\\text{E}[X_i]=\\sum_{i=1}&#94;n1/2=n/2$$ 例题2 ：雇佣问题。计算雇佣一个新的办公助理的期望次数。 解答 ：设指示器随机变量 \\(X_i\\) 对应第 \\(i\\) 个应聘者被雇用的事件。设随机变量 \\(X\\) 表示 雇用一个新办公助理的次数，则： $$X_i=\\text{I}\\{应聘者\\ i\\ 被雇用\\}=\\cases{ 1 & 如果应聘者 i 被雇用 \\\\ 0 & 如果应聘者 i 不被雇用 }$$ 以及： $$X=\\sum_{i=1}&#94;nX_i$$ 容易得到： $$\\text{E}[X_i]=\\frac{\\text{A}_{n-1}&#94;{n-1}}{\\text{A}_n&#94;n}=\\frac{1}{n}$$ 故： $$\\text{E}[X]=\\text{E}\\left[\\sum_{i=1}&#94;nX_i\\right]=\\sum_{i=1}&#94;n\\text{E}[X_i]=\\sum_{i=1}&#94;n1/i=\\ln n+O(1)$$ 例题3 ： \\(n\\) 位顾客，他们每个人给餐厅核对帽子的服务生一顶帽子。服务生以随机顺序将帽子归还给顾客，求拿到自己帽子的客户的期望数。 解答 ：设指示器随机变量 \\(X_i\\) 对应第 \\(i\\) 个顾客拿到自己帽子的事件。设随机变量 \\(X\\) 表示拿到自己帽子的客户的期望数，则： $$X_i=\\text{I}\\{第\\ i\\ 个顾客拿到自己的帽子\\}=\\cases{ 1 & 如果第 i 个顾客拿到自己的帽子 \\\\ 0 & 如果第 i 个顾客没有拿到自己的帽子 }$$ 以及： $$X=\\sum_{i=1}&#94;nX_i$$ 容易得到： 故： $$\\text{E}[X]=\\text{E}\\left[\\sum_{i=1}&#94;nX_i\\right]=\\sum_{i=1}&#94;n\\text{E}[X_i]=\\sum_{i=1}&#94;n1/n=1$$ 例题4 ：设 \\(A[1\\dots n]\\) 是由 \\(n\\) 个不同数构成的数列。如果 \\(i<j\\) 且 \\(A[i]>A[j]\\) ，则称 \\((i,j)\\) 对为 \\(A\\) 的一个逆序对。假设 \\(A\\) 的元素构成 \\(<1,2,\\dots,n>\\) 上的一个均匀分布。求其中逆序对数目的期望。 解答 ：设指示器随机变量 \\(X_{ij}\\) 对应 \\((i,j)\\) 为逆序对的事件。则： $$X_{ij}=\\text{I}\\{A[i]>A[j], \\text{for}\\ 1\\leq i<j\\leq n\\}$$ 容易得到： $$\\text{E}[X_{ij}]=\\text{Pr}\\{X_{ij}=1\\}=1/2$$ 设随机变量 \\(X\\) 表示逆序对总数目，则： $$X=\\sum_{i=1}&#94;{n-1}\\sum_{j=i+1}&#94;nX_{ij}$$ 故： $$\\text{E}[X]=\\text{E}\\left[\\sum_{i=1}&#94;{n-1}\\sum_{j=i+1}&#94;nX_{ij}\\right]=\\sum_{i=1}&#94;{n-1}\\sum_{j=i+1}&#94;n\\text{E}[X_{ij}]=\\sum_{i=1}&#94;{n-1}\\sum_{j=i+1}&#94;n1/2\\\\=\\frac{1}{2}\\text{C}_n&#94;2=\\frac{n(n-1)}{4}$$ 例题5 ：一个骰子，6面，1个面是 1， 2个面是2， 3个面是3， 问平均掷多少次能使1,2,3都至少出现一次？ 解答 ： 设指示器随机变量 \\(X_{i}\\) ，对应\"前i次掷骰子，1，2，3没能都至少出现一次\"的事件，其值为1表示\"前n次掷骰子，1，2，3没能都至少出现一次\"的事件，其值为0表示这个事件没有发生，即\"前n次掷骰子，1，2，3各至少出现一次\"。 设随机变量 \\(X\\) 表示1，2，3刚好全部出现过需要的投掷次数。 $$X=\\sum_0&#94;{\\infty}X_i$$ 说明一下，等式两边都是随机变量，假设对于某个随机实例（例如，这里指一次具体的投掷序列），其对应事件是：\"投了 \\(K\\) 次恰好1，2，3都出现了\"，于是等式左边显然等于 \\(K\\) ；而等式右边，对于 \\(n < K\\) ，由于这些项的对应定义事件发生了（即1，2，3没能出现），所以他们的实例值是1，而对于 \\(n\\geq K\\) ，则由于对应定义事件都没发生，实例值为0，可见这个和也是 \\(K\\) 。故两侧相等。（为了达到这个相等关系，可以看出需要把 \\(X_0\\) 包含在内的必要性）。 值得注意的是，对 \\(n < 3\\) ， \\(X_n\\) 显然恒为1。而对于 \\(n\\geq 3\\) ，这些随机变量不是独立的。他们的相关性是不容易求出的，唯一容易知道的是，当序列中一个项为0时，其后的项均为0。好在对于这题我们不需要担忧这个相关性。 下面求 \\(\\text{E}[X_i]\\) ，由于 \\(X_i\\) 考虑的是 \\(i\\) 次投掷三者没有全部出现，于是就是其中两者出现或仅一者出现。假设单次投掷1，2和3出现的概率分别为： \\(p1\\) ， \\(p2\\) 和 \\(p3\\) 。于是 \\((p1+p2)&#94;i\\) 表示 \\(i\\) 次投掷只出现1或2的概率，这其中包括了出现全1和全2的情形，于是求 \\(\\text{Pr}\\{X_{i}=1\\}\\) 可由这样的项求和并剔除重复计算的单面值情形： $$\\text{Pr}\\{X_{i}=1\\}=\\cases{ (p1+p2)&#94;i+(p1+p3)&#94;i+(p2+p3)&#94;i-p1&#94;i-p2&#94;i-p3&#94;i & i>0\\\\ 0 & i=0}$$ 故： $$\\text{E}[X]=\\text{E}\\left[\\sum_{i=0}&#94;{\\infty}X_i\\right]=\\sum_{i=0}&#94;{\\infty}\\text{E}[X_i]=\\sum_{i=0}&#94;{\\infty}\\text{Pr}\\{X_{i}=1\\}\\\\ =1+\\frac{1-p3}{p3}+\\frac{1-p2}{p2}+\\frac{1-p1}{p1}-\\frac{p1}{1-p1}-\\frac{p2}{1-p2}-\\frac{p3}{1-p3}\\\\ =7.3$$ if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"其他","url":"https://xutree.github.io/pages/2018/10/28/指示器随机变量/"},{"title":"最大子数组问题","text":"寻找数组中和最大的非空连续子数组。 暴力求解 先找出从第1个元素开始的最大子数组，而后再从第2个元素开始找出从第2个元素开始的最大子数组，依次类推，比较得出最大的子数组。 时间复杂度 \\(O(n&#94;2)\\) 。 #include <tuple> typedef std :: tuple < int , int , int > array_info_message ; array_info_message find_max_subarray ( int a [], int len ) { int i , j ; int sum = 0 ; int max_left , max_right ; //每次开始累加的起始位置的循环 for ( i = 0 ; i < len ; i ++ ) { max_left = i ; int temp = 0 ; //向后累加的循环 for ( j = i ; j < len ; j ++ ) { temp += a [ j ]; if ( temp > sum ) { sum = temp ; max_right = j ; } } } return std :: make_tuple ( max_left , max_right , sum ); } 分治算法 时间复杂度 \\(O(nlgn)\\) 。 #include <limits> #include <tuple> typedef std :: tuple < int , int , int > array_info_message ; void find_max_cross_subarray ( int a [], int low , int mid , int high ) { int left_sum = std :: numeric_limits < int >:: min (); int right_sum = std :: numeric_limits < int >:: min (); int sum = 0 ; int max_left = mid ; int max_right = mid ; for ( int i = mid ; i >= low ; -- i ) { sum += a [ i ]; if ( left_sum < sum ) { left_sum = sum ; max_left = i ; } } sum = 0 ; for ( int i = mid + 1 ; i <= high ; ++ i ) { sum += a [ i ]; if ( right_sum < sum ) { right_sum = sum ; max_right = i ; } } return std :: make_tuple ( max_left , max_right , left_sum + right_sum ); } array_info_message find_max_subarray ( int a [], int low , int high ) { array_info_message r1 , r2 , r3 ; if ( low == high ) return std :: make_tuple ( low , high , a [ low ]); else { // 第一次这里处理成减号了，找了半天 bug int mid = static_cast < int > (( high + low ) / 2 ); r1 = find_max_subarray ( a , low , mid ); r2 = find_max_subarray ( a , mid + 1 , high ); r3 = find_max_cross_subarray ( a , low , mid , high ); if ( std :: get < 2 > ( r1 ) >= std :: get < 2 > ( r2 ) && std :: get < 2 > ( r1 ) >= std :: get < 2 > ( r3 )) return r1 ; if (( std :: get < 2 > ( r2 ) >= std :: get < 2 > ( r1 ) && std :: get < 2 > ( r2 ) >= std :: get < 2 > ( r3 ))) return r2 ; if (( std :: get < 2 > ( r3 ) >= std :: get < 2 > ( r1 ) && std :: get < 2 > ( r3 ) >= std :: get < 2 > ( r2 ))) return r3 ; } return std :: make_tuple ( 0 , 0 , 0 ); } 动态规划：Kadane 算法 Kadane 算法扫描一次整个数列的所有数值，在每一个扫描点计算以该点数值为结束点的子数列的最大和（正数和）。该子数列由两部分组成：以前一个位置为结束点的最大子数列、该位置的数值。因为该算法用到了\"最佳子结构\"（以每个位置为终点的最大子数列都是基于其前一位置的最大子数列计算得出）。 Kadane 算法时间复杂度为 \\(O(n)\\) ，空间复杂度为 \\(O(1)\\) 。 array_info_message find_max_subarray ( int a [] , int n ) { void maxSubArray(int a [] , int n) { int max = std : : numeric_limits < int >:: min (); int sum = 0 ; int left = 0, right = 0, max_left = 0, max_right = 0 ; for (int i = 0 ; i < n ; i++) { if (sum + a [ i ] > a [ i ] ) { sum = sum + a [ i ] ; right = i ; } else { sum = a [ i ] ; left = i ; right = i ; } if ( sum > max ) { max = sum ; max_left = left ; max_right = right ; } } return std :: make_tuple ( max_left , max_right , max ); } 若我们只需要求最大和，则有如下简洁解法： int find_max_subarray ( int a [] , int n ) { int max = std : : numeric_limits < int >:: min (); int sum = 0 ; for (int i = 0 ; i < n ; i++) { sum = sum + a [ i ] > a [ i ] ? sum + a [ i ] : a [ i ] ; max = sum > max ? sum : max ; } return max ; } if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"读书笔记","url":"https://xutree.github.io/pages/2018/10/27/find_maximum_subarray/"},{"title":"排序算法","text":"插入排序 插入排序（英语：Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用 in-place 排序（即只需用到 \\(O(1)\\) 的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。 void insertion_sort(int arr[], int len) { for (int i = 1; i < len; i++) { int key = arr[i]; int j; for (j = i - 1; j >= 0 && key < arr[j]; j--) { arr[j + 1] = arr[j]; arr[j] = key; } } } 如果目标是把 \\(n\\) 个元素的序列升序排列，那么采用插入排序存在最好情况和最坏情况。最好情况就是，序列已经是升序排列了，在这种情况下，需要进行的比较操作需 \\(n-1\\) 次即可。最坏情况就是，序列是降序排列，那么此时需要进行的比较共有 \\(\\frac {1}{2}n(n-1)\\) 次。插入排序的赋值操作是比较操作的次数减去 \\(n-1\\) 次，（因为 \\(n-1\\) 次循环中，每一次循环的比较都比赋值多一个，多在最后那一次比较并不带来赋值）。平均来说插入排序算法复杂度为 \\(O(n&#94;{2})\\) 。因而，插入排序不适合对于数据量比较大的排序应用。但是，如果需要排序的数据量很小，例如，量级小于千；或者若已知输入元素大致上按照顺序排列，那么插入排序还是一个不错的选择。 插入排序在工业级库中也有着广泛的应用，在 STL 的 sort 算法和 stdlib 的 qsort 算法中，都将插入排序作为快速排序的补充，用于少量元素的排序（通常为8个或以下）。 最坏时间复杂度： \\(O(n&#94;2)\\) 最优时间复杂度： \\(O(n)\\) 平均时间复杂度： \\(\\Theta (n&#94;2)\\) 最坏空间复杂度： \\(O(1)\\) 稳定排序 归并排序 归并排序（英语：Merge sort，或 mergesort），是创建在归并操作上的一种有效的排序算法，效率为 \\(O(n\\log n)\\) 。1945年由约翰·冯·诺伊曼首次提出。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。 template < typename Iterator > void merge ( Iterator begin , Iterator end , Iterator middle ) { typedef typename std : : iterator_traits < Iterator >:: value_type T ; // 迭代器指向对象的值类型 if ( std : : distance ( begin , middle ) <= 0 || std :: distance ( middle , end ) <= 0 ) return ; std : : vector < T > result ( begin , end ); //暂存结果 auto current = result.begin() ; auto left_current = begin ; //左侧序列当前比较位置 auto right_current = middle ; //右序列当前比较位置 while (left_current != middle && right_current != end) { if (*left_current < *right_current) { *current++ = *left_current++ ; //左侧较小 } else { *current++ = *right_current++ ; //左侧较小 } } if ( left_current == middle && right_current != end ) // 当左侧序列为搬空 { std : : copy ( right_current , end , current ); } if ( right_current == end && left_current != middle ) // 当右侧序列搬空 { std : : copy ( left_current , middle , current ); } std :: copy ( result . begin (), result . end (), begin ); // 复制回原序列 ， 因此是非原地的 } template < typename Iterator > void merge_sort ( Iterator begin , Iterator end ) { auto size = std : : distance ( begin , end ); if (size > 1) { Iterator middle = begin + size / 2 ; merge_sort(begin, middle) ; merge_sort(middle, end) ; merge(begin, end, middle) ; } } 比较操作的次数介于 \\(\\frac{1}{2}n\\log n\\) 和 \\(n\\log n-n+1\\) 之间。 赋值操作的次数是 \\(2n\\log n\\) 。归并算法的空间复杂度为： \\(\\Theta (n)\\) 。 最坏时间复杂度： \\(O(n\\log n)\\) 最优时间复杂度： \\(\\Omega(n \\log n)\\) 平均时间复杂度： \\(\\Theta (n\\log n)\\) 最坏空间复杂度： \\(O(n)\\) 稳定排序 堆排序 堆排序（英语：Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。 堆节点的访问 通常堆是通过一维数组来实现的。在数组起始位置为0的情形中： 父节点 \\(i\\) 的左子节点在位置 \\(2i+1\\) 父节点 \\(i\\) 的右子节点在位置 \\(2i+2\\) 子节点 \\(i\\) 的父节点在位置 \\(\\text{floor}((i-1)/2)\\) 堆的操作 堆中定义以下几种操作： 最大堆调整（Max Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点 创建最大堆（Build Max Heap）：将堆中的所有数据重新排序 堆排序（HeapSort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算 #include <iostream> using namespace std ; //最大堆调整，i 为要调整节点，n 为最大堆尺寸 void max_heapify ( int arr [], int n , int i ) { int largest = i ; int l = 2 * i + 1 ; //左孩子 int r = 2 * i + 2 ; //右孩子 if ( l < n && arr [ l ] > arr [ largest ]) largest = l ; if ( r < n && arr [ r ] > arr [ largest ]) largest = r ; if ( largest != i ) { swap ( arr [ i ], arr [ largest ]); heapify ( arr , n , largest ); } } //堆排序 void heapSort ( int arr [], int n ) { //建堆 for ( int i = n / 2 - 1 ; i >= 0 ; i -- ) max_heapify ( arr , n , i ); //排序 for ( int i = n - 1 ; i >= 0 ; i -- ) { //交换堆顶和\b尾元素 swap ( arr [ 0 ], arr [ i ]); max_heapify ( arr , i , 0 ); } } void printArray ( int arr [], int n ) { for ( int i = 0 ; i < n ; ++ i ) cout << arr [ i ] << \" \" ; cout << \" \\n \" ; } int main () { int arr [] = { 12 , 11 , 13 , 5 , 6 , 7 }; int n = sizeof ( arr ) / sizeof ( arr [ 0 ]); heapSort ( arr , n ); cout << \"Sorted array is \\n \" ; printArray ( arr , n ); } 最坏时间复杂度： \\(O(n\\log n)\\) 最优时间复杂度： \\(O(n\\log n)\\) 平均时间复杂度： \\(\\Theta (n\\log n)\\) 最坏空间复杂度： \\(O(1)\\) 不稳定排序 快速排序 快速排序（英语：Quicksort），又称划分交换排序（partition-exchange sort），简称快排，一种排序算法，最早由东尼·霍尔提出。在平均状况下，排序 \\(n\\) 个项目要 \\(O(n\\log n)\\) 次比较。在最坏状况下则需要 \\(O(n&#94;{2})\\) 次比较，但这种状况并不常见。事实上，快速排序 \\(\\Theta (n\\log n)\\) 通常明显比其他算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地达成。 快速排序是二叉查找树（二叉搜索树）的一个空间最优化版本。不是循序地把数据项插入到一个明确的树中，而是由快速排序组织这些数据项到一个由递归调用所隐含的树中。这两个算法完全地产生相同的比较次数，但是顺序不同。对于排序算法的稳定性指标，原地分割版本的快速排序算法是不稳定的。其他变种是可以通过牺牲性能和空间来维护稳定性的。 template < typename T > void quick_sort_recursive ( T arr [] , int start , int end ) { if (start >= end) return ; T mid = arr [ end ] ; int left = start, right = end - 1 ; while (left < right) { //在整个范围内搜寻比枢纽元值小或大的元素，然后将左侧元素与右侧元素交换 while (arr [ left ] < mid && left < right) //试图在左侧找到一个比枢纽元更大的元素 left++ ; while (arr [ right ] >= mid && left < right) //试图在右侧找到一个比枢纽元更小的元素 right-- ; std : : swap ( arr [ left ] , arr [ right ] ); //交换元素 } if ( arr [ left ] >= arr [ end ] ) std :: swap ( arr [ left ] , arr [ end ] ); else left ++; quick_sort_recursive ( arr , start , left - 1 ); quick_sort_recursive ( arr , left + 1 , end ); } template < typename T > // 整数或浮点数皆可使用 , 若要使用类时必須定义 \"小于\" (<) 、 \"大于\" (>) 、 \"不小于\" (>=) 操作 void quick_sort ( T arr [] , int len ) { quick_sort_recursive(arr, 0, len - 1) ; } 随机算法 当划分产生的两个子问题分别包含 \\(n-1\\) 和0个元素时，最坏情况发生。划分操作的时间复杂度为 \\(\\Theta(n)\\) ， \\(T(0)=\\Theta(1)\\) ，这时算法运行时间的递归式为： \\(T(n) = T(n-1) + T(0) + \\Theta(n) = T(n-1) + \\Theta(n)\\) ，解为 \\(T(n) = \\Theta(n&#94;2)\\) 。 当划分产生的两个子问题分别包含 \\(\\lfloor n/2 \\rfloor\\) 和 \\(\\lceil n/2 \\rceil-1\\) 个元素时，最好情况发生。算法运行时间递归式为： \\(T(n) = 2T(n/2) + \\Theta(n)\\) ，解为 \\(T(n) = \\Theta(n\\lg n)\\) 。 可以通过在算法中引入随机性，使得算法对所有输入都能获得较好的期望性能。随机算法保证了对任何的输入而言，都可以保证 \\(\\Theta (n\\lg n)\\) 的时间复杂度。 void rand_quick_sort ( T arr [] , int begin , int end ) { if (end-begin <= 1) return ; int pindex = rand() % (end-begin) + begin ; std : : swap ( arr [ end - 1 ] , arr [ pindex ] ); quick_sort(arr, end - begin + 1) ; } 最坏时间复杂度： \\(\\Theta(n&#94;2)\\) 最优时间复杂度： \\(\\Theta(n\\log n)\\) 平均时间复杂度： \\(\\Theta (n\\log n)\\) 空间复杂度： \\(O(\\log n)\\) 不稳定排序 计数排序 计数排序（Counting sort）是一种稳定的线性时间排序算法。计数排序使用一个额外的数组 \\(C\\) ，其中第 \\(i\\) 个元素是待排序数组 \\(A\\) 中值等于 \\(i\\) 的元素的个数。然后根据数组 \\(C\\) 来将 \\(A\\) 中的元素排到正确的位置。 当输入的元素是 \\(n\\) 个 \\([0,k]\\) 之间的整数时，它的运行时间是 \\(\\Theta (n+k)\\) 。计数排序不是比较排序，排序的速度快于任何比较排序算法。 由于用来计数的数组 \\(C\\) 的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。例如：计数排序是用来排序0到100之间的数字的最好的算法，但是它不适合按字母顺序排序人名。但是，计数排序可以用在基数排序算法中，能够更有效的排序数据范围很大的数组。 当原数组有重复数据时，为保证稳定排序，最后要反向填充目标数组，以及将每个数字的统计减去1。 步骤 找出待排序的数组中最大和最小的元素 统计数组中每个值为 \\(i\\) 的元素出现的次数，存入数组 \\(C\\) 的第 \\(i\\) 项 对所有的计数累加（从 \\(C\\) 中的第一个元素开始，每一项和前一项相加） 反向填充目标数组：将每个元素 \\(i\\) 放在新数组的第 \\(C[i]\\) 项，每放一个元素就将 \\(C[i]\\) 减去1 #include <iostream> #include <time.h> #include <vector> using namespace std ; void Counting_sort ( int A [], size_t n , int k ) { //申请额外空间 int * B = new int [ n ]; int * C = new int [ k + 1 ]; for ( int i = 0 ; i <= k ; ++ i ) { C [ i ] = 0 ; //将 C 指向的数组所有元素置0 } //保存数组 A 中每个元素出现的个数 for ( int j = 0 ; j < n ; ++ j ) { C [ A [ j ]] ++ ; } //将所有计数次数累加 for ( int i = 1 ; i <= k ; ++ i ) { C [ i ] = C [ i ] + C [ i - 1 ]; } //将元素重新输入 for ( int i = n - 1 ; i >= 0 ; -- i ) { //次数大小最小为1、数组开始为0 B [ C [ A [ i ]] - 1 ] = A [ i ]; C [ A [ i ]] -- ; } for ( int j = 0 ; j < n ; ++ j ) { A [ j ] = B [ j ]; } //不要忘了释放分配的空间 delete [] B ; delete [] C ; } int main ( int argc , char ** argv ) { int a [ 10 ] = { 2 , 56 , 4 , 2 , 9 , 56 , 3 , 59 , 9 , 16 }; int max = a [ 0 ]; for ( int i = 1 ; i < 10 ; ++ i ) { if ( a [ i ] > max ) { max = a [ i ]; } } Counting_sort ( a , 10 , max ); for ( int i = 0 ; i < 10 ; ++ i ) { cout << a [ i ] << \" \" ; } return 0 ; } 最坏时间复杂度 \\(O(n+k)\\) 最优时间复杂度 \\(O(n+k)\\) 平均时间复杂度 \\(O(n+k)\\) 最坏空间复杂度 \\(O(n+k)\\) 稳定排序 基数排序 基数排序（英语：Radix sort）是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。 它是这样实现的：将所有待比较数值（正整数）统一为同样的数字长度，数字较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。 基数排序的时间复杂度是 \\(O(k\\cdot n)\\) ，其中 \\(n\\) 是排序元素个数， \\(k\\) 是数字位数。 最坏时间复杂度 \\(O(k\\cdot n)\\) 最坏时间复杂度 \\(O(n&#94;2)\\) 最坏空间复杂度 \\(O(k+n)\\) 稳定排序 int maxbit(int data[], int n) //辅助函数，求数据的最大位数 { int maxData = data[0]; ///< 最大数 /// 先求出最大数，再求其位数 for (int i = 1; i < n; ++i) { if (maxData < data[i]) maxData = data[i]; } int d = 1; int p = 10; while (maxData >= p) { maxData /= 10; ++d; } return d; } void radixsort(int data[], int n) //基数排序 { int d = maxbit(data, n); int *tmp = new int[n]; int *count = new int[10]; //计数器 int i, j, k; int radix = 1; for (i = 1; i <= d; i++) //进行 d 次排序 { //每一次都是计数排序 for (j = 0; j < 10; j++) count[j] = 0; //每次分配前清空计数器 for (j = 0; j < n; j++) { k = (data[j] / radix) % 10; //统计每个桶中的记录数 count[k]++; } for (j = 1; j < 10; j++) count[j] = count[j - 1] + count[j]; //将tmp中的位置依次分配给每个桶 for (j = n - 1; j >= 0; j--) //将所有桶中记录依次收集到tmp中 { k = (data[j] / radix) % 10; tmp[count[k] - 1] = data[j]; count[k]--; } for (j = 0; j < n; j++) //将临时数组的内容复制到data中 data[j] = tmp[j]; radix = radix * 10; } delete[] tmp; delete[] count; } 桶排序 桶排序（Bucket sort）或所谓的箱排序，是一个排序算法，工作的原理是将数组分到有限数量的桶里。每个桶再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。桶排序是鸽巢排序的一种归纳结果。当要被排序的数组内的数值是均匀分配的时候，桶排序使用线性时间 \\(\\Theta (n)\\) 。桶排序不是比较排序。 步骤 设置一个定量的数组当作空桶子 寻访序列，并且把项目一个一个放到对应的桶子去 对每个不是空的桶子进行排序 从不是空的桶子里把项目再放回原来的序列中 实现 转自： https://blog.csdn.net/misayaaaaa/article/details/66969486 #include <cstdlib> #include <iostream> #include <vector> using namespace std ; void Bucket_sort ( double a [], size_t n ) { double ** p = new double * [ 10 ]; // p数组存放十个double指针，分为10个桶 for ( int i = 0 ; i < 10 ; ++ i ) { p [ i ] = new double [ 100 ]; //每个指针都指向一块10个double的数组，每个桶都可以包含100个元素 } int count [ 10 ] = { 0 }; //元素全为0的数组 for ( int i = 0 ; i < n ; ++ i ) { double temp = a [ i ]; int flag = ( int )( temp * 10 ); //判断每个元素属于哪个桶 p [ flag ][ count [ flag ]] = temp ; //将每个元素放入到对应的桶中，从0开始 int j = count [ flag ] ++ ; //将对应桶的计数加1 //在本桶之中与之前的元素做比较，比较替换（插入排序） for (; j > 0 && temp < p [ flag ][ j - 1 ]; -- j ) { p [ flag ][ j ] = p [ flag ][ j - 1 ]; } p [ flag ][ j ] = temp ; } //元素全部放完之后，需要进行重新链接的过程 int k = 0 ; for ( int i = 0 ; i < 10 ; ++ i ) { for ( int j = 0 ; j < count [ i ]; ++ j ) //桶中元素的个数count[i] { a [ k ++ ] = p [ i ][ j ]; } } //申请内存的释放 for ( int i = 0 ; i < 10 ; i ++ ) { delete p [ i ]; p [ i ] = NULL ; } delete [] p ; p = NULL ; } //随机初始化数组[0,1) void Initial_array ( double a [], size_t n ) { for ( size_t i = 0 ; i < n ; ++ i ) { a [ i ] = rand () / ( static_cast < double > ( RAND_MAX ) + 1 ); } } int main ( int argc , char ** argv ) { double a [ 100 ]; Initial_array ( a , 100 ); Bucket_sort ( a , 100 ); for ( int i = 0 ; i < 100 ; ++ i ) { cout << a [ i ] << \" \" ; } return 0 ; } 时间复杂度为 \\(O(n)\\) 空间复杂度为 \\(O(n+M)\\) 稳定排序 if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"读书笔记","url":"https://xutree.github.io/pages/2018/10/26/sort/"},{"title":"矩阵微积分","text":"矩阵求导，本质是多元函数求导，仅仅是把函数的⾃变量以及求导的结果排列成了矩阵的形式，⽅便表达与计算。类似地，复合函数的求导法则本质上也是多元函数求导的链式法则，只是将结果整理成了矩阵的形式。从原理上讲，可以对矩阵的每个分量逐元素地求导，得到最终结果；但是这样做太繁琐，极其容易出错，因此推导并记住⼀些常⽤的结论在实践中是⾮常必要的。 不同的矩阵求导方法采取不同的导数排列方法，以便于所求导数可以方便后续计算。主要存在两种符号约定。 1. 概述 矩阵微积分的自变量可以是标量，向量，或者是一个矩阵，因变量也可以是上述的三者之一。每一种不同的自变量和因变量的组合都有不同的一套运算规则。 标量 向量 矩阵 标量 \\(\\frac{\\partial y}{\\partial x}\\) \\(\\frac{\\partial {\\boldsymbol y}}{\\partial x}\\) \\(\\frac{\\partial {\\bf Y}}{\\partial x}\\) 向量 \\(\\frac{\\partial y}{\\partial {\\boldsymbol x}}\\) \\(\\frac{\\partial {\\boldsymbol y}}{\\partial {\\boldsymbol x}}\\) 矩阵 \\(\\frac{\\partial y}{\\partial {\\bf X}}\\) 向量和标量可以看作矩阵的特殊形式。表中用粗体小写字母代表向量，粗体大写字母代表矩阵。 上表中空白的部分求导结果维度太高，而且没有统一的符号约定。 以下说明采用\b\"分子布局\"。 2. 分子布局下的求导 2.1 向量对标量求导 $${\\boldsymbol y}=\\begin{bmatrix} y_{1}\\\\ y_{2}\\\\ \\vdots\\\\ y_{m} \\end{bmatrix} \\Longrightarrow\\frac{\\partial {\\boldsymbol y}}{\\partial x}=\\begin{bmatrix} \\frac{\\partial y_1}{\\partial x}\\\\ \\frac{\\partial y_2}{\\partial x}\\\\ \\vdots\\\\ \\frac{\\partial y_m}{\\partial x}\\\\ \\end{bmatrix}$$ 在向量微积分中，向量 \\({\\boldsymbol y}\\) 相对于标量 \\(x\\) 的导数被称为向量 \\({\\boldsymbol y}\\) 的切向量。 2.2 标量对向量求导 $${\\boldsymbol x} = \\begin{bmatrix} x_1 \\\\ x_2 \\\\ \\vdots \\\\ x_n \\\\ \\end{bmatrix}\\Longrightarrow \\frac{\\partial y}{\\partial {\\boldsymbol x}&#94;{\\text{T}}} = \\left[ \\frac{\\partial y}{\\partial x_1} \\frac{\\partial y}{\\partial x_2} \\cdots \\frac{\\partial y}{\\partial x_n} \\right]$$ 这是标量函数 \\(f({\\boldsymbol x})\\) 梯度的转置。 2.3\b 向量对向量的求导 $${\\boldsymbol y} = \\begin{bmatrix} y_1 \\\\ y_2 \\\\ \\vdots \\\\ y_m \\\\ \\end{bmatrix},{\\boldsymbol x} = \\begin{bmatrix} x_1 \\\\ x_2 \\\\ \\vdots \\\\ x_n \\\\ \\end{bmatrix}\\Longrightarrow \\frac{\\partial {\\boldsymbol y}}{\\partial {\\boldsymbol x}} = \\begin{bmatrix} \\frac{\\partial y_1}{\\partial x_1} & \\frac{\\partial y_1}{\\partial x_2} & \\cdots & \\frac{\\partial y_1}{\\partial x_n}\\\\ \\frac{\\partial y_2}{\\partial x_1} & \\frac{\\partial y_2}{\\partial x_2} & \\cdots & \\frac{\\partial y_2}{\\partial x_n}\\\\ \\vdots & \\vdots & \\ddots & \\vdots\\\\ \\frac{\\partial y_m}{\\partial x_1} & \\frac{\\partial y_m}{\\partial x_2} & \\cdots & \\frac{\\partial y_m}{\\partial x_n}\\\\ \\end{bmatrix}$$ 此即雅可比矩阵。 2.5 矩阵对标量求导 $$\\frac{\\partial {\\bf Y}}{\\partial x} = \\begin{bmatrix} \\frac{\\partial y_{11}}{\\partial x} & \\frac{\\partial y_{12}}{\\partial x} & \\cdots & \\frac{\\partial y_{1n}}{\\partial x}\\\\ \\frac{\\partial y_{21}}{\\partial x} & \\frac{\\partial y_{22}}{\\partial x} & \\cdots & \\frac{\\partial y_{2n}}{\\partial x}\\\\ \\vdots & \\vdots & \\ddots & \\vdots\\\\ \\frac{\\partial y_{m1}}{\\partial x} & \\frac{\\partial y_{m2}}{\\partial x} & \\cdots & \\frac{\\partial y_{mn}}{\\partial x}\\\\ \\end{bmatrix}$$ 称为切矩阵。 2.6 标量对矩阵求导 $$\\frac{\\partial y}{\\partial {\\bf X}} = \\begin{bmatrix} \\frac{\\partial y}{\\partial x_{11}} & \\frac{\\partial y}{\\partial x_{21}} & \\cdots & \\frac{\\partial y}{\\partial x_{p1}}\\\\ \\frac{\\partial y}{\\partial x_{12}} & \\frac{\\partial y}{\\partial x_{22}} & \\cdots & \\frac{\\partial y}{\\partial x_{p2}}\\\\ \\vdots & \\vdots & \\ddots & \\vdots\\\\ \\frac{\\partial y}{\\partial x_{1q}} & \\frac{\\partial y}{\\partial x_{2q}} & \\cdots & \\frac{\\partial y}{\\partial x_{pq}}\\\\ \\end{bmatrix}$$ 矩阵标量 \\(f({\\bf X})\\) 在矩阵 \\({\\bf Y}\\) 方向上的方向导数为： $$\\nabla_{\\bf Y} f = \\operatorname{tr} \\left(\\frac{\\partial f}{\\partial {\\bf X}} {\\bf Y}\\right)$$ 2.7 其他矩阵求导 对于向量对矩阵求导，矩阵对向量求导，矩阵对矩阵求导。它们没有统一的符号，也没有统一的应用。 与向量相关的两种矩阵导数，可以被看作是一个只有一列的矩阵和另一个矩阵导数的特例。下面只考虑如何写出一个矩阵对另一个矩阵求导的导数结果。 3. 标量对矩阵求导计算方法 3.1 全微分公式 \b 对于实值函数对矩阵求导，我们可以写出： $$df=\\sum_{i=1}&#94;m\\sum_{j=1}&#94;n\\frac{\\partial f}{\\partial x_{ij}}dx_{ij}=\\text{tr}\\left(\\left(\\frac{\\partial f}{\\partial x}\\right)&#94;\\text{T}dx\\right)$$ 3.2 微分法则 加减： \\(d({\\bf X}\\pm{\\bf Y})=d{\\bf X}\\pm d{\\bf Y}\\) 乘\b法： \\(d({\\bf XY})=(d{\\bf X}){\\bf Y}+{\\bf X}(d{\\bf Y})\\) 转置： \\(d({\\bf X}&#94;\\text{T})=(d{\\bf X})&#94;\\text{T}\\) 迹： \\(d\\text{tr}({\\bf X})=\\text{tr}(d{\\bf X})\\) 逆： \\(d{\\bf X}&#94;{-1}=-{\\bf X}&#94;{-1}d{\\bf X}{\\bf X}&#94;{-1}\\) ，利用 \\({\\bf X}{\\bf X}&#94;{-1}=\\mathbb{I}\\) 行列式： \\(d|{\\bf X}|=\\text{tr}({\\bf X}&#94;*d{\\bf \bX})\\) ，其中 \\({\\bf X}&#94;*\\) 表示 \\({\\bf X}\\) 的伴随矩阵，在 \\({\\bf X}\\) 可逆时又可以写做： \\(d|{\\bf X}|=|{\\bf X}|\\text{tr}({\\bf X}&#94;{-1}d{\\bf X})\\) 逐元素乘： \\(d({\\bf X}\\odot{\\bf Y})=\bd{\\bf X}\\odot{\\bf Y}+{\\bf X}\\odot d{\\bf Y}\\) ， \\(\\odot\\) 表示尺寸相同的矩阵逐元素相乘 逐元素函数： \\(dw({\\bf X})=w'({\\bf X})\\odot d{\\bf X}\\) \b， \\(w({\\bf X})\\) 是逐元素标量运算， \\(w'({\\bf X})\\) 是逐元素求导 3.3 其他\b公式 \b \\(\\text{tr}(a)=a\\) ， \\(a\\) 为标量 \\(\\text{tr}({\\bf A}&#94;\\text{T})=\\text{tr}({\\bf A})\\) \\(\\text{tr}({\\bf A}+{\\bf B})=\\text{tr}({\\bf A})+\\text{tr}({\\bf B})\\) \\(\\text{tr}({\\bf AB})=\\text{tr}({\\bf BA})\\) \\(\\text{tr}\\left({\\bf A}&#94;{\\text{T}}({\\bf B}\\odot{\\bf C})\\right)=\\text{tr}\\left(({\\bf A}\\odot {\\bf B})&#94;{\\text{T}}{\\bf C}\\right)\\) 3.4 求导方法 若标量函数 \\(f\\) 是矩阵 \\({\\bf X}\\) 经加减乘法、行列式、逆、逐元素\b函数等运算构成，则使用相应的运算法则对 \\(f\\) 求微分，再使用迹变换给 \\(df\\) 套上迹\b并将其它项交换至 \\(d{\\bf X}\\) 左侧，即能得到导数。 例题1 ： \\(f={\\boldsymbol a}&#94;{\\text{T}}{\\bf X}{\\boldsymbol b}\\) ，求： \\(\\frac{\\partial f}{\\partial {\\bf X}}\\) 。其\b中 \\(\b{\\boldsymbol a}\\) 是 \\(m\\times 1\\) 列向量， \\(\b{\\bf X}\\) 是 \\(m\\times n\\) 矩阵， \\({\\boldsymbol b}\\) 是 \\(n\\times 1\\) 列向量， \\(f\\) 是标量。 解答 ： 全微分： $$df={\\boldsymbol a}&#94;{\\text{T}}d{\\bf X}{\\boldsymbol b}$$ 两边取迹： $$df=\\text{tr}({\\boldsymbol a}&#94;{\\text{T}}d{\\bf X}{\\boldsymbol b})=\\text{tr}({\\boldsymbol b}{\\boldsymbol a}&#94;{\\text{T}}d{\\bf X})$$ 对照全微\b分公式： $$(\\frac{\\partial f}{\\partial {\\bf X}})&#94;{\\text{T}}={\\boldsymbol b}{\\boldsymbol a}&#94;{\\text{T}}$$ 得到： $$\\frac{\\partial f}{\\partial {\\bf X}}=({\\boldsymbol b}{\\boldsymbol a}&#94;{\\text{T}})&#94;{\\text{T}}={\\boldsymbol a}{\\boldsymbol b}&#94;{\\text{T}}$$ 例题2 ： \\(f={\\boldsymbol a}&#94;{\\text{T}}\\text{exp}({\\bf X}{\\boldsymbol b})\\) ，求： \\(\\frac{\\partial f}{\\partial {\\bf X}}\\) 。其中 \\(\\boldsymbol{a}\\) 是 \\(m\\times 1\\) 列向量， \\({\\bf X}\\) 是 \\(m\\times n\\) 矩阵， \\(\\boldsymbol{b}\\) 是 \\(n\\times 1\\) 列向量， \\(\\text{exp}\\) 表示逐元素求指数， \\(f\\) 是标量。 解答 ： 全微分： $$df=\\boldsymbol{a}&#94;{\\text{T}}\\left(\\text{exp}({\\bf X}{\\boldsymbol b})\\odot(d{\\bf X}{\\boldsymbol b})\\right)$$ 两边取迹： $$df = \\text{tr}( \\boldsymbol{a}&#94;{\\text{T}}(\\exp({\\bf X}\\boldsymbol{b})\\odot (d{\\bf X}\\boldsymbol{b}))) \\\\ =\\text{tr}((\\boldsymbol{a}\\odot \\exp({\\bf X}\\boldsymbol{b}))&#94;{\\text{T}}dX \\boldsymbol{b}) \\\\ = \\text{tr}(\\boldsymbol{b}(\\boldsymbol{a}\\odot \\exp({\\bf X}\\boldsymbol{b}))&#94;\\text{T}d{\\bf X})$$ 对照全微\b分公式得到： $$\\frac{\\partial f}{\\partial {\\bf X}} = (\\boldsymbol{b}(\\boldsymbol{a}\\odot \\exp({\\bf X}\\boldsymbol{b}))&#94;{\\text{T}})&#94;{\\text{T}}= (\\boldsymbol{a}\\odot \\exp({\\bf X}\\boldsymbol{b}))\\boldsymbol{b}&#94;{\\text{T}}$$ 例题3 ：线性回归问题。 \\(l = \\|{\\bf X}\\boldsymbol{w}- \\boldsymbol{y}\\|&#94;2\\) 。求 \\(\\boldsymbol{w}\\) 的最小二乘估计，即求 \\(\\frac{\\partial l}{\\partial \\boldsymbol{w}}\\) 的零点。其中 \\(\\boldsymbol{y}\\) 是 \\(m\\times 1\\) 列向量， \\({\\bf X}\\) 是 \\(m\\times n\\) 矩阵， \\(\\boldsymbol{w}\\) 是 \\(n\\times 1\\) 列向量， \\(l\\) 是标量。 解答 ： 改写模平方表达式： $$l = ({\\bf X}\\boldsymbol{w}- \\boldsymbol{y})&#94;{\\text{T}}({\\bf X}\\boldsymbol{w}- \\boldsymbol{y})$$ 全微分： $$dl = ({\\bf X}d\\boldsymbol{w})&#94;\\text{T}({\\bf X}\\boldsymbol{w}-\\boldsymbol{y})+({\\bf X}\\boldsymbol{w}-\\boldsymbol{y})&#94;\\text{T}({\\bf X}d\\boldsymbol{w}) = 2({\\bf X}\\boldsymbol{w}-\\boldsymbol{y})&#94;\\text{T}{\\bf X}d\\boldsymbol{w}$$ 对照全微\b分公式得到： $$\\frac{\\partial l}{\\partial \\boldsymbol{w}}= (2({\\bf X}\\boldsymbol{w}-\\boldsymbol{y})&#94;\\text{T}{\\bf X})&#94;\\text{T} = 2{\\boldsymbol X}&#94;\\text{T}({\\bf X}\\boldsymbol{w}-\\boldsymbol{y})$$ \\(\\frac{\\partial l}{\\partial \\boldsymbol{w}}\\) 的零点即 \\(\\frac{\\partial l}{\\partial \\boldsymbol{w}}\\) 的最小二乘估计 \\(\\boldsymbol{w} = ({\\bf X&#94;\\text{T}X})&#94;{-1}{\\bf X}&#94;\\text{T}\\boldsymbol{y}\\) 例题4 ：方差的最大似然估计。样本 \\(\\boldsymbol{x}_1,\\dots, \\boldsymbol{x}_n\\sim N(\\boldsymbol{\\mu}, \\Sigma)\\) ，求方差 \\(\\Sigma\\) 的最大似然估计。写成数学式是： \\(l =\\log|\\Sigma|+\\frac{1}{n}\\sum_{i=1}&#94;n(\\boldsymbol{x}_i-\\boldsymbol{\\bar{x}})&#94;\\text{T}\\Sigma&#94;{-1}(\\boldsymbol{x}_i-\\boldsymbol{\\bar{x}})\\) ，求 \\(\\frac{\\partial l }{\\partial \\Sigma}\\) 的零点。其中 \\(\\boldsymbol{x}_i\\) 是 \\(m\\times 1\\) 列向量， \\(\\overline{\\boldsymbol{x}}=\\frac{1}{n}\\sum_{i=1}&#94;n \\boldsymbol{x}_i\\) 是样本均值， \\(\\Sigma\\) 是 \\(m\\times m\\) 对称正定矩阵， \\(l\\) 是标量。 解答 ： 第一项： $$d\\log|\\Sigma| = |\\Sigma|&#94;{-1}d|\\Sigma| = \\text{tr}(\\Sigma&#94;{-1}d\\Sigma)$$ 第二项： $$\\frac{1}{n}\\sum_{i=1}&#94;n(\\boldsymbol{x}_i-\\boldsymbol{\\bar{x}})&#94;\\text{T}d\\Sigma&#94;{-1}(\\boldsymbol{x}_i-\\boldsymbol{\\bar{x}}) = -\\frac{1}{n}\\sum_{i=1}&#94;n(\\boldsymbol{x}_i-\\boldsymbol{\\bar{x}})&#94;\\text{T}\\Sigma&#94;{-1}d\\Sigma\\Sigma&#94;{-1}(\\boldsymbol{x}_i-\\boldsymbol{\\bar{x}})$$ 第二项求迹： $$\\text{tr}\\left(\\frac{1}{n}\\sum_{i=1}&#94;n(\\boldsymbol{x}_i-\\boldsymbol{\\bar{x}})&#94;\\text{T}\\Sigma&#94;{-1}d\\Sigma\\Sigma&#94;{-1}(\\boldsymbol{x}_i-\\boldsymbol{\\bar{x}})\\right)\\\\ =\\frac{1}{n} \\sum_{i=1}&#94;n \\text{tr}((\\boldsymbol{x}_i-\\boldsymbol{\\bar{x}})&#94;\\text{T}\\Sigma&#94;{-1} d\\Sigma \\Sigma&#94;{-1}(\\boldsymbol{x}_i-\\boldsymbol{\\bar{x}}))\\\\ = \\frac{1}{n}\\sum_{i=1}&#94;n\\text{tr}\\left(\\Sigma&#94;{-1}(\\boldsymbol{x}_i-\\boldsymbol{\\bar{x}})(\\boldsymbol{x}_i-\\boldsymbol{\\bar{x}})&#94;\\text{T}\\Sigma&#94;{-1}d\\Sigma\\right)=\\text{tr}(\\Sigma&#94;{-1}S\\Sigma&#94;{-1}d\\Sigma)$$ 定义： $$S = \\frac{1}{n}\\sum_{i=1}&#94;n(\\boldsymbol{x}_i-\\boldsymbol{\\bar{x}})(\\boldsymbol{x}_i-\\boldsymbol{\\bar{x}})&#94;\\text{T}$$ 为样本方差矩阵 得到： $$dl = \\text{tr}\\left(\\left(\\Sigma&#94;{-1}-\\Sigma&#94;{-1}S\\Sigma&#94;{-1}\\right)d\\Sigma\\right)$$ 对照全微\b分公式得到： $$\\frac{\\partial l }{\\partial \\Sigma}=(\\Sigma&#94;{-1}-\\Sigma&#94;{-1}S\\Sigma&#94;{-1})&#94;\\text{T}$$ 其零点即 \\(\\Sigma\\) 的最大似然估计为 \\(\\Sigma = S\\) 例题5 ：多元 logistic 回归。 \\(l = -\\boldsymbol{y}&#94;\\text{T}\\ln\\text{softmax}({\\bf W}\\boldsymbol{x})\\) ，求 \\(\\frac{\\partial l}{\\partial W}\\) 。其中 \\(\\boldsymbol{y}\\) 是除一个元素为1外其它元素为0的 \\(m\\times 1\\) 列向量， \\({\\bf W}\\) 是 \\(m\\times n\\) 矩阵， \\(\\boldsymbol{x}\\) 是 \\(n\\times 1\\) 列向量， \\(l\\) 是标量； \\(\\text{softmax}(\\boldsymbol{a}) = \\frac{\\exp(\\boldsymbol{a})}{\\boldsymbol{1}&#94;\\text{T}\\exp(\\boldsymbol{a})}\\) ，其中 \\(\\exp(\\boldsymbol{a})\\) 表示逐元素求指数， \\(\\boldsymbol{1}\\) 代表全1向量。 解答 ： 首先将 softmax 函数代入并写成： $$l = -\\boldsymbol{y}&#94;\\text{T} \\left(\\ln (\\exp({\\bf W}\\boldsymbol{x}))-\\boldsymbol{1}\\ln(\\boldsymbol{1}&#94;\\text{T}\\exp({\\bf W}\\boldsymbol{x}))\\right) \\\\ = -\\boldsymbol{y}&#94;\\text{T}{\\bf W}\\boldsymbol{x} + \\ln(\\boldsymbol{1}&#94;\\text{T}\\exp({\\bf W}\\boldsymbol{x}))\\\\$$ 这里注意：注意逐元素 log 满足等\b式： $$\\ln(\\boldsymbol{u}/c) = \\ln(\\boldsymbol{u}) - \\boldsymbol{1}\\ln(c)$$ 以及： $$\\boldsymbol{y}&#94;\\text{T} \\boldsymbol{1} = 1$$ 求微分： $$dl =-\\boldsymbol{y}&#94;\\text{T}d{\\bf W}\\boldsymbol{x}+\\frac{\\boldsymbol{1}&#94;\\text{T}\\left(\\exp({\\bf {\\bf W}}\\boldsymbol{x})\\odot(d{\\bf W}\\boldsymbol{x})\\right)}{\\boldsymbol{1}&#94;\\text{T}\\exp({\\bf W}\\boldsymbol{x})}$$ 根据： $$\\boldsymbol{1}&#94;\\text{T} (\\boldsymbol{u}\\odot \\boldsymbol{v}) = \\boldsymbol{u}&#94;\\text{T} \\boldsymbol{v}$$ 得： $$\\boldsymbol{1}&#94;\\text{T}\\left(\\exp({\\bf W}\\boldsymbol{x})\\odot(d{\\bf W}\\boldsymbol{x})\\right) = \\exp({\\bf W}\\boldsymbol{x})&#94;\\text{T}d{\\bf W}\\boldsymbol{x}$$ 求迹化简为： $$dl = \\text{tr}\\left(-\\boldsymbol{y}&#94;\\text{T}d{\\bf W}\\boldsymbol{x}+\\frac{\\exp({\\bf W}\\boldsymbol{x})&#94;\\text{T}d{\\bf W}\\boldsymbol{x}}{\\boldsymbol{1}&#94;\\text{T}\\exp({\\bf W}\\boldsymbol{x})}\\right) =\\text{tr}(\\boldsymbol{x}(\\text{softmax}({\\bf W}\\boldsymbol{x})-\\boldsymbol{y})&#94;\\text{T}d{\\bf W})$$ 得到： $$\\frac{\\partial l}{\\partial {\\bf W}}= (\\text{softmax}({\\bf W}\\boldsymbol{x})-\\boldsymbol{y})\\boldsymbol{x}&#94;\\text{T}$$ 例题5 ：二层神经网络\b。 \\(l = -\\boldsymbol{y}&#94;\\text{T}\\log\\text{softmax}({\\bf W_2}\\sigma({\\bf W_1}\\boldsymbol{x}))\\) ，求 \\(\\frac{\\partial l}{\\partial {\\bf W_1}}\\) 和 \\(\\frac{\\partial l}{\\partial \\bf{W_2}}\\) 。其中 \\(\\boldsymbol{y}\\) 是除一个元素为1外其它元素为0的的 \\(m\\times 1\\) 列向量， \\({\\bf W_2}\\) 是 \\(m\\times p\\) 矩阵， \\({\\bf W_1}\\) 是 \\(p\\times n\\) 矩阵， \\(\\boldsymbol{x}\\) 是 \\(n\\times 1\\) 列向量， \\(l\\) 是标量； \\(\\text{softmax}(\\boldsymbol{a}) = \\frac{\\exp(\\boldsymbol{a})}{\\boldsymbol{1}&#94;\\text{T}\\exp(\\boldsymbol{a})}\\) 同例5， \\(\\sigma(\\cdot)\\) 是逐元素 sigmoid 函数 \\(\\sigma(a) = \\frac{1}{1+\\exp(-a)}\\) 。 解答 ： 定义： $$\\boldsymbol{a}_1={\\bf W_1}\\boldsymbol{x}，\\boldsymbol{h}_1 = \\sigma(\\boldsymbol{a}_1)，\\boldsymbol{a}_2 = {\\bf W_2} \\boldsymbol{h}_1$$ 则： $$l =-\\boldsymbol{y}&#94;\\text{T}\\log\\text{softmax}(\\boldsymbol{a}_2)$$ 在例5中已求出： $$\\frac{\\partial l}{\\partial \\boldsymbol{a}_2} = \\text{softmax}(\\boldsymbol{a}_2)-\\boldsymbol{y}$$ 使用复合法则，注意此处 \\(\\boldsymbol{h}_1, {\\bf W_2}\\) 都是变量： $$dl = \\text{tr}\\left(\\frac{\\partial l}{\\partial \\boldsymbol{a}_2}&#94;\\text{T}d\\boldsymbol{a}_2\\right) = \\text{tr}\\left(\\frac{\\partial l}{\\partial \\boldsymbol{a}_2}&#94;\\text{T}dW_2 \\boldsymbol{h}_1\\right) + \\text{tr}\\left(\\frac{\\partial l}{\\partial \\boldsymbol{a}_2}&#94;\\text{T}W_2 d\\boldsymbol{h}_1\\right)$$ 使用矩阵乘法交换的迹技巧从第一项得到： $$\\frac{\\partial l}{\\partial W_2}= \\frac{\\partial l}{\\partial\\boldsymbol{a}_2}\\boldsymbol{h}_1&#94;\\text{T}$$ 从第二项得到： $$\\frac{\\partial l}{\\partial \\boldsymbol{h}_1}= W_2&#94;\\text{T}\\frac{\\partial l}{\\partial\\boldsymbol{a}_2}$$ 接下来求 \\(\\frac{\\partial l}{\\partial \\boldsymbol{a}_1}\\) ，继续使用复合法则，并利用矩阵乘法和逐元素乘法交换的迹技巧： $$\\text{tr}\\left(\\frac{\\partial l}{\\partial\\boldsymbol{h}_1}&#94;\\text{T}d\\boldsymbol{h}_1\\right) = \\text{tr}\\left(\\frac{\\partial l}{\\partial\\boldsymbol{h}_1}&#94;\\text{T}(\\sigma'(\\boldsymbol{a}_1)\\odot d\\boldsymbol{a}_1)\\right) = \\text{tr}\\left(\\left(\\frac{\\partial l}{\\partial\\boldsymbol{h}_1}\\odot \\sigma'(\\boldsymbol{a}_1)\\right)&#94;\\text{T}d\\boldsymbol{a}_1\\right)$$ 得到： $$\\frac{\\partial l}{\\partial \\boldsymbol{a}_1}= \\frac{\\partial l}{\\partial\\boldsymbol{h}_1}\\odot\\sigma'(\\boldsymbol{a}_1)$$ 为求 \\(\\frac{\\partial l}{\\partial {\\bf W_1}}\\) ，再用一次复合法则 ： $$\\text{tr}\\left(\\frac{\\partial l}{\\partial\\boldsymbol{a}_1}&#94;\\text{T}d\\boldsymbol{a}_1\\right) = \\text{tr}\\left(\\frac{\\partial l}{\\partial\\boldsymbol{a}_1}&#94;\\text{T}d{\\bf W_1}\\boldsymbol{x}\\right) = \\text{tr}\\left(\\boldsymbol{x}\\frac{\\partial l}{\\partial\\boldsymbol{a}_1}&#94;\\text{T}d{\\bf W_1}\\right)$$ 得到： $$\\frac{\\partial l}{\\partial {\\bf W_1}}= \\frac{\\partial l}{\\partial\\boldsymbol{a}_1}\\boldsymbol{x}&#94;\\text{T}$$ if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"基础知识","url":"https://xutree.github.io/pages/2018/10/23/矩阵求导/"},{"title":"C++ Primer 第十七章 标准库特殊设施","text":"tuple 类型 当我们希望将一些数据组合成单一对象，但又不想麻烦地定义一个新数据结构来表示这些数据时，可以使用 tuple 类型。与 pair 类似，但 tuple 可以有任意数量的成员。它的一个常见用途就是从一个函数返回多个值。 tuple 定义在同名的头文件中。 支持的操作： 要访问一个 tuple 的成员，使用 get 标准库模板。为了使用 get ，我们必须指定一个显式模板参数，它指明我们想要访问第几个成员。这个显式模板参数必须是一个整型常量表达式，从0开始计数，返回指定成员的引用。 auto book = get<0>(item); // 返回 item 的第一个成员 get<0>(item) *= 0.8; // 修改书的单价 借助辅助类模板 tuple_size 和 tuple_element ，可以查询 tuple 成员的数量和类型。不过使用这两个类，必须知道 tuple 对象的类型，这可以通过 decltype 很简单地得到： typedef decltype(item) trans; // 返回 trans 类型对象中成员的数量 size_t sz = tuple_size<trans>::value; // 返回 3 // cnt 的类型与 item 中第二个成员相同，是一个 int tuple_element<1, trans>::type cnt = get<1>(item); 只有两个 tuple 具有相同数量的成员，且每对成员使用 == 或 < 是合法时，才能比较两个 tuple 。另外，由于 tuple 定义了 < 和 == 运算符，可以将 tuple 序列传递给算法，并且可以在无序容器中将 tuple 作为关键字类型。 bitset 类型 bitset 类，可以方便地将整型运算对象当作二进制位集合处理，并且能够处理超过最长整型类型大小的位集合。 bitset 定义在同名的头文件中。 支持的操作： 使用字符串初始化 bitset 时，下标最小的字符对应 bitset 中的高位。 bitset<32> bitvec4(\"1100\"); // 2、3两位为1，剩余位为0 正则表达式 RE 库定义在头文件 regex 中。 组件 意义 regex 表示有一个正则表达式的类 regex_match 将一个字符序列与一个正则表达式匹配，整串匹配返回 true regex_search 寻找第一个与正则表达式匹配的子序列，有子串匹配，返回 true regex_replace 使用给定格式替换一个正则表达式 regex_iterator 迭代器适配器，调用 regex_search 来遍历一个 string 中所有匹配的子串 smatch 容器类，保存 string 中搜索的结果 ssub_match string 中匹配的子表达式的结果 regex_search 和 regex_search 的参数如下，这些操作都返回 bool ，指出是否找到匹配： (seq, m, r, mft) 或 (seq, r, mft) ：在字符序列 seq 中查找 regex 对象 r 中的正则表达式。seq 可以是一个 string 、表示范围的一对迭代器以及一个指向空字符结尾的字符数组的指针。m 是一个 match 对象，用来保存匹配结果的相关细节。m 和 seq 必须具有兼容的类型。mft 是一个可选的 regex_constants::match_flag_type 值，它们会影响匹配过程。 待续...","tags":"读书笔记","url":"https://xutree.github.io/pages/2018/10/21/C++_Primer_Chapter_17/"},{"title":"C++ Primer 第十六章 模板与泛型编程","text":"面向对象编程（OOP）和泛型编程都能处理在编写程序时不知道类型的情况。不同之处是：OOP能处理类型在程序运行之前都未知的情况；而在泛型编程中，在编译时就能获知类型了。 容器、迭代器和算法都是泛型编程的例子。模板是 C++ 中泛型编程的基础。一个模板就是一个创建类或函数的蓝图或者说公式。 定义模板 函数模板 模板的定义以关键字 template 开始，后面跟一个模板参数列表，用 <> 括起来。 模板有类型参数（type parameter）和非类型参数（nontype parameter）之分。 类型参数 我们可以将类型参数看作类型说明符，就像内置类型或类类型说明符一样使用。 类型参数可以用来指定返回类型或函数的参数类型，以及在函数体内用于变量声明或类型转换。 参数列表中，类型参数前必须使用关键字 class 或 typename 。在模板定义中，模板参数列表不能为空。 // 错误，U 之前必须加上 class 或 typename template <typename T, U> T calc(const T&, const U&); 非类型参数 除了定义类型参数，还可以在模板中定义非类型参数，通过一个特定的类型名而非关键字 class 或 typename 来指定非类型参数。 因为编译器需要在编译时实例化模板，此时非类型参数会被一个用户提供的或编译器推断出的值所代替，所以这些值必须是常量表达式。 非类型参数可以是一个整型，对应的模板实参必须是常量表达式。而在模板定义内，可以将这个非类型参数用在任何需要常量表达式的地方，如指定数组大小。 template <unsigned N, unsigned M> int compare(const cahr (&p1)[N], const cahr (&p2)[M]) [ return strcmp(p1, p2); } compare(\"hi\", \"mom\"); // 上式调用会实例化处如下版本，注意字符串字面常量的末尾有一个空字符！ int compare(const cahr (&p1)[3], const cahr (&p2)[4]) 也可以是一个指向对象或函数类型的指针或（左值）引用。绑定到指针或引用非类型参数的实参必须具有静态的生存期。 inline 和 constexpr 的函数模板 函数模板可以声明为 inline 或 constexpr 的，如同非模板函数一样。 inline 或 constexpr 说明符放在模板参数列表之后，返回类型之前： //正确，inline 说明符跟在模板参数列表之后 template <typename T> inline T min(const T&, const T&); //错误：inline 说明符的位置不正确 inline template <typename T> T min(const T&, const T&); 编写类型无关的代码 为了提高适用性，模板程序应尽量减少对实参类型的要求。 模板中的函数参数是 const 的引用。这样做一方面保证了即使参数类型不支持拷贝，模板程序也能正确运行；另一方面引用不会引起对象的拷贝构造，提高运行性能。 模板中使用到的类型相关的函数或运算符应尽可能的少。 模板编译 当编译器遇到一个模板定义时，它并不生成代码。只有当我们实例化出模板的一个特定版本时，编译器才会生成代码。 通常，当我们调用一个函数时，编译器只需要掌握函数的声明。类似的，当我们使用一个类类型的对象时，类定义必须是可用的，但成员函数的定义不必已经出现。因此，我们将类定义和函数声明放在头文件中，而普通函数和类的成员函数的定义放在源文件中。 为了生成一个实例化版本，编译器需要掌握函数模板或类模板成员函数的定义。因此，与非模板代码不同，模板不能分离式编译，其头文件中通常既包括声明也包括定义。 大多数编译错误在实例化期间报告 模板直到实例化时才会生成代码，大多数编译错误在实例化期间报告。通常，编译器会在三个阶段报告错误。 第一个阶段是编译模板本身时。这个阶段，编译器可以检查语法错误，如忘记分号或者变量名拼错等。 第二个阶段是编译器遇到模板使用时。对于函数模板调用，会检查实参数目是否正确和参数类型是否匹配。对于类模板，则只检查模板实参数目是否正确。 第三个阶段是模板实例化时，只有这个阶段才能发现类型相关的错误。依赖于编译器如何管理实例化，这类错误可能在链接时才报告。 类模板 类模板（class template）是用来生成类的蓝图的。与函数模板的不同之处是，编译器不能为类模板推断模板参数类型。使用时，必须显式提供模板实参。 定义类模板 在类模板（及其成员）的定义中，我们将模板参数当做替身，代替使用模板时用户需要提供的类型或值： template < typename T > class Bolb { public : typedef T value_type ; typedef typename std :: vector < T >:: size_type size_type ; //构造函数 Bolb (); Bolb ( std :: initializer_list < T > il ); //Bolb中的元素数目 size_type size () const { return data -> size (); } bool empty () const { return data -> empty (); } //添加和删除元素 void push_back ( const T & t ) { data -> push_back ( t ); } //移动版本 void push_back ( T && t ) { data -> push_back ( std :: move ( t )); } void pop_back (); //元素访问 T & back (); T & operator []( size_type i ); private : std :: shared_ptr < std :: vector < T >> data ; //若data[i]无效，则抛出msg void check ( size_type i , const std :: string & msg ) const ; }; 实例化模板 当使用一个类模板时，我们必须提供额外信息。我们现在知道这些额外信息是显式模板实参（explicit template argument）列表，它们被绑定到模板参数。例如： Bolb<int> ia; //空 Bolb<int> Bolb<int> ia2 = {0,1,2,3,4}; //有5个元素的 Bolb<int> 一个类模板的每个实例都形成一个独立的类。Bolb 与任何其他 Bolb 类型没有关联，也不会对任何其他 Bolb 类型的成员有特殊访问权限。 类模板的成员函数 我们既可以在类模板内部，也可以在外部为其定义成员函数。定义在类模板之外的成员函数必须以关键字 template 开始，后接类模板参数列表。 默认情况下，一个类模板的成员函数只有当程序用到它时才进行实例化。这一特性使得即使某种类型不能完全符合模板操作的要求，仍然能用该类型实例化类，但相应操作无法使用！ 在类代码内简化模板类型的使用 在类模板自己的作用域中，我们可以直接使用模板名而不提供实参，其他情况下都必须提供模板实参。： template < typename T > class BolbPtr { public : ... //递增和递减 BolbPtr & operator ++ (); //前置运算符 BolbPtr & operator -- (); ... }; 上述 BolbPtr 的前置递增和递减成员返回 BolbPtr&，而不是 BolbPtr &。当我们处于一个类模板的作用域时，编译器处理模板自身引用时就好像我们已经提供了与模板参数匹配的实参一样。 template <typename T> // 返回类型，处于类的作用域之外，需要提供模板实参 BlobPtr<T> BlobPtr<T>::operator++(int) { // 函数体内，处于类的作用域之内 BlobPtr ret = *this; ... } 类模板和友元 如果一个类模板包含一个非模板友元，则友元被授权可以访问所有模板实例；如果友元自身是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例。 一对一友好关系。用相同模板实参实例化的友元是该类的友元，可以访问非 public 部分，而对于用其他实参实例化的实例则没有特殊访问权限。 // 为了在 Blob 中声明友元，需要前置声明 template < typename T > class BlobPtr ; template < typename T > class Blob ; // 声明运算符 == 中的参数所需要的 template < typename T > bool operator == ( const Blob < T > & lhs , const Blob < T > & rhs ); template < typename T > class Blob { // 每个 Blob 实例将访问权限授予用相同类型实例化的 BlobPtr 和相等运算符 friend class BlobPtr < T > ; friend bool operator ==< T > ( const MyBlobPtr & lhs , const MyBlobPtr & rhs ); // 其它成员定义 }; // BlobPtr<char> 的成员可以访问 ca（或任何其它 Blob<char>对象）的非 public 部分 Blob < char > ca ; Blob < int > ia ; 通用和特定的模板友好关系。为了让所有实例成为友元，友元声明中必须使用与类模板本身不同的模板参数。 // 前置声明，在将模板的一个特定实例声明为友元时要用到 template < typename T > class Pal ; class C { // C是一个普通的非模板类 friend class Pal < C > ; // 用类 C 实例化的 Pal 是 C 的一个友元 // Pal2 的所有实例都是 C 的友元，这种情况无须前置声明 template < typename T > friend class Pal2 ; }; template < typename T > class C2 { // C2 本身是一个模板 // C2 的每个实例将相同实例化的 Pal 声明为友元 friend class Pal < T > ; // Pal 的模板声明必须在作用域之内 // Pal2 的所有实例都是 C2 的每个实例的友元，不需要前置声明 template < typename X > friend class Pal2 ; // Pal3 是一个非模板类，它是 C2 所有实例的友元 friend class Pal3 ; // 不需要 Pal3 的前置声明 }; 令模板自己的类型参数成为友元。在 C++11 新标准中，我们可以将模板类型参数声明为友元： template < typename Type > class Bar { friend Type ; //将访问权限授予用来实例化 Bar 的类型 //... }; 因此，对于某个类型名 Foo，Foo 将成为 Bar 的友元。 模板类型别名 类模板的一个实例定义了一个类型，与任何其他类类型一样，我们可以定义一个 typedef 来引用实例化的类： typedef Blob<string> StrBlob; 由于模板不是一个类型，我们不能定义一个 typedef 引用一个模板。即，无法定义一个 typedef 引用 Blob 。 但是，C++11 新标准允许我们为类模板定义一个类型别名： template <typename T> using twin = pair<T,T>; twin<string> authors; //autohors 是一个 pair<string,string> 当我们定义一个模板类型别名时，可以固定一个或多个模板参数： template <typename T> using partNo = pair<T, unsigned>; partNo<string> books; //books 是一个 pair<string, unsigned> partNo<Vehicle> cars; //cars 是一个 pair<Vehicle, unsigned> partNo<Student> kids; //kids 是一个 pair<Student, unsigned> 类模板的 static 成员 对于类模板 Foo 中的 static 成员 ctr，对于任意给定类型 X，都有一个 Foo::ctr 成员。所有 Foo 类型的对象共享相同的 ctr 成员： template < typename T > class Foo { public : static std :: size_t count () { return ctr ; } // 其它接口成员 private : static std :: size_t ctr ; // 其它数据成员 } ; // 所有三个对象共享相同的 Foo < int > :: ctr 和 Foo < int > :: count 成员 Foo < int > fi , fi2 , fi3 ; 类模板的 static 成员，可以通过类类型对象来访问，也可以用作用域运算符直接访问该成员，不过必须提供一个特定的模板实参。另外， static 成员函数也是只在使用时才会被初始化： Foo < int > fi ; // 实例化 Foo < int > 类和 static 数据成员 ctr auto ct = Foo < int > :: count (); // 实例化 Foo < int > :: count ct = fi . count (); // 使用 Foo < int > :: count ct = Foo :: count (); // 错误 ， 无法确定使用哪个模板实例化的 count 模板参数 一个模板参数的名字也没有什么内在含义，我们通常将类型参数命名为 T，但实际上我们可以使用任何名字。 模板参数名的可用范围是在其声明之后，至模板声明或定义结束之前。模板参数会隐藏外层作用域中声明的相同名字，但是在模板内不能重用模板参数名。 typedef double A; template <typename A, typename B> void f(A a, B b) { A tmp = a; // tmp的类型为模板参数 A 的类型，而非 double double B; // 错误，重声明模板参数 B } 模板声明必须包含模板参数，声明中的模板参数的名字不必与定义中相同。 template <typename T> class Blob; // 声明但不定义 使用类的类型成员 假定 T 是一个模板类型参数，当编译器遇到类似 T::mem 这样的代码时，它不知道 mem 是一个类型成员还是一个 static 数据成员，直至实例化时才会知道。 但是为了处理模板，编译器必须知道名字是否表示一个类型。例如： T::size_type * p; 。编译器需要知道我们是在定义一个名为 p 的变量还是将一个名为 size_type 的 static 数据成员与名为 p 的变量相乘。 默认情况，C++ 语言假定通过作用域运算符访问的名字不是类型。因此，如果我们希望使用一个模板类型参数的类型成员，就必须显式告诉编译器该名字是一个类型。 我们通过使用关键字 typename 来实现这一点： template < typename T > typename T :: value_type top ( const T & c ) { if (!c.empty()) return c.back() ; else return typename T : : value_type (); } 默认模板实参 在新标准中，我们可以为函数和类模板提供默认实参。而更早的 C++ 标准只允许为类模板提供默认实参。 //compare有一个默认模板实参 less<T> 和一个默认函数实参 F() template <typename T, typename F = less<T>> int compare(const T &v1, const T &b2, F f = F()) { if (f(v1, v2)) return -1; if (f(v2, v1)) return 1; return 0; } 如果一个类模板为其所有模板参数都提供了模板实参，且我们希望使用这些默认实参，就必须在模板名之后跟一个空尖括号对。 成员模板 一个类可以包含本身是模板的成员函数。这种成员被称为成员模板（member template）。成员模板不能是虚函数（Member template functions cannot be declared virtual.Current compiler technology experts to be able to determine the size of a class's virtual function table when the class is parsed.Allowing virtual member template functions woule require knowing all calls to such member functions everywhere in the program ahead of time.This is not feasible,especially for multi-file projects.） 普通（非模板）类的成员模板 我们定义一个类，类似 unique_ptr 所使用的默认删除器类型： //函数对象类，对给定指针执行 delete class DebugDelete { public : DebugDelete ( std :: ostream & s = std :: cerr ) : os ( s ) {} //与任何函数模板相同，T 的类型由编译器推断 template < typename T > void operator ()( T * p ) const { os << \"deleting unqiue_ptr\" << std :: endl ; delete p ; } private : std :: ostream & os ; }; 我们可以用这个类代替 delete ： double *p = new double; DebugDelete d; //可像 delete 表达式一样使用的对象 d(p); //调用 DebugDelete::operator()(double*),释放 p int* ip = new int; //在一个临时 DebugDelete 对象上调用 operator()(int*) DebugDelete()(ip); 类模板的成员模板 在此情况下，类和成员各有自己的独立的模板参数。例如，我们将 Blob 类定义一个构造函数，它接受两个迭代器，表示要拷贝的元素范围，我们希望支持不同类型序列的迭代器： template < typename T > class Blob { template < typename It > Blob ( It b , It e ); //... }; 当我们在类模板外定义一个成员模板时，必须同时为类模板和成员模板提供模板参数列表。类模板的参数列表在前，后跟成员自己的模板参数列表： template <typename T> template <typename It> Blob<T>::Blob(It b, It e) : data(std::make_shared<std::vector<T>(b,e)) {} 实例化成员模板 为了实例化一个类模板的成员模板，我们必须同时提供类和函数模板的实参： int ia[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; vector<long> vi = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; list<const char*> w = {\"now\", \"is\", \"the\", \"time\"}; //实例化 Blob<int> 类及其接受两个 int* 参数的构造函数 Blob<int> a1(begin(ia), end(ia)); 控制实例化 模板被使用时才会进行实例化，这意味着，当两个或多个独立编译的源文件使用了相同的模板，并提供了相同的模板参数时，每个文件中就都会有该模板的一个实例。 相同的实例可能出现在多个对象文件中，在多个文件中实例化相同模板的额外开销可能非常大。在新标准中，我们可以通过显示实例化（explicit instantiation）来避免这种开销。 形式： extern template declaration; //实例化声明 template declaration; //实例化定义 declaration 是一个类或函数声明，其中所有模板参数已被替换为模板实参，例如： //实例化声明与定义 extern template class Blob<string>; //声明 template int compare(const int&, const int&); //定义 当编译器遇到 extern 模板声明时，它不会在本文件中生成实例代码。将一个实例化声明为 extern 就表示承诺在程序其他位置有该实例化的一个非 extern 声明（定义）。对于一个给定的实例化版本，可能有多个 extern 声明，但必须只有一个定义。 由于编译器在使用一个模板时自动对其实例化，因此 extern 声明必须出现在任何使用此实例化版本的代码之前： // Application.cc // 这些模板类型必须在程序其它位置进行实例化 extern template class Blob<string>; extern template int compare(const int&, const int&); Blob<string> sa1, sa2; // 实例化会出现在其他位置 // Blob<int>及其接受 initializer_list 的构造函数在本文件中实例化 Blob<int> a1 = {0, 1, 2, 3, 4}; Blob<int> a2(a1); // 拷贝构造函数在本文件中实例化 int i = compare(a1[0], a2[0]); // 实例化出现在其他位置 // templateBuild.cc // 实例化文件必须为每个在其他文件中声明为 extern 的类型和函数提供一个（非 extern）的定义 template int compare(const int&, const int&); template class Blob<string>; 与类模板的普通实例化不同，类模板的显式实例化定义会实例化该模板的所有成员。因此，用来显示实例化一个类模板的类型，必须能用于模板的所有成员。 效率与灵活性 对模板设计者所面对的设计选择，标准库智能指针类型给出了一个很好的展示。 shared_ptr 和 unique_ptr 之间的明显不同是它们管理所保存的指针的策略——前者给予我们共享指针所有权的能力；后置则独占指针。 这两个类的另一差异是它们允许用户重载默认删除器的方式：我们可以很容器地重载一个 shared_ptr 的删除器，只要在创建或 reset 指针时传递给他一个可调用对象即可；与之相反，删除器类型是 unique_ptr 对象类型的一部分，用户必须在定义 unique_ptr 时以显示模板实参的形式提供删除器的类型。 在运行时绑定删除器（shared_ptr） 虽然我们不知道标准库类型是如何实现的，但可以推断出， shared_ptr 必须能直接访问其删除器。即删除器必须保存为一个指针或封装了指针的类。 我们可以确定 shared_ptr 不是将删除器直接保存为一个成员，因为删除器的类型运行时才会知道。 在编译时绑定删除器（unique_ptr） 现在，让我来考察 unique_ptr 可能的工作方式： 在这个类中，删除器的类型是类类型的一部分。即 unique_ptr 有两个模板参数，一个表示它所管理的指针，另一个表示删除器的类型。 由于删除器类型是 unique_ptr 的一部分，因此删除器成员的类型在编译时是知道的，从而删除器可以直接保存在 unique_ptr 对象中。 总结：通过在编译时绑定删除器， unique_ptr 避免了间接调用删除器的运行时开销。通过在运行时绑定删除器， shared_ptr 使用户重载删除器更为方便。 模板实参推断 我们已经看到，对于函数模板，编译器利用调用中的函数实参来确定其模板实参。从函数实参来确定模板实参的过程被称为模板实参推断（template argument deduction）。 类型转换与模板类型参数 只有很有限的几种类型转换会自动地应用于模板实参，编译器通常不是对实参进行类型转换，而是生成一个新的模板实例： 顶层 const ，无论是在形参还是实参中，都会被忽略 const 转换，可以将一个非 const 对象的引用（或指针）传递给一个 const 的引用（或指针）形参 数组或函数指针转换：如果函数形参不是引用类型，则可以对数组或函数类型的实参应用正常的指针转换 其他类型转换，如算术转换，派生类向基类转换以及用户定义的转换都不能应用于函数模板 template <typename T> T fobj(T, T); //实参被拷贝 template <typename T> T fref(const T&, const T&); //引用捕获方式；c 显示捕获，值捕获方式 string s1(\"a value\"); const string s2(\"another value\"); fobj(s1, s2); //调用 fobj(string, string);const 被忽略 fref(s1, s2); //调用 fref(const string&, const string&),将 s1 转换为 const 是允许的 int a[10], b[42]; fobj(a, b); //调用 f(int*, int*) fref(a, b); //错误：数组类型不匹配 将实参传递给带模板类型的函数形参时，能够自动应用的类型转换只有 const 转换以及数组或函数到指针的转换。 正常类型转换应用于普通函数实参 函数模板可以有用普通类型定义的参数，即，不涉及模板类型参数的类型。这种函数实参不进行特殊处理；它们正常转换为对应形参的类型。例如： template <typename T> ostream &print(ostream &os, const T &obj) { return os << obj; } //第一个函数参数是一个已知类型 ostream&。第二个参数 obj 则是模板参数类型 //由于 os 的类型是固定的，因此当调用 print 时，传递给它的实参会进行正常的 //类型转换 print(const , 42); //实例化 print(ostream&, int) ofstream f(\"output\"); print(f, 10); //使用 print(ostream&, int);将 f 转换为 ostream& 如果函数参数类型不是模板参数，则对实参进行正常的类型转换。 函数模板显式实参 在某些情况下，编译器无法推断出模板实参的类型。其他一些情况下，我们希望允许用户控制模板实例化。 指定显式模板实参 //编译器无法推断 T1，它未出现在函数参数列表中 template <typename T1, typename T2, typename T3> T1 sum(T2, T3); 本例中，没有任何函数实参的类型可用来推断 T1 的类型。每次调用 sum 时调用者都必须为 T1 提供一个显式模板实参（explicit template argument）。如下： //T1 是显示指定的，T2 和 T3 是从函数实参类型推断而来的 auto val3 = sum<long long>(i, lng); //long long sum(int, long) 显示模板实参按由左至右的顺序与对应的模板参数匹配。推断不出的模板参数的类型在定义时应该放在参数列表的最左边。 正常类型转换应用于普通函数实参 对于模板类型参数已经显式指定了的函数实参，可以进行正常的类型转换。 long lng; compare(lng, 1024); // 错误，模板参数不匹配 compare<long>(lng, 1024); // 正确，1024自动转化为 long 尾置返回类型与类型转换 例如，我们可能希望编写一个函数，接受表示序列的一对迭代器和返回序列中一个元素的引用。但是，我们并不知道返回结果的准确类型，但知道所需类型是处理的序列的元素类型。由于尾置返回出现在参数列表之后，它可以使用函数的参数： //尾置返回允许我们在参数列表之后声明返回类型 template <typename It> auto fcn(It beg, It end) -> decltype(*beg) { //处理序列 return *beg; //返回序列中一个元素的引用 } 使用类型转换的标准库模板类 为了获取元素类型，我们可以使用标准库的类型转换（type transformation）模板。这些模板定义在头文件 type_traits 中。这个头文件的类通常用于模板元编程设计。 // 返回一个序列中的元素值 // 为了使用模板参数的类型成员，必须使用 typename template <typename It> auto fcn(It beg, It end) -> typename remove_reference<decltype(*beg)>::type; { // 处理序列 return *beg; } 函数指针和实参推断 使用函数模板初始化一个函数指针或为一个函数指针赋值时，编译器使用指针的类型来推断模板实参。如果不能从函数指针类型确定模板实参，则产生错误。 template <typename T> int compare(const T&, const T&); // func 的重载版本，每个版本接受一个不同的函数指针类型 void func(int(*)(const string&, const string&)); void func(int(*)(const int&, const int&)); func(compare); // 错误，不能确定使用哪一个实例 // 正确的做法是可以显式指出实例化哪个版本 func(compare<int>); 模板实参推断和引用 从左值引用函数参数推断类型 template <typename T> void f(T &p) ：实参必须是一个左值。如果实参是 const 的，则 T 将被推断为 const 类型。 template <typename T> void f(const T &p) ：实参可以是任意类型(包括右值在内)，即使实参是 const 的，T 的推断类型也不会是一个 const 类型。 从右值引用函数参数推断类型 传递的实参为右值。推断出的 T 的类型是该右值实参的类型。 传递的实参为左值。此时得到的模板参数和函数参数都是左值引用。 对于接受右值引用参数的模板函数，当分别传递右值和左值实参时，模板参数类型可能是普通类型，也可能是引用类型。有时这可能会造成意想不到的结果。解决这种问题的办法是，使用基于函数参数的模板重载，来将实参分别为右值或左值时的情况分离开来： template <typename T> void f3(T&&) { T t = val; // 实参为右值时，赋值语句 // 实参为左值时，绑定引用 t = fcn(t); // 实参为右值时，只改变 t // 实参为左值时，既改变 t，也改变 val } // 定义一组重载函数，解决上述问题 template <typename T> void f(T&&); // 绑定到非 const 右值 template <typename T> void f(const T&); // 绑定到左值和 const 右值 理解 std::move 由于 move 本质上可以接受任何类型的实参，因此我们不会惊讶于它是一个函数模板。 标准库是这样定义 move 的： //在返回类型和类型转换中也要用到 typename template <typename T> typename remove_reference<T>::type&& move(T&& t) { //特例：可以使用 static_cast 显式地将左值转换为右值 return static_cast<typename remove_reference<T>::type&&>(t); } 转发 某些函数需要将其一个或多个实参连同类型不变地转发给其它参数，需要保持转发实参的所有性质，包括实参类型是否是 const 的以及实参是左值还是右值。 // 该模板将两个额外参数逆序传递给指定的可调用对象 template<typename F, typename T1, typename T2> void flip1(F f, T1 t1, T2 t2) { f(t2, t1); } // flip1 一般情况下工作的很好，但是当用它调用一个接受引用参数的函数时会出现问题 void f(int v1, int &v2) { cout << v1 << \" \" << ++v2 << endl; } f(42, i); // f 改变了实参 i flip1(f, j, 42) // j 的值不会改变 如果一个函数参数是指向模板类型参数的右值引用（如 T&&），它对应的实参的 const 属性和左值/右值属性将得到保持。使用这种方案改写上面的 flip1 函数。 // 该模板将两个额外参数逆序传递给指定的可调用对象 template<typename F, typename T1, typename T2> void flip2(F f, T1 &&t1, T2 &&t2) { f(t2, t1); } // flip2 对接受左值引用函数工作的很好，但不能用于接受右值引用的函数 void g(int &&v1, int &v2) { cout << v1 << \" \" << v2 << endl; } g(42, i); // 正确 flip1(g, i, 42) // 错误，g 中接收到的 \"42\" 是左值 当我们试图通过 flip2 调用 g，则参数 t2 将被传递给 g 的右值引用参数（即使我们传递一个右值给 filp2，也会被拷贝到 t2）。函数参数是左值表达式，不能用于实例化右值。 当用于一个指向模板参数类型的右值引用函数（T&&）时， forward 会保持实参类型的所有细节。与 move 不同， forward 必须通过显式模板实参来调用。 forward 也定义在 utility 头文件中。下面使用 forward 重写翻转函数： template < typename F , typename T1 , typename T2 > void flip3 ( F f , T1 && t1 , T2 && t2 ) { f( std : : forward < T2 > ( t2 ), std :: forward < T1 > ( t1 ) ); } 重载与模板 函数模板可以被另一个模板或一个普通非函数模板重载，与往常一样，名字相同的函数，必须具有不同数量或类型的参数。如果涉及函数模板，则函数匹配规则会在以下几个方面受到影响: 对于一个调用，其候选函数包括所有模板实参推断成功的函数模板实例 候选的函数模板总是可行的，因为模板实参推断会排除任何不可行的模板 与往常一样，可行函数（模板与非模板）按类型转换（如果对此调用需要的话）来排序。当然，可以用于函数模板调用的类型转换是非常有限的（参考前文） 与往常一样，如果恰有一个函数提供比任何其他函数都更好的匹配，则选择此函数。但是如果有多个函数提供同样好的匹配，则：（1）如果同样好的函数中只有一个是非模板函数，则选择此函数；（2）如果同样好的函数中没有非模板函数，而有多个函数模板，且其中一个模板比其它模板更特例化则选择此模板；（3）否则，此调用有歧义 // 通用模板 ， 返回 T 型对象 t 的 string 表示 template < typename T > string debug_rep ( const T & t ) { std : : ostringstream ret ; ret << t ; return ret.str() ; } // 通用模板 ， 返回 T 型指针 p 的 string 表示 template < typename T > string debug_rep ( T * p ) { std : : ostringstream ret ; // 打印指针本身的值 ret << \" pointer : \" << p; // p不为空，则打印 p指向的值 if (p) ret << \" \" << debug_rep(*p); else ret << \" null pointer \"; return ret.str(); } // 对于下面的代码调用，只会使用第一个模板 string s(\" hi \"); cout << debug_rep(s) << endl; // 对于下面的代码调用，最终会调用第二个模板 cout << debug_rep(&s) << endl; // 对于下面的代码调用，最终会调用第二个模板 const string *sp = \" hi \"; cout << debug_rep(sp) << endl; // 再定义一个普通非模板函数，打印双引号包围的 string string debug_rep(const string &s) { cout << '\" ' + s + ' \"'; } // 对于下面的代码调用，会使用普通非模板函数 cout << debug_rep(s) << endl; // 对于下面的代码调用，最终会调用第二个模板 cout << debug_rep(\" hi \" ) << endl ; 对于第一个模板参数 const T &t ，当实例化 string * 参数时，模板参数是 string * ，而函数参数是 string * const &t ，表示 t 是引用，引用自 string 型指针（本身是常量）。在进行模板实参推断之后会进行普通函数的函数匹配过程。而 string * const &t 中的顶层 const 属性也会被略去，即 f(string * const &t)和 f(string *t) 存在二义性。此时后者更特例化，所以编译器实际执行的是后者。 对于第一个模板参数 const T &t ，当实例化 const string * 参数时，模板参数是 const string * ，而函数参数是 const string * const &t ，表示 t 是引用，引用自 string 型指针（指向常量，且本身是常量）。所以，同样地， f(const string * const &t)和 f(const string *t) 存在二义性。此时后者更特例化，所以编译器实际执行的是后者。 对于第一个模板，T 的类型为 char[3] ；对于第二个模板，T 的类型是 const char ；对于普通非模板函数，要求从 const char* 到 string 的类型转换。此时，3个候选函数都是可行的。普通函数由于需要进行类型转换，可以首先排除掉。而剩下两个模板函数，后者更特例化，所以编译器实际执行的是后者。 在定义任何函数之前，记得声明所有重载的函数版本。这样就不必担心编译器由于未遇到你希望调用的函数，而实例化一个并非你所需的版本: template <typename T> string debug_rep(const T &t); template <typename T> string debug_rep(T *p); // 为了使 debug_rep(char*) 的定义正确工作，下面的声明必须在作用域中 string debug_rep(const string &); string debug_rep(char *p) { // 如果接受一个 const string&的版本的声明不在作用域中， // 返回语句将调用 debug_rep(const T &t) 的 T 实例化为 string 的版本 return debug_rep(string(p)); } 可变参数模板 一个可变参数模板（variadic template）就是一个接受可变数目参数的模板函数或模板类。可变数目的参数被称为参数包（parameter packet）。存在两种参数包：模板参数包，函数参数包。 在一个模板参数列表中， class... 或 typename... 指出，接下来的参数表是零个或多个类型的列表；一个类型名后面跟一个省略号表示零个或多个给定类型的非类型参数的列表。在函数参数列表中，如果一个参数的类型是一个模板参数包，则此参数也是一个函数参数包。 // Args 是一个模板参数包； rest 是一个函数参数包 // Args 表示零个或多个模板类型参数 // rest 表示零个或多个函数参数 template <typename T, typename... Args> void foo(const T &t, const Args& ... rest); // 对于下面调用 int i = 0; foo(i, \"hi\"); // 包中有一个参数，实例化为 foo(const int &, const char[3]&); foo(\"hi\"); // 空包，实例化为 foo(const char[3]&); sizeof... 运算符可以返回一个常量表达式，表示包中的元素个数，而且不会对其实参求值： template<typename... Args> void g(Args... args) { cout << sizeof...(Args) << endl; // 类型参数的数目 cout << sizeof...(args) << endl; // 类型参数的数目 } 编写可变参数函数模板 initializer_list 用来表示一组类型相同的可变数目参数，而当类型也是未知时，则需要使用可变参数函数模板。可变参数函数通常是递归的，第一步调用处理包中的第一个实参，然后用剩余实参调用自身。 // 用来终止递归并打印最后一个元素的函数 // 此函数必须在可变参数版本的 print 定义之前声明 template<typename T> ostream& print(ostream &os, const T &t) { return os << t; // 包中最后一个元素之后不打印分隔符 } // 包中除了最后一个元素之外的其他元素都会调用这个版本的 print template<typename T, typename... Args> ostream& print(ostream &os, const T &t, const Args&... rest) { os << t << \", \"; // 打印第一个实参 return print(os, rest...); // 递归调用，打印其他实参 } 给定 print(cout, i, s, 42)，其调用过程如下： 对于最后一次递归调用 print(cout, 42)，两个 print 版本都是可行的。但是因为非可变参数模板比可变参数模板更特例化，因此编译器选择非可变参数版本。另外，定义可变参数版本的 print 时，非可变参数版本的声明必须在作用域中，否则，可变参数版本会无限递归。 包扩展 当扩展一个包时，可以提供用于每个扩展元素的模式。扩展一个包就是将它分解为构成的元素，对每个元素应用模式，获得扩展后的列表。通过在模式右边放一个省略号（...）来触发扩展操作。 template<typename T, typename... Args> ostream& print(ostream &os, const T &t, const Args&... rest) // 扩展 Args { os << t << \", \"; return print(os, rest...); // 扩展 rest } // 对 Args 的扩展中，将模式 const Arg& 应用到模板参数包 Args 中的每个元素 print(cout, i, s, 42); // 实例化的形式为 ostream& print(ostream &, const int&, const string&, const int&); print 中的函数参数包扩展仅仅将包扩展为其构成元素，还可以进行更复杂的扩展模式。比如，对其每个实参调用之前出现过的 debug_rep： template<typename... Args> ostream& errorMsg(ostream &os, const Args&... rest) { print(os, debug_rep(rest)...); // 上式等价于 print(os, debug_rep(a1), debug_rep(a2), ..., debug_rep(a3)); // 注意，不可以写成下式形式 print(os, debug_rep(rest...)); // 错误，此调用无匹配函数 return os; } 扩展中的模式会独立地应用于包中的每个元素。 转发参数包 可变参数函数通常将它们的参数转发给其他函数，这种函数具有与容器中的 emplace_back 函数一样的形式。work 调用中的扩展既扩展了模板参数包也扩展了函数参数包： // fun 有零个或多个参数 ， 每个参数都是一个模板参数类型的右值引用 template < typename ... Args > void fun ( Args &&... args ) // 将 Args 扩展为一个右值引用的列表 { // work的实参既扩展 Args又扩展 args work( std : : forward < Args > ( args ) ... ); } 模板特例化 在某些情况下，通用模板的定义可能编译失败、做的不正确，或者利用特定知识来编写更高效的代码，而不是从通用模板实例化。这时可以定义类或函数模板的一个特例化版本。 当我们特例化一个函数模板时，必须为元模板中的每个模板参数都提供实参。为了指出我们正在实例化一个模板，应使用关键字 template 后跟一个空尖括号对（<>）。空尖括号指出我们将为原模板的所有模板参数提供实参。 // 第一个版本，可以比较任意两个类型 template <typename T> int compare(const T&, const T&); // 第二个版本，处理字符串字面常量 template <size_t N, size_t M> int compare(const cahr (&p1)[N], const cahr (&p2)[M]); const char *p1 = \"hi\", *p2 = \"mom\"; compare(p1, p2); // 调用第一个版本 compare(\"hi\", \"mom\"); // 调用第二个版本 // compare 的特例化版本，处理字符数组的指针 template <> int compare(const char* const &p1, const char* const &p2) { return strcmp(p1, p2); } // 参数类型为指针，不能调用第二个版本，这里调用的是特例化版本 compare(p1, p2); 我们希望定义此函数的一个特例化版本，其中 T 的类型为 const char * 。我们的函数要求一个指向此类型的 const 版本的引用。所以 p1 是一个指向 const char 的 const 指针的引用。 函数重载与模板特例化 当定义函数模板的特例化版本时，我们本质上接管了编译器的工作，一个特例化版本本质上是一个实例，而非函数名的一个重载版本。因此，特例化不影响函数匹配。 模板及其特例化版本应该声明在同一个头文件中。所有同名模板的声明应该放在前面，然后是这些模板的特例化版本。 类模板特例化 作为例子，这里为 Sales_data 类定义特例化版本的 hash 模板。而定义了 hash 模板的特例化版本的类类型，可以存储在无序容器中。为了让 Sales_data 类的用户能使用 hash 的特例化版本，应该在 Sales_data 的头文件中定义该特例化版本。一个特例化 hash 类必须定义： 一个重载的调用运算符，它接受一个容器关键字类型的对象，返回一个 size_t 两个类型成员， result_type 和 argument_type ，分别表示调用运算符的返回类型和参数类型 默认构造函数和拷贝赋值运算符（可以隐式定义） template < typename T > struct std :: hash ; class Sales_data { friend struct std :: hash < Sales_data > ; // 其它数据成员 }; // 为了使 Sales_data 能存储在无序容器中，特例化 hash 模板 // 注意， Sales_data 类应支持 == 操作 namespace std { template <> struct hash < Sales_data > { typedef size_t result_type ; typedef Sales_data argument_type ; size_t operator ()( const Sales_data & s ) const ; }; inline size_t hash < Sales_data >:: operator ()( const Sales_data & s ) const { std :: cout << \"hash模板的 Sales_data特例化版本\" << std :: endl ; return hash < string > ()( s . bookNo ) &#94; hash < unsigned > ()( s . units_sold ) &#94; hash < double > ()( s . revenue ); } } 类模板部分特例化 可以指定一部分而非所有模板参数，或是参数的一部分而非全部特性。一个类模板的部分特例化本身是一个模板，使用它时用户还必须为那些在特例化版本中未指定的模板参数提供实参。只能部分特例化类模板，而不能部分特例化函数模板。 特例化成员而不是类 template <typename T> struct Foo { Foo(cosnt T &t = T()) : men(t) {} void Bar() { /* ... */ } T men; // Foo 的其他成员 }; template<> // 表示正在特例化一个模板 void Foo<int>::Bar() // 正在特例化 Foo<int> 的成员 Bar { // 进行应用于 int的特例化处理 } Foo<string> fs; // 实例化 Foo<string>::Foo() fs.Bar(); // 实例化 Foo<string>::Bar() Foo<int> fi; // 实例化 Foo<int>::Foo() fi.Bar(); // 使用特例化版本的 Foo<int>::Bar()","tags":"读书笔记","url":"https://xutree.github.io/pages/2018/10/21/C++_Primer_Chapter_16/"},{"title":"C++ Primer 第十五章 面向对象程序设计","text":"OOP：概述 面向对象程序设计（object-oriented programming）的核心思想是数据抽象、继承和动态绑定。 继承 通过继承（inheritance）联系在一起的类构成一种层次关系。在 C++ 语言中，基类将类型相关的函数与派生类不做改变直接继承的函数区分对待。对于某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明成虚函数（virtual function）。 class Quote { public : std :: string isbn () const ; virtual double net_price ( std :: size_t n ) const ; }; 派生类必须通过使用派生列表（class derivation list）明确指出它是从哪个(哪些)基类继承而来的： class Bulk_quote : public Quote { public : double net_price ( std :: size_t ) const override ; }; 派生类必须在其内部对所有重新定义的虚函数进行声明。派生类可以在这样的函数之前加上 virtual 关键字，但是并不是非得这么做。并且，C++11 新标准允许派生类显式地注明它将使用哪个成员函数改写基类的虚函数，具体措施是在改函数的形参列表之后增加一个 override 关键字。 动态绑定 函数的运行版本由实参决定，即在运行时选择函数的版本，所以动态绑定有时又称为运行时绑定（run-time binding）。 在 C++ 语言中，当我们使用基类的引用（或指针）调用一个虚函数时将发生动态绑定。 定义基类和派生类 定义基类 基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。 成员函数与继承 基类必须将它的两种成员函数区分开来：一种是基类希望其派生类进行覆盖的函数，基类通常将其定义为虚函数；另一种是基类希望派生类直接继承而不要改变的函数。 任何构造函数之外的非静态函数都可以是虚函数，关键字 virtual 只能出现在类内部的声明语句之前而不能用于类外部的函数定义。 如果基类把一个函数声明为虚函数，则该函数在派生类中隐式地也是虚函数。 成员函数如果没被声明为虚函数，则其解析过程发生在编译时而非运行时。 访问控制与继承 派生类可以继承定义在基类中的成员，但是派生类的成员函数不一定有权访问从基类继承而来的成员。 派生类能访问公有成员，而不能访问私有成员。 不过在某些时候，基类中还有一种成员，基类希望它的派生类有权访问该成员，同时禁止其他用户访问。我们用受保护的（protected）访问运算符说明这样的成员。 定义派生类 派生类中的虚函数 派生类经常（但不总是）覆盖它继承的虚函数。如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为类似于其他的普通成员，派生类会直接继承其在基类中的版本。 C++ 新标准允许派生类显式地注明它使用某个成员函数覆盖了它继承的虚函数。具体做法是在函数后面加上关键字 override 。 派生类对象及派生类向基类的类型转换 在派生类对象中含有与其基类对应的组成部分，所以我们能把派生类的对象当成基类对象来使用，而且我们也能将基类的指针或引用绑定到派生类对象中的基类部分上。 这种转换通常称为派生类到基类的(derived-to-base)类型转换。和其他类型转换一样，编译器会隐式地执行这种转换。 在派生类对象中含有与其基类对应的组成部分，这一事实是继承的关键所在。 派生类构造函数 派生类并不能直接初始化这些从基类继承来的成员，派生类必须使用基类的构造函数来初始化它的基类部分。 每个类控制它自己的成员初始化过程。 除非我们特别指出，否则派生类对象的基类部分会向数据成员一样执行默认初始化。如果想使用其他的基类构造函数，就需要以类名加圆括号内的实参列表的形式为构造函数提供初始值。 首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员。 派生类使用基类的成员 派生类可以访问基类的共有成员和受保护的成员。 继承与静态成员 如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。不论从基类中派生出来多少个派生类，对于每个静态成员来说都只存在唯一的实例。 静态成员遵循通用的访问控制规则，如果基类中的成员是 private 的，则派生类无权访问它。假设某静态成员是可访问的，则我们既能通过基类也能通过派生类使用它。 派生类的声明 派生类的声明与其他类型差别不大，声明中包含类名但不包含它的派生列表： class Bulk_quote : public Quote ; //错误 class Bulk_quote ; //正确 被用作基类的类 如果我们想要将某个类用作基类，则该类必须已经定义而非仅仅声明。这一规定的原因显而易见：派生类中包含并且可以使用它从基类继承而来的成员，为了使用这些成员，派生类当然要知道它们是什么。因此这一规定还有一层隐含的含义，即一个类不能派生它本身。 防止继承的发生（final） C++11 新标准提供了一种防止继承发生的方法，即在类名后跟一个关键字 final ： class NoDerived final { /* */ }; //NoDerived 不能作为基类 类型转换与继承 理解基类和派生类之间的类型转换是理解 C++ 语言面向对象编程的关键所在。 我们可以将基类的指针或引用绑定到派生类对象上。和内置指针一样，智能指针类也支持派生类向基类的类型转换，这意味着我们可以将一个派生类对象的指针存储在一个基类的智能指针内。 静态类型与动态类型 静态类型在编译时总是已知的，动态类型则是变量或表达式表示的内存中的对象的类型，动态类型直到运行时才可知。 基类的指针或引用的静态类型可能与其动态类型不一致。 如果表达式既不是引用也不是指针，则它的动态类型永远与静态类型一致。 不存在从基类向派生类的隐式类型转换。 在对象之间不存在类型转换：派生类向基类的自动类型转换只能对指针或引用类型有效，在派生类类型和基类类型之间不存在这样的转换。 当我们用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中基类部分会被拷贝、移动或赋值，它的派生类部分将被忽略掉。 虚函数 我们必须为每一个虚函数都提供定义，而不管它是否被用到，这是因为连编译器也无法确定到底会使用哪个虚函数。 对虚函数的调用可能在运行时才被解析 必须搞清楚的一点是，动态绑定只有当我们通过指针或者引用调用虚函数才会发生。 OOP 的核心思想是多态性（polymorphism）。我们把具有继承关系的多个类型称为多态类型。引用或指针的静态类型与动态类型不同这一事实正是 C++ 语言支持多态性的根本所在。 派生类中的虚函数 一旦某个函数被声明为虚函数，则在所有派生类中它都是虚函数。 一个派生类的函数如果覆盖了某个继承来的虚函数，则它的形参类型必须与被覆盖的基类函数完全一致。该规则有一个例外，当类的虚函数返回类型是类本身的指针或引用时，派生类的虚函数可以返回派生类的指针或引用，只要求从派生类到基类的类型转换是可访问的。 final 和 override 说明符 C++11 新标准中我们可以使用 override 关键字来说明派生类中的虚函数，这么做的好处是使得程序员的意图更加清晰的同时让编译器可以为我们发现一些错误。 我们还能把某个函数指定为 final ，如果我们已经把函数定义成 final 了，则之后任何尝试覆盖该函数的操作都将引发错误。 final 和 override 说明符出现在形参列表（包括任何 const 或引用修饰符）以及尾置返回类型之后。 虚函数与默认实参 如果某次函数调用使用了默认实参，则该实参值由本次调用的 静态类型 决定。如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致。 回避虚函数机制 某些情况下，我们希望对虚函数的调用不要进行动态绑定，而是强迫其执行虚函数的某个特定版本。使用作用域运算符可以实现： // 强制调用基类中定义的函数版本而不管 baseP 的动态类型是什么 double undiscounted = baseP- > Quote :: net_price ( 42 ); 该调用将在编译时完成解析。 抽象基类 纯虚函数 我们可以将函数定义成纯虚（pure virtual）函数，这样做可以清晰明了地告诉用户这个函数是没有实际意义的。 一个纯虚函数无需定义。通过在函数体的位置（声明语句的分号之前）书写 = 0 就可以将一个虚函数说明为纯虚函数。其中 = 0 只能出现在类内部的虚函数声明语句处： //用于保存折扣值和购买量的类，派生类使用这些数据可以实现不同的价格策略 class Disc_quote : public Quote { public : Disc_quote () = default ; Disc_quote ( const std :: string & book , double price , std :: size_t qty , double disc ) : Quote ( book , price ), quantity ( qty ), discount ( disc ) {} double net_price ( std :: size_t ) const = 0 ; protected : std : size_t quantity = 0 ; //折扣适用的购买量 double discount = 0.0 ; //表示折扣的小数值 }; 我们也可以为纯虚函数提供定义，不过函数体必须定义在类的外部。 含有纯虚函数的类是抽象基类 含有（或未经覆盖直接继承）纯虚函数的类是抽象基类（abstruct base class）。 抽象基类负责定义接口，而后续的其他类可以覆盖该接口。 我们不能创建抽象基类的对象。 派生类构造函数只初始化它的直接基类 重构 重构负责重新设计类的体系以便将操作和/或数据从一个类移动到另一个类中。对于面向对象的应用程序来说，重构是一种很普遍的现象。 访问控制与继承 受保护的成员 protected 说明符可以看做是 public 和 private 中和后的产物： 和私有成员类似，受保护的成员对于类的用户来说是不可访问的 和公有成员类似，受保护的成员对于派生类的成员和友元来说是可访问的 派生类的成员或友元只能通过派生类对象来访问基类的受保护成员。派生类对于一个基类对象中的受保护成员没有任何访问特权 为了便于理解第（3）条，请看如下示例： class Base { protected : int prot_mem ; //protected 成员 }; class Sneaky : public Base { friend void clobber ( Sneaky & ); //能访问 Sneaky::prot_mem friend void clobber ( Base & ); //不能访问 Base::prot_mem int j ; //j默认是private }; //正确：clobber 能访问 Sneaky 对象的 private 和 protected 成员 void clobber ( Sneaky & s ) { s . j = s . prot_mem = 0 ; } //错误：clobber 不能访问 Base 的 protected 成员 void clobber ( Base & b ) { b . prot_mem = 0 ; } 理解下面两点很重要： 在类内部，类成员函数可访问类的任何一个成员（ public ， pirvate ， protected ）。 但是，在类的外部（比如 main 函数中），类的 pirvate 成员不管是对该类的对象还是该类派生类的对象，都是无访问权限的 公有、私有和受保护继承 某个类对其继承而来的成员的访问权限受到两个因素影响：一是在基类中该成员的访问说明符，二是在派生类的派生列表中的访问说明符。三种不同的继承方式下的基类特性和派生类特性： 继承方式 public public private 公有继承 public protected 不可见 私有继承 private private 不可见 保护继承 protected protected 不可见 派生类向基类转换的可访问性 假定 D 继承自 B： 只有当 D 公有地继承 B 时，用户代码才能使用派生类向基类的转换；如果 D 继承 B 的方式是受保护的或者私有的，则用户代码不能使用该转换 不论 D 以什么方式继承 B，D 的成员函数和友元都是使用派生类向基类的转换：派生类向其直接基类的类型转换对于派生类的成员和友元来说永远是可访问的 如果 D 继承 B 的方式是公有或者受保护的，则 D 的派生类的成员和友元可以使用 D 向 B 的类型转换；反之，如果 D 继承 B 的方式是私有的，则不能使用 友元与继承 就像友元关系不能传递一样，友元关系也不能继承。每个类负责控制各自成员的访问权限。 改变个别成员的可访问性 有时我们需要改变派生类继承的某个名字的访问级别，通过使用 using 声明可以达到这一目的： class Base { public : std :: size_t size () const { return n ; } protected : std :: size_t n ; }; class Derived : private Base { //注意 private 继承 public : //保持对象尺寸相关的成员的访问级别 using Base :: size ; protected : using Base :: n ; } 派生类只能为那些它可以访问的名字提供 using 声明。 继承中的类作用域 每个类定义自己的作用域，在这个作用域内我们定义类的成员。当存在继承关系时，派生类的作用域在其基类的作用域之内。如果一个名字在派生类作用域内无法正确解析，则编译器将继续在外层的基类作用域中寻找该名字的定义。 在编译时进行名字查找。 名字冲突与继承 派生类能重用定义在其基类或间接基类中的名字，此时定义在内层作用域（即派生类）的名字将隐藏定义在外层作用域（即基类）的名字。 通过作用域运算符来使用隐藏的成员 我们可以通过作用域运算符来使用一个被隐藏的基类成员。 名字查找先于类型检查 如前所述，声明在内层作用域的函数并不会重载声明在外层作用域的函数。同理，定义在派生类中的函数也不会重载其基类中的成员。如果派生类的成员与基类的某个成员同名，则派生类将在其作用域内隐藏（非重载）该基类成员。即使它们的形参列表不一致，基类成员也会被隐藏掉。 虚函数与作用域 假如基类与派生类的虚函数接受的实参不同，则我们就无法通过基类的引用或指针调用派生类的虚函数了。 class Base { public : virtual int fcn (); }; class D1 : public Base { public : //隐藏基类的 fcn，这个 fcn 不是虚函数 //D1 继承了 Base::fcn() 的定义 int fcn ( int ); //形参列表与 Base 中的 fcn 不一致 virtual void f2 (); //是一个新的虚函数，在 Base 中不存在 }; class D2 : public D1 { public : int fcn ( int ); //是一个非虚函数，隐藏了 D1::fcn(int) int fcn (); //覆盖了 Base 的虚函数 fcn void f2 (); //覆盖了 D1 的虚函数 f2 }; 通过基类调用隐藏的虚函数 基于上述定义的类，我们看下面的代码： Base bobj; D1 d1obj; D2 d2obj; Base *bp1 = &bobj, *bp2 = d1obj, *bp3 = d2obj; bp1->fcn(); //虚调用，将在运行时调用 Base::fcn bp2->fcn(); //虚调用，将在运行时调用 Base::fcn bp3->fcn(); //虚调用，将在运行时调用 D2::fcn D1 *d1p = &d1obj; D2 *d2p = &d2obj; bp2->f2(); //错误：Base 没有名为 f2 的成员 d1p->f2(); //虚调用，将在运行时调用 D1::f2() d2p->f2(); //虚调用，将在运行时调用 D2::f2() Base *p1 = &d2obj; D1 *p2 = &d2obj; D2 *p3 = &d2obj; p1->fcn(42); //错误：Base中 没有接受一个 int 的 fcn p2->fcn(42); //静态绑定，调用 D1::fcn(int) p3->fcn(42); //静态绑定，调用 D2::fcn(int) 基类指针指向派生类对象，则调用基类中的成员函数（该类中无虚函数，实现静态绑定）。 若想让基类指针调用派生类中的成员，则需将该成员函数声明为虚函数（实现动态绑定）。 构造函数与拷贝控制 虚析构函数 继承关系对基类拷贝控制最直接的影响是基类通常应该定义一个虚析构函数，这样我们就能动态分配继承体系中的对象了。 如前所述，当我们 delete 一个动态分配对象的指针时将执行析构函数。如果该指针指向继承体系中的某个类型，则可能出现指针的静态类型与被删除对象的动态类型不符的情况。通过在基类中将析构函数定义成虚函数以确保执行正确的析构函数版本： class Quote { public : //如果我们删除的是一个指向派生类对象的基类指针，则需要虚析构函数 virtual ~ Quote () = default ; //动态绑定析构函数 }; 和其他虚函数一样，析构函数的虚属性也会被继承。只要基类的析构函数是虚函数，就能确保当我们 delete 基类指针时将运行正确的析构函数版本： Quote *itemP = new Quote; //静态类型与动态类型一致 delete itemP; //调用 Quote 的析构函数 itemP = new Bulk_quote; //静态类型与动态类型不一致 delete itemP; //调用 Bulk_quote 的析构函数 如果基类的析构函数不是虚函数，则 delete 一个指向派生类对象的基类指针将产生未定义的行为。 虚析构函数将阻止合成移动操作 如果一个类定义了析构函数，即使它通过 = default 的形式使用了合成的版本，编译器也不会为这个类合成移动操作。 合成拷贝控制与继承 派生类中删除的拷贝控制与基类的关系 如果基类中的默认构造函数、拷贝控制函数、拷贝赋值运算符或析构函数是被删除的或者不可访问，则派生类中对应的成员将是被删除的，原因是编译器不能使用基类成员来执行派生类对象基类部分的构造、赋值或销毁操作 如果在基类中有一个不可访问或删除掉的析构函数，则派生类中合成的默认和拷贝构造函数将是被删除的，因为编译器无法销毁派生类对象的基类部分 编译器将不会合成一个删除掉的析构函数。当我们使用 = default 请求一个移动操作时，如果基类中的对应操作是删除的或不可访问的，那么派生类中该函数将是删除的，原因是派生类对象的基类部分不可移动。同样，如果基类的析构函数是删除的或不可访问的，则派生类的移动构造函数也将是删除的 class B { public : B (); B ( const B & ) = delete ; //其他成员，不含移动构造函数 }; class D : public B { //没有声明任何构造函数 }; D d ; //正确：D 的合成默认构造函数使用B的默认构造函数 D d2 ( d ); //错误：D 的合成拷贝构造函数是被删除的 D d3 ( std :: move ( d )); //错误：隐式地使用 D 的被删除的拷贝构造函数 因为我们定义了拷贝构造函数，所以编译器不会为 B 合成一个移动构造函数。因此，我们既不能移动也不能拷贝 B 的对象。在实际编程过程中，如果在基类中没有默认、拷贝或移动构造函数，则一般情况下派生类也不会定义相应的操作。 移动操作与继承 如前所述，大多数基类都会定义一个虚析构函数。因此在默认情况下，基类通常不含有合成的移动操作，而且在它的派生类中也没有合成的移动操作。 因为基类缺少移动操作会阻止派生类拥有自己的合成移动操作，所以当我们确实需要执行移动操作时应该首先在基类中进行定义。 派生类的拷贝控制成员 当派生类定义了拷贝或移动构造函数时，该操作负责拷贝或移动包括基类部分成员在内的整个对象。 定义派生类的拷贝或移动构造函数 当为派生类定义拷贝或移动构造函数时，我们通常使用对应的基类构造函数初始化对象的基类部分。在默认情况下，基类默认构造函数初始化派生类对象的基类部分。如果我们想拷贝（或移动）基类部分，则必须在派生类的构造函数初始值列表中显示地使用基类的拷贝（或移动）构造函数。 class Base { /*...*/ }; class D : public Base { public : //默认情况下，基类的默认构造函数初始化对象的基类部分 //要想使用拷贝或移动构造函数，我们必须在构造函数初始值列表中 //显示地调用该构造函数 D ( const D & d ) : Base ( d ) //拷贝基类成员 /* D的成员的初始值*/ { /*...*/ } D ( D && d ) : Base ( std :: move ( d )) //移动基类成员 /* D的成员的初始值*/ { /*...*/ } }; 派生类赋值运算符 与拷贝和移动构造函数一样，派生类的赋值运算符也必须显示地为其基类部分赋值： // Base :: operator =( const Base &) 不会被自动调用 D & D :: operator =( const D & rhs ) { Base : : operator = ( rhs ); //为基类部分赋值 //按照过去的方式为派生类的成员赋值 //酌情处理自赋值及释放已有资源等情况 return *this ; } 派生类析构函数 对象销毁的顺序正好与其创建顺序相反：派生类析构函数首先执行，然后是基类的析构函数。 在构造函数和析构函数中调用虚函数 如果构造函数或析构函数调用了某个虚函数，则我们应该执行与构造函数或析构函数所属类型相对应的虚函数版本。 继承的构造函数 在 C++11 新标准中，派生类能够重用其直接基类定义的构造函数。一个类只初始化它的直接基类，出于同样的原因，一个类也只继承其直接基类的构造函数。类不能继承默认、拷贝和移动构造函数。 我们重新定义 Bulk_quote，令其继承 Disc_quote 类的构造函数： class Bulk_quote : public Disc_quote { public : using Disc_quote :: Disc_quote ; //继承 Disc_quote 的构造函数 double net_price ( std :: size_t ) const ; }; 继承的构造函数的特点 通常情况下， using 声明语句只是令某个名字在当前作用域可见。而当作用域构造函数时， using 声明语句将令编译器产生代码。对于基类的每个构造函数，编译器都生成一个与之对应的派生类构造函数。 一个构造函数的 using 声明不会改变构造函数的访问级别。 一个 using 声明语句不能指定 explicit 或 constexpr 。继承的构造函数的这两个性质与基类构造函数相同。 当一个基类构造函数含有默认实参时，这些实参不会被继承。相反，派生类将获得多个继承的构造函数，其中每个构造函数分别省略掉一个含有默认实参的形参。 大部分派生类会继承所有的基类构造函数：第一个例外，派生类可以继承一部分构造函数，而为其他构造函数定义自己的版本；第二个例外，默认、拷贝和移动构造函数不会被继承。这些构造函数按照正常规则被合成。 容器和继承 当我们使用容器存放继承体系中的对象时，通常必须采取间接存储的方式。因为不运行在容器中保存不同类型的元素，所以我们 不能把具有继承关系的多种类型的对象直接存放在容器当中。 我们可以再容器中放置（智能）指针而非对象：当我们希望在容器中存放具有继承关系的对象时，我们实际上存放的通常是基类的指针（更好的选择是智能指针）。","tags":"读书笔记","url":"https://xutree.github.io/pages/2018/10/20/C++_Primer_Chapter_15/"},{"title":"C++ Primer 第十四章 重载运算与类型转换","text":"基本概念 重载的运算符是具有特殊名字的函数：它们的名字由关键字 operator 和其后要定义的运算符号共同组成。和其他函数一样，重载的运算符也包含返回类型、参数列表以及函数体。 对一个运算符函数来说，它或者是类的成员，或者至少含有一个类类型的参数，这一约定意味着当运算符作用于内置类型的运算对象时，我们无法改变该运算符的含义： //错误：不能为 int 重定义内置的运算符 int operator+(int, int); 我们只能重载已存在的运算符，而无权发明新的运算符。重载运算符无法改变优先级和结合律。 直接调用一个重载的运算符函数 //一个非成员运算符函数的等价调用 data1 + data2; //普通的表达式 operator+(data1, data2); //等价的函数调用 //一个成员运算符函数的等价调用 data1 +=data2; //基于\"调用\"的表达式 data1.operator+(data2); //等成员运算符函数的等价调用 选择作为成员或者非成员 当定义重载的运算符时，必须首先决定是将其声明为类的成员函数还是声明为一个普通的非成员函数。在某些时候我们别无选择，因为有的运算符必须作为成员；另一个情况下，运算符作为普通函数比作为成员更好。下面的准则有助于选择： 赋值(=)、下标([ ])、调用( () )和成员访问箭头(->)运算符必须是成员 复合赋值运算符一般来说应该是成员，但并非必须，这一点与赋值运算符略有不同 改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减和解引用运算符，通常应该是成员 具有对称性的运算符可能转换任意一端的运算对象，例如算术、相等性、关系和位运算符等，因此它们通常应该是普通的非成员函数 输入和输出运算符 重载输出运算符 << 通常，输出运算符的第一个形参是一个非常量 ostream 对象的引用。之所以 ostream 是非常量是因为向流写入内容会改变其状态；而该形参是引用是因为我们无法直接复制一个 ostream 对象。 第二个形参一般来说是一个常量的引用，该常量是我们想要打印的类类型。第二个形参是引用的原因是我们希望避免复制实参；而之所以该形参可以是常量是因为(通常情况下)打印对象不会改变对象的内容。 为了与其他输出运算符保持一致， operator<< 一般要返回它的 ostream 形参。 Sales_data的输出运算符： ostream &operat<< (ostream &os, const Sales_data &item) { os << item.isbn() << \" \" << item.units_sold << \" \" << item.revenue << \" \" << item.avg_price(); return os; } 输出运算符尽量减少格式化操作通常，输出运算符应该主要负责打印对象的内容而非控制格式，输出运算符不应该打印换行符。 输入输出运算符必须是非成员函数：与 iostream 标准库兼容的输入输出运算符必须是普通的非成员函数，而不能是类的成员函数。否则，它们的左侧运算对象将是我们的类的一个对象： Sales_data data; data << cout; //如果 operator<< 是 Sales_data 的成员 假设输入输出运算符是某个类的成员，则它们也必须是 istream 或 ostream 的成员。然而，这两个类属于标准库，并且我们无法给标准库中的类添加任何成员。因此，我们必须将其定义成非成员函数。当然， IO 运算符通常需要读写类的非公有数据成员，所以 IO 运算符一般被声明为友元。 重载输入运算符 >> 通常，输入运算符的第一个形参是运算符将要读取的流的引用，第二个形参是将要读入到的(非常量)对象的引用。该运算符通常会返回某个给定流的引用。第二个形参之所以是个非常量是因为输入运算符的目的就是将数据读入到这个对象中。 Sales_data的输入运算符： istream &operator>>(istream &is, Sales_data &item) { double price; //不需要初始化，因为我们将先读入数据到 price，之后才使用它 is >> item.bookNo >> item.units_sold >> price; if (is) //检查输入是否成功 item.revenue = item.units_sold * price; else item = Sales_data(); //输入失败：对象被赋予默认的状态 return is; } 输入运算符必须处理输入可能失败的情况，而输出运算符不需要。当读取操作发生错误时，输入运算符应该负责从错误中恢复。 算术和关系运算符 通常情况下，我们将算术和关系运算符定义成非成员函数以允许对左侧或右侧的运算对象进行转换。因为这些运算符一般不需要改变运算对象的状态，所以形参都是常量的引用。 Sales_data operator+(const Sales_data &lhs, const Sales_data &rhs) { Sales_data sum = lhs; //把lhs的数据成员拷贝给sum sum += rhs; //将rhs加到sum中 return sum; } 如果类同时定义了算术运算符和相关的复合赋值运算符，则通常情况下应该使用复合赋值来实现算术运算符。 相等运算符 bool operator==(const Sales_data &lhs,const Sales_data &rhs) { return lhs.isbn() == rhs.isbn() && lhs.units_sold == rhs.units_sold && lhs.revenue == rhs.revenue; } bool operator!=(const Sales_data &lhs, const Sales_data &rhs) { return !(lhs == rhs); } 如果某个类在逻辑上有相等性的含义，则该类应该定义 operator== ，这样做可以使得用户更容易使用标准库算法来处理这个类。 关系运算符 定义了相等运算符的类也常常(但不总是)包含关系运算符。特别是，因为关联容器和一些算法要用到小于运算符，所以定义 operator< 会比较有用。 赋值运算符 我们可以重载赋值运算符。不论形参 的类型是什么，赋值运算符都必须定义为成员函数。 复合赋值运算符 复合赋值运算符不非得是类的成员，不过我们还是倾向于把包括复合赋值在内的所有赋值运算都定义在类的内部。 //作为成员的二元运算符：左侧运算对象绑定到隐式地 this 指针 //假定两个对象表示的是同一本书 Sales_data& Sales_data::operator+=(const Sales_data &rhs) { units_sold += rhs.units_sold; revenue += rhs.revenue; return *this; } 这两类运算符都应该返回左侧运算对象的引用。 下标运算符 表示容器的类通常可以通过元素在容器中的位置访问元素，这些类一般会定义下标运算符 operator[] 。下标运算符必须是成员函数。 为了与下标的原始定义兼容，下标运算符通常以所访问元素的引用作为返回值，这样做的好处是下标可以出现在赋值运算符的任意一端。 如果一个类包含下标运算符，则它通常会定义两个版本：一个返回普通引用，另一个是类的常量成员并且返回常量引用。 递增和递减运算符 C++ 语言并不要求递增和递减运算符必须的类的成员，但是因为它们改变的正好是所操作对象的状态，所以建议将其设定为成员函数。 定义递增和递减运算符的应该同时定义前置后后置版本。这些运算符通常应该被定义成类的成员。 定义前置递增/递减运算符 class StrBlobPtr { public : //递增和递减运算符 StrBlobPtr & operator ++ (); //前置运算符 StrBlobPtr & operator -- (); //其他成员和之前版本一致 }; //前置版本：返回递增/递减对象的引用 StrBlobPtr & StrBlobPtr :: operator ++ () { //如果curr已经指向了容器的尾后位置，则无法递增它 check ( curr , \"increment past end of StrBlobPtr\" ); ++ curr ; //将curr在当前状态下向前移动一个元素 return * this ; } StrBlobPtr & StrBlobPtr :: operator -- () { //如果curr是0，则继续递减它将产生一个无效下标 -- curr ; //将curr在当前状态下向后移动一个元素 check ( curr , \"decrement past begin of StrBlobPtr\" ); return * this ; } 区分前置和后置运算符 后置版本接受一个额外的(不使用) int 类型的形参。这个形参的唯一作用就是区分前置版本和后置版本的函数，而不是真的要在实现后置版本时参与运算。 class StrBlobPtr { public : //递增和递减运算符 StrBlobPtr operator ++ ( int ); //后置运算符 StrBlobPtr operator -- ( int ); //其他成员和之前版本一致 }; //后置版本：递增/递减对象的值但是返回原值 StrBlobPtr StrBlobPtr :: operator ++ ( int ) { //此处无须检查有效性，调用前置递增运算时才需要检查 StrBlobPtr ret = * this ; //记录当前的值 ++* this ; //向前移动一个元素，前置++需要检查递增的有效性 return ret ; //返回之前记录的状态 } StrBlobPtr StrBlobPtr :: operator -- ( int ) { //此处无须检查有效性，调用前置递减运算时才需要检查 StrBlobPtr ret = * this ; //记录当前值 --* this ; //向后移动一个元素，前置--需要检查递减的有效性 return ret ; //返回之前记录的状态 } 显示地调用后置运算符 如果我们想通过函数调用的方式调用后置版本，则必须为它的整型参数传递一个值： StrBlobPtr p(a1); //p 指向 a1 中的 vector p.operator++(0); //调用后置版本的 operator++ p.operator++(); //调用前置版本的 operator++ 成员访问运算符 class StrBlobPtr { public : std :: string & operator * () const { auto p = check ( curr , \"dereference past end\" ); return ( * p )[ curr ]; //(*p)是对象所指的 vector } std :: string * operator -> () const { //将实际工作委托给解引用运算符 return & this -> opreator * (); } //其他成员与之前的版本一致 }; 解引用运算符首先检测 curr 是否仍在作用范围内，如果是，则返回 curr 所指元素的一个引用。箭头运算符不执行任何自己的操作，而是调用解引用运算符并返回解引用结果元素的地址。 箭头运算符必须是类的成员，解引用运算符通常也是类的成员，尽管并非必须如此。 值得注意的是，我们将这两个运算符定义成了 const 成员，这是因为与递增和递减运算符不一样，获取一个元素并不会改变 StrBlobPtr 对象的状态。 函数调用运算符 如果类重载了函数调用运算符，则我们可以像使用函数一样使用该类的对象。 举个🌰 ，下面这个名为 absInt 的 struct 含有一个调用运算符，该运算符负责返回其参数的绝对值： struct absInt { int operator ()( int val ) const { return val > 0 ? val : - val ; } }; 我们使用调用运算符的方式是令一个 absInt 对象作用于一个实参列表，这一过程看起来非常像调用函数的过程： int i = -42; absInt absObj; //含有函数调用运算符的对象 int ui = absObj(i); //将 i 传递给 absObj.operator() 函数调用运算符必须是成员函数。一个类可以定义多个不同版本的调用运算符，相互之间应该在参数数量或类型上有所区别。 如果定义了调用运算符，则该类的对象称为函数对象（function object）。 含有状态的函数对象类 和其他类一样，函数对象除了 operator() 之外也可以包含其他成员。函数对象类通常含有一些数据成员，这些成员被用于定制调用运算符中的操作。 class PrintString { public : PrintString ( ostream & o = cout , char c = ' ' ) : os ( o ), sep ( c ){} void operator ()( const string & s ) const { os << s << sep ;} private : ostream & os ; //用于写入的目的流 char sep ; //用于将不同输出隔开的字符 }; 当定义 PrintString 的对象时，对于分隔符及输出流即可以使用默认值也可以提供自己的值： PrintString printer; //使用默认值，打印到 cout printer(s); //在 cout 中打印 s，后面跟一个空格 PrintString errors(cerr, '\\n'); errors(s); //在 cerr 中打印 s，后面跟一个换行符 函数对象常常作为泛型算法的实参： //例如可以使用标准库 for_each 算法和我自己的 PrintString 类来打印容器内容 for_each(vs.begin(), vs.end(), PrintString(cerr, '\\n')); lambda 是函数对象 当我们编写了一个 lambda 后，编译器将该表达式翻译成一个未命名类的未命名对象。在 lambda 表达式产生的类中含有一个重载的函数调用运算符。 stable_sort ( words . begin (), words . end (), []( const string & a , const & b ) { return a . size () < b . size ();}); //其行为类似于下面这个类的一个未命名对象 class ShorterString { public : bool operator ()( const string & s1 , const string & s2 ) const { return s1 . size () < s2 . size ();} }; 产生的类只有一个函数调用运算符成员它负责接受两个 string 并比较他们的长度，它的形参列表和函数体与lambda表达式完全一样。 默认情况下 lambda 不能改变它捕获的变量。因此在默认情况下，由 lambda 产生的类当中的函数调用运算符是一个 const 成员函数。如果 lambda 被声明为可变的，则调用运算符就不是 const 的了。 表示 lambda 及相应捕获行为的类 当一个 lambda 表达式通过引用捕获变量时，将有程序负责确保 lambda 执行时引用所引的对象确实存在。因此编译器可以直接使用该引用而无须在 lambda 产生的类中将其存储为数据成员。 相反，通过值捕获的变量被拷贝到 lambda 中。因此，这种 lambda 产生的类必须为每个值捕获的变量建立对应的数据成员，同时创建构造函数，令其使用捕获的变量的值来初始化数据成员。 lambda 表达式产生的类不含默认构造函数、赋值构造函数及默认析构函数，它是否含有默认的拷贝/移动构造函数则通常要视捕获的数据成员类型而定。 标准库定义的函数对象 下表所列的类型定义在 functional 头文件中： 在算法中使用标准库函数对象 在默认情况下排序算法使用 operator< 将序列按照升序排列。如果要执行降序排列的话，我们可以传入一个 greater 类型的对象。例如： //svec 是一个 vector<string> //传入一个临时的函数对象用于执行两个 string 对象的 > 比较运算 sort(svec.begin(), svec.end(), greater<string>()); 则上面的语句将按照降序对 svec 进行排序。第三个实参是 greater<string> 类型的一个未命名的对象。 需要特别注意的是，标准库规定其函数对象对于指针同样适用。我们之前曾介绍过比较两个无关指针将产生未定义的行为，然而我们可能会希望通过比较指针的内存地址来 sort 指针的 vector 。直接这么做会产生未定义的行为，但是我们可以用标准库函数对象来实现： vector<string *> nameTable; sort(nameTable.begin(), nameTable.end(), [] (string *a, sting *b { return a < b; })); //错误 sort(nameTable.begin(), nameTable.end(), less<string *>()); //正确 可调用对象和 function C++ 语言中的几种可调用对象： 函数 函数指针 lambda 表达式 bind 创建的对象 重载了函数调用运算符的类 与其他对象一样，可调用的对象也有类型。例如，每个 lambda 有它自己唯一的（未命名）的类型；函数及函数指针的类型则由其返回值类型和实参类型决定。 调用形式：指明了调用返回的类型以及传递给调用的实参类型。 不同类型可能具有相同的调用形式 //普通函数 int add(int i, int j) { return i + j; } //lambda，其产生一个未命名的函数对象类 auto mod = [] (int i, int j) { return i % j; } //函数对象类 struct divide{ int operator()(int denominator, int divisor){ return denominator / divisor; } } 上面的类型共享同一个调用形式： int(int, int) 。 若我们想把它们存入同一个函数表： map<string, int(*)(int, int)> binops; binops.insert({\"+\", add}); //正确，add 是一个指向正确类型函数的指针 binops.insert({\"%\",mod}); //错误，mod 不是一个函数指针 标准库 function 类型 我们可以使用一个名为 function 的新标准库类型解决上述问题，它定义在 functional 头文件中，支持的操作如下： map<string, function<int(int, int)>> binops = { {\"+\", add}, //函数指针 {\"-\", std::minus<int>()}, //标准库函数对象 {\"/\", divide()}, //未命名的 lambda {\"*\", [] (int i, int j) { return i * j; }}, //命名了的 lambda {\"%\", mod}}; // 重载的函数与 function 我们不能（直接）将重载函数的名字存入 function 类型的对象中： int add(int i, int j) { return i + j; } Sales_data add(const Sales_data&, const Sales_data&); map<string, function<int(int, int)>> binops; binops.insert({\"+\", add}); //错误，哪个 add？ 解决上述二义性问题的一条途径是存储函数指针而非函数名字： int (*fp)(int, int) = add; binops.insert({\"+\",fp}); 同样，也可以使用 lambda 来消除二义性： binops.insert({\"+\", [] (int i, int j) { return add(i, j); }}); 重载、类型转换与运算符 类型转换运算符 类型转换运算符（conversion operator）是类的一种特殊成员函数，它负责将一个类类型的值转换成其他类型。一般形式： operator type() const; 其中type表示某种类型。 我们不允许转换成数组或函数类型，但允许转换成指针(包括数组指针及函数指针)或引用类型。 类型转换运算符既没有显示的返回类型，也没有形参，而且必须定义成类的成员函数。类型转换运算符通常不应该改变待转换对象的内容，因此，类型转换运算符一般被定义成 const 成员。 定义含有类型转换符的类 class SmallInt { public : SmallInt ( int i = 0 ) : val ( i ) { if ( i < 0 || i > 255 ) throw std :: out_of_range ( \"Bad SmallInt value\" ); } operator int () const { return val ; } private : std :: size_t val ; }; SmallInt 类既定义了向类类型的转换，也定义了从类类型向其他类型的转换。其中构造函数将算符类型的值转换成 SmallInt 对象，而类型转换运算符将 SmallInt 对象转换成 int : SmallInt si; si = 4; //首先将4隐式地转换成 SmallInt，然后调用 SmallInt::operator= si + 3; //首先将 si 隐式地转换成 int，然后执行整数的加法 尽管编译器一次只能执行一个用户定义的类型转换，但是隐式的用户定义类型转换可以置于一个标准（内置）类型转换之前或之后： //内置类型转换将 double 实参转换为 int SmallInt si = 3.14; //调用 SmallInt(int) 构造函数 //SmallInt 的类型转换运算符将 si 转换为 int si + 3.14; //内置类型转换将所得的 int 继续转换成 double 类型转换运算符可能产生意外结果 在实践中，类很少提供类型转换运算符。在大多数情况下，如果类型转换自动发生，用户可能会感到比较意外，而不是感到受到了帮助。然而这条经验法则存在一种例外情况：对于类来说，定义向 bool 的类型转换还是比较普遍的现象。 在 C++ 标准的早期版本中，如果类想定义一个向 bool 的类型转换，则它常常遇到一个问题：因为 bool 是一种算术类型，所以类类型的对象转换成 bool 后就能被用在任何需要算术类型的上下文中。这样的类型转换可能引发意想不到的结果，特别是当 istream 含有向 bool 的类型转换时，下面的代码仍能编译通过： int i = 42; cin << i; 该程序试图将输出运算符作用在输入流。因为 istream 本身没有定义 << ，所以本来这段代码应该产生错误。然而，该代码能使用 istream 的 bool 类型转换运算符将 cin 转换成 bool ，而这个 bool 值会接着被提升成 int 并用作内置的左移运算符的左侧运算对象。这样一来，提升后的 bool 值（1或0）最终会被左移42个位置。这一结果显然与我们的预期大相径庭。 显示的类型转换运算符 为了防止这样的异常情况发生，C++ 11新标准引入了显示的类型转换运算符（explicit conversion operator）： class SmallInt { public : //编译器不会自动执行这一类型转换 explicit operator int () const { return val ; } //其他成员与之前的版本一致 }; 和显示的构造函数一样，编译器(通常)也不会将一个显式的类型转换运算符用于隐式类型转换： SmallInt si = 3; //正确：SmallInt 的构造函数不是显式的 si + 3; //错误：此处需要隐式的类型转换，但类的运算符是显式的 static_cast<int>(si) + 3; //正确：显式地请求类型转换 该规定存在一个例外，即如果表达式被用作条件，则编译器会将显式地类型转换自动应用于它。换句话说，当表达式出现在下列位置时，显示的类型转换将被隐式地执行： if 、 while 及 do 语句的条件部分 for 语句头的条件表达式 逻辑非运算符( ! )、逻辑或( || )、逻辑与( && )的运算对象 条件表达式( ? : )的条件表达式 转换为 bool 在标准库的早期版本中， IO 类型定义了向 void* 的转换规则，以避免上面提到的问题。但 C++ 11新标准通过显示的类型转换运算符实现同样的目的。","tags":"读书笔记","url":"https://xutree.github.io/pages/2018/10/20/C++_Primer_Chapter_14/"},{"title":"C++ Primer 第十三章 拷贝控制","text":"当定义一个类时，我们显示地或隐式地指定在此类型的对象拷贝、移动、赋值和销毁时做什么。一个类通过定义五种特殊的成员函数来控制这些操作，包括：拷贝构造函数（copy constructor）、拷贝赋值运算符（copy-assignment operator）、移动构造函数（move constructor）、移动赋值运算符（move-assignment operator）和析构函数（destructor）。 拷贝和移动构造函数定义了当用同类型的另一个对象初始化本对象时做什么。 拷贝和移动赋值运算符定义了将一个对象赋予同类型的另一个对象时做什么。 析构函数定义了当此类型对象销毁时做什么。 我们称这些操作为拷贝控制操作（copy control）。 拷贝、赋值和销毁 拷贝构造函数 如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数。 class Foo { public : Foo (); //默认构造函数 Foo ( const Foo & ); //拷贝构造函数 //... }; 拷贝构造函数的第一个参数必须是一个引用类型，虽然我们可以定义一个接受非 const 引用的拷贝构造函数，但此参数几乎总是一个 const 引用。拷贝构造函数在几种情况下都会被隐式地使用。因此，拷贝构造函数通常不应该是 explicit 的。 合成拷贝构造函数（synthesized copy constructor） 如果我们没有为一个类定义拷贝构造函数，编译器会为我们定义一个。与合成默认构造函数不同，即使我们定义了其他构造函数，编译器也会为我们合成一个拷贝构造函数。 每个成员的类型决定了它如何拷贝：对类类型成员，会使用其拷贝构造函数来拷贝；内置类型的成员则直接拷贝。Sales_data 类的合成拷贝构造函数等价于： class Slaes_data { public : //其他成员和构造函数的定义，如前 //与合成的拷贝构造函数等价的拷贝构造函数的声明 Sales_data ( const Sales_data & ); private : std :: string bookNo ; int units_sold = 0 ; double revenue = 0.0 ; }; //与 Sales_data 的合成的拷贝构造函数等价 Sales_data :: Sales_data ( const Sales_data & orig ) : bookNo ( orig . bookNo ), //使用string的拷贝构造函数 units_sold ( orig . units_sold ) ， //拷贝orig.units_sold revenue ( orig . revenue ) //拷贝orig.revenue { } //空函数体 拷贝初始化（copy initialization） string dots(10,'.'); //直接初始化 string s(dots); //直接初始化 string s2 = dots; //拷贝初始化 string null_book = \"9-999-99999-9\"; //拷贝初始化 string nines = string(100, '9'); //拷贝初始化 当使用直接初始化时，我们实际上是要求编译器使用普通的函数匹配来选择与我们提供的实参最匹配的构造函数。当我们使用拷贝初始化时，我们要求编译器将右侧运算对象拷贝到正在创建的对象中，如果需要的话还要进行类型转换。 拷贝初始化通常通过拷贝构造函数来完成，但是，如果一个类有一个移动构造函数，则拷贝初始化有时会使用移动构造函数而非拷贝构造函数来完成。 拷贝初始化不仅在外面用=定义变量时会发生，在下列情况下也会发生： 将一个对象作为实参传递给一个非引用类型的形参 从一个返回类型为非引用类型的函数返回一个对象 用花括号列表初始化一个数组中的元素或一个聚合类中的成员 某些类类型还会对它们所分配的对象使用拷贝初始化。例如，当我们初始化标准库容器或是调用其 insert 或 push 成员时，容器会对其元素进行拷贝初始化。与之相对，用 emplace 成员创建的元素都进行直接初始化。 参数和返回值 在函数调用过程中，具有非引用类型的参数要进行拷贝初始化。 拷贝构造函数被用来初始化非引用类类型参数，这一特性解释了为什么拷贝构造函数自己的参数必须是引用类型。如果其参数不是引用类型，则调用永远也不会成功——为了调用拷贝构造函数，我们必须拷贝它的实参，但为了拷贝实参，我们又需要调用拷贝构造函数，如此无限循环。 拷贝初始化的限制 如前所述，如果我们使用的初始化值要求通过一个 explicit 的构造函数来进行类型转换，那么使用拷贝初始化还是直接初始化就不是无关紧要的了： vector<int> v1(10); //正确，直接初始化 vector<int> v2 = 10; //错误：接受大小参数的构造函数是 explicit 的 void f(vector<int>); //f 的参数进行拷贝初始化 f(10); //错误：不能用一个 explicit 的构造函数拷贝一个实参 f(vector<int>(10)); //正确：从一个 int 直接构造一个临时的 vector 编译器可以绕过拷贝构造函数 在拷贝初始化的过程中，编译器可以（但不是必须）跳过拷贝/移动构造函数，直接创建对象。即，编译器允许将下面的代码： string null_book = \"9-999-99999-9\"; //拷贝初始化 改写为： string null_book(\"9-999-99999-9\"); //编译器略过了拷贝构造函数 但是，即使编译器略过拷贝/移动构造函数，但在这个程序点上，拷贝/移动构造函数必须是存在并且是可访问的（例如，不能是 private 的）。 拷贝赋值运算符 与控制其对象如何初始化一样，类也可以控制其对象如何赋值： Sales_data trans, accum; trans = accum; //使用 Sales_data 的拷贝赋值运算符 重载赋值运算符 重载运算符本质上是函数，其名字由 operator 关键字后接表示要定义的运算符的符号组成。因此，赋值运算符就是一个名为 operator= 的函数。 某些运算符，包括赋值运算符，必须定义为成员函数。如果一个运算符是一个成员函数，其左侧运算对象就绑定到隐式的 this 参数。对于一个二元运算符，例如赋值运算符，其右侧运算对象作为显式参数传递。 //拷贝赋值运算符接受一个与其所在类相同类型的参数 class Foo { public : Foo & operator = ( const Foo & ); //赋值运算符 //... }; 为了与内置类型的赋值保持一致，赋值运算符通常返回一个指向其左侧运算对象的引用。 合成拷贝赋值运算符 //等价于合成拷贝赋值运算符 Sales_data& Sales_data::operator=(const Sales_data &rhs) { bookNo = rhs.bookNo； //调用 string::operator= units_sold = rhs.units_sold; //使用内置的 int 赋值 revenue = rhs.revenue; //使用内置的 double 赋值 return *this; } 析构函数 析构函数执行与构造函数相反的操作：构造函数初始化对象的非 static 数据成员，还可能做一些其他工作；析构函数释放对象使用的资源，并销毁对象的非 static 数据成员。 析构函数是类的一个成员函数，名字由波浪号接类名构成，没有返回值，也不接受参数： class Foo { public : ~ Foo (); //析构函数 //... }; 由于析构函数不接受参数，因此它不能被重载。对一个给定类，只会有唯一一个析构函数。 在一个析构函数中，首先执行函数体，然后销毁成员。成员按初始化顺序的逆序销毁。 在一个析构函数中，不存在类似构造函数中初始化列表的东西来控制成员如何销毁，析构部分是隐式的。 成员销毁时发生什么完全依赖于成员的类型。 销毁类类型成员需要执行成员自己的析构函数。内置类型没有析构函数，因此销毁内置类型成员什么也不需要做。所以： 隐式销毁一个内置指针类型的成员不会 delete 它所指向的对象 当指向一个对象的引用或指针离开作用域时，析构函数不会执行 { //新作用域 //p 和 p2 指向动态分配的内存 Sales_data *p = new Sales_data; //p 是一个内置指针 auto p2 = make_shared<Sales_data>(); //p2 是一个 shared_ptr Sales_data item(*p); //拷贝构造函数将 p 拷贝到 item 中 vector<Sales_data> vec; //局部变量 vec.push_back(*p2); //拷贝 p2 指向的对象 delete p; //对 p 指向的对象进行析构函数 } //退出局部作用域；对 item、p2 和 vec 调用析构函数 //销毁 p2 会递减其引用计数；如果引用计数为0，对象被释放 //销毁 vec 会销毁它的元素 什么时候会调用析构函数 无论何时一个对象被销毁，就会自动调用其析构函数： 变量在离开作用域时被销毁 当一个对象被销毁时，其成员被销毁 容器（无论是标准库容器还是数组）被销毁时，其元素被销毁 对于动态分配的对象，当对指向它的指针应用 delete 运算符时被销毁 对于临时对象，当创建它的完整表达式结束时被销毁 合成析构函数（synthesized destructor） 当一个类未定义自己的析构函数时，编译器会为他定义一个合成析构函数。例如，下面的代码等价于 Sales_data 的合成析构函数： class Sales_data { public : //成员会被自动销毁，除此之外不需要做其他事情 ~ Sales_data() { } //其他成员的定义，如前 }; 在（空）析构函数体执行完毕后，成员会被自动销毁。特别的， string 的析构函数会被调用，它将释放 bookNo 成员所用的内存。认识到析构函数本身并不直接销毁成员是非常重要的。成员是在析构函数体之后隐含的析构阶段中被销毁的。在整个对象销毁过程中，析构函数体是作为成员销毁步骤之外的另一部分而进行的。 三/五法则 如前所述，有三个基本操作可以控制类的拷贝操作：拷贝构造函数、拷贝赋值运算符和析构函数。而且，在新标准下，一个类还可以定义一个移动构造函数和一个移动赋值运算符。 需要析构函数的类也需要拷贝和赋值操作 当我们决定一个类是否要定义它自己版本的拷贝控制成员时，一个基本的原则是首先确定这个类是否需要一个析构函数。如果这个类需要一个自定义析构函数，我几乎可以肯定它也需要自定义拷贝构造函数和自定义拷贝赋值运算符。 如果类在构造函数中分配动态内存。合成析构函数不会 delete 一个指针数据成员。因此，此类需要定义一个析构函数来释放构造函数分配的内存。 需要拷贝操作的类也需要赋值操作，反之亦然 虽然很多类需要定义所有(或是不需要定义任何)拷贝控制成员，但某些类所要完成的工作，只需要拷贝或赋值操作，不需要析构函数。第二个基本原则：如果一个类需要一个拷贝构造函数，几乎可以肯定它也需要一个拷贝赋值运算符。反之亦然。 使用 =default 我们可以通过将拷贝控制成员定义为=default来显示地要求编译器生成合成的版本： class Sales_data { public : //拷贝控制成员；使用default Sales_data () = default ; Sales_data ( const Sales_data & ) = default ; Sales_data & operator = ( const Sales_data & ); ~ Sales_data () = default ; //其他成员的定义，如前 }; Sales_data & Sales_data :: operator = ( const Sales_data & ) = default ; 当我们在类内使用 =default 修饰成员的声明时，合成的函数将隐式地声明为内联的。如果我们不希望合成的成员是内联函数，应该只对成员的类外定义使用 =default ，就像对拷贝赋值运算符所做的那样。 我们只能对具有合成版本的成员函数使用 =default (即，默认构造函数或拷贝控制成员)。 阻止拷贝 大多数类应该定义默认构造函数、拷贝构造函数和拷贝赋值运算符，无论是隐式地还是显示地。 但是，在某些情况下，定义类时必须采用某种机制阻止拷贝或赋值。例如， iostream 类阻止了拷贝，以避免多个对象写入或读取相同的 IO 缓冲。 为了阻止拷贝，看起来可能应该不定义拷贝控制成员。但是，这种策略是无效的：如果我们的类未定义这些操作，编译器为它生成合成的版本。 定义删除的函数 在新标准下，我们可以通过将拷贝构造函数和拷贝赋值运算符定义为删除的函数（deleted function）来阻止拷贝。删除的函数是这样一种函数：我们虽然声明了它们但不能以任何方式使用它们： struct NoCopy{ NoCopy() = default; //使用合成的默认构造函数 NoCopy(const NoCopy&) = delete; //阻止拷贝 NoCopy &operator=(const NoCopy&) = delete; //阻止赋值 ~NoCopy() = delete; //使用合成的析构函数 //其他成员 }; =delete 通知编译器（以及我们代码的读者），我们不希望定义这些成员 与 =default 不同， =delete 必须出现在函数第一次声明的时候 与 =default 的另一不同之处是，我们可以对任何函数指定 =delete （我们只能对编译器可以合成的默认构造函数或拷贝控制成员使用 =default ） 析构函数不能是删除的成员 值得注意的是，我们不能删除析构函数。如果析构函数被删除，就无法销毁此类型的的对象了。对于析构函数已删除的类型，不能定义该类型的变量或释放指向该类型动态分配对象的指针，但是可以动态分配这种类型的对象（然而动态分配后不能释放）。 合成的拷贝控制成员可能是删除的 如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数将被定义为删除的。 private 拷贝控制 在新标准发布之前，类是通过将其拷贝构造函数和拷贝赋值运算符声明为 private 的来阻止拷贝： class PrivateCopy { //无访问说明符；接下来的成员默认为 private 的 //拷贝控制成员是 private 的，因此普通用户代码无法访问 PrivateCopy ( const PrivateCopy & ); PrivateCopy & operator = ( const PrivateCopy & ); //其他成员 public ： PrivateCopy () = default ; //使用合成的默认构造函数 ~ PrivateCopy (); //用户可以定义此类型的对象，但无法拷贝它们 }; 为了阻止友元和成员函数进行拷贝，我们将这些拷贝控制成员声明为 private 的，但并不定义它们。声明但不定义一个成员函数是合法的(例外：我们必须为每一个虚函数都提供定义，而不管它是否被用到，这是因为连编译器也无法确定到底会使用哪个虚函数)。 通过声明（但不定义） private 的拷贝构造函数，我们可以预先阻止任何拷贝该类对象的企图：试图拷贝对象的用户代码将在编译阶段被标记为错误；成员函数或友元函数的拷贝操作将会导致链接时错误。 建议：希望阻止拷贝的类应该使用 =delete 来定义它们自己的拷贝构造函数和拷贝赋值运算符，而不应该将它们声明为 private 的。 拷贝控制和资源管理 为了定义这些成员，我们首先必须确定此类型对象的拷贝语义。一般来说，有两种选择：可以定义拷贝操作，使类的行为看起来像一个值或者像一个指针。 类的行为像一个值，意味着它应该也有自己的状态。当我们拷贝一个像值的对象时，副本和原对象是完全独立的。改变副本不会对原对象有任何影响，反之亦然； 行为像指针的类则共享状态。当我们拷贝一个这种类的对象时，副本和原对象使用相同的底层数据。改变副本也会改变原对象，反之亦然。 行为像值的类 class HasPtr { public : HasPtr ( const std :: string & s = std :: string ()) : ps ( new std :: string ( s )), i ( 0 ){ } //ps 指向的 string，每个 HasPtr 对象都有自己的拷贝 HasPtr ( const HasPtr & p ) : ps ( new std :: string ( * p . ps )), i ( p . i ) {} HasPtr & operator = ( const HasPtr & ); ~ HasPtr() { delete ps ;} private : std :: string * ps ; int i ; }; 类值拷贝赋值运算符赋值运算符通常组合了析构函数和构造函数的操作：类似析构函数，赋值操作会销毁左侧运算对象的资源；类似拷贝构造函数，赋值操作会从右侧运算对象拷贝数据。 本例中，通过先拷贝右侧运算对象，我们可以处理自赋值情况，并能保证异常发生时代码也是安全的。在完成拷贝后，我们释放左侧运算对象的资源，并更新指针指向新分配的 string ： HasPtr& HasPtr::operator=(const HasPtr&rhs) { auto newp = new string(*rhs.ps); //拷贝底层 string，注意成员选择优先级大于解引用，故等价于*(rhs.ps) delete ps; //释放旧内存 ps = newp; //从右侧运算对象拷贝数据到本对象 i = rhs.i; return *this; //返回本对象 } 当你编写赋值运算符时，有两点需要记住： 如果将一个对象赋予它自身，赋值运算符必须能正确工作 大多数赋值运算符组合了析构函数和拷贝构造函数的工作 当你编写一个赋值运算符时，一个好的模式是先将右侧运算对象拷贝到一个局部临时对象中。当拷贝完成后，销毁左侧运算对象的现有成员就是安全的了。一旦左侧运算对象的资源被销毁，就只剩下将数据从临时对象拷贝到左侧运算对象的成员中了。 为了说明防范自赋值操作的重要性，看下面一个错误的例子： //这样编写赋值运算符是错误的！ HasPtr& HasPtr::operator=(const HasPtr &rhs) { delete ps; //释放对象指向的 string //如果 rhs 和 *this 是同一个对象，我们就将从已释放的内存中拷贝数据！ ps = new string(*(rhs.ps)); i = rhs.i; return *this; } 如果 rhs 和本对象是同一个对象， delete ps 会释放 *this 和 rhs 指向的 string 。接下来，当我们在 new 表达式中试图拷贝 *(rhs.ps) 时，就会访问一个指向无效内存的指针，其行为和结果是未定义的。 定义行为像指针的类 对于行为类似指针的类，我们需要为其定义拷贝构造函数和拷贝赋值运算符，来拷贝指针成员本身而不是它指向的 string 。我们的类仍然需要自己的析构函数来释放接受 string 参数的构造函数分配的内存。但是，析构函数不能单方面地释放关联的 string ，只有当最后一个指向 string 的对象销毁时，才可以释放 string 。 令一个类展现类似指针的行为最好的方法是使用 shared_ptr 来管理类中的资源。如果我们希望直接管理资源，可以使用引用计数（reference count）。下面我们不使用 shared_ptr 而是使用引用计数来实现行为像指针的类。 引用计数 引用计数的工作方式如下： 除了初始化对象之外，每个构造函数(拷贝构造函数除外)都要创建一个引用计数，用来记录有多少对象共享正在创建的对象共享状态，当创建一个对象时，引用计数为1，因为此时只有一个对象共享 拷贝构造函数不分配新得引用计数器，拷贝给定对象的数据成员，包括引用计数器，拷贝构造函数递增共享的计数器，表示给定对象更的状态又被一个新用户所共享 拷贝赋值运算符递减左侧运算对象的引用计数器，递增右侧对象的引用计数器，如果左侧对象的引用计数器为0，则销毁左侧对象 析构函数判断引用计数是否为0，如果为0，则销毁左侧对象 引用计数的实现：我们假设有下面的情况： HasPtr h1; HasPtr h2(h1); HasPtr h3(h1); HasPtr 是一个行为像指针的类，新创建的 h1的引用计数为1，创建 h2，用 h1 初始化 h2，会递增 h1 的引用计数值，此时 h2 保存了 h1 中的引用计数，在创建 h3 的时候，递增了 h1 的引用计数值，而且我们必须做的是要更新 h2 中的引用计数值，此时无法更新 h2 中的引用计数值。因此，我们需要将引用计数保存在动态内存中，这样原对象和其他副本对象都会指向相同的计数器，这样就可以自动更新引用计数在每个共享对象中的状态。 class HasPtr { public : //构造函数分配新的 string 和新的计数器，将计数器置为1 HasPtr ( const std :: string & s = std :: string ()) : ps ( new std :: string ( s )), i ( 0 ), use ( new size_t ( 1 )) {} //拷贝构造函数拷贝所以三个数据成员，并递增计数器 HasPtr ( const HasPtr & p ) : ps ( p . ps ), i ( p . i ), use ( p . use ) { ++* use ; } HasPtr & operator = ( const HasPtr & ); ~ HasPtr (); private : std :: string * ps ; int i ; std :: size_t * use ; // 引用计数 }; HasPtr :: HasPtr & operator = ( const HasPtr & has ) { ++* has . use ; //递增右侧运算对象的引用计数 if ( 0 == --* use ) { //然后递减本对象的引用计数 delete ps ; delete use ; } ps = has . ps ; i = has . i ; use = has . use ; return * this ; } HasPtr ::~ HasPtr() { if ( --* use == 0 ) { delete ps ; delete use ; } } 交换操作 通常，管理资源的类除了定义拷贝控制成员之外，还会定义交换操作的函数 swap 。 如果一个类定义了自己的 swap ，那么算法将使用类自定义版本，否则，将使用标准库定义的 swap 。 理论上来说，我们的 swap 函数应该是这样的： //交换两个类值 HasPtr 对象的代码可能像下面这样： HasPtr temp = v1; //创建 v1 的值的一个临时副本 v1 = v2; //将 v2 的值赋予 v1 v2 = temp; //将保存的 v1 的值赋予 v2 这样的代码将 v1 中 string 拷贝了两次，但是这样做是没有必要的，我们希望 swap 交换指针，而不是分配 string 的副本： string *temp = v1.ps; //为 v1.ps 中的指针创建一个副本 v1.ps = v2.ps; //将 v2.ps 中的指针赋予 v1.ps1 v2.ps = temp; //将保存的 v1.ps 中原来的指针赋予 v2.ps 编写我们自己的 swap 函数 class HasPtr { friend void swap ( HasPtr & , HasPtr & ); //其他成员定义 }; inline void swap ( HasPtr & lhs , HasPtr & rhs ) { using std :: swap ; swap ( lhs . ps , rhs . ps ); //交换指针，而不是string数据 swap ( lhs . i , rhs . i ); //交换 int 成员 } 我们首先将 swap 定义为 friend 以便能访问 HasPtr 的（private的）数据成员。由于 swap 的存在就是为了优化代码，我们将其声明为 inline 函数。 与拷贝控制成员不同， swap 并不是必要的。但是，对于分配了资源的类，定义 swap 可能是一种很重要的优化手段。 swap 函数应该调用 swap，而不是 std::swap 在 swap 函数中，使用了 using std::swap ，如果这个类有自己的 swap 函数，匹配程度会高于标准库 swap ，会优先使用类自己的 swap ，如果没有，则使用标准库的 swap 。 swap 里交换类的指针和 int 成员，并不会发生递归循环，HasPtr 的数据成员是内置类型的，这时候会调用标准库版本的 swap 。 在赋值运算符中使用 swap 定义 swap 的类通常用 swap 来定义它们的赋值运算符。这些运算符使用了一种名为拷贝并交换（copy and swap）的技术。这种技术将左侧运算对象与右侧运算对象的一个副本进行交换： //注意 rhs 是按值传递的，意味着 HasPtr 的拷贝构造函数将 //右侧运算对象中的 string 拷贝到 rhs HasPtr& HasPtr::operator=(HasPtr rhs) { //交换左侧运算对象和局部变量 rhs 的内容 swap(*this, rhs); //rhs 现在指向本对象曾经使用的内存 return *this; //rhs 被销毁，从而 delete 了 rhs 中的指针 } 在进行 HasPtr 类的赋值运算中，先将右侧对象拷贝到拷贝赋值运算符函数里，然后交换左侧对象的指针和右侧对象的指针，交换后，右侧对象赋值给了左侧对象，左侧对象相应的 string 指针也指向了右侧对象副本的对应成员，而右侧对象的 string 指针则指向了左侧对象的相应成员。在这个函数结束后，右侧对象的副本被销毁，于是原来左侧对象的资源被释放，而左侧对象现在保存的是右侧对象的成员。 拷贝并交换的操作，和之前的拷贝赋值运算符的实现原理是相同的， 在改变左侧对象之前拷贝右侧对象。保证了这样的操作异常的安全。 对象移动 新标准的一个最主要的特性是可以移动而非拷贝对象的能力。在某些情况下对象拷贝后就立即被销毁了。在这些情况下，移动而非拷贝对象会大幅度提升性能。 使用移动而不是拷贝的另一个原因源于 IO 类或 unique_ptr 这样的类。这些类都包括不能被共享的资源。因此，这些类型的对象不能拷贝但可以移动。 类似的，在旧版本的标准库中，容器所保存的类必须是可拷贝的，但在新标准中，我们可以用容器保存不可拷贝的类型，只要它们能被移动就行。 标准库容器、 string 和 shared_ptr 类既支持移动也支持拷贝。 IO 类和 unique_ptr 类可以移动但不能拷贝。 右值引用 为了支持移动操作，新标准引入了一种新的引用类型——右值引用（rvalue reference）。我们通过 && 而不是 & 来获得右值引用。右值引用一个重要性质——只能绑定到一个将要销毁的对象。 一般而言，一个左值表达式表示的是一个对象的身份，而一个右值表达式表示的是对象的值。 对于常规引用(我们可以称之为左值引用)，我们不能将其绑定到要求转换的表达式、字面常量或是返回右值的表达式。右值引用有着完全相反的特性：我们可以将一个右值引用绑定到这类表达式上，但不能将一个右值引用直接绑定到一个左值上： int i = 42; int &r = i; //正确：r 引用 i int &&rr = i; //错误：不能将一个右值引用绑定到一个左值上 int &r2 = i * 42; //错误：i * 42是一个右值 const int &r3 = i * 42; //正确：我们可以将一个 const 的引用绑定到一个右值上 int &&rr2 = i * 42; //正确：将 rr2 绑定到乘法结果上 返回左值引用的函数，连同赋值、下标、解引用和前置递增/递减运算符，都是返回左值的表达式的例子，我们可以将一个左值引用绑定到这类表达式的结果上。 返回非引用类型的函数，连同算术、关系、位以及后置递增/递减运算符，都生成右值。我们不能将一个左值引用绑定到这类表达式上，但我们可以将一个 const 的左值引用或者一个右值引用绑定到这类表达式上。 左值持久；右值短暂 由于右值引用只能绑定到临时对象，我们得知： 所引用的对象将要被销毁 该对象没有其他用户 这两个特性意味着：使用右值引用的代码可以自由地接管所引用的对象的资源。右值引用指向将要被销毁的对象。因此，我们可以从绑定到右值引用的对象\"窃取\"状态。 变量是左值 变量可以看作只有一个运算对象而没有运算符的表达式。变量表达式都是左值，这意味着我们不能讲一个右值引用绑定到一个右值引用类型的变量上： int &&rr1 = 42; //正确：字面常量是右值 it &&rr2 = rr1; //错误：表达式 rr1 是左值！ 其实有了右值表示临时对象这一观察结果，变量是左值这一特性并不令人惊讶。毕竟，变量是持久的，直至离开作用域时才被销毁。 变量是左值，因此我们不能将一个右值引用直接绑定到一个变量上，即使这个变量是右值引用类型也不行。 标准库 move 函数 虽然不能将一个右值引用直接绑定到一个左值上，但我们可以显示地将一个左值转换为对应的右值引用类型。我们还可以通过调用一个名为 move 的新标准库函数来获得绑定到左值上的右值引用。 move 定义在头文件 utility 中。 # inclue < utility > int && rr3 = std :: move ( rr1 ); // ok move 调用告诉编译器：我们有一个左值，但我们希望像一个右值一样处理它。我们必须认识到，调用 move 就意味承诺：除了对 rr1 赋值或销毁它外，我们将不再使用它。 我们可以销毁一个移后源对象，也可以赋予它新值，但不能使用一个移后源对象的值。 对 move 我们不提供 using 声明。我们直接调用 std::move 而不是 move 。这样可以避免潜在的名字冲突。 移动构造函数和移动赋值运算符 类似 string 类（及其他标准库类），如果我们自己的类也同时支持移动和拷贝，那么也能从中受益。这两个成员类似对应的拷贝操作，但它们从给定对象\"窃取\"资源而不是拷贝资源。 类似拷贝构造函数，移动构造函数的第一个参数是该类类型的一个引用。不同于拷贝构造函数的是，这个引用参数在移动构造函数中是一个右值引用。与拷贝构造函数一样，任何额外的参数都必须有默认实参。 除了完成资源移动，移动构造函数还必须确保移后源对象处于这样一个状态——销毁它是无害的。 作为一个例子，我们为 StrVec 类定义移动构造函数，实现从一个 StrVec 到另一个 StrVec 的元素移动而非拷贝： StrVec::StrVec(StrVec &&s) noexcept //移动操作不应抛出任何异常 //c成员初始化器接管s中的资源 ：elements(s.elements), first_free(s.first_free), cap(s.cap) { //令s进入这样的状态———对其运行析构函数是安全的 s.elements = s.first_free = s.cap = nullptr; } 移动操作、标准库容器和异常 由于移动操作\"窃取\"资源，它通常不分配任何资源。因此，移动操作通常不会抛出任何异常。一种通知标准库的方法是在我们的构造函数中指明 noexcept 。 noexcept 是新标准引入的。在一个构造函数中， noexcept 出现在参数列表被初始化列表开始的冒号之间。我们必须在类头文件声明和定义中（如果定义在类外的话）都指定 noexcept 。 不抛出异常的移动构造函数和移动赋值运算符必须标记为 noexcept 。 移动赋值运算符 移动赋值运算符执行与析构函数和移动构造函数相同的工作。 StrVec &StrVec::operator=(StrVec &&rhs) noexcept { //直接检测自赋值 if (this != &rhs){ free(); //释放已有元素 elements = rhs.elements; //从 rhs 接管资源 first_free = rhs.first_free; cap = rhs.cap; //将 rhs 置于可析构状态 rhs.elements = rhs.first_free = rhs.cap = nullptr; } return *this; } 我们进行自赋值检查的原因是此右值可能是 move 调用的返回结果。 移后源对象必须可析构 在移动操作之后，移后源对象必须保持有效的、可析构的状态，但是用户不能对其值进行任何假设。 合成的移动操作 只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非 static 数据成员都可以移动时，编译器才会为它合成移动构造函数或移动赋值运算符。 与拷贝操作不同，移动操作永远不会隐式定义为删除的函数。但是，如果我们显示地要求编译器生成 =default 的移动操作，且编译器不能移动所有成员，则编译器会将移动操作定义为删除的函数。 移动操作和合成的拷贝控制成员之间还有最后一个相互作用关系：一个类是否定义了自己的移动操作对拷贝操作如何合成有影响。如果类定义了一个移动构造函数和/或一个移动赋值运算符，则该类的合成拷贝构造函数和拷贝赋值运算符会被定义为删除的。 移动右值，拷贝左值 如果一个类既有移动构造函数，也有拷贝构造函数，编译器使用普通的函数匹配规则来确定使用哪个构造函数。赋值操作的情况类似。 但如果没有移动构造函数，右值也被拷贝 使用拷贝构造函数代替移动构造函数几乎肯定是安全的。 拷贝并交换赋值运算符和移动操作 更新的三/五法则 一般来说，如果一个类定义了任何一个拷贝操作，它就应该定义所有五个操作。 移动迭代器 新标准库中定义了一种移动迭代器（move iterator）适配器。一个移动迭代器通过改变给定迭代器的解引用运算符的行为来适配此迭代器。一般来说，一个迭代器的解引用运算符返回一个指向元素的左值。与其他迭代器不同，移动迭代器的解引用运算符生成一个右值引用。 我们通过调用标准库的 make_move_iterator 函数将一个普通迭代器转换为一个移动迭代器。此函数接受一个迭代器参数，返回一个移动迭代器。 原迭代器的所有其他操作在移动迭代器中都照常工作。由于移动迭代器支持正常的迭代器操作，我们可以将一对移动迭代器传递给算法。特别地，可以将移动迭代器传递给 uninitialized_copy ： void StrVec::reallocate() { //分配大小两倍于当前规模的内存空间 auto newcapacity = size() ? 2 * size() : 1; auto first = alloc.allocate(newcapacity); //移动元素 auto last = uninitialized_copy(make_move_iterator(begin()), make_move_iterator(end()), first); free(); //释放旧空间 elements = first; //更新指针 first_free = last; cap = elements + newcapacity; } 不要随意使用移动操作，由于一个移后源对象具有不确定的状态，对其调用 std::move 是危险的。当我们调用 move 时，必须绝对确认移后源对象没有其他用户。 通过在类代码中小心地使用 move ，可以大幅度提升性能。而如果随意在普通用户代码（与类实现代码相对）中使用移动操作，很可能导致莫名其妙的、难以查找的错误，而难以提升应用程序性能。 右值引用和成员函数 除了构造函数和赋值运算符外，如果一个成员函数同时提供拷贝和移动操作，它也能从中受益。一个版本接受一个指向 const 的左值引用，另一个版本接受指向非 const 的右值引用。 一般来说，我们不需要为函数操作定义接受一个 const X&& 或是一个（普通的） X& 参数的版本。当我们希望从实参\"窃取\"数据时，通常传递一个右值引用。为了达到这一目的，实参不能是 const 的。类似的，从一个对象进行拷贝的操作不应该改变该对象，因此，通常不需要定义一个接受（普通的） X& 参数的版本。 区分移动和拷贝的重载函数通常有一个版本接受一个 const T& ，而另一个版本接受 T&& 。 class StrVec { public : void push_back ( const std :: string & ); //移动元素 void push_back ( std :: string && ); //拷贝元素 //其他成员的定义 }; void StrVec : push_back ( const string & s ){ chk_n_alloc (); //确保有空间容纳新元素 //在 first_free 指向的元素中构造 s 的一个副本 alloc . constructor ( first_free ++ , s ); } void StrVec :: push_back ( string && ){ chk_n_alloc (); //如果需要的话为 StrVec 重新分配内存 alloc . constructor ( first_free ++ , std :: move ( s )); } constructor 函数使用第二个和随后的实参类型来确定使用哪个构造函数。由于 move 返回一个右值引用，因此，会使用 string 的移动构造函数来构造新元素。 左值和右值引用成员函数 重载和引用函数 就像一个成员函数可以根据是否有 const 来区分其重载版本一样，引用限定符也可以区分重载版本。而且，我们可以综合引用限定符和 const 来区分一个成员函数的重载版本。 当我们定义 const 成员函数时，可以定义两个版本，唯一的差别是一个版本有 const 限定而另一个没有。引用限定的函数则不一样。如果我们定义两个或两个以上具有相同名字和相同参数列表的成员函数，就必须对所有函数都加上引用限定符，或者所有都不加。","tags":"读书笔记","url":"https://xutree.github.io/pages/2018/10/20/C++_Primer_Chapter_13/"},{"title":"C++ Primer 第十二章 动态内存","text":"一个由 C/C++ 编译的程序占用的内存分为以下几个部分： 栈区（stack）：由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈 堆区（heap）：一般由程序员分配释放，若程序员不释放，程序结束时可能由 OS 回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表 全局区（静态区）（static）：全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量、未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放 文字常量区：常量字符串就是放在这里的。程序结束后由系统释放 程序代码区：存放函数体的二进制代码 动态内存与智能指针 在 C++ 中，动态内存的管理是通过一对运算符来完成的： new ，在动态内存中为对象分配空间并返回一个指向该对象的指针，我们可以选择对对象进行初始化； delete ，接受一个动态指针，销毁该对象，并释放与之关联的内存。 为了更容易地使用动态内存，新的标准提供了两种智能指针(smart pointer)类型来管理动态对象。 shared_ptr 允许多个指针指向同一个对象； unique_ptr 则\"独占\"所指向的对象。标准库还定义了一个名为 weak_ptr 的伴随类，指向 shared_ptr 所管理的对象。这三种类型都定义在 memory 头文件中。 shared_ptr 类 类似 vector 智能指针也是模板： shared_ptr<string> p1; //shared_ptr，可以指向 string shared_ptr<list<int>> p2; //shared_ptr,可以指向 int 的 list 当我们创建 shared_ptr 时，可以传递一个（可选的）指向删除器函数的参数。 智能指针操作： make_shared 函数 最安全的分配和使用动态内存的方法是调用一个名为 make_shared 的标准库函数。此函数在动态内存中分配一个对象并初始化它，返回指向此对象的 shared_ptr 。与智能指针一样， make_shared 也定义在 memory 头文件中。 //指向一个值为42的 int 的 shared_ptr shared_ptr<int> p3 = make_shared<int>(42); //p4 指向一个值为\"999999999\"的 string shared_ptr<string> p4 = make_shared<string>(10,'9'); //p5 指向一个值初始化的 int，即，值为0 shared_ptr<int> p5 = make_shared<int>(); 类似顺序容器的 emplace 成员， make_shared 用其参数来构造给定类型的对象。例如，调用 make_shared<string> 时传递的参数必须与 string 的某个构造函数相匹配。 当然，我们通常用 auto 定义一个对象来保存 make_shared 的结果，这种方式简单： //p6 指向一个动态分配的空 vector<string> auto p6 = make_shared<vector<string>>(); shared_ptr 的拷贝和赋值 当进行拷贝或赋值操作时，每个 shared_ptr 都会记录有多少个其他 shared_ptr 指向相同的对象。 我们可以认为每个 shared_ptr 都有一个关联的计数器，通常称其为引用计数(reference count)。无论何时我们拷贝一个 shared_ptr ，计数器都会递增；当我们给 shared_ptr 赋予一个新值或是 shared_ptr 被销毁时，计算器就会递减。 一旦一个 shared_ptr 的计数器变为0，它就会自动释放自己所管理的对象。 auto r = make_shared<int>(42); //r 指向的 int 只有一个引用者 r = q; //给 r 赋值，令它指向另一个地址 //递增 q 指向的对象的引用计数 //递减 r 原来指向对象的引用计数 //r 原来指向的对象已没有引用者，会自动释放 shared_ptr 自动销毁所管理的对象，还会自动释放相关联的内存。 如果你将 shared_ptr 存放于一个容器中，而后不再需要全部元素，要记得使用 erase 删除不需要的那些元素，否则 shared_ptr 在无用之后会仍然保留。 直接管理内存 C++ 语言定义了两个运算符来分配和释放动态内存。运算符 new 分配内存， delete 释放 new 分配的内存。相对于智能指针，使用这两个运算符管理内存非常容易出错。 使用 new 动态分配和初始化对象 在自由空间分配的内存是无名的，因此 new 无法为其分配的对象命名，而是返回一个指向该对象的指针： int *pi = new int; //pi 指向一个动态分配的、未初始化的无名对象 默认情况下，动态分配的对象是默认初始化的，这意味着内置类型或组合类型的对象的值将是未定义的，而类类型对象将用默认构造函数进行初始化： string *ps = new string; //初始化为空 string int *pi = new int; //pi 指向一个未初始化的 int //可以使用直接初始化方式来初始化一个动态分配的对象 int *pi = new int(1024); //pi 指向的对象的值为1024 string *ps = new string(10,'9'); //*ps 为\"999999999\" //vector 有10个元素，值依次从0到9 vector<int> *pv = new vector<int>{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; 也可以对动态分配的对象进行值初始化，只需在类型名之后跟一对空括号即可： string *ps1 = new string; //默认初始化为空 string string *ps = new string(); //值初始化为空 string int *pi1 = new int; //默认初始化；*pi1 的值未定义 int *pi2 = new int(); //值初始化为0；*pi2 为0 如果我们提供了一个括号包围的初始化器，就可以用 auto 从此初始化器推断我们想要分配的对象的类型。但是由于编译器要用初始化器类型来推断分配的类型，只有当括号中仅有单一初始化器时才可以使用 auto （这也意味着不能用 auto 动态分配数组）。 动态分配的 const 对象 //分配并初始化一个 const int const int *pci = new const int(1024); //分配并默认初始化一个 const 的空 string const string *pcs =new const string; 类似其他任何 const 对象，一个动态分配的 const 对象必须进行初始化。对于一个定义了默认构造函数的类类型，其 const 动态对象可以隐式初始化，而其他类型的对象就必须显式初始化。由于分配的对象是 const 的， new 返回的指针是一个指向 const 的指针。 内存耗尽 默认情况下，如果 new 不能分配所要求的内存空间，它会抛出一个类型为 bad_alloc 的异常。我们可以改变使用 new 的方式来阻止它抛出异常： //若果分配失败，new返回一个空指针 int *p1 = new int; //如果分配失败，new 抛出std::bad_alloc int *p2 = new (nothrow) int; //如果分配失败，new 返回一个空指针 我们称这种形式的 new 为定位 new ， bad_alloc 和 nothrow 都定义在 new 头文件中。 释放动态内存 为了防止内存耗尽，在动态内存使用完毕后，必须将其归还给系统。我们通过 delete 表达式(delete expression)来将动态内存归还给系统。 与 new 类似， delete 表达式也执行两个动作：销毁给定的指针指向的对象；释放对应的内存。在 delete 之后，指针就变成了人们所说的空悬指针，即指向一块曾经保存数据对象但现在已经无效的内存的指针。如果需要保留指针，可以在 delete 之后将 nullptr 赋予指针。 使用 new 和 delete 管理动态内存存在的三个常见问题 忘记 delete 内存。忘记释放动态内存会导致人们常说的\"内存泄露\"问题，因为这种内存永远不可能归还给自由空间了。查找内存泄露错误是非常困难的。 使用已经释放掉的对象。通过在释放内存后将指针置为空，有时可以检测出这种错误。 同一块内存释放两次。当两个指针指向相同的动态分配对象时，可能发生这种错误。 shared_ptr 和 new 结合使用 如前所述，如果我们不初始化一个智能指针，他就会被初始化为一个空指针。如下表所示，我们还可以用 new 返回的指针来初始化智能指针： shared_ptr<double> p1; //shared_ptr 可以指向一个 double shared_ptr<int> p2(new int (42)); //p2 指向一个值为42的 int 接受指针参数的智能指针构造函数是 explicit 的。因此，我们不能将一个内置指针隐式转换为一个智能指针，必须使用直接初始化形式来初始化一个智能指针： shared_ptr<int> p1 = new int(1024); //错误：必须使用直接初始化形式 shared_ptr<int> p2(new int (1024)); //正确：使用了直接初始化 出于相同的原因，一个返回 shared_ptr 的函数不能在其返回语句中隐式转换一个普通指针： shared_ptr<int> clone(int p){ return new int(p); //错误：隐式转换为 shared_ptr<int> } //我们必须将 shared_ptr 显式绑定到一个想要返回的指针上： shared_ptr<int> clone(int p){ //正确：显式地用 int* 创建 shared_ptr<int> return shared_ptr<int>(new int(p)); } 默认情况下，一个用来初始化智能指针的普通指针必须指向动态内存，因为智能指针默认使用 delete 释放它所关联的对象。 不要混合使用普通指针和智能指针： 也不要使用get初始化另一个智能指针或为智能指针赋值： unique_ptr 指针 一个 unique_ptr \"拥有\"它所指向的对象。与 shared_ptr 不同，某个时刻只能有一个 unique_ptr 指向一个给定对象。 与 shared_ptr 不同，没有类似 make_shared 的标准库函数返回一个 unique_ptr 。当我们定义一个 unique_ptr 时，需要将其绑定到一个 new 返回的指针上。类似 shared_ptr ，初始化 unique_ptr 必须采用直接初始化形式： unique_ptr<double> p1; //可以指向一个 double 的 unique_ptr unique_ptr<int> p2(new int(42)); //p2 指向一个值为42的 int 由于一个 unique_ptr 拥有它指向的对象，因此 unique_ptr 不支持普通的拷贝或赋值操作： unique_ptr<string> p1(new string(\"Stegosaurus\"); unique_ptr<string> p2(p1); //错误：unique_ptr 不支持拷贝 unique_ptr<string> p3; p3 = p2; //错误：unique_ptr 不支持赋值 unique_ptr 特有的操作： 虽然我不能拷贝或赋值 unique_ptr ，但可以通过调用 release 或 reset 将指针的所有权从一个（非 const ） unique_ptr 转移给另一个 unique ： //将所有权从 p1（指向 string Stegosaurus）转移给 p2 unique_ptr<string> p2(p1.release()); //release 将 p1 置为空 unique_ptr<string> p3(new string(\"Trex\")); //将所有权从 p3 转移给 p2 p2.reset(p3.release()); //reset 释放了 p2 原来指向的内存 调用 release 会切断 unique_ptr 和它原来管理的对象间的联系。 release 返回的指针通常被用来初始化另一个智能指针或给另一个智能指针赋值。 传递 unique_ptr 参数和返回 unique_ptr 不能拷贝 unique_ptr 的规则有一个例外：我们可以拷贝或赋值一个将要被销毁的 unique_ptr 。最常见的例子是从函数返回一个 unique_ptr ： unique_ptr<int> clone(int p){ //正确：从int*创建一个unique_ptr<int> return unique_ptr<int>(new int(p)); } //还可以返回一个局部对象的拷贝 unique_ptr<int> clone(int p){ unique_ptr<int> ret(new int(p)); //... return ret; } 对于两段代码，编译器都知道要返回的对象将要销毁。在此情况下，编译器执行一种特殊的\"拷贝\"。 向 unique_ptr 传递删除器 类似 shared_ptr ， unique_ptr 默认情况下用 delete 释放它指向的对象。与 shared_ptr 一样，我们可以重载一个 unique_ptr 中默认的删除器。与重载关联容器的比较操作类似，我们必须在尖括号中 unique_ptr 指向类型之后提供删除器类型。在创建或 reset 一个这种 unique_ptr 类型对象时，必须提供一个指定类型的可调用对象（删除器）： //p指向一个类型为 objT 的对象，并使用一个类型为 delT 的对象释放 objT 对象 //它会调用一个名为 fcn 的 delT 类型对象 unique_ptr<objT, delT> p(new objT,fcn); //作为一个更具体的例子，我们将重写连接程序，用 unique_ptr 代替 shared_ptr void f(destination &d /*其他需要的参数*/) { connection c = connect(&d); //打开连接 //当 p 被销毁时，连接将会关闭 unique_ptr<connection, decltype(end_connection)*> p(&c, end_connection); //使用连接 //当 f 退出时，connection 会被正确关闭 } weak_ptr weak_ptr 是一种不控制所指向对象生存期的智能指针，它指向由一个 shared_ptr 管理的对象。将一个 weak_ptr 绑定到一个 shared_ptr 不会改变 shared_ptr 的引用计数。 一旦最后一个指向对象的 shared_ptr 被销毁，对象就会被释放，即使有 weak_ptr 指向对象。 weak_ptr 操作： 当创建一个 weak_ptr 时，要用一个 shared_ptr 来初始化它： auto p = make_shared<int>(42); weak_ptr<int> wp(p); //wp 弱共享 p；p 的引用计数未改变 由于对象可能不存在，我们不能使用 weak_ptr 直接访问对象，而必须调用 lock 。此函数检查 weak_ptr 指向的对象是否存在。 动态数组 new 和 delete 运算符一次分配/释放一个对象，但某些应用需要一次为很多对象分配内存的功能。为了支持这种需求，C++ 语言和标准库提供了两种一次分配一个对象数组的方法。C++ 语言定义了一种 new 表达式，可以分配并初始化一个对象数组。 标准库中包含一个名为 allocator 的类，允许我们将分配和初始化分离。使用 allocator 通常会提供更好的性能和更灵活的内存管理能力。 大多数应用应该使用标准库容器而不是动态分配的数组。使用容器更为简单、更不容易出现内存管理错误并且可能有更好的性能。 new 和数组 //调用 get_size 确定分配多少个 int int *pia = new int[get_size]; //pia 指向第一个 int //方括号中的大小必须是整型，但不必是常量 typedef int arrT[42]; //arrT 表示42个 int 的数组类型 int *p = new arrT; // 分配一个数组会得到一个元素类型的指针 虽然我们通常称 new T[] 分配的内存为\"动态数组\"，但这种叫法某种程度上有些误导。当用 new 分配一个数组时，我们并未得到一个数组类型的对象，而是得到一个数组元素类型的指针。 由于分配的内存并不是一个数组类型，因此不能对动态数组调用 begin 和 end 。这些函数使用数组维度来返回指向首元素和尾元素的指针。处于相同的原因，也不能用范围 for 语句来处理（所谓的）动态数组中的元素。 要记住我们所说的动态数组并不是数组类型，这是很重要的。 初始化动态分配对象的数组 默认情况下， new 分配的对象，不管是单个分配的还是数组中的，都是默认初始化的。可以对数组中的元素进行值初始化，方法是在大小之后跟一对空括号。 int *pia = new int[10]; //10个未初始化的 int int *pia2 = new int[10](); //10个值初始化为0的 int string *psa = new string[10]; //10个空 string string *psa2 = new string[10](); //10个空 string //在新标准中，我们还提供一个元素初始化器的花括号列表： //10个 int 分别用列表中对应的初始化器初始化 int *pia3 = new int[10] {0,1,2,3,4,5,6,7,8,9}; //10个 string，前4个用给定的初始化器初始化，剩余的进行值初始化 string *psa3 = new string[10]{\"a\", \"an\", \"the\", string(3,'x')}; 如果初始化器数目大于元素数目，则 new 表达式失败，不会分配任何内存，并抛出 bad_array_new_length 的异常，类似于 bad_alloc ，此类型定义在头文件 new 中。 动态分配一个空数组是合法的 我们在使用 new 分配一个动态数组时，可以指定分配数组的大小为0，这样做是合法的： char *pc = new char(0); 此时 new 返回一个与其他 new 表达式返回类型都不同的指针类型， 该指针不能解引用，就像一个数组的尾后迭代器一样。 释放动态数组 为了释放动态数组，我们使用一种特殊形式的 delete ——在指针前加上一个空括号对： delete p; //p 必须指向一个动态分配的对象或为空 delete [] pa; //pa 必须指向一个动态分配的数组或为空 第二条语句销毁 pa 指向的数组中的元素，并释放对应的内存。数组中的元素按逆序销毁，即，最后一个元素首先被销毁，然后是倒数第二个，以此类推。 当我们释放一个动态数组时，空方括号是必须的，它指示编译器此指针指向一个对象数组的第一个元素。 delete 一个动态数组时未添加空方括号或 delete 一个普通指针时添加了空方括号，其行为都是未定义的。 前面我们讲到， 可以使用 typedef 来给动态数组起一个别名，这样在 new 一个动态数组时就不必添加方括号 [] ，即使这样，我们在释放一个动态数组时，仍然需要添加方括号 [] ，因为它本质上还是一个动态数组。 智能指针和动态数组 unique_ptr 智能指针有个可以管理 new 分配的动态数组的版本，为了使用一个 unique_ptr 来管理动态数组，需要在对象类型后加一个空方括号 [] : unique_ptr<int[]> up(new int[10]()); up.release(); // 自动调用 delete [] 销毁其指针 当一个 unique_ptr 指向一个数组时，我们不能使用点和箭头成员运算符，毕竟， unique_ptr 指向的是一个数组而不是单个对象。不过，我们可以使用下表运算符来访问数组中的元素： for (size_t i = 0; i < 10; ++i) up[i] = i; shared_ptr 不支持动态数组，如果希望使用 shared_ptr 管理一个动态数组，我们需要提供自己的删除器： shared_ptr<int> sp(new int[10], [](int* p){ delete [] p; }); sp.reset(); 我们在这个例子中使用 lambda 做为 shared_ptr 的删除器，如果我们不提供删除器，这样的行为是未定义的，因为默认情况下 shared_ptr 使用 delete 来释放内存，使用 delete 来释放一个动态数组的定位是未定义的。 shared_ptr 不支持动态数组这一特性会影响我们访问数组中的元素： for (size_t i = 0; i != 10; ++i) *(sp.get() + i) = i; shared_ptr 没有定义下标运算符，而且智能指针不支持指针算术运算。因此，为了访问数组中的元素，我们必须用 get 成员函数获取一个内置指针，然后使用该内置指针来访问数租元素。 allocator 类 标准库 allocator 类定义在头文件 memory 中。它帮助我们将内存分配和构造分离开来，它分配的内存是原始的、未构造的。 类似 vector ， allocator 也是一个模板类，我们在定义一个 allocator 类类型的时候需要制定它要分配内存的类型，它会根据给定的对象类型来确定恰当的内存大小和对齐位置： allocator<string> alloc; auto const p = alloc.allocate(n); // 分配 n 个未初始化的 string allocator 类及其算法： 操作 意义 allocator a 定义了一个名为 a 的 allocator 对象，可以为类型为 T 的对象分配内存 a.allocate(n) 分配一段原始的、未构造的内存，保存 n 个类型为 T 的对象 a.deallocate(p, n) 释放从 T* 指针 p 中地址开始的内存，这块内存保存了 n 个类型为 T 的对象；p 必须是一个先前由 allocate 成员函数返回的指针，且 n 必须是创建时候的大小，在调用 deallocate 之前，用户必须对每个在在这块内存中创建的对象调用 destroy 函数 a.construct(p, args) p 必须是一个类型为 T* 的指针，指向一块原始内存，args 被传递给类型为 T 的构造函数 a.destroy(p) p 为 T* 类型的指针，此算法对 p 执行析构函数 allocator 分配未构造的内存 auto q = p; //q 指向最后构造的元素之后的位置 alloc.construct(q++); //*q 为空字符串 alloc.construct(q++, 10, 'c'); //*q 为cccccccccc alloc.construct(q++, \"hi\"); //*q 为hi 为了使用 allocate 返回的内存，我们必须用 construct 构造对象。使用未构造的内存，其行为是未定义的。 当我们用完对象后，必须对每个构造的元素调用 destroy 来销毁它们。函数 destroy 接受一个指针，对指向的对象执行析构函数： while(q != p) alloc.destroy(--q); //释放我们真正构造的 string 一旦元素被销毁后，就可以重新使用这部分内存来保存其他 string ，也可以将其归还给系统。释放内存通过调用 deallocate 来完成： alloc.deallocate(p, n); //传递给 deallocate 的指针不能为空，它必须指向由 allocate 分配的内存 //传递给 deallcoate 的大小参数必须与调用 allocate 分配内存时提供的大小参数具有一样的值 我们只能对真正构造了的元素进行 destroy 操作。 拷贝和填充为初始化内存的算法 标准库为 allocator 类定义了两个伴随算法，可以在未初始化内存中创建对象： 操作 意义 uninitialized_copy(b, e, b2) 从迭代器 b 和 e 指出的输入范围中拷贝元素到迭代器 b2 指定的未构造的原始内存中，b2 指向的内存必须足够大，能容下输入序列中的元素的拷贝 uninitialized_copy_n(b, n, b2) 从迭代器 b 指向的元素开始，拷贝 n 个元素到 b2 开始的原始内存中 uninitialized_fill(b, e, t) 在迭代器 b 和 e 指定的原始内存范围中创建对象，值均为 t 的拷贝 uninitialized_fill_n(b, n, t) 从迭代器 b 指向的原始内存地址开始创建 n 个对象，b 必须指向足够大的未构造的原始内存，能容纳给定数量的对象 这些函数在给定目的位置创建元素，而不是由系统分配内存给他们。 vector<int> vec{0, 1, 2, 3, 4, 5}; auto p = alloc.allocate(vec.size() * 2); auto q = uninitialized_copy(vec.begin(), vec.end(), p); uninitialize_fill_n(q, vec.size(), 42); uninitialized_copy 在给定位置构造元素，函数返回递增后的目的位置迭代器。因此，一个 uninitialized_copy 调用会返回一个指针，指向 最后一个构造的元素之后的位置。","tags":"读书笔记","url":"https://xutree.github.io/pages/2018/10/17/C++_Primer_Chapter_12/"},{"title":"C++ Primer 第十一章 关联容器","text":"关联容器和顺序容器有着根本的不同：关联容器中的元素是按关键字来保存和访问的。与之相对，顺序容器中的元素是按它们在容器中的位置来顺序保存和访问的。 关联容器支持高效的关键字查找和访问。两个主要的关联容器（associative-container）类型是 map 和 set 。 map 中的元素是一些关键字-值（key-value）对：关键字起到索引的作用，值则表示与索引相关联的数据。 set 中每个元素只包含一个关键字， set 支持高效的关键字查询操作。 类型 map 和 multimap 定义在头文件 map 中； set 和 multiset 定义在头文件 set 中；无序容器则定义在头文件 unordered_map 和 unordered_set 中。无序容器使用哈希函数来组织元素。 关联容器类型： 按关键字有序保存元素 map：关联数组，保存关键字-值对 set：关键字即值，即只保存关键字的容器 multimap：关键字可重复的 map multiset：关键字可重复的 set 无序集合 unordered_map：用哈希函数组织的 map unordered_set：用哈希函数组织的 set unordered_multimap：哈希组织的 map，关键字可重复出现 unordered_multiset：哈希组织的 set，关键字可重复出现 关联容器概述 关联容器（有序和无序的）都支持如下的普通容器操作： 关联容器不支持顺序容器位置相关的\b操作，例如 push_front 或 push_back ，关联容器也不支持构造函数或插入操作这些接受一个元素值和一个数量值的操作。 关联容器的迭代器都是双向的。 定义关联容器 每个关联容器都定义一个默认构造函数，它创建一个指定类型的空容器。我们可以将关联容器初始化为另一个同类型容器的拷贝，或者从一个值范围来初始化关联容器，只要这些值可以转换为容器所需类型就行。在新标准下，我们也可以对关联容器进行值初始化，与往常一样，初始化器必须能够转换为容器中元素的类型： map<string, size_t> word_count; //空容器 //列表初始化 set<string> exclude = {\"the\", \"but\", \"and\"}; //两个元素，列表初始化 map<string, string> authors = { {\"Joyce\", \"James\"}, {\"Austen\", \"Jane\"} }; 关键字类型的要求 有序容器 关键字类型必须定义元素比较的方法，默认情况下，标准库使用关键字类型的 < 运算符来比较两个关键字。 无序容器 默认情况下，无序容器使用关键字类型的 == 运算符来比较元素，它们还使用一个 hash<key_type> 类型的对象来生成每个元素的哈希值。标准库为内置类型（包括指针）提供了 hash 模板。还为一些标准库类型，包括 string 和智能指针类型定义了 hash 。 因此，我们可以直接定义关键字是内置类型（包括指针类型）、 string 还有智能指针类型的无序容器。 但是，我们不能直接定义关键字类型为自定义类类型的无序容器。\b我们必须提供自己的 hash 模板版本。 使用关键字类型的比较函数 multiset<Sales_data, decltype(compareIsbn)*> bookstore(compareIsbn); 用尖括号指出要定义哪种类型的容器，自定义的操作类型必须在尖括号中紧跟着元素类型给出 比较操作的类型应该是一种函数指针类型 在尖括号中的类型仅仅是一个类型而已，当我们创建一个容器（对象）时，才会以构造函数参数的形式提供真正的比较操作（其类型必须与尖括号中指定的类型吻合） 当使用 decltype \b来获得一个函数指针类型时，必须加上一个\"*\"来指出我们需要一个函数指针类型 用于初始化 bookstore 对象的参数也可以写作 &compareIsbn ，因为函数名会自动转换为函数指针 pair 类型 pair 标准\b库类型定义在头文件 utility 中。一个 pair 保存两个数据成员。 pair 是一个用来生成特定类型的模板。 pair 的默认构造函数对数据成员进行值初始化。 pair 的成员是 public 的，两个成员为 first 和 second 。 标准库定义的 pair 操作： 操作 意义 pair p; p 是一个 pair，两个类型分布为 T1 和 T2 的成员都进行值初始化 pair p(v1, v2); 用 v1 和 v2 初始化 pair p = 同上 make_pair(v1, v2) 返回一个用 v1 和 v2 初始化的 pair，pair 的类型由 v1 和 v2 推断而来 p.first, p.second 成员 p1 relop p2 关系运算符按字典顺序定义。关系运算利用元素的 < 运算符实现 p1 == p2, p1 != p2 相等性判定利用元素的 == 运算符实现 创建返回 pair 对象的函数 pair<string, int> process(vector<string> &v) { //处理 v if (!v.empty()) //列表初始化 return {v.back(), v.back().size()}; else //隐式构造返回值 return pair<string, int>(); } 关联容器操作 关联容器额外定义了一些类型别名： 别名 意义 key_type 此容器类型的关键字类型 mapped_type 每个关键字关联的类型，只适用于 map value_type 对于 set ，与 key_type 相同，对于 map ，为 pair 由于我们不能改变一个元素的关键字，因此这些 pair 的关键字部分是 const 的。 set<string>::value_type v1; //v1 是一个 string set<string>::key_type v2; //v2 是一个 string map<string, int>::value_type v3; //v3 是一个 pair<const string, int> map<string, int>::key_type v4; //v4 是一个 string map<string, int>::mapped_type v5; //v5 是一个 int 关联容器迭代器 当解引用一个关联容器迭代器时，我们会得到一个类型为容器的 value_type 的值的引用。 对 map 而言，得到 pair 类型，其 first 成员保存 const 关键字，second 成员保存值 对 set 而言，迭代器也是 const 的 当使用一个迭代器遍历一个 map 、 multimap 、 set 、 multiset 时，迭代器按关键字升序遍历元素。 我们通常不对关联容器使用泛型算法。在实际编程中，如果我们真的要对一个关联容器使用算法，要么将它作为一个源序列，要么将它作为一个目的位置。 添加元素 返回值： 不包含重复关键字的容器：返回一个 pair ，first 成员是一个迭代器，指向具有给定关键字的元素，second 成员是一个 bool 值，关键字不存在，为 true ，否则为 false 包含重复关键字的容器：返回一个指向新元素的迭代器 删除元素 map 下标操作 操作 意义 c[k] 返回关键字为 k 的元素；如果 k 不在 c 中，添加一个关键字为 k 的元素，对其进行值初始化 c.at(k) 访问关键字为 k 的元素，带参数检查；若 k 不在 c 中，抛出 out_of_range 异常 由于下标运算可能插入一个新元素，我们只可以对非 const 的 map 使用下标操作。 map 下标操作与其他下标操作不同的地方：对 map 进行下标操作时，会得到一个 mapped_type 对象；但当解引用一个 map 迭代器时，得到一个 value_type 对象。 map 下标操作与其他下标操作相同的地方：返回一个左值，可读也可写。 访问元素 lower_bound 和 upper_bound 不适用于无序容器。 下标和 at 操作只适用于非 const 的 map 和 unordered_map 。 对 map 使用 find 代替下标操作，以防添加不存在元素。 无序容器 新标准定义了4个无序关联容器（unordered associative container）。这些容器不是使用比较运算符来组织元素，而是使用一个哈希函数和关键字类型的 == 运算符。 除了哈希管理操作之外，无序容器还提供了与有序容器相同的操作。 管理桶 无序容器在存储上组织为一组桶，每个桶保存零个或多个元素。 无序容器使用一个哈希函数将元素映射到桶。 为了访问一个元素，容器首先计算元素的哈希值，它指出应该搜索哪个桶。 容器将具有一个特定哈希值的所有元素都保存在相同的桶中。 如果容器允许重复关键字，所有具有相同关键字的元素也都会在同一个桶中。 无序容器的性能依赖于哈希函数的质量和桶的数量和大小。 对于相同的参数，哈希函数必须总是产生相同的结果。 理想情况下，哈希函数还能将每个特定的值映射到唯一的桶。但是将不同关键字的元素映射到相同的桶也是允许的。 当一个桶保存多个元素时，需要顺序搜索这些元素来查找我们想要的那个。计算一个元素的哈希值和在桶中搜索通常都是很快的操作。但是如果一个桶保存了很多元素，那么查找一个特定元素就需要大量比较操作。 无序容器提供了一组管理桶的函数： 无序容器对关键字类型的要求","tags":"读书笔记","url":"https://xutree.github.io/pages/2018/10/17/C++_Primer_Chapter_11/"},{"title":"C++ Primer 第十章 泛型算法","text":"顺序容器只定义了很少的操作：在多数情况下，我们可以添加和删除元素。访问首尾元素、确定容器是否为空以及获得指向首元素或尾元素之后位置的迭代器。 如果我们想要做：查找特定元素、替换或删除一个特定值、重排元素顺序等。标准库并未给每个容器都定义成员函数来实现这些操作，而是定义了一组泛型算法：称它们为\"算法\"，是因为它们实现了一些经典算法的公共接口，如排序和搜索；称它们是\"泛型的\"，是因为它们可用于不同类型的元素和多种容器类型（不仅包括标准库类型，如 vector 或 list ，还包括内置的数组类型）。 概述 大多数算法都定义在头文件 algorithm 中。标准库还在头文件 numeric 中定义了一组数值泛型算法。 一般情况下，这些算法并不直接操作容器，而是遍历由两个迭代器指定的一个元素范围来进行操作。通常情况下，算法遍历范围，对其中每个元素进行一些处理。 迭代器令算法不依赖于容器，但算法依赖于元素类型的操作。虽然迭代器的使用令算法不依赖于容器类型。但大多数算法都使用了一个(或多个)元素类型上的操作。例如， find 用元素的 == 运算符完成每个元素与给定值的比较。其他算法可能要求元素类型支持 < 运算符。不过，我们将会看到，大多数算法提供了一种方法，允许我们使用自定义的操作来代替默认的运算符。 泛型算法本身不会执行容器的操作，它们只会运行与迭代器之上，执行迭代器的操作。泛型算法运行于迭代器之上而不会执行容器操作的特性带来了一个令人惊讶但非常必要的编程假定：算法永远不会改变底层容器的大小。算法可能改变容器中保存的元素的值，也可能在容器内移动元素，但永远不会直接添加或删除元素。 初识泛型算法 除了少数例外，标准库算法都对一个范围内的元素进行操作。我们将此元素范围称为\"输入范围\"。接受输入范围的算法总是使用前两个参数来表示此范围，两个参数分别是指想要处理的第一个元素和尾元素之后位置的迭代器。 只读算法 一些算法只会读取其输入范围内的元素，而从不改变元素。 find 就是这样一种算法。 accumulate 另一个只读算法是 accumulate ，它定义在头文件 numeric 中。 accumulate 函数接受三个参数，前两个指出了需要求和的元素的范围，第三个参赛是和的初值。假定 vec 是一个整数序列，则： //对 vec 中元素的求和，和的初值是0 int sum = accumulate(vec.cbegin(), vec.cend(), 0); 这条语句将 sum 设置为 vec 中元素的和，和的初值被设置为0. accumulate 的第三个参数的类型决定了函数中使用哪个加法运算符以及返回值的类型。 accumulate 将第三个参数作为求和起点，这蕴含着一个编程假定：将元素类型加到和的类型上的操作必须是可行的。即，序列中元素的类型必须与第三个参数匹配，或者能够转换为第三个参数的类型。 下面是另一个例子，由于 string 定义了 + 运算符，所有我们可以通过调用 accumulate 来将 vector 中所有 string 元素连接起来： string sum = accumulate(v.cbegin(), v.cend(), string(\"\")); 此调用将 v 中每个元素连接到一个 string 上，该 string 初始时是空串。注意，我们通过第三个参数显式地创建了一个 string 。将空串当做一个字符串字面值传递给第三个参数是不可以的，会导致一个编译错误： //错误：const char*上没有定义+运算符 string sum = accumulate(v.cbegin(), v.cend(), \"\"); 原因在于，如果我们传递了一个字符串字面值，用于保存和的对象的类型将是 const char* 。如前所述，此类型决定了使用哪个 + 运算符。由于 const char* 并没有+运算符，此调用将产生编译错误。 操作两个序列的算法 equal 另一个只读算法是 equal ，用于确定两个序列是否保存相同的值，它将第一个序列中的每个元素与第二个序列中的对应元素进行比较。如果所有对应元素都相等，则返回 true ，否则返回 false 。此算法接受三个迭代器：前两个表示第一个序列中的元素的范围，第三个表示第二个序列的首元素： //roster2 中的元素数目应该至少与 roster1 一样多 equal(roster1.cbegin(), roster1.cend(), roster2.cbegin()); 由于 equal 利用迭代器完成操作，因此我们可以通过调用 equal 来比较两个不同类型的容器中的元素。而且，元素类型也不必一样，只要我们能用 == 来比较两个元素类型即可。例如，在此例中，roster1 可以是 vector<string> ,而 roster2 是 list<const char*> 。 但是， equal 基于一个非常重要的假设：它假定第二个序列至少与第一个序列一样长。此算法要处理第一个序列中的每个元素，它假定每个元素在第二个序列中都有一个与之对应的元素。 那些只接受一个单一迭代器来表示第二个序列的算法，都假定第二个序列至少与第一个序列一样长。确保算法不会试图访问第二个序列中不存在的元素是程序员的责任。 写容器元素的算法 一些算法将新值赋予序列中的元素。当我们使用这类算法时，必须注意确保序列原大小至少不小于我们要求算法写入的元素数目。记住，算法不会执行容器操作，因此它们自身不可能改变容器的大小。 一些算法会自己向输入范围写入元素，这些算法本质上并不危险，它们最多写入与给定序列一样多的元素。 例如，算法 fill 接受一对迭代器表示一个范围，还接受一个值作为第三个参数。 fill 将给定的这个值赋予输入序列中的每个元素： fill(vec.begin(), vec.end(), 0); //将每个元素重置为0 //将容器的一个子序列设置为10 fill(vec.begin(), vec.begin()+vec.size()/2, 10); 由于 fill 向给定输入序列中写入数据，因此，只要我们传递一个有效的输入序列，写入操作就是安全的。 算法不检查写操作 一些算法接受一个迭代器来指出一个单独的目的位置。这些算法将新值赋予一个序列中的元素，该序列从目的位置迭代器指向的元素开始。例如，函数 fill_n 接受一个单迭代器、一个计数值和一个值。它将给定值赋予迭代器指向的元素开始的指定个元素。我们可以用 fill_n 将一个新值赋予 vector 中的元素： vector<int> vec; //空vector //使用vec，赋予它不同值 fill_n(vec.begin(), vec.size(), 0); //将所有元素重置为0 函数 fill_n 假定写入指定个元素是安全的。即，如下形式的调用： fill_n(dest, n, val) 函数 fill_n 假定 dest 指向一个元素，而 dest 开始的序列至少包含 n 个元素。 一个初学者非常容易犯的错误是在一个空容器上调用 fill_n （或类似的写元素的算法）： vector<int> vec; //空向量 //灾难：修改vec中10个（不存在）元素 fill_n(vec.begin(), 10, 0); 这个调用是一场灾难，我们指定了要写入10个元素，但 vec 中并没有元素——它是空的，这条语句的结果是未定义的。 向目的迭代器写入数据的算法假定目的位置是足够大，能容纳要写入的元素。 介绍 back_inserter 一种保证算法有足够元素空间来容纳输出数据的方法是使用插入迭代器。插入迭代器是一种向容器中添加元素的迭代器。通常情况下，当我们通过一个迭代器向容器元素赋值时，值被赋予迭代器指向的元素。而当我们通过一个插入迭代器赋值时，一个赋值号右侧值相等的元素被添加到容器中。 为了展示如何用算法向容器中写入数据，我们现在将使用 back_inserter ，它是定义在头文件 iterator 中的一个函数。 back_inserter 接受一个 指向容器的引用 ，返回一个与该容器绑定的插入迭代器。当我们通过此迭代器赋值时，赋值运算符会调用 push_back 将一个具有给定值的元素 添加 到容器中： vector<int> vec; //空容器 auto it = back_inserter(vec); //通过它赋值会将元素添加到vec中 *it = 42;//vec现在有一个元素，值为42 我们常常使用 back_inserter 来创建一个迭代器，作为算法的目的位置来使用。例如： vector<int> vec; //空向量 //正确：back_inserter 创建一个插入迭代器，可以用来向 vec 添加元素 fill_n(back_inserter(vec), 10, 0); //添加10个元素到 vec 在每步迭代中， fill_n 向给定容器序列的一个元素赋值。由于我们传递的参数是 back_inserter 返回的迭代器，因此每次赋值都会在 vec 上调用 push_back 。最终，这条 fill_n 调用语句向 vec 的末尾添加了10个元素，每个元素的值都是0. 拷贝算法 拷贝算法是另一个向目的位置迭代器指向的输出序列中的元素写入数据的算法。此算法接受三个迭代器，前两个表示一个输入范围，第三个表示目的序列的起始位置。此算法将输入范围中的元素拷贝到目的序列中。传递给 copy 的目的序列至少要包含与输入序列一样多的元素，这一点很重要。 我们可以用 copy 实现内置数组的拷贝，如下面代码所示： int a[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; int a2[sizeof(a1) / sizeof(*a1)]; auto ret = copy(begin(a1), end(a1), a2); //把a1的内容拷贝到a2 copy 返回的是其目的位置迭代器（递增后）的值。即，ret 恰好指向拷贝到 a2 的尾元素之后的位置。 多个算法都提供所谓的\"拷贝\"版本。这些算法计算新元素的值，但不会将它们放置在输入序列的末尾，而是创建以新序列保存这些结果。 例如， replace 算法读入一个序列，并将其中所有等于给定值的元素都改为另一个值。此算法接受4个参数：前两个是迭代器，表示输入序列，后两个一个是要搜索的值，另一个是新值。它将所有等于第一个值的元素替换为第二个值： //将所有值为0的元素改为42 replace(ilist.begin(), ilist.end(), 0, 42); 此调用将序列中所有0都替换为42,。如果我们希望保留原序列不变，可以调用 replace_copy 。此算法接受额外第三个迭代器参数，指出调整后序列的保存位置： //使用back_inserter按需要增长目标序列 replace_copy(ilist.begin(), ilist.end(), back_inserter(ivec), 0, 42); 此调用后，ilis 并未改变，ivec 包含 ilist 的一份拷贝，不过原来在 ilist 中值为0的元素在 ivec 中都变为42。 重排容器元素的算法 sort 某些算法会重排容器中元素的顺序，一个明显的例子是 sort 。调用 sort 会重排输入序列中的元素，使之有序，它是利用元素类型的 < 运算符来实现排序的。 unique unique 算法重排输入序列，将相邻的重复项\"消除\"，并返回一个指向不重复范围末尾的迭代器。 unique 并不真正的删除任何元素，它只是覆盖相邻的重复元素，使得不重复元素出现在序列开始部分， unique 返回的迭代器指向最后一个不重复元素之后的位置。此位置之后的元素仍然存在，但我们不知道它们的值是什么。 标准库算法对迭代器而不是容器进行操作。因此，算法不能（直接）添加或删除元素。为了真正删除无用元素，我们必须使用容器操作，例如 erase 。 定制操作 很多算法都会比较输入序列中的元素。默认情况下，这类算法使用元素类型的 < 或 == 运算符完成比较。标准库还为这些算法定义了额外的版本，允许我们提供自己定义的操作来代替默认运算符。 例如， sort 算法默认使用元素类型的 < 运算符。但可能我们希望的排序顺序与 < 所定义的顺序不同，或是我们的序列可能保存的是未定义 < 运算符的元素类型。在这两种情况下，都需要重载 sort 的默认行为。 向算法传递函数 sort 的第二个版本是重载过的，它接受三个参数，此参数是一个 谓词 。 谓词是一个可调用的表达式，其返回结果是一个能用作条件的值。标准库算法所使用的谓词分为两类：一元谓词（unary predicate 意味着它们只接受单一参数）和二元谓词（binary predicate 意味着它们接受两个参数）。接受谓词参数的算法对输入序列中的元素调用谓词。因此，元素类型必须能转换为谓词的参数类型。 //比较函数，用来比较长度排序单词 bool isShorter(const string &s1, const string &s2) { return s1.size() < s2.size(); } //按长度由短至长排序words sort(words.begin(), words.end(), isShorter); stable_sort 算法：这种稳定排序算法维持相等元素的原有顺序。 lambda 表达式 根据算法接受一元谓词还是二元谓词，我们传递给算法的谓词必须严格接受一个或两个参数。但是，有时我们希望进行的操作需要更多参数，超出了算法对谓词的限制。这时候我们可以利用 lambda 表达式。 我们可以向一个算法传递任何类别的可调用对象。对于一个对象或一个表达式，如果可以对其使用调用运算符，则称它为可调用的。即，如果 e 是一个可调用的表达式，则我们可以编写代码 e(args),其中 args 是一个逗号分隔的一个或多个参数的列表。 到目前为止，我们使用过的仅有的两种可调用对象是函数和函数指针。还有其他两种可调用对象：重载了函数调用运算符的类，以及 lambda 表达式。 一个 lambda 表达式表示一个可调用的代码单元。我们可以将其理解为一个未命名的内联函数。与任何函数类似，一个 lambda 具有一个返回返回类型、一个参数列表和一个函数体。但与函数不同， lambda 可能定义在函数内部。一个 lambda 表达式具有如下形式 [ capture list ] ( parameter list ) -> return type { function body } 其中， capture list (捕获列表)是一个 lambda 所在函数中定义的局部变量列表（通常为空）； return type 、 parameter list 和 function body 与任何普通函数一样，分别表示返回类型、参数列表和函数体。但是，与普通函数不同， lambda 必须使用尾置返回来指定返回类型。 我们可以忽略参数列表和返回类型，但必须永远包含捕获列表和函数体： auto f = [] { return 42; }; 此例中，我们定义了一个可调用对象，它不接受参数，返回42. lambda 的调用方式与普通函数的调用方式相同，都是使用调用运算符： cout << f() << endl; //打印42 在 lambda 中忽略括号和参数列表等价于指定一个空参数列表。在此例中，当调用 f 时，函数参数列表是空的。如果忽略返回类型，则返回类型从返回的表达式的类型推断而来。否则，返回类型为 void 。 如果 lambda 的函数体包含任何单一 return 语句之外的语句，且未指定返回类型，则返回 void 。 向 lambda 传递参数 与普通函数调用类似，调用一个 lambda 时给定的实参类型被用来初始化 lambda 的形参。通常，实参和形参的类型必须匹配，但与普通函数不同， lambda 不能有默认参数。因此，一个 lambda 调用的实参数目永远与形参数目相等。一旦形参初始化完毕，就可以执行函数体了。 作为一个带参数的 lambda 的例子，我们可以编写一个与 isShorter 函数完成相同功能的 lambda ： [] (const string &s1, const string &s2) { return s1.size() < s2.size(); } 空捕获列表表明此 lambda 不使用它所在函数中的任何局部变量。 lambda 的参数与 isShorter 的参数类似，是 const string 的引用。 lambda 的函数体也与 isShorter 类型，比较两个参数的 size() ，并根据两者的相对大小返回一个布尔值。 如下所示，可以使用此 lambda 来调用 stable_sort ： stable_sort(words.begin(), words.end(), [] (const string &s1, const string &s2) { return s1.size()<s2.size(); }); 当 stable_sort 需要比较两个元素时，它就会调用给定的这个 lambda 表达式。 使用捕获列表 编写一个可以传递给 find_if 的可调用表达式。我们希望这个表达式能将输入序列中每个 string 的长度与 biggies 函数中的 sz 参数的值进行比较。 虽然一个 lambda 可以出现在一个函数中，使用其局部变量，但它只能使用那些明确指明的变量。一个 lambda 通过将局部变量包含在其捕获列表中指出将会使用这些变量。捕获列表指引 lambda 在其内部包含访问局部变量所需的信息。 在本例中，我们的 lambda 会捕获 sz，并只有单一的 string 参数。其函数体会将 string 的大小与捕获的 sz 的值进行比较： [sz] (const string &s) { return s.size() >= sz; }; lambda 以一对 [] 开始，我们可以在其中提供一个以逗号分隔的名字列表，这些名字都是它所在函数中定义的。 如果我们给 lambda 提供了一个空捕获列表，则代码会编译错误： //错误：sz未捕获 [] (const string &s) { return s.size() >= sz; }; 一个 lambda 只有在其捕获列表中捕获一个所在函数中的局部变量，才能在函数体中使用该变量。 一个 lambda 可以直接使用定义在当前函数之外的名字。捕获列表只用于局部非 static 变量， lambda 可以直接使用局部 static 变量和在它所在函数之外声明的名字。 lambda 捕获和返回 当定义一个 lambda 时，编译器生成一个与 lambda 对应的新的（未命名的）类类型。当向一个函数传递一个 lambda 时，同时定义了一个新类型和该类型的一个对象；传递的参数就是此编译器生成的类类型的未命名对象。类似的，当使用 auto 定义一个用 lambda 初始化的变量时，定义了一个从 lambda 生成的类型的对象。 默认情况下，从 lambda 生成的类都包含一个对应该 lambda 所捕获的变量的数据成员类似任何普通类的数据成员， lambda 的数据成员也在 lambda 对象创建时被初始化。 值捕获 类似参数传递，变量的捕获方式也可以是值或引用。到目前为止，我们的 lambda 采用值捕获的方式。与传值参数类似，采用值捕获的前提是变量可以拷贝。与参数不同，被捕获的变量的值是在 lambda 创建时拷贝，而不是调用时拷贝： void fcn1() { size_t v1 = 42; //局部变量 //将 v1 拷贝到名为 f 的可调用对象 auto f = [v1] { return v1; }; v1 = 0; auto j = f(); //j 为42；f 保存了我们创建它时 v1 的拷贝 } 由于被捕获变量的值是在 lambda 创建时拷贝，因此随后对其修改不会影响到 lambda 内对应的值。 引用捕获 我们定义 lambda 时可以采用引用方式捕获变量。例如： void fcn2() { size_t v1 = 42; //对象 f2 包含 v1 的引用 auto f2 = [&v1] { return v1; }; v1 = 0; auto j = f2(); //j 为0；f2 保存 v1 的引用，而非拷贝 } 一个以引用方式捕获的变量与其他任何类型的引用的行为类似。当我们在 lambda 函数体内使用此变量时，实际上使用的是引用所绑定的对象。引用捕获与返回引用有着相同的问题和限制。如果我们采用引用方式捕获一个变量，就必须确保被引用的对象在 lambda 执行的时候是存在的。 lambda 捕获的都是局部变量，这些变量在函数结束后就不复存在了。如果 lambda 可能在函数结束后执行，捕获的引用指向的局部变量已经消失。 我们不能拷贝 ostream 对象，因此捕获 os 的唯一方式就是捕获其引用（或指向 os 的指针）。 我们也可以从一个函数返回 lambda ，函数可以直接返回一个可调用对象，或者返回一个类对象，该类含有可调用对象的数据成员。如果函数返回一个 lambda ，则与函数不能返回一个局部变量的引用类似，此 lambda 也不能包含引用捕获。 当以引用方式捕获一个变量时，必须保证在 lambda 执行时变量是存在的。 隐式捕获 除了显式列出我们希望使用的来自所在函数的变量外，还可以让编译器根据 lambda 体中的代码来推断我们要使用哪些变量。为了指示编译器推断捕获列表，应在捕获列表中写一个 & 或 = 。 & 告诉编译器采用捕获引用方式， = 则采用值捕获。 //sz为隐式捕获，值捕获方式 wc=find_if(words.begin(),words.end(), [=] (const string &s) { return s.size()>=sz; }); 如果我们希望对一部分变量采用值捕获，对其它变量采用引用捕获，可以混合使用隐式捕获和显式捕获： void biggies(vector<string> &words, vector<string>::size_type sz, ostream &os=cout, char c=' ') { //os 隐式捕获，引用捕获方式；c 显式捕获，值捕获方式 for_each(words.begin(), words.end(), [&, c] (const string &s) { os << s <<c; }); //os 显式捕获，引用捕获方式；c 隐式捕获，值捕获方式 for_each(words.begin(), words.end(),[=, &os] (const string &s) { os << s <<c; }); } 当我们混合使用隐式捕获和显式捕获时，捕获列表中的第一个元素必须是一个 & 或 = ，此符号指定了默认捕获方式为引用或值。 当混合使用隐式捕获和显式捕获时，显式捕获的变量必须使用与隐式捕获不同的方式。即，如果隐式捕获是引用方式（使用了 & ），则显示捕获命名变量必须采用值方式，因此不能在其名字前使用 & 。类似的，如果隐式捕获采用的是值方式（使用了 = ），则显式捕获命名变量必须采用引用方式，即，在名字前使用 & 。 可变 lambda 默认情况下，对于一个值被拷贝的变量， lambda 不会改变其值。如果我们希望能改变一个捕获的变量的值，就必须在参数列表首加上关键字 mutable 。因此，可变 lambda 能省略参数列表： void fcn3() { size_t v1 = 42; //局部变量 //f 可以改变它所捕获的变量的值 auto f = [v1] () mutable { return ++v1; }; v1=0; auto j = f(); //j为43 } 一个引用捕获的变量是否（如往常一样）可以修改依赖于此引用指向的是一个 const 类型还是一个非 const 类型： void fcn4() { size_t v1 = 42; //局部变量 //v1 是一个非 const 变量的引用 //可以通过 f2 中的引用来改变它 auto f2 = [&v1] { return ++v1; }; v1=0; auto j = f2(); //j为1 } 指定 lambda 返回类型 默认情况下，如果一个 lambda 体包含 return 之外的任何语句，则编译器假定此 lambda 返回 void 。与其它返回 void 的函数类型类似，被推断返回 void 的 lambda 不能返回值。 当我们需要为一个 lambda 定义返回类型时，必须使用尾置返回类型。 参数绑定 对于那种只有一两个地方使用的简单操作， lambda 表达式是最有用的。如果我们需要在很多地方使用相同的操作，通常应该定义一个函数，而不是多次编写相同的 lambda 表达式。类似的，如果一个操作需要很多语句才能完成，通常使用函数更好。 但是，对于捕获局部变量的 lambda ，用函数来替换它就不是那么容易了。例如，我们用在 find_if 调用中的 lambda 比较一个 string 和一个给定大小。我们可以很容易地编写一个完成同样工作的函数： bool check_size(const string &s, string::size_type sz) { return s.size() >= sz; } 但是，我们不能用这个函数作为 find_if 的一个参数。 find_if 接受一个一元谓词，因此传递给 find_if 的可调用对象必须接受单一参数。为了用 check_size 函数来代替 lambda ，必须解决如何向 sz 形参传递一个参数的问题。 标准库 bind 函数 我们可以解决向 check_size 传递一个长度参数的问题，方法是使用一个新的名为 bind 的标准库函数，它定义在头文件 functional 中。可以将 bind 函数看作一个通用的函数适配器，它接受一个可调用对象，生成一个新的可调用对象来\"适应\"原对象的参数列表。 调用bind的一般形式： auto newCallable = bind(callable, arg_list); 其中，newCallable 本身是一个可调用对象，arg_list 是一个逗号分隔的参数列表，对应给定的 callable 的参数。即，当我们调用 newCallable 时，newCallable 会调用 callable，并传递给它 arg_list 中的参数。 arg_list 中的参数可能包含形如 _n 的名字，其中 n 是一个整数。这些参数是\"占位符\"，表示 newCallable 的参数，它们占据了传递给 newCallable 的参数的\"位置\"。数值n表示生成的可调用对象中参数的位置： _1 为newCallable的第一个参数， _2 为第二个参数，以此类推。 绑定 check_size 的 sz 参数 作为一个简单的例子，我们将使用 bind 生成一个调用 check_size 的对象，如下所示，它用一个定值作为其大小参数来调用 check_size: //check6 是一个可调用对象，接受一个 string 类型的参数 //并用此 string 和值6来调用 check_size auto check6 = bind(check_size, _1, 6); 此 bind 调用只有一个占位符，表示 check6 只接受单一参数。占位符出现在 arg_list 的第一个位置，表示 check6 的此参数对应 check_size 的第一个参数。此参数是一个 const string& 。因此，调用 check6 必须传递给它一个 string 类型的参数，check6 会将此参数传递给 check_size。 string s = \"hello\"; bool b1 = check6(s); //check6(s) 会调用 check_size(s, 6) 使用 bind ，我们可以将原来基于 lambda 的 find_if 调用： auto wc = find_if(words.begin(), words.end(), [sz] (const string &s) 替换为如下使用 check_size 的版本： auto wc = find_if(words.begin(), words.end(), bind(check_size, _1, sz)); 此 bind 调用生成一个可调用对象，将 check_size 的第二个参数绑定到 sz 的值。 placeholders 名字 _n 都定义在一个名为 placeholders 的命名空间中，而这个命名空间本身定义在 std 命名空间中。为了使用这些名字，两个命名空间都要写上。例如， _1 对应的 using 声明为： using std :: placeholders :: _1 ; 此声明说明我们要使用的名字 _1 定义在命名空间 placeholders 中，而此命名空间又定义在命名空间 std 中。 对每个占位符名字，我们都必须提供一个单独的 using 声明。编写这样的声明很烦人，也很容易出错。可以使用另外一种不同形式的 using 语句，而不是分别声明每个占位符，如下所示： using namespace namespace_name ; 这种形式说明希望所有来自 namespace_name 的名字都可以在我们的程序中直接使用。例如： using namespace std :: placeholders ; 使得由 placeholders 定义的所有名字都可用。与 bind 函数一样， placeholders 命名空间也定义在 functional 头文件中。 绑定引用参数 默认情况下， bind 的哪些不是占位符的参数被拷贝到 bind 返回的可调用对象中。但是，与 lambda 类似，有时对有些绑定的参数我们希望以引用方式传递，或是要绑定参数的类型无法拷贝。例如，为了替换一个引用方式捕获 ostream 的 lambda 。 bind 拷贝其参数，而我们不能拷贝一个 ostream ，如果我们希望传递给 bind 一个对象而又不是拷贝它，就必须使用标准库 ref 函数： for_each(words.begin(), words.end(), bind(print, ref(os), _1,' ')); 函数 ref 返回一个对象，包含给定的引用，此对象是可以拷贝的。标准库中还有一个 cref 函数，生成一个保存 const 引用的类。与 bind 一样，函数 ref 和 cref 也定义在头文件 functional 中。 再探迭代器 除了为每个容器定义的迭代器之外，标准库在头文件iterator中还定义了额外几种迭代器。这些迭代器包括以下几种。 迭代器 意义 插入迭代器 这些迭代器被绑定到一个容器上，可用来向容器插入元素 流迭代器 这些迭代器被绑定到输入或输出上，可用来遍历所有关联的 IO 流 反向迭代器 这些迭代器向后而不是向前移动。除了 forward_list 之外的标准库容器都有反向迭代器 移动迭代器 这些专用的迭代器不是拷贝其中的元素，而是移动它们 插入迭代器 插入器是一种迭代器适配器，它接受一个容器，生成一个迭代器，能实现向给定容器添加元素。当我们通过一个迭代器进行赋值时，该迭代器调用容器操作来向给定容器的指定位置插入一个元素。下表列出了这种迭代器支持的操作。 操作 意义 it = t 在 it 指定的当前位置插入值 t。假定 c 是 it 绑定的容器，依赖于插入迭代器的不同种类，此赋值分别调用 c.push_back(t) 、 c.push_front(t) 或 c.insert(t, p) ,其中 p 为传递给 inserter 的迭代器位置 *it, ++it, it++ 这些操作虽然存在，但不会对 it 做任何事情。每个操作都返回 it 插入迭代器有三种类型，差异在于元素插入的位置： back_inserter 创建一个使用 push_back 的迭代器 front_inserter 创建一个使用 push_front 的迭代器 inserter 创建一个使用 insert 的迭代器。此函数接受三个参数，这个参数必须是一个指向给定容器的迭代器。元素将被插入到给定迭代器所表示的元素之前。 只有在容器支持 push_front 的情况下，我们才可以使用 front_inserter 。类似的，只有在容器支持 push_back 的情况下，我们才能使用 back_inserter 。 理解插入迭代器的工作过程是很重要的：当调用 inserter(c,iter) 时，我们得到一个迭代器，接下来使用它时，会将元素插入到 iter 原来所指的位置之前的位置。即，如果 it 是由 inserter 生成的迭代器，则下面这样的赋值语句： *it = val; 其效果与下面代码一样： it = c.insert(it, val); //it 指向新加入的元素 ++it; //递增 it 使它指向原来的元素 front_inserter 生成的迭代器的行为与 inserter 生成的迭代器完全不一样。当我们使用 front_inserter 时，元素总是插入到容器第一个元素之前，即使我们传递给 inserter 的位置原来指向第一个元素，只要我们在此元素之前插入一个新元素，此元素就不再是容器的首元素了： list<int> lst = {1, 2, 3, 4}; list<int> lst2, lst3; //空 list //拷贝完成之后，lst2 包含4 3 2 1 copy(lst.begin(), lst.end(), front_inserter(lst2)); //拷贝完成之后 lst3 包含1 2 3 4 copy(lst.begin(), lst.end(), inserter(lst3,lst.begin())); 当调用 front_inserter(c) 时，我们得到一个插入迭代器，接下来会调用 push_front 。当每个元素被插入到容器 c 中时，它变为 c 的新的首元素。因此， front_inserter 生成的迭代器会将插入的元素序列的顺序颠倒过来，而 inserter 和 back_inserter 则不会。 流迭代器 虽然 iostream 类型不是容器，但标准库定义了用于这些 IO 类型对象的迭代器。 istream_iterator 读取输入流， ostream_iterator 向一个输出流写数据。这些迭代器将它们对应的流当作一个特定类型的元素序列来处理。通过使用流迭代器，我们可以用泛型算法从流对象读取数据以及向其写入数据。 istream_iterator 当创建一个流迭代器时，必须指定迭代器将要读写的对象类型。一个 istream_iterator 使用 >> 来读取流。因此， istream_iterator 要读取的类型必须定义了输入运算符。当创建一个 istream_iterator 时，我们可以将它绑定到一个流。当然，我们还可以默认初始化迭代器，这样就创建了一个可以当作尾后值使用的迭代器。 istream_iterator<int> int_it(cin); //从 cin 读取 int istream_iterator<int> int_eof; //尾后迭代器 ifstream in(\"afile\"); istream_iterator<string> str_in(in); //从 afile 读取字符串 下面是一个用 istream_iterator 从标准输入流读取数据，存入一个 vector 的例子： istream_iterator<int> in_iter(cin); //从 cin 读取 int istream_iterator<int> eof; //istream 尾后迭代器 while(in_iter != eof) //后置递增运算读取流，返回迭代器的旧值 //解引用迭代器，获得从流读取的前一个值 vec.push_back(*in_iter++); 此循环从 cin 读取 int 值，保存在 vec 中。在每个循环步中，循环体代码检查 in_iter 是否等于 eof。eof 被定义为空 istream_iterator ,从而可以当作尾后迭代器来使用。对于一个绑定到流的迭代器，一旦其关联的流遇到文件尾或遇到 IO 错误，迭代器的值就与尾后迭代器相等。 我们可以将程序重写为如下形式，这体现了 istream_iterator 更有用的地方： istream_iterator<int> in_iter(cin), eof; //从 cin 读取 int vector<int> vec(in_iter,eof); //从迭代器范围构造 vec 本例中我们使用了一对表示范围的迭代器来构造 vec，这两个迭代器是 istream_iterator ，这意味着元素范围是通过从关联的流中读取数据获得的。这个构造函数从 cin 读取数据，直至遇到文件尾或者遇到一个不是 int 的数据为止。从流中读取的数据被用来构造 vec。 istream_iterator 操作 意义 istream_iterator in(is); in 从输入流 is 读取类型为 T 的值 istream_iterator end; 读取类型为 T 的值的 istream_iterator 迭代器，表所尾后位置 in1 == in2, in1 != in2 in1 和 in2 必须读取相同类型。如果它们都是尾后迭代器，或绑定到相同的输入，则两个相等 *in 返回从流中读取数据 in->mem 与 (*in).mem 的含义相同 ++in, in++ 使用元素类型所定义的 >> 运算符从输入流中读取下一个值。与以往一样，前置版本返回一个指向递增后迭代器的引用，后置版本返回旧值 使用算法操作流迭代器 由于算法使用迭代器操作来处理数据，而流迭代器又至少支持某种迭代器操作，因此我们至少可以用某些算法来操作流迭代器。下面是一个例子，我们可以用一对 istream_iterator 来调用 accumulate ，此调用会计算出从标准输入读取的值的和: istream_iterator<int> in(cin), eof; cout << accumulatre(in, eof, 0) << endl; istream_iterator 允许使用懒惰求值 当我们将一个 istream_iterator 绑定到一个流时，标准库并不保证迭代器立即从流读取数据。具体实现可以推迟从中读取数据，直到我们使用迭代器时才真正读取。标准库中的实现所保证的是，在我们第一次解引用迭代器之前，从流中读取数据的操作已经完成了。对于大多数程序来说，立即读取还是推迟读取并没有什么差别。但是，如果我们创建了一个 istream_iterator ，没有使用就销毁了，或者我们正在从两个不同的对象同步读同一个流，那么何时读取可能就很重要了。 ostream_iterator 我们可以对任何输出运算符( << 运算符)的类型定义 ostream_iterator 。当创建一个 ostream_iterator 时，我们可以提供（可选的）第二参数，它是一个字符串，在输出每个元素后都会打印此字符串。此字符串必须是一个 C 风格字符串（即，一个字符串字面值或者一个指向以空字符结尾的字符数组的指针）。必须将 ostream_iterator 绑定到一个指定的流。不允许空的或表示尾后位置的 ostream_iterator 。 ostream_iterator 操作 意义 ostream_iterator out(os); out 将类型为 T 的值写到输出流 os 中 ostream_iterator out(os,d); out 将类型为T的值写到输出流 os 中，每个值后面都输出一个 d。d 指向一个空字符串结尾的字符数组 out = val 用 << 运算符将 val 写入到 out 所绑定的 ostream 中。val 的类型必须与 out 可写的类型兼容 *out, ++out, out++ 这些运算符是存在的，但不对 out 做任何事情。每个运算符都返回 out 我们可以使用 ostream_iterator 来输出值的序列： ostream_iterator<int> out_iter(cout,\" \"); for(auto e : vec) *out_iter++ = e; //赋值语句实际上将元素写到 cout cout << endl; 此程序将 vec 中的每个元素写到 cout ，每个元素加一个空格，每次向 out_iter 赋值时，写操作就会被提交。 值得注意的是，当我们向 out_iter 赋值时，可以忽略解引用和递增运算。即，循环可以重写成下面的样子： for(auto e : vec) out_iter = e;//赋值语句将元素写到 cout cout << end; 运算符 * 和 ++ 实际上对 ostream_iterator 对象不做任何事情，因此忽略它们对我们的程序没有任何影响。但是，推荐第一种形式。在这种写法中，流迭代器的使用与其他迭代器的使用保存一致。如果想将此循环改为操作其他迭代器类型，修改起来非常容易。而且，对于读者来说，此循环的行为也更为清晰。 可以通过调用 copy 来打印 vec 中的元素，这比编写循环更为简单： copy(vec.begin(), vec.end(), out_iter); cout << endl; 反向迭代器 反向迭代器就是在容器中从尾元素向首元素反向移动的迭代器。对于反向迭代器，递增（以及递减）操作的含义会颠倒过来。递增一个反向迭代器（++it）会移动到前一个元素；递减一迭代器（--it）会移动到下一个元素。 除了 forward_list 之外，其他容器都支持反向迭代器。我们可以通过调用 rbegin 、 rcend 、 crbegin 和 crend 成员函数来获得反向迭代器。这些成员函数返回指向容器尾元素和首元素之前一个位置的迭代器。与普通迭代器一样，反向迭代器也有 const 和非 const 版本。 反向迭代器需要递减运算符 我们只能从既支持 ++ 也支持 -- 的迭代器来定义反向迭代器。毕竟反向迭代器的目的是在序列中反向移动。除了 forward_list 之外，标准容器上的其他迭代器都既支持递增运算又支持递减运算。但是，流迭代器不支持递减运算，因为不可能在一个流中反向移动。因此，不可能从一个 forward_list 或一个流迭代器创建反向迭代器。 反向迭代器与其他迭代器间的关系 假定有一个名为 line 的 string ，保存着一个逗号分隔的单词列表，我们希望打印 line 中的第一个单词，使用 find 可以很容易地完成这一任务： //在一个逗号分隔的列表中查找一个元素 auto comma = find(line.cbegin(), line.cend(), ','); cout << string(line.cbegin(), comma) << endl; 如果 line 中有逗号，那么 comma 将指向这个逗号；否则，它将等于 line.cend().当我们打印从 line.cbegin() 到 comma 之间的内容时，将打印到逗号为止的序列，或者打印整个 string （如果其中不含逗号的话）。 如果希望打印最后一个单词，可以改用反向迭代器： //在一个逗号分隔的列表中查找最后一个元素 auto rcomma = find(line.crbegin(), line.crend(), ','); 由于我们将 crbegin 和 crend 传递给 find ， find 将从 line 的最后一个字符开始向前搜索。当 find 完成后，如果 line 中有逗号，则 rcomma 指向最后一个逗号——即，它指向反向搜索中找到的第一个逗号。如果 line 中没有逗号，则 rcomma 指向 line.crend()。 但我们试图打印找到的单词时，看起来下面的代码是显然的方法 //错误:将逆序输出单词的字符 cout << string(line.crbegin(), rcomma) << endl; 但它会生成错误的输出结果。例如，如果我们的输入是：FIRST,MIDOLE,LAST 则这条语句会打印：TSAL 问题所在：我们使用的是反向迭代器，会反向处理 string 。因此，上述输出语句从 crbegin 开始反向打印 line 中内容。而我们希望按正常顺序打印从 rcomma 开始到 line 末尾间的字符。但是，我们不能直接使用 rcomma。因为它是一个反向迭代器，意味着它会反向朝着 string 的开始位置移动。需要做的是，将 rcomma 转换回一个普通迭代器，能在 line 中正向移动。我们通过调用 reverse_iterator 的 base 成员函数来完成这一转换，此成员函数会返回其对应的普通迭代器： //正确：得到一个正向迭代器，从逗号开始读取字符直到 line 末尾 cout << string(rcomma.base(), line.cend()) << endl; rcomma 和 rcomma.base() 指向了不同的元素，line.crbegin() 和 line.cend() 也是如此。这些不同保证了元素范围无论是正向处理还是反向出来都是相同的。从技术上讲，普通迭代器与反向迭代器的关系反映了左闭合区间的特征。关键点在于 [line.crbegin(),rcomma) 和 [rcomma.base(),line.cend()) 指向 line 中相同的元素范围。 泛型算法结构 任何算法的最基本的特性是它要求其迭代器提供哪些操作。某些算法，如 find ，只要求通过迭代器访问元素、递增迭代器以及比较两个迭代器是否相等这些能力。其他一些算法，如 sort ，还要求读、写和随机访问元素的能力。算法所要求的迭代器操作可以分为5个迭代器类别，如表所示： 迭代器类型 要求 输入迭代器 只读，不写；单遍扫描，只能递 输出迭代器 只写，不读；单遍扫描，只能递 前向迭代器 可读写；多遍扫描，只能递 双向迭代器 可读写；多遍扫描，可递增递 随机访问迭代器 可读写；多遍扫描，支持全部迭代器运 5类迭代器 类似容器，迭代器也定义了一组公共操作，一些操作所有迭代器都支持，另外一些只有特定类别的迭代器才支持。例如， ostream_iterator 只支持递增、解引用和赋值。 vector 、 string 和 deque 的迭代器除了这些操作外，还支持递减、关系和算术运算。 迭代器是按它们所提供的操作来分类的，而这种分类形成了一种层次。除了输出迭代器之外，一个高层类别的迭代器支持底层类别迭代器的所有操作。 输入迭代器 输入迭代器：可以读取序列中的元素。一个输入迭代器必须支持： 用于比较两个迭代器的相等和不相等运算符（==、!=） 用于推进迭代器的前置和后置递增运算（++） 用于读取元素的解引用运算符（*）；解引用只会出现在赋值运算符的右侧 箭头运算符（->），等价于（*it）.member，即，解引用迭代器，并提取对象的成员 输入迭代器只用于顺序访问。对于一个输入迭代器， *it++ 保证是有效的，但递增它可能导致所有其他指向流的迭代器失效。其结果就是，不能保证输入迭代器的状态可以保存下来并用来访问元素。因此，输入迭代器只能用于单遍扫描算法。算法 find 和 accumulate 要求输入迭代器；而 istream_iterator 是一种输入迭代器。 输出迭代器 输出迭代器：可以看做输入迭代器功能上的补集——只写而不读元素。输出迭代器必须支持： 用于推进迭代器的前置和后置递增运算（++） 解引用运算符（*），只能出现在赋值运算符的左侧（向一个已经解引用的输出迭代器赋值，就是将值写入它所指向的元素） 我们只能向一个输出迭代器赋值一次。类似输入迭代器，输出迭代器只能用于单遍扫描算法。用作目的位置的迭代器通常都是输出迭代器。例如， copy 函数的第三个参数就是输出迭代器。 ostream_iterator 类型也是输出迭代器。 前向迭代器 前向迭代器：可以读元素。这类迭代器只能在序列中沿一个方向移动。前向迭代器支持所有输入和输出迭代器的操作，而且可以多次读写同一个元素。因此，我们可以保存前向迭代器的状态，使用前向迭代器的算法可以对序列进行多遍扫描。算法 replace 要求前向迭代器， forward_list 上的迭代器就是前向迭代器。 双向迭代器 双向迭代器：可以正向/反向读写序列中的元素。除了支持所有前向迭代器的操作之外，双向迭代器还支持前置和后置递减运算符（--）。算法 reverse 要求双向迭代器，除了 forward_list 之外，其他标准库都提供符合双向迭代器要求的迭代器。 随机迭代器 随机访问迭代器：提供在常量时间内访问序列中的任意元素的能力。此类迭代器支持双向迭代器的所有功能，此外还支持如下的操作： 用于比较两个迭代器相对位置的关系运算符（<、<=、> 和 >=） 迭代器和一个整数值的加减运算（+、+=、- 和 -=），计算结果是迭代器在序列中前进（或后退）给定整数个元素后的位置 用于两个迭代器上的减法运算符（-）得到两个迭代器的距离 下标运算符 (iter[n])，与 *(iter[n]) 等价 算法 sort 要求随机访问迭代器， array 、 deque 、 string 和 vector 的迭代器都是随机访问迭代器，用于访问内置数组元素的指针也是。 算法形参模式 在任何其他算法分类之上，还有一组参数规范。大多数算法具有如下4种形式之一： alg(beg, end, other args); alg(beg, end, dest, other args); alg(beg, end, beg2, other args); alg(beg, end, beg2, end2, other args); 其中 alg 是算法的名字，beg 和 end 表示算法所操作的输入范围。几乎所有算法都接受一个输入范围，是否有其他参数依赖于要执行的操作。这里列出了常见的一种——dest、beg2 和 end2，都是迭代器参数。顾名思义，如果用到了这些迭代器参数，它们分别承担指定目的位置和第二个范围的角色。除了这些迭代器参数，一些算法还接受额外的、非迭代器的特定参数。 算法命名规范 一些算法使用重载形式传递一个谓词 接受谓词参数来代替 < 或 == 运算符的算法，以及哪些不接受额外参数的算法，通常都是重载的函数。函数的一个版本用元素类型的运算符来比较元素；另一个版本接受一个额外谓词参数，来代替 < 或 ==。 unique(beg, end); //使用 == 运算符比较元素 unique(beg, end, comp); //使用 comp 比较运元素 两个调用都重新整理给定序列，将相邻的重复元素删除。第一个调用使用元素类型的 == 运算符来检查重复元素；第二个则调用 comp 来确定两个元素是否相等。由于两个版本的函数在参数个数上不相等，因此具体应该调用那个不会产生歧义。 _if 版本的算法 接受一个元素值的算法通常有另一个不同名的版本，该版本接受一个谓词代替元素值。接受谓词参数的算法都有附加 _if 前缀： find(beg, end, val); //查找输入范围中 val 第一次出现的位置 find_if(beg, end, pred); //查找第一个令 pred 为真的元素 这两个算法提供了命名上的差异的版本，而非重载版本，因为两个版本的算法都接受相同数目的参数。因此可能产生重载歧义，虽然很罕见，但为了避免任何可能的歧义，标准库提供不同名字的版本而不是重载。 区分拷贝元素的版本和不拷贝的版本 默认情况下，重排元素的算法将重排后的元素写回固定的输入序列中。这些算法还提供另一个版本，将元素写到一个指定的输出目的位置。如我们所见，写到额外目的空间的算法都在名字后面附加一个 _copy： reverse(beg, end); //反转输入范围中元素的顺序 reverse_copy(beg, end, dest); //将元素按逆序拷贝到 dest 一些算法同时提供 _copy 和 _if 版本。这些版本接受一个目的位置迭代器和一个谓词： //从 v1 中删除奇数元素 remove_if(v1.begin(), v1.end(), [] (int i) { return i % 2; }); //将偶数元素从 v1 拷贝到 v2；v1 不变 remove_copy_if(v1.begin(), v1.end(), back_inserter(v2), [] (int i) { return i % 2; }); 两个算法都调用了 lambda 来确定元素是否为奇数。在第一个调用中，我们从输入序列中将奇数元素删除。在第二个调用中，我们将非奇数（即偶数）元素从输入范围拷贝到 v2 中。 特定容器算法 与其他容器不同，链表类型 list 与 forward_list 定义了几个成员函数形式的算法。特别是，它们定义了独有的 sort 、 merge 、 remove 、 reverse 和 unique 。通用版本的 sort 要求随机访问迭代器，因此不能用于 list 和 forward_list ，因为这两个类型分别提供双向迭代器和前向迭代器。 链表类型定义的其他算法的通用版本可以用于链表，但代价太高。这些算法需要交换输入序列中的元素。一个链表可以通过改变元素间的链接而不是真正的交换它们的值来传递\"交换\"元素。因此，这些链表版本的算法的性能比对应的通用版本好很多。 对于 list 和 forward_list 应该优先使用成员函数版本的算法而不是通用算法。 list 和 forward_list 成员函数版本的算法，这些操作都返回 void ： lst.merge(lst2)、lst.merge(lst2, comp)：将来自 lst2 的元素合并入 lst。lst 和 lst2 都必须是有序的。元素将从 lst2 中删除。在合并之后，lst2 变为空。第一个版本使用 < 运算符；第二个版本使用给定的比较操作 lst.remove(val)、lst.remove_if(pred)：调用 erase 删除掉与给定值相等（==）或令一元谓词为真的每个元素 lst.reverse()：反转 lst 中元素的顺序 lst.sort()、lst.sort(comp)：使用 < 或给定比较操作排序元素 lst.unique()、lst.unique(pred)：调用 erase 删除同一值的连续拷贝。第一个版本使用 ==；第二个版本使用给定的二元谓词 splice 成员 链表类型还定义了splice算法。此算法是链表数据结构所特有的，因此不需要通用版本。 list 和 forward_list 的 splice 成员函数的参数： lst.splice(args)或flst.splice_after(args) (p,lst2)：p 是一个指向 lst 中元素的迭代器，或一个指向 flst 首前位置的迭代器。函数将 lst2 的所有元素移动到 lst 中 p 之前的位置或是 flst 中 p 之后的位置。将元素从 lst2 中删除。lst2 的类型必须与 lst 或 flst 相同，且不能是同一个链表 (p,lst2,p2)：p2 是一个指向 lst2 中位置的有效的迭代器。将 p2 指向的元素移动到 lst 中，或将 p2 之后的元素移动到 flst 中。lst2 可以是与 lst 或 flst 相同的链表 (p,lst2,b,e)：b 和 e 必须表示 lst2 中的合法范围。将给定范围中的元素从 lst2 移动到 lst 或 flst。lst2 与 lst（或 flst）可以是相同的链表，但 p 不能指向给定范围中元素 链表特有的操作会改变容器 多数链表特有的算法都与其通用版本很相似，但不完全相同。链表特有版本与通用版本间的一个至关重要的区别是链表版本会改变底层的容器。例如， remove 的链表版本会删除指定的元素。 unique 的链表版本会删除第二个和后继的重复元素。 类似的， merge 和 splice 会销毁其参数。例如，通用版本的 remove 将合并的序列写给一个给定的目的迭代器：两个输入序列是不变的。而链表版本的 merge 函数会销毁给定的链表——元素从参数指定的链表中删除，被合并到调用 merge 的链表对象中。在 merge 之后，来自两个链表中的元素仍然存在，但它们都已在同一个链表中。","tags":"读书笔记","url":"https://xutree.github.io/pages/2018/10/17/C++_Primer_Chapter_10/"},{"title":"C++ Primer 第九章 顺序容器","text":"一个容器就是一些特定类型对象的集合。顺序容器（sequential container）为程序员提供了控制元素存储和访问顺序的能力。这种顺序不依赖于元素的值，而是与元素加入容器时的位置相对应。 顺序容器概述 类型 简介 vector 可变大小数组。支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢 deque 双端队列。支持快速随机访问。在头尾位置插入或删除速度很快 list 双向链表。只支持双向顺序访问。在任何位置进行插入或删除都很快 forward_list 单向链表。只支持单向顺序访问。在任何位置进行插入或删除都很快 array 固定大小数组。支持快速随机访问。不能添加或删除元素 string 与 vector 相似的容器，专门用于保存字符。随机访问快。在尾部插入或删除快 string 和 vector 保存在连续的内存空间中，因此由下标计算地址非常快速。 forward_list 的设计目标是达到与最好的手写的单向链表数据结构相当的性能，因此不提供 size 操作，因为保存和计算大小会增加开销。 通常， vector 是最好的选择。 每个容器都定义在同名的头文件中，容器均是模板类。 容器库概览 类型别名 类型别名 意义 iterator 此容器类型的迭代器类型 const_iterator 常量迭代器类型 size_type 无符号整数，足够保存此种容器的最大大小 difference_type 带符号整数，足够保存两个迭代器之间的距离 value_type 元素类型 reference 元素的左值类型，与 value_type& 含义相同 const_reference 常量左值类型 构造函数 构造函数 意义 C c; 默认构造函数，构造空容器。如果 c 是一个 array ，则元素按默认方式初始化 C c1(c2); 构造 c2 的拷贝 c1，必须为相同类型，且保存元素也相同 C c1 = c2; 同上 C c(b, e); 构造 c，将迭代器指定的范围内的元素拷贝到 c，类型要相容（ array 不支持） C c 列表初始化，类型要相容，遗漏元素值初始化 C c = 同上 C seq(n); 包含 n 个元素并进行值初始化，是 explicit 构造函数（ string 不要求explicit） C seq(n, t); 包含 n 个初始值为 t 的元素 只有顺序容器（不包括 array 的构造函数才能接受大小参数）。如果元素类型没有默认构造函数，除了大小参数外，还需要显式指定元素初始值。 array 支持拷贝和赋值（内置数组不行）。 赋值与 swap 赋值与 swap 意义 c1 = c2; 将 c1 中的元素替换成 c2 中的元素，类型要相同 c1 = 将 c1 中的元素替换成列表中的元素（ array 不支持） a.swap(b); 交换 a 和 b 的元素，类型要相同，此操作通常比拷贝元素快得多 swap(a, b); 与上面等价 seq.assign(b, e) 将 seq 中的元素替换为迭代器范围中的元素，迭代器不能指向 seq 的元素 seq.assign(il) 用初始化列表替换 seq.assign(n, t) 用 n 个 t 替换 由于右边运算对象的大小可能与左边不同，因此 array 不支持 assign ，也不运行用花括号包围的值列表赋值。 assign 不适用于关联容器。 assign 仅要求类型相容。 赋值相关操作会导致指向左边容器内部的迭代器、引用和指针失效，而 swap 操作不会导致失效（ array 和 string 除外），它们仍指向交换之前的那些元素。 除 array 外， swap 不对任何元素进行拷贝、删除和插入操作，因此可以保证在常数时间完成，它只是交换了两个容器的内部数据结构。 swap 两个 array 会真正交换它们的元素。在操作之后，指针、引用和迭代器所绑定的元素保持不变，但元素值已经和另一个 array 中对应元素的值进行了交换。 统一使用非成员版本的 swap 是一个好习惯。 容器大小操作 大小 意义 c.size(); c 中元素的数目， forward_list 不支持 c.max_size(); c 可保存的最大元素数目 c.empty(); 判空 关系运算符 意义 ==、!= 所有容器都支持 <、<=、>、>= 无序关联容器不支持，类型相同，保存元素也要相同 添加元素 添加元素 意义 c.push_back(t) 在尾部创建值为 t 的元素，返回 void c.emplace_back(args) 在尾部用参数构造元素，返回 void c.push_front(t) 在头部创建值为 t 的元素，返回 void c.emplace_front(t) 在头部用参数构造元素，返回 void c.insert(p, t) 在迭代器 p 指向的元素之前创建值为 t 的元素，返回指向新添加元素迭代器 c.emplace(p, args) 在迭代器 p 指向的元素之前构造值为 t 的元素，返回指向新添加元素迭代器 c.insert(p, b, e) 在迭代器 p 指向的元素之前插入迭代器范围指定的元素，返回指向新添加的第一个元素的迭代器，若范围为空，返回 p c.insert(p, n, t) n 个 t c.insert(p, il) 列表 这些操作会改变容器大小， array 不支持。 forward_list 有自己版本的 insert 和 emplace。 forward_list 不支持 push_back 和 emplace_back。 vector 和 string 不支持push_front 和 emplace_front。 emplace 函数会在容器管理的内存空间中直接创建对象，而 push 函数会创建一个局部临时变量，并将其压入容器中。传递给 emplace 的参数必须与元素类型的构造函数相匹配。 访问元素 访问元素 意义 c.back() 返回尾元素引用。若 c 为空，行为未定义 c.front() 返回首元素引用。若 c 为空，行为未定义 c[n] 返回下标为 n 元素的引用，n 是一个无符号整数。若 n >= c.size()，行为未定义 c.at(n) 返回下标为 n 元素的引用，若 n 越界，抛出 out_of_range 异常 at 和下标操作只适用于 string 、 vector 、 deque 和 array 。 back 不适用于 forward_list 。 删除元素 删除元素 意义 c.pop_back() 删除尾元素。若 c 为空，行为未定义。返回 void c.pop_front() 删除首元素。若 c 为空，行为未定义。返回 void c.erase(p); 删除迭代器所指元素\b，返回被删除元素之后元素的迭代器，若 p 为尾后迭代器，行为未定义 c.erase(b, e); 删除迭代器所指元素\b，返回最后一个被删除元素之后元素的迭代器，若 e 为尾后迭代器，函数返回尾后迭代器 c.clear(); 清空，返回 void 这些操作会改变容器大小， array 不支持。 forward_list 有自己版本的 erase。 forward_list 不支持 pop_back。 vector 和 string 不支持pop_front。 删除元素的成员函数并不检查其参数。在删除元素前，程序员必须确保它们是存在的。 迭代器 迭代器 意义 c.begin(), c.end() 首尾迭代器 c.cbegin(), c.cend() 首尾常量迭代器 反向容器额外成员 意义 reverse_iterator 按逆序寻址元素的迭代器 const_reverse_iterator 按逆序寻址元素的常量迭代器 c.rbegin(), c.rend() 尾首迭代器 c.crbegin(), c.crend() 尾首常量迭代器 注： forward_list 不支持 特殊的 forward_list 操作 为了理解 forward_list 为什么有特殊版本的添加和删除操作，考虑当我们从一个单向链表中删除一个元素时会发生什么。当添加或删除一个元素时，删除或添加的元素之前的那个元素的后继会发生变化。为了添加或删除一个元素，我们需要访问其前驱，以便改变前驱改变前驱的链接。但是， forward_list 是单向链表。在一个单向链表中，没有简单的方法来获取一个元素的前驱，出于这个原因，在一个 forward_list 中添加或删除元素的操作是通过改变给定元素之后的元素来完成的。这样，我们总是可以访问到被添加或删除元素所影响的元素。 由于这些操作与其他容器上的操作有实现方式不同， forward_list 并未定义 insert 、 emplace 和 erase ，而是定义了名为 insert_after 、 emplace_after 和 erase_after 的操作。为了支持这些操作， forward_list 也定义了 before_begin ,它返回一个首前迭代器。这个迭代器允许我们在链表首元素之前并不存在的元素\"之后\"添加或删除元素（亦即在链表首元素之前添加删除元素）。 操作 意义 lst.before_begin() 返回指向链表首元素之前并不存在的元素的迭代器，此迭代器不能解引用 lst.cbefore_begin() cbefore_begin() 返回一个 const_iterator lst.insert_after(p, t) 在迭代器 p 之后的位置插入元素 t，若 p 为尾后迭代器，则函数的行为未定义。若范围为空，返回 p lst.insert_after(p, n, t) 在迭代器 p 之后的位置插入 n 个 t lst.insert_after(p, b, e) 在迭代器 p 之后的位置插入迭代器范围表示的元素 lst.insert_after(p,il) 在迭代器 p 之后的位置插入花括号列表 emplace_after(p,args) 使用 args 在 p 指定的位置之后构造一个元素，返回一个指向这个新元素的迭代器。若 p 为尾后迭代器，则函数的行为未定义 lst.erase_after(p) 删除 p 指向的位置之后的元素，返回一个指向被删除元素之后元素的迭代器，若不存在这样的元素，则返回尾后迭代器，如果 p 指向 lst 的尾元素或者是一个尾后迭代器，则函数的行为未定义 lst.erase_after(b, e) 删除从 b 之后直到（但不包含）e 之间的元素 改变容器大小 操作 含义 c.resize(n) 调整 c 的大小为 n 个元素。若 n < c.size()，多出的元素被丢弃。若必须添加新元素，则新元素采取值初始化 c.resize(n, t) 调整 c 的大小为 n 个元素。，多出的元素被丢弃。若必须添加新元素，则新元素初始化为 t c.shrink_to_fit() 请求将 capacity() 减小为与 size() 相同，具体的实现可能忽略此请求 c.capacity() 不重新分配内存的话，c 可以保存多少元素 c.reserve(n) 分配至少能容纳 n 个元素的内存空间 shrink_to_fit() 只适用于 vector 、 string 和 deque 。 capacity() 和 reserve(n) 只适用于 vector 和 string 。 迭代器失效 添加元素 vector 或 string ： 存储空间重新分配：迭代器、指针、引用均失效 未重新分配：插入位置之前的有效，之后的失效 deque ： 插入首尾之外：均失效 插入首尾：迭代器失效，指针、引用不失效 list 或 forward_list ：都有效（包括尾后和首前） 删除元素 list 或 forward_list ：都有效（包括尾后和首前） deque ： 删除首尾之外：均失效 删除首：\b首前失效，其他有效 删除尾：尾后失效，其他有效 vector 或 string ：被删除元素之前的都有效 当我们删除元素时，尾后迭代器总是会失效（除了删除 deque 首元素外），所以不要保存 end 返回的迭代器。 额外的 string 操作 构造 string 的其他方法 方法 解释 string s(cp, n) s 是 cp 指向的数组中前 n 个字符的拷贝。此数组至少应该包含 n 个字符 string s(s2, pos2) s 是 string s2 从下标 pos2 开始的字符的拷贝。若 pos2 > s2.size()，行为未定义 string s(s2, pos2, len2) 这些构造函数接受一个 string 或 const char* 参数。从 const char* 拷贝时，指针指向的数组必须以空字符结尾，如果还传递了一个计数值，数组就不必以空字符结尾。 substr 操作 s.substr(pos, n) 返回一个 string ，包含 s 中从 pos 开始的 n 个字符的拷贝。pos 的默认值是0，n 的默认值是 s.size()-pos，即拷贝从 pos 开始的所有字符。如果开始位置超出 string 的大小，抛出 out_of_range 异常，不管\b n 值为多少，最多拷贝到 string 的末尾。 其他修改 string 的操作 string 搜索操作 string 类提供了6个不同的搜索函数，每个函数有4个重载版本。每个搜索操作都返回 string::size_type 值，表示匹配发生的下标。如果搜索失败，则返回 string::npos 的 static 成员。标准库将 string::npos 定义成一个 const string::size_type ，并初始化为-1。由于 npos 是一个无符号数，此初始值意味着 npos 等于任何 string 最大的可能大小。 compare 函数 数值转换 string s2 = \"pi = 3.14\"; d = stod(s2.substr(s2.find_first_of(\"+-.0123456789\"))); 容器适配器 适配器（adaptors）是标准库中的一个通用概念，容器、迭代器和函数都有适配器。本质上，一个适配器是一种机制，能使某种事物的行为看起来像另外一种事物一样。一个容器适配器（Container adaptors）接受一种已有的容器类型，使其行为看起来像一种不同的类型。标准库定义了三个序列容器适配器： stack 、 queue 和 priority_queue 。 所以适配器都支持的的操作和类型 名称 意义 size_type 一种类型，足以保存当前类型的最大对象的大小 value_type 元素类型 container_type 实现适配器的底层容器\b类型 A a; 创建一个名为 a 的空\b适配器 A a(c); 创建一个名为 a 的适配器，带有容器 c 的一个拷贝 关系运算符 每个适配器都支持所有\b关系运算符。这些关系运算符返回底层容器的比较结果 a.empty() 判空 a.size() 元素数目 swap(a, b) 交换，类型要相同，包括底层容器类型也必须相同 a.swap(b) 同上 定义适配器 stack 默认基于 deque 实现，要求 push_back 、 pop_back 和 back 操作，可使用除 array 和 forward_list 之外的任何容器构造 queue 默认基于 deque 实现，\b要求 back 、 push_back 、 front 、 push_front 操作，可使用 list 和 deque 构造 priority_queue 默认基于 vector 实现，要求 front 、 push_back 和 pop_back 操作，还需要随机访问能力，可使用 vector 和 deque 构造 两种构造方法：默认构造函数创建一个空对象；接受一个容器的构造函数拷贝该容器来初始化适配器。 //假设 deq 是一个 deque<int> stack<int> stk(deq); //从 deq 拷贝元素到 stk 我们可以在创建一个适配器时将一个命名的顺序容器作为第二个类型参数，来重载默认容器类型： //在 vector 上实现的空栈 stack<string, vector<string>> str_stk; //在 vector 上实现的空栈，初始化时保存 svec 的拷贝 stack<string, vector<string>> str_stk2（svec); 栈适配器 stack 类型定义在同名头文件中。下面展示了如何使用： stack<int> intStack; //空栈 //填满栈 for (size_t ix = 0; ix != 10; ++ix) intStack.push(ix); //栈保存0-9十个数 while (!intStack.empty()) { //栈中有值就继续循环 int value = intStack.top(); //使用栈顶值的代码 intStack.pop(); //弹出栈顶元素，继续循环 } 操作 意义 s.pop() 删除栈顶元素，但不返回该元素值 s.push(item) 创建一个新元素压入栈顶，该元素通过拷贝或移动 item 而来 s.emplace(args) 构造一个新元素压入栈顶，该元素通过 args 构造 s.top() 返回栈顶元素，但不将元素弹出栈 每个容器适配器都基于底层容器类型的操作定义了自己的特殊操作，我们只能\b使用适配器操作，而不能使用底层容器类型的操作。 队列适配器 queue 和 priority_queue 定义在头文件 queue 中。操作方法如下： 操作 意义 q.pop() 删除 queue 的首元素或 priority_queue 的最高优先级的元素，但不返回该元素 q.front() 返回首元素，但不删除此元素，只适用于 queue q.back() 返回尾元素，但不删除此元素，只适用于 queue q.top() 返回优先级\b最高的元素，但不删除该元素，只适用于 priority_queue q.push(item) 在 queue \b末尾或 priority_queue 中恰当的位置创建一个元素，其值为 item q.emplace(args) 在 queue \b末尾或 priority_queue 中恰当的位置由 args 参数构造一个元素","tags":"读书笔记","url":"https://xutree.github.io/pages/2018/10/16/C++_Primer_Chapter_9/"},{"title":"Atom 快捷键","text":"参考： https://www.jianshu.com/p/e33f864981bb 、 https://github.com/nwinkler/atom-keyboard-shortcuts 基本快捷键 快捷键 快捷键的功能 cmd-, 打开设置面板 shift-cmd-p 打开和关闭命令面板 ctrl-alt-cmd-l 重启 alt-cmd-i 打开开发者工具 文件切换 快捷键 快捷键的功能 cmd-shift-o 打开目录 ctrl-0 焦点移到目录树,注意这里是数字0，非常实用也可以用cmd+\\来变相达到效果 a, m, d, delete 目录树下，增加，修改，另存为和删除 cmd-t 或 cmd-p 查找文件（模糊查找） cmd-b 在打开的文件之间切换 cmd-shift-b 只搜索从上次 git commit 后修改或者新增的文件 alt-cmd-left 在打开的标签页往左切换 alt-cmd-right 在打开的标签页往右切换 导航 快捷键 快捷键的功能 ctrl-p 前一行 ctrl-n 后一行 ctrl-f 后一个字符 ctrl-b 前一个字符 alt-b, alt-left 移动到单词开始 alt-f, alt-right 移动到单词末尾 cmd-right, ctrl-e 移动到一行结束 cmd-left, ctrl-a 移动到一行开始 cmd-up 移动到文件开始 cmd-down 移动到文件结束 cmd-r 在方法之间跳转 窗口管理 快捷键 快捷键的功能 cmd-n 新建文件 shift-cmd-n 新建窗口 cmd-o 打开文件 cmd-shift-o 打开文件夹 cmd-s 保存 shift-cmd-s 另存为 alt-cmd-s 保存所有 cmd-w 关闭标签 shift-cmd-w 关闭窗口 cmd-k up/down/left/right 分隔窗口 cmd-k cmd-up/down/left/right 聚焦窗口 ctrl-cmd-f 全屏 目录树操作 快捷键 快捷键的功能 cmd-\\ 显示(隐藏)目录树 ctrl-0 焦点切换到目录树(再按一次或者 Esc 退出目录树) alt-right 和 alt-left 展开(隐藏)所有目录 ctrl-alt-] 和 ctrl-alt-[ 同上 ctrl-[ 和 ctrl-] 展开(隐藏)当前目录 ctrl-shift-c 复制当前文件绝对路径 cmd-k h 或 cmd-k left 在左半视图中打开文件 cmd-k j 或 cmd-k down 在下半视图中打开文件 cmd-k k 或 cmd-k up 在上半视图中打开文件 cmd-k l 或 cmd-k right 在右半视图中打开文件 cmd-k h 为先按下 cmd-k ，松开后按 h 。 书签 快捷键 快捷键的功能 cmd-F2 在本行增加书签 F2 跳到当前文件的下一条书签 shift-F2 跳到当前文件的上一条书签 选取 快捷键 快捷键的功能 ctrl-shift-p 选取至上一行 ctrl-shift-n 选取至下一行 ctrl-shift-b 选取至前一个字符 ctrl-shift-f 选取至后一个字符 alt-shift-b, alt-shift-left 选取至字符开始 alt-shift-f, alt-shift-right 选取至字符结束 ctrl-shift-e, cmd-shift-right 选取至本行结束 ctrl-shift-a, cmd-shift-left 选取至本行开始 cmd-shift-up 选取至文件开始 cmd-shift-down 选取至文件结尾 cmd-a 全选 cmd-l 选取一行，继续按会继续选取下一行 ctrl-shift-w 选取当前单词 编辑和删除文本 快捷键 快捷键的功能 ctrl-t 使光标前后字符交换 cmd-j 将下一行与当前行合并 ctrl-cmd-up, ctrl-cmd-down 使当前行向上或者向下移动 cmd-shift-d 复制当前行到下一行 cmd-/ 将选择的文件加入注释 Atom 大小写转换 快捷键 快捷键的功能 cmd-k, cmd-u 使当前字符大写 cmd-k, cmd-l 使当前字符小写 cmd-k, cmd-u 为先按 cmd-k 再按 cmd-u 。 删除和剪切 快捷键 快捷键的功能 ctrl-shift-k 删除当前行 ctrl-k 剪切到当前行结束 alt-h 或 alt-delete 删除到当前单词开始 alt-d 删除到当前单词结束 多光标和多处选取 快捷键 快捷键的功能 cmd-click 增加新光标 cmd-shift-l 将多行选取改为多行光标 ctrl-shift-up, ctrl-shift-down 增加上（下）一行光标 cmd-d 选取文档中和当前单词相同的下一处 cmd-u 取消选择 ctrl-cmd-g 选取文档中所有和当前光标单词相同的位置 跳转 快捷键 快捷键的功能 ctrl-m 相应括号之间，html tag之间等跳转 ctrl-g 移动到指定行 row:column 处 ctrl-cmd-m 括号(tag)之间文本选取 alt-cmd-.|关闭当前XML/HTML tag ctrl-shift-o 打开链接 编码方式，文件类型，Markdown 预览 快捷键 快捷键的功能 ctrl-shift-u 调出切换编码选项 ctrl-shift-l 选择文本类型 ctrl-shift-m Markdown 预览 查找和替换 快捷键 快捷键的功能 cmd-f 在buffer中查找 cmd-g 查找下一个 shift-cmd-g 查找上一个 cmd-shift-f 在整个工程中查找 折叠 快捷键 快捷键的功能 alt-cmd-[ 折叠 alt-cmd-] 展开 alt-cmd-shift-{ 折叠全部 alt-cmd-shift-} 展开全部 cmd-k cmd-n 指定折叠层级，n为层级数 git 操作 快捷键 快捷键的功能 cmd-alt-z checkout HEAD 版本 cmd-shift-b 弹出 untracked 和 modified 文件列表 alt-g down alt-g up 在修改处跳转 alt-g d 弹出diff列表 alt-g o 在 github 上打开文件 alt-g g 在 github 上打开项目地址 alt-g b 在 github 上打开文件 blame alt-g h 在 github 上打开文件 history alt-g i 在 github 上打开 issues alt-g r 在 github 打开分支比较 alt-g c 拷贝当前文件在 gihub 上的网址","tags":"教程","url":"https://xutree.github.io/pages/2018/10/16/atom快捷键/"},{"title":"Perl 入门","text":"Perl 是 Practical Extraction and Report Language 的缩写，可翻译为 \"实用报表提取语言\"。 Perl 是高级、通用、直译式、动态的程序语言。 Perl 最初的设计者为拉里·沃尔（Larry Wall），于1987年12月18日发表。 Perl 借用了 C、sed、awk、shell 脚本以及很多其他编程语言的特性。 Perl 最重要的特性是 Perl 内部集成了正则表达式的功能，以及巨大的第三方代码库CPAN。 以下代码为使用 Perl 输出 \"Hello World！\"： 1 2 #!/usr/bin/perl print \"Hello, World!\\n\" ; Perl 语言的应用范围很广，除 CGI 以外，Perl 被用于图形编程、系统管理、网络编程、金融、生物以及其他领域。由于其灵活性，Perl 被称为脚本语言中的瑞士军刀。 Perl 与脚本语言一样，Perl 不需要编译器和链接器来运行代码，你要做的只是写出程序并告诉 Perl 来运行而已。这意味着 Perl 对于小的编程问题的快速解决方案和为大型事件创建原型来测试潜在的解决方案是十分理想的。 运行 Perl 交互式 $perl -e <perl code> # Unix/Linux C:>perl -e <perl code> # Windows/DOS 选项 描述 -d[:debugger] 在调试模式下运行程序 -Idirectory 指定 @INC/#include 目录 -T 允许污染检测 -t 允许污染警告 -U 允许不安全操作 -w 许很多有用的警告 -W 允许所有警告 -X 禁用使用警告 -e program 执行 perl 代码 file 执行 perl 脚本文件 脚本执行 $perl script.pl # Unix/Linux C:>perl script.pl # Windows/DOS Perl 基础语法 语句 Perl 程序有声明与语句组成，程序自上而下执行，包含了循环，条件控制，每个语句以分号 ( ; ) 结束。Perl 语言没有严格的格式规范，你可以根据自己喜欢的风格来缩进。 注释 perl 注释的方法为在语句的开头用字符 #。 perl 也支持多行注释，最常用的方法是使用 POD(Plain Old Documentations) 来进行多行注释。方法如下: 1 2 3 4 5 6 7 8 9 10 11 #!/usr/bin/perl # 这是一个单行注释 print \"Hello, world\\n\" ; =pod 注释 这是一个多行注释 这是一个多行注释 这是一个多行注释 这是一个多行注释 =cut =pod、 =cut只能在行首 以=开头，以=cut结尾 =后面要紧接一个字符，=cut后面可以不用 空白 Perl 解释器不会关心有多少个空白。但是如果空格和分行出现在字符串内，他会原样输出。 引号 Perl 双引号和单引号的区别: 双引号可以正常解析一些转义字符与变量，而单引号无法解析会原样输出。 Here 文档 必须后接分号，否则编译通不过 END 可以用任意其它字符代替，只需保证结束标识与开始标识一致 结束标识必须顶格独自占一行(即必须从行首开始，前后不能衔接任何空白和字符) 开始标识可以不带引号号或带单双引号，不带引号与带双引号效果一致，解释内嵌的变量和转义符号，带单引号则不解释内嵌的变量和转义符号 当内容需要内嵌引号（单引号或双引号）时，不需要加转义符，本身对单双引号转义 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #!/usr/bin/perl $a = 10 ; $var = <<\" EOF \"; 这是一个 Here 文档实例，使用双引号。 可以在这输如字符串和变量。 例如：a = $a EOF print \"$var\\n\" ; $var = <<' EOF '; 这是一个 Here 文档实例，使用单引号。 例如：a = $a EOF print \"$var\\n\" ; 执行以上程序输出结果为： 这是一个 Here 文档实例，使用双引号。 可以在这输如字符串和变量。 例如：a = 10 这是一个 Here 文档实例，使用单引号。 例如：a = $a Perl 数据类型 Perl 是一种弱类型语言，所以变量不需要指定类型，Perl 解释器会根据上下文自动选择匹配类型。 Perl 有三个基本的数据类型：标量、数组、哈希。 标量 标量是 Perl 语言中最简单的一种数据类型。这种数据类型的变量可以是数字，字符串，浮点数，不作严格的区分。在使用时在变量的名字前面加上一个\"$\",表示是标量。 数组 数组变量以字符\"@\"开头，索引从0开始。 哈希 哈希是一个无序的 key/value 对集合。可以使用键作为下标获取值。哈希变量以字符\"%\"开头。 数字字面量 整型 Perl 实际上把整数存在你的计算机中的浮点寄存器中，所以实际上被当作浮点数看待。 在多数计算机中，浮点寄存器可以存贮约16位数字，长于此的被丢弃。整数实为浮点数的特例。 8进制和16进制数：8进制以0开始，16进制以0x开始。 浮点数 浮点数数据如：11.4 、 -0.3 、.3 、 3. 、 54.1e+02 、 5.41e03 浮点寄存器通常不能精确地存贮浮点数，从而产生误差，在运算和比较中要特别注意。指数的范围通常为-309到+308。 字符串 Perl 中的字符串使用一个标量来表示，定义方式和 c 很像，但是在 Perl 里面字符串不是用0来表示结束的。 Perl 双引号和单引号的区别: 双引号可以正常解析一些转义字符与变量，而单引号无法解析会原样输出。但是用单引号定义可以使用多行文本。 转义字符 转义字符 含义 \\\\ 反斜线 \\' 单引号 \\\" 双引号 \\a 系统响铃 \\b 退格 \\f 换页符 \\n 换行 \\r 回车 \\t 水平制表符 \\v 垂直制表符 \\0nn 创建八进制格式的数字 \\xnn 创建十六进制格式的数字 \\cx 控制字符，x可以是任何字符 \\u 强制下一个字符为大写 \\l 强制下一个字符为小写 \\U 强制将所有字符转换为大写 \\L 强制将所有的字符转换为小写 \\Q 将到\\E为止的非单词（non-word）字符加上反斜线 \\E 结束\\L、\\U、\\Q Perl 变量 标量 \\( 开始， 如\\) a $b 是两个标量。 数组 @ 开始 ， 如 \\@a \\@b 是两个数组。 哈希 % 开始 ， %a %b 是两个哈希。 Perl 为每个变量类型设置了独立的命令空间，所以不同类型的变量可以使用相同的名称，你不用担心会发生冲突。例如 $foo 和 \\@foo 是两个不同的变量。 变量不需要显式声明类型，在变量赋值后，解释器会自动分配匹配的类型空间。 Perl 标量 标量是一个简单的数据单元。 标量可以是一个整数，浮点数，字符，字符串，段落或者一个完整的网页。 特殊字符 以下我们将演示 Perl 中特殊字符的应用，如 __FILE__, __LINE__, 和 __PACKAGE__ 分别表示当前执行脚本的文件名，行号，包名。 注意： 是两条下划线，__FILE 前后各两条下划线。 这些特殊字符是单独的标记，不能写在字符串中，例如： 1 2 3 4 5 6 7 8 #!/usr/bin/perl print \"文件名 \" . __FILE__ . \"\\n\" ; print \"行号 \" . __LINE__ . \"\\n\" ; print \"包名 \" . __PACKAGE__ . \"\\n\" ; # 无法解析 print \"__FILE__ __LINE__ __PACKAGE__\\n\" ; 文件名 test.pl 行号 4 包名 main __FILE__ __LINE__ __PACKAGE__ v 字符串 用于十六进制： 1 2 3 4 5 6 7 8 9 #!/usr/bin/perl $smile = v9786 ; $foo = v102 .111.111 ; $martin = v77 .97.114.116.105.110 ; print \"smile = $smile\\n\" ; print \"foo = $foo\\n\" ; print \"martin = $martin\\n\" ; Wide character in print at test.pl line 7. smile = &#x263a; foo = foo martin = Martin 数组 Perl 数组一个是存储标量值的列表变量，变量可以是不同类型。 数组变量以 \\@ 开头。访问数组元素使用 $ + 变量名称 + [索引值] 格式来读取。 if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"教程","url":"https://xutree.github.io/pages/2018/10/15/perl入门/"},{"title":"数据结构——向量","text":"数据结构大致可分为：线性结构、半线性结构和非线性结构。线性结构中最基本的称为序列（sequence），根据其中数据项的逻辑次序与其物理存储地址的对应关系不同，又可分为向量（vector）和列表（list）。 从数组到向量 数组：集合 S 由 n 个元素组成，且各元素之间具有一个线性次序，则可以将它们存放于起始地址 A，物理位置连续的一段存储空间。记为： A[0,n) = { A[0], A[1], ..., A[n-1] } 将它们存放于起始地址 A，若每个元素占用 s 个单位的空间，则元素 A[i] 的物理地址为： A + i * s ，所以被称作线性数组。 向量： V[0,n) = { v[0], v[1], ..., v[n-1] } 是线性数组的一种抽象和泛化，由具有线性次序的一组元素构成的集合，其中的元素由秩区分。各元素秩互异，且均为 [0, n) 内的整数。采用\"寻秩访问\"。经过抽象，不限定同一向量中元素都属于同一数据类型，故而不保证它们之间可以相互比较大小。 接口 作为一种抽象数据类型，向量对象应支持如下操作接口： 操作接口 功能 适用对象 size() 元素总数 向量 get(r) 获取秩为 r 的元素 向量 put(r, e) 用 e 代替秩为 r 的元素 向量 insert(r, e) e 作为秩为 r 的元素插入，原后继元素依次后移 向量 remove(r) 删除秩为 r 的元素，返回该元素中原存放的对象 向量 disordered() 判断所有元素是否已按非降序排列 向量 sort() 非降序排序 向量 find(e) 查找等于 e 且秩最大的元素 向量 search(e) 查找目标元素 e，返回不大于 e 且秩最大的元素 有序向量 deduplicate() 剔除重复元素 向量 uniquify() 剔除重复元素 有序向量 traverse() 遍历向量并统一处理所有元素，处理方法由函数对象指定 向量 Vector 模板类 typedef int Rank; //秩 #define DEFAULT_CAPACITY 3 //默认的初始容量（实际应用中可设置为更大） template <typename T> class Vector { //向量模板类 protected: Rank _size; int _capacity; T* _elem; //规模、容量、数据区 void copyFrom(T const* A, Rank lo, Rank hi); //复制数组区间A[lo,hi) void expand(); //空间不足时扩容 void shrink(); //装填因子过小时压缩 bool bubble(Rank lo, Rank hi); //扫描交换 void bubbleSort()Rank lo, Rank hi); //气泡排序算法 Rank max(Rank lo, Rank hi); //选取最大元素 void selectionSort(Rank lo, Rank hi); //选择排序算法 void merge(Rank lo, Rank mi, Rank hi); //归并算法 void mergeSort(Rank lo, Rank hi); //归并排序算法 Rank partition(Rank lo, Rank hi); //轴点构造算法 void quickSort(Rank lo, Rank hi); //快速排序算法 void heapSort(Rank lo, Rank hi); //堆排序 public: //构造函数 //容量为 c，规模为 s，所有元素初始化为 v，s<=c Vector(int c = DEFAULT_CAPACITY, int s = 0, T v = 0) { _elem = new T[_capacity = c]; for(_size = 0; _size < s; _elem[_size++] = v); } Vector(T const* A, Rank n) { copyFrom(A, 0, n); } //数组整体复制 Vector(T const* A, Rank lo, Rank hi) { copyFrom(A, lo, hi); } //区间 Vector(Vector<T> const& V) { copyFrom(V._elem, 0, V._size); } //向量整体复制 Vector(Vector<T> const& V, Rank lo, Rank hi) { copyFrom(V._elem, lo, hi); } //区间 //析构函数 ~Vector() { delete [] _elem; } //释放内部空间 //只读访问接口 Rank size() const { return _size; } //规模 bool empty() const { return !_size; } //判空 int disordered() const; //判断向量是否已排序 Rank find(T const& e) const { return find(e, 0, _size); } //无序向量整体查找 Rank find(T const& e, Rank lo, Rank hi) const; //无序向量区间查找 Rank search(T const& e) const //有序向量整体查找 { return (0 >= _size) ? -1 : search(e, 0, _size); } Rank search(T const& e, Rank lo, Rank hi) const //有序向量区间查找 //可写访问接口 T& operator[](Rank r) const; //重载下标运算符，可以类似于数组形式引用各元素 Vector<T> & operator=(Vector<T> const&); //重载赋值运算符，以便直接克隆向量 T remove(Rank r); //删除秩为 r 的元素 int remove(Rank lo, Rank hi); //删除秩在区间 [lo,hi) 之内的元素 Rank insert(Rank r, T const& e); //插入元素 Rank insert(T const& e) { return insert(_size, e); } //默认作为尾元素插入 void sort(Rank lo, Rank hi); //对 [lo,hi) 排序 void sort() { sort(0, _size); } //整体排序 void unsort(Rank lo, Rank hi); //对 [lo,hi) 置乱 void unsort() { unsort(0, _size); } //整体置乱 int deduplicate(); //无序去重 int uniquify(); //有序去重 //遍历 void traverse(void (*)(T&)); //遍历（使用函数指针，只读或局部性修改） template <typename VST> void traverse(VST&); //遍历（使用函数对象，可全局性修改） };//Vector 构造与析构 约定：向量中秩为 r 的元素，对应于内部数组中的 _elem[r]，其物理地址为：_elem + r 默认构造函数 整个默认构造过程顺序进行，没有任何迭代，故忽略用于分配数组空间的时间，需要常数时间。 基于复制的构造函数 在模板的实现中，我们将基于数组或者向量的复制操作（局部或整体的）都转交给如下的 copyFrom 函数处理： template <typename T> void Vector<T>::copyFrom(T const* A, Rank lo, Rank hi) { _elem = new T[_capacity = 2 * (hi -lo) ]; _size = 0; //分配空间，规模清零 while( lo <hi) //A[lo,hi) 元素逐一复制 _elem[_size++] = A[lo++]; // } 需要 O (_size) 时间。 需要强调的是，由于向量内部含有动态分配的空间，默认的\"=\"运算符不足以支持向量之间的直接赋值。故要重建\"=\"： template <typename T> Vector<T>& Vector<T>::operator=(Vector<T> const& V) { if( _elem ) delet [] _elem; copyFrom(V._elem, 0, V.size()); return *this; } 析构 若不计系统用于空间回收的时间，整个析构过程只需常数时间。 动态空间管理 扩容 template <typename T> void Vector<T>::expand() { if(_size < _capacity) return; //尚未满员，不必扩容 if(_capacity < DEFAULT_CAPACITY) _capacity = DEFAULT_CAPACITY; //不低于最小容量 T *oldElem = _elem; _elem = new T[_capacity << 1]; //容量加倍 for( int i = 0; i < _size; i++) _elem[i] = oldElem[i]; //复制原向量内容（T为基本类型，或以重载赋值运算符 delete [] oldElem; //释放原空间 } 分摊运行时间为 O (1) 缩容 template <typename T> void Vector<T>::shrink() { if(_capacity < DEFAULT_CAPACITY << 1) return; //不至收缩到DEFAULT_CAPACITY if(_size << 2 > _capacity) return; //以25%为界 T *oldElem = _elem; _elem = new T[_capacity >> 1]; //容量减半 for( int i = 0; i < _size; i++) _elem[i] = oldElem[i]; //复制原向量内容（T为基本类型，或以重载赋值运算符 delete [] oldElem; //释放原空间 } 就单次扩容或缩容操作而言，所需时间的确会高达 O (n)，因此在对单次操作的执行速度及其敏感的应用场合以上策略并不适用，其中缩容操作甚至可以完全不予考虑。 常规向量 直接引用元素 与数组直接通过下标访问元素的形式相比，向量 ADT（abstract data type）所设置的 get() 和 put() 接口都显得不甚自然。 template <typename T> T& Vector<T>::operator[](Rank r) const { return _elem[r]; } //assert: 0 <= r < _size 置乱器 重载后 [] 返回的是对数组元素的引用，这就意味着它既可以取代 get() 操作（通常作为赋值表达式的右值），也可以取代 set() 操作（通常作为左值）。采用这种形式，可以很清晰地实现如下的向量置乱器： template <typename T> void permute(Vector<T>& V) { for(int i = V.size(); i > 0; i--) swap(V[i-1], V[rand() % i]); //V[i-1] 与 V[0,i) 中某一随机元素交换 } 从理论上讲，上述算法可以枚举出同一向量所有可能的排列，而且能够保证生成各种排列的概率均等。 为便于对各种向量算法的测试与比较，不妨将上述算法封装到向量 ADT 中，并对外提供向量的置乱接口操作： template <typename T> void Vector<T>::unsort(Rank lo, Rank hi) { T* V = _elem + lo; for(Rank i =hi -lo; i > 0; i--) swap(V[i-1], V[rand() % i]); } 上述两段代码的细微差异：上面的代码通过重载\"[]\"，利用秩间接访问 向量 元素，下面的代码通过下标直接访问内部 数组 的元素。 判等器和比较器 template <typename T> static bool lt(T* a, T* b) { return lt(*a, *b); } //less than template <typename T> static bool lt(T& a, T& b) { return a < b; } //less than template <typename T> static bool eq(T* a, T* b) { return eq(*a, *b); } //equal template <typename T> static bool eq(T& a, T& b) { return a == b; } //equal 在一些复杂的数据结构中，内部元素本身的类型可能就是指向其他对象的指针，从而外部更多关注的，往往是其所指向对象的大小如直接比较指针，则结果毫无意义，故上面的代码分别出了了指针和引用的情况。 无序查找 判等器 Vector 模板中的 find 接口的语义为\"查找与数据对象 e 相等的元素\"。这暗示向量元素可以通过相互\"比对\"判断是否相等。这类仅支持比对，但未必支持比较的向量，称为无序向量（unsorted vector）。 顺序查找 由于 find 函数查找相等的最大秩元素，故从后往前比对： template <typename T> Rank Vector<T>::find(T const& e, Rank lo, Rank hi) const { while( (lo < hi--) && (e != _elem[hi]) ); //assert: 0 <= lo < hi <= _size return hi; } 最坏情况： O (n)；最好情况： O (1)。为输入敏感（input sensitive）算法。 插入 //assert: 0 <= r <= size template <typename T> Rank Vector<T>::insert(Rank r, T const& e) { expan(); //如有必要，扩容 for(int i = _size; i > r; i--) _elem[i] = _elem[i-1]; _elem[r] = e; _size++; //插入并更新容量 return r; } 注意从后往前搬移数据，以防覆盖。复杂度：若插入位置等概论分布，则平均运行时间为 O (_size)= O (n)。 删除 应将单元素删除视为区间删除的特例，并基于后者来实现前者。 区间删除 //删除区间[lo, hi) template <typename T> int Vector<T>::remove(Rank lo, Rank hi) { if(lo === hi) return 0; while(hi < _size) _elem[lo++] = _elem[hi++]; _size = lo; shrink(); return hi - lo; //返回被删除元素个数 } 单元素删除 template <typename T> T Vector<T>::remove(Rank r) { T e = _elem[r]; remove(r, r + 1); return e; } 被删除元素在向量中的位置越靠后（前）所需时间越短（长），最好为 O (1)，最坏为 O (n)。 唯一化 template <typename T> int Vector<T>::deduplicate() { int oldSize = _size; Rank i = 1; while(i < _size) (find(_elem[i], 0, i) < 0) ? i++ : remove(i); return oldSize - _size; }","tags":"读书笔记","url":"https://xutree.github.io/pages/2018/10/10/数据结构向量/"},{"title":"C++ Primer 第八章 IO 库","text":"IO 类 iostream 头文件： istream , wistream , ostream , wostream , iostream , wiostream 类型。 fstream 头文件： ifstream , wifstream , ofstream , wofstream , fstream , wfstream 类型。 sstream 头文件： istringstream , wistringstream , ostringstream , wostringstream , stringstream , wstringstream 类型。 宽字符版本的类型和函数的名字以一个\"w\"开始。 IO 对象无拷贝和赋值。进行 IO 操作的函数通常以引用方式传递和返回值。读写一个 IO 对象会改变其状态，因此传递和返回的引用不能是 const 的。 条件状态 下表中 strm 是一种 IO 类型： 状态 含义 strm ::iostate iostate 是一种机器相关的类型，提供了表达条件状态的完整功能 strm ::badbit 流已崩溃 strm ::failbit IO 操作失败了 strm ::eofbit 流到达了文件结束 strm ::goodbit 流未处于错误状态，此值保证为0 s.eof() 若流 s 的 eofbit 置位，返回 true s.fail() 若流 s 的 failbit 或 badbit 置位，返回 true s.bad() 若流 s 的 badbit 置位，返回 true s.good() 若流 s 处于有效状态，返回 true s.clear() 将流 s 所以状态位复位，将流的状态设为有效，返回 void s.clear(flags) 根据 flags 复位，flags 类型为 strm ::iostate，返回 void s.setstate(flags) 根据 flags 置位，flags 类型为 strm ::iostate，返回 void s.rdstate() 返回流 s 的当前条件状态，返回值类型为 strm ::iostate badbit 表示系统级错误，如不可恢复的读写错误，一旦被置位，流就无法再使用了。 failbit 表示可恢复的错误，例如期望读取数值却读到一个字符等错误。这种问题通常是可以修正的，流还可以继续使用。 如果到达文件结尾， eofbit 和 failbit 都会被置位。 goodbit 值为0，表示流未发生错误。 如果 badbit 、 failbit 和 eofbit 任一个被置位，则检测流状态的条件会失败。 good() 函数在所有错误位均未置位的情况下返回 true 。 我们将流当做条件使用的代码等价于 !fail() 。 管理条件状态 // 记住 cin 的当前状态 auto old_state = cin.rdstate(); // 记住 cin 的当前状态 cin.clean(); // 使 cin 有效 process_input(cin); // 使用 cin cin.setstate(old_state); // 将 cin 置为原有状态 // 复位 failbit 和 badbit，保持其他标志位布标 cin.clear(cin.rdstate() & ~cin.failbit & ~cin.badbit); 管理输出缓冲 每个输出流都管理一个缓冲区，用来保存程序读写的数据。 导致缓冲刷新（即，数据真正写到输出设备或文件）的原因有很多： 程序正常结束，作为 main 函数的 return 操作的一部分，缓冲刷新被执行 缓冲区满 使用操纵符 endl （插入换行）、 ends （插入空字符）、 flush （什么都不插入）显式刷新 在每个输出操作之后，可以用操纵符 unitbuf 设置流的内部状态，来情况缓冲区。默认情况下，对 cerr 是设置 unitbuf 的，因此 cerr 的内容都是立即刷新的 一个输出流可以关联到另一个流。当读写被关联的流时，关联到的流的缓冲区会被刷新。默认情况下， cin 和 cerr 都关联到 cout 。因此读 cin 或者写 cerr 都会导致 cout 的缓冲区被刷新 unitbuf 操纵符 如果想在每次输出操作后都刷新缓冲区，可以使用 unitbuf 操纵符。它告诉流在接下来的每次写操作之后都执行一次 flush 刷新。 nounitbuf 操纵符则重置流，使其恢复使用正常的系统管理的缓冲区刷新机制： cout << unitbuf; // 所有输出操作后都会立即刷新缓冲区 // 任何输出都会立即刷新，无缓冲 cout << nounitbuf; // 回到正常的缓冲方式 关联输入和输出流 tie() 有两个重载的版本： 不带参数的版本返回指向输出流的指针。如果本对象当前关联到一个输出流，则返回的就是指向这个流的指针，如果对象未关联到流，则返回空指针 第二个版本接受一个指向 ostream 的指针，将自己关联到此 ostream 每个流同时最多关联到一个流，但多个流可以同时关联到同一个 ostream 文件输入输出 fstream 特有的操作 下表中的 fstream 是头文件 fstream 中定义的一个类型： 操作 含义 fstream fstrm; 创建一个未绑定的文件流 fstream fstrm(s); 创建一个 fstream ，并打开名为 s 的文件。s 可以是 string 类型或者指向 C 风格字符串的指针。这些构造函数都是 explicit 的。默认的文件模式 mode 依赖于 fstream 的类型 fstream fstrm(s, mode); 按 mode 打开文件 fstrm.open(s) 打开名为 s 的文件并与 fstrm 绑定。s 可以是 string 类型或者指向 C 风格字符串的指针。默认的文件模式 mode 依赖于 fstream 的类型。返回 void fstrm.close() 关闭与 fstrm 绑定的文件。返回 void fstrm.is_open() 返回一个布尔值，指出与 fstrm 关联的文件是否打开成功且尚未关闭 如果调用 open() 失败， failbit 会被置位，条件会为假： if(open(file)) 可用于判定。 对一个已经打开的文件流调用 open() 会失败，并且 failbit 会被置位。为了将文件流关联到另一个文件，必须先关闭已经关联的文件。 当一个 fstream 对象被销毁时， close 会自动被调用。 文件模式 文件模式 意义 in 只读 out 只写（会清空已有数据） app 每次写操作前均定位到文件末尾 ate 打开文件后立即定位到文件末尾 trunc 截断文件 binary 以二进制方式进行 IO ifstream 默认 in 模式； ofstream 默认 out 模式； fstream 默认 in 和 out 模式打开。 string 流 fstream 特有的操作 下表中的 sstream 是头文件 sstream 中定义的一个类型： 操作 含义 sstream strm; 创建一个未绑定的 stringstream 对象 sstream strm(s); strm 是一个 sstream 对象，保存 string s 的一个拷贝。此构造函数时 explicit 的 strm.str() 返回 strm 所保存的 string 的拷贝 strm.str(s) 将 string s 拷贝到 strm 中，返回 void","tags":"读书笔记","url":"https://xutree.github.io/pages/2018/10/09/C++_Primer_Chapter_8/"},{"title":"C++ Primer 第七章 类","text":"类的基本思想是数据抽象和封装。 数据抽象是一种依赖于接口和实现分离的编程（以及设计）技术。类的接口包括用户可以执行的操作，类的实现包括类的数据成员，负责接口实现的函数体以及定义类所需的各种私有函数。 封装实现了类的接口和实现的分离。封装后的类隐藏了它的实现细节，类的用户只能使用接口而无法访问实现部分。 类的定义 定义在类内部的函数时隐式 inline 的。 this 是一个常量指针。 const 成员函数 通过在紧随参数列表之后添加 const ，可以定义 const 成员函数。 const 的作用是修改隐式 this 指针的类型。 默认情况下， this 指针的类型是指向类类型非常量版本的常量指针（顶层常量）。这意味着我们不能把 this 绑定到一个常量对象上。 常量对象，以及常量对象的引用或者指针都只能调用常量成员函数。 类作用域和成员函数 编译器分两步处理类：首先编译成员的声明，然后才轮到成员函数体（如果有的话）。因此，成员函数体可以随意使用类中的其他成员而无须在意这些成员出现的顺序。 编译器处理完类中的全部声明后才会处理成员函数的定义。 这种两阶段的处理方式只适用于成员函数中使用的名字。声明中使用的名字，包括返回类型或者参数列表中使用的名字，都必须在使用前确保可见。如果某个成员的声明使用了类中尚未出现的名字，则编译器将会在定义该类的作用域中继续查找。 typedef double Money ; string bal ; class Account { public : Money balance() { return bal ; } private : Money bal ; // ... }; 当编译器看到 balance 函数的声明语句时，它将在 Account 类的范围内寻找对 Money 的声明。编译器只考虑 Account 中在使用 Money 前出现的声明，因为没找到匹配的成员，所以编译器会接着到 Account 的外层作用域中查找。在上面的例子中，编译器会找到 Money 的 typedef 语句，该类型被用作 balance 函数的返回类型及数据成员 bal 的类型。另一方面，balance 函数体在整个类可见后才被处理。因此，该函数的 return 语句返回名为 bal 的成员，而非外层作用域的 string 对象。 构造函数 构造函数不能被声明成 const 的。 当我们创建类的一个 const 对象时，直到构造函数完成初始化过程，对象才能真正取得其\"常量\"属性。因此，构造函数在 const 对象的构造过程中可以向其写值。 如果我们的类没有显式定义构造函数，编译器会生成合成的默认构造函数。对于大多数类来说，合成的默认构造函数按照如下规则初始化类的数据成员： 如果存在类内的初始值，用它来初始化成员 否则，执行默认初始化 在 C++ 11中，如果我们需要默认的行为，那么可以通过在参数列表后面写上 = default 来要求编译器生成构造函数。如果 = default 出现在类的内部，则默认构造函数是内联的；如果它出现在外部，则该成员默认情况下不是内联的。 构造函数初始值列表 构造函数初始值列表： Sales_data(const std::string &s) : bookNo(s) { } 如果成员是 const 或者引用的话，必须将其初始化。类似的，当成员属于某种类类型且该类类型没有定义默认构造函数时，也必须将这个成员初始化。 随着构造函数体一开始执行，初始化就完成了。我们初始化 const 或者引用类型的唯一机会就是通过构造函数初始化。 构造函数初始值列表只说明用于初始化成员的值。成员的初始化顺序与它们在类定义中出现顺序一致。 委托构造函数 一个委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程，或者说它把它自己的一些（或者全部）职责委托给了其他构造函数。 class Sales_data { public : // 非委托构造函数 Sales_data ( std :: string s , unsigned cnt , double price ) : bookNo ( s ), units_sold ( cnt ), revenue ( cnt * price ) { } // 其余构造函数都委托给另外一个构造函数 Sales_data () : Sales_data ( \"\" , 0 , 0 ) { } Sales_data ( std :: string s ) : Sales_data ( s , 0 , 0 ) { } Sales_data ( std :: istream & is ) : Sales_data() { read ( is , * this ); } //其他成员 } 受委托的构造函数先执行。 访问控制与封装 定义在 public 说明符之后的成员在整个程序内可被访问， public 成员定义类的接口。 定义在 private 说明符之后的成员可以被类的成员函数访问，但是不能被使用该类的代码访问。 class 和 struct 定义类唯一的区别就是默认的访问权限。 友元 通过友元，类可以允许其他类或者函数访问它的 非公有成员 。 如果类想把一个函数作为它的友元，只需要增加一条以 friend 关键字开始的函数声明即可。友元声明只能出现在类定义的内部，但是在类内出现的具体位置不限。友元不是类的成员也不受它所在区域访问控制级别的约束。 友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明。如果我们希望类的用户能够调用某个友元函数，那么我们必须在友元声明之外再专门对函数进行一次声明。 友元关系不存在传递性。 如果一个类指定了友元类，则友元类的成员函数可以访问此类 包括非公有成员在内的所有成员 。 类的其他特性 定义类型成员 类可以自定义某种类型在类中的别名。要注意，用来定义类型的成员必须先定义后使用。 可变数据成员 有时我们希望能够修改类的某个数据成员，即使是在一个 const 成员函数内。通过关键字 mutable 可以达到这种效果。一个可变数据成员永远不会是 const ，即使它是 const 对象的成员。 返回 *this 的成员函数 一个 const 成员函数如果以引用的方式返回*this，那么它的返回类型将是常量引用。 基于 const 的重载： class Screen { public : // 根据对象是否是 const 重载 display 函数 Screen & display ( std :: ostream & os ) { do_display ( os ); return * this ; } const Screen & display ( std :: ostream & os ) const { do_display ( os ); return * this ; } private : // 该函数负责显示 Screen 的内容 void do_display ( std :: ostream & os ) const { os << contents ; } }; 类类型 声明方法： Sales_data item1; 或 class Sales_data item1; 后一种从 C 语言继承而来。 类的声明：前向声明，在类声明之后定义之前，类是一个不完全类型。 不完全类型只能在非常有限的情景下使用：定义指向这种类型的引用或指针，也可以声明（但是不能定义）以不完全类型作为参数或者返回类型的函数。 直到类被定义之后数据成员才可以被声明成这种类类型。然而，当一个类的名字出现后，它被认为是声明过了（但尚未定义），因此允许包含指向它自身类型的引用或者指针（有没有想到链表结构）。 隐式的类类型转换 如果构造函数只接受一个实参，则它实际上定义了转换为此类类型的隐式转换机制，有时我们把这种构造函数称为转换构造函数。 只允许一步类类型转换。类类型转换不是总有效。 抑制构造函数定义的隐式转换 可以通过将构造函数声明为 explicit 加以阻止。 关键字 explicit 只对一个实参的构造函数有效。需要多个实参的构造函数不能用于执行隐式转换，所以无须将这些构造函数指定为 explicit 。 只能在类内声明构造函数时使用 explicit 关键字，在类外部定义时不应重复。 explicit 构造函数只能用于直接初始化。 尽管编译器不会将 explicit 的构造函数用于隐式转换过程，但是我们可以使用这样的构造函数显式地强制类型转换： item.combine(static_cast<Sales_data>(cin)); 聚合类 当一个类满足如下条件时，我们说它是聚合的： 所有成员都是 public 的 没有定义任何构造函数 没有类内初始值 没有基类，也没有虚函数 例子： struct Data { int ival; string s; } 可以使用初始化列表初始化，初始值的顺序必须与声明的顺序一致。如果初始值列表中的元素个数少于类的成员数量，则靠后的成员被值初始化。 字面值常量类 字面值类型的类可能含有 constexpr 函数成员，它们是隐式 const 成员函数。 数据成员都是字面值类型的聚合类是字面值常量类。 如果一个类不是聚合类，符合以下要求也是一个字面值常量类： 数据成员都必须是字面值类型 类必须至少有一个 constexpr 构造函数 如果一个数据成员含有类内初始值，则内置类型成员的初始值必须是一条常量表达式；如果成员属于某种类类型，则初始值必须使用成员自己的 constexpr 构造函数 类必须使用析构函数的默认定义，该成员负责销毁类的定义 尽管构造函数不能是 const 的，但是字面值常量类的构造函数可以使 constexpr 函数。事实上，一个字面值常量类都必须至少提供一个 constexpr 构造函数。通过前置关键字 constexpr 就可以声明一个 constexpr 构造函数。 constexpr 构造函数可以声明成 =default 或者删除函数的形式，否则， constexpr 构造函数就必须既符合构造函数的要求（意味着不能包含返回语句），又符合 constexpr 函数的要求（意味着它唯一可执行语句就是返回语句），综合这两点， constexpr 构造函数体一般来说应该是空的。 constexpr 构造函数必须初始化所有数据成员，初始值或者使用 constexpr 构造函数，或者是一条常量表达式。 类的静态成员 类的静态成员存在于任何对象之外，对象中不包含任何与静态数据成员有关的数据。类似的，静态成员函数也不与任何对象绑定在一起，它们不包含 this 指针。作为结果，静态成员函数不能声明成 const 的，而且我们也不能在静态函数体内使用 this 指针。 成员函数不用通过作用域运算符就能直接使用静态成员。 当在类的外部定义静态成员时，不能重复 static 关键字，该关键字只出现在类内部的声明语句。 必须在类的外部定义和初始化每个静态成员（一个例外，如果静态成员是字面值类型的 constexpr 可以在类内给它提供一个整数类型的常量表达式初始值），一个静态成员只能被初始化一次。 类似于全局变量，静态数据成员定义在任何函数之外，一直存在于程序的整个生命周期中。 静态数据成员可以是不完全类型，非静态数据成员只能声明成它所属类的指针或引用。 静态数据成员可以作为默认实参，非静态数据成员不行，因为它的值本身属于对象的一部分，这么做的结果是无法真正提供一个对象以便从中获得成员的值（类似于循环定义），将引发错误。","tags":"读书笔记","url":"https://xutree.github.io/pages/2018/10/09/C++_Primer_Chapter_7/"},{"title":"C++ Primer 第六章 函数","text":"函数是一个命名了的代码块。 函数基础 为了与 C 语言兼容，可以使用关键字 void 表示函数没有形参。 函数的返回值不能是数组或者函数类型，但可以返回指向数组和函数的指针。 自动对象：只存在于块执行期间的对象。当块的执行结束后，块中创建的自动对象的值就变成未定义的了。 局部静态对象：在程序执行路径第一次经过对象定义语句时初始化，并且直到程序终止才销毁。如果没有显示初始化，则执行值初始化，内置类型的局部静态变量初始化为0。 参数传递 值传递和引用传递。 当某种类型不支持拷贝操作时，函数只能通过引用形参访问该类型的对象。如 IO 类型。 const 形参和实参 如果函数无须改变引用形参的值，最好将其声明为常量引用。 此外，使用引用而非常量引用也会极大地限制函数所能接受的实参类型。例如，我们不能把 const 对象、字面值或者需要类型转换的对象传递给普通的引用形参，这种绝不像看起来那么简单，它可能造成出人意料的后果。考虑如下函数： string :: size_type find_char ( string & s , char c , string :: size_type & occurs ); 则只能将 find_char 函数用于 string 对象。类似下面的调用将在编译时发生错误： find_char(\"Hello World\", 'o', ctr); 还有一个更难察觉的问题。假如其它函数（正确的）将它们的形参定义成常量引用，那么上述的 find_char 函数无法在此类函数中正常使用。例如 bool is_sentence ( const string & s ) { string : : size_type ctr = 0 ; return find_char(s, '.', ctr) == s.size() - 1 && ctr == 1 ; } 正确的修改思路是改正 find_char 函数的形参。如果实在不能修改 find_char，就在 is_sentence 内部定义一个 string 类型的变量，令其为 s 的副本，然后把这个对象传递给 find_char。 用实参初始化形参时，会忽略顶层 const 。也就是说，当形参是顶层 const 时，传给它常量对象或者非常量对象都是可以的。 可以使用一个非常量初始化一个底层 const 对象，但反过来不行。 数组形参 数组的两个性质：不允许拷贝数组；使用数组时会将其转换成指针。 当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针。 尽管不能以值传递的方式传递数组，但是我们可以把形参写成类似数组的形式： void print(const int*); void print(const int[]); void print(const int[10]); 尽管表现形式不同，但是上面的三个函数是等价的：每个函数的唯一形参都是 const int* 类型的。如果我们传给 print 函数的是一个数组，则实参自动的转换成指向数组首元素的指针，数组的大小对函数的调用没有影响。 因为数组是以指针的形式传递给函数的，所以一开始函数并不知道数组的确切尺寸，调用者应该为此提供一些额外的信息： 使用标记指定数组长度：让数组本身包含一个结束标记，例如 C 风格字符串 使用标准库规范， begin() 和 end() 函数 显示传递一个表示数组大小的形参 当函数不需要对数组元素执行写操作的时候，数组形参应该是指向 const 的指针，注意下面的函数只能作用于大小为10的数组 void print(int (&arr)[10]) { for (auto elem : arr) cout << elem << endl; } main：处理命令行选项 int main(int argc, char *argv[]) { ... } 第二个形参 argv 是一个数组，它的元素是指向 C 风格字符串的指针；第一个形参 argc 表示数组中字符串的数量。因为第二个形参是数组，所以 main 函数也可以定义成： int main(int argc, char **argv) { ... } 当实参传给 main 函数之后，argv 的第一个元素指向程序的名字或者一个空字符串，接下来的元素依次传递命令行提供的实参，最后一个指针之后的元素值保证为0。 含有可变形参的函数 为了编写能够处理不同数量实参的函数，C++11 新标准提供了两种主要的方法： 如果所有实参类型相同，可以传递一个名为 initializer_list 的标准库类型 如果实参的类型不同，可以编写可变参数模板 C++ 还有一种特殊的形参类型（即省略号），可以用它传递可变数量的实参，不过需要注意的是，这种功能一般只用于与 C 函数交互的接口程序 initializer_list 形参 initializer_list 类型定义在同名的头文件中。 initializer_list 是一种类型模板，提供的操作如下： initializer_list <T> lst; 默认初始化；T 类型元素的空列表。 initializer_list <T> lst{a,b,c...}; lst 的元素数量和初始值一样多；lst 的元素是对应初始值的副本；列表中的元素是 const。 lst2(lst); 拷贝或赋值一个 initializer_list 对象不会拷贝列表中的元素；拷贝后，原始列表和副本共享元素。 lst2 = lst; 等价于 lst2(lst) 。 lst.size(); 列表中的元素数量。 lst.begin(); 返回指向 lst 中首元素的指针。 lst.end(); 返回指向 lst 中尾元素下一位置的指针。 initializer_list 和 vector 一样，也是类型模板，定义 initializer_list 对象时，必须说明列表中所含对象的类型。和 vector 不一样的是， initializer_list 对象中的元素永远是常量值。 如果想向 initializer_list 形参中传递一个值的序列，则必须把序列放在一对花括号内： //expected和actual是string对象 if (expected != actual) error_msg({\"functionX\", expected, actual}); else error_msg({\"functionX\", \"okay\"}); 省略符形参 省略符形参是为了便于 C++ 程序访问某些特殊的 C 代码而设置的，这些代码使用了名为 varargs 的 C 标准库功能。通常，省略符形参不应用于其他目的。你的 C 编译器文档会描述如何使用 varargs。 省略符形参只能出现在形参列表的最后一个位置，无外乎两种形式，在第一种形式中，形参声明后面的逗号是可选的： void foo(parm_list,...); void foo(...); 返回类型和 return 语句 返回 void 的函数不要求非得有 return 语句，以为这类函数的最后一句会隐式的执行 return 。 返回的值用于初始化调用点的一个临时量，该临时量就是函数调用的结果。 不要返回局部对象的引用或指针。 调用一个返回引用的函数得到左值，其他返回类型得到右值。 C++ 11新标准规定，函数可以返回花括号包围的值的列表，类似于其他返回结果，此处的列表也用来对表示函数返回的临时量进行初始化。如果列表为空，临时量执行值初始化。如果函数返回的是内置类型，则花括号包围的列表最多包含一个值，且该值所占空间不应该大于目标类型的空间。如果返回的是类类型，由类本身定义初始值如何使用。 如果控制语句到达了 main 函数的结尾处而且没有 return 语句，编译器会隐式的插入一条返回0的 return 语句。 cstdlib 头文件定义了两个预处理变量表示成功与失败： EXIT_SUCCESS ， EXIT_FAILURE 。 int (*func(int i))[10]; func 是一个函数指针，指向：接受一个 int 参数，返回值是包含10个 int 数组的地址的函数。也可以利用尾置返回类型（C++ 11）写为： auto func(int i) -> int(*)[10]; 还有一种情况，如果我们知道函数返回的指针将指向哪个数组，就可以使用 decltype 关键字声明返回类型。例如，下面的函数返回一个指针，该指针根据参数i的不同指向两个已知数组中的某一个： int odd[] = {1, 3, 5, 7, 9}; int even[] = {0, 2, 4, 6, 8}; //返回一个指针，该指针指向含有5个整数的数组 decltype(odd) *arrPtr(int i) { return (i % 2) ? &odd : &even; } arrPtr 使用关键字 decltype 表示它的返回类型是个指针，并且该指针所指的对象与 odd 的类型一致。因为 odd 是数组，所以 arrPtr 返回一个指向含有5个整数的数组的指针。有一个地方需要注意， decltype 并不负责把数组类型转换成对应的指针，所以 decltype 的结果是个数组，要想表示 arrPtr 返回指针还必须在函数声明时加一个 * 符号。 函数重载 顶层 const 顶层 const 不影响传入函数的对象。一个用于顶层 const 的形参无法和一个没有顶层 const 的形参区分开，无法重载： Record lookup(Phone); Record lookup(const Phone); // Record lookup(Phone*); Record lookup(Phone* const); 底层 const 底层 const 可以实现重载。当我们传递一个非常量对象或者指向非常量对象的指针时，编译器会优先选用非常量的版本： Record lookup(Account&); Record lookup(const Account&); // Record lookup(Account*); Record lookup(const Account*); const_cast和重载 //函数1 const string &shorterString(const string &s1, const strinf &s2) { return s1.size() <= s2.size() ? s1 : s2; } //函数2 string &shorterString(string &s1, string &s2) { auto &r = shorterString(const_cast<const string &>(s1), const_cast<const string&>(s2)); return const_cast<string&>(r); } 函数1的参数和返回类型都是 const string 的引用。我们当然可以对两个非常量的 string 实参调用这个函数，但返回的结果仍然是 const string 的引用。 作用域与重载 编译器首先在当前作用域寻找函数，一旦找到，就会忽略掉外层作用域中的同名实体，剩下的工作就是检查函数调用是否有效了。 在C++语言中，名字查找发生在类型检查之前。 特殊用于语言特性 默认实参 一旦一个形参被赋予了默认值，它后面的所有形参都必须有默认值。 在给定的作用域中，一个形参只能被赋予一次默认实参。 局部变量不能作为默认实参。 用作函数实参的名字在函数声明所在的作用域内解析，而这些名字的求值过程发生在函数调用时： sz wd = 80; char def = ''; sz ht(); string screen(sz = ht(), sz = wd, char = def); void f() { def = '*'; //改变默认实参的值 sz wd = 100; //隐藏了外层定义的wd，但是没有改变默认值 window = screen(); //调用 screen(ht(), 80, '*') } 内联函数 以空间换时间。在函数返回类型前面加上关键字 inline 。内联说明只是向编译器发出一个请求，编译器可以选择忽略这个请求。 constexpr 函数 能用于常量表达式的函数。函数的返回类型及所有的形参类型都得是字面值类型。函数体中必须有且只有一条 return 语句。 constexpr int new_sz() { return 42; } constexpr int foo = new_sz(); 编译器在程序编译时验证 new_sz 函数的返回类型。执行初始化任务时，编译器把对 constexpr 函数的调用替换成其结果值。为了能在编译过程中随时展开， constexpr 函数被隐式指定为内联函数。 constexpr 函数体内也可以包含其他语句，只要这些语句在运行时不执行任何操作就行，例如，空语句、类型别名及 using 声明。 constexpr 函数不一定返回常量表达式，当把这类函数用在需要常量表达式的上下文中时，会出错。 把内联函数和 constexpr 函数放在头文件内。 和其它函数不一样，内联函数和 constexpr 函数可以在程序中多次定义，但是多个定义必须完全一致。 调试帮助 assert 预处理宏 所谓预处理宏其实是一个预处理变量，它的行为有点类似于内联函数。 assert 宏使用一个表达式作为它的条件： assert(expr); 首先对 expr 求值，如果表达式为假， assert 输出信息并终止程序的执行。如果表达式为真， assert 什么也不做。 assert 定义在cassert头文件中， assert 宏常用于检查\"不能发生\"的条件。 NDEBUG 预处理变量 assert 的行为依赖于 NDEBUG 预处理变量的状态。如果定义了 NDEBUG ， assert 什么都不做，默认情况下没有定义 NDEBUG ， assert 将执行运行时检查。我们可以使用一个 #define 语句定义 NDEBUG ，从而关闭调试状态。同时，很多编译器都提供了一个命令行选项使我们可以定义预处理变量： $ CC -D NDEBUG main.C #use /D with the Mocrosoft compiler. 除了使用 assert 外，也可以使用 NDEBUG 编写自己的条件调试代码。如果 NDEBUG 未定义，将执行 #ifndef 和 #endif 之间的代码；如果定义了 NDEBUG ，这些代码将被忽略掉。 编译器为每个函数都定义了 __func__ ，它是一个 const char 局部静态数组，用于存放函数的名字，除了 C++ 编译器定义的 __func__ 之外，预处理器还定义了另外4个对于程序调试很有用的名字： __FILE__ 存放文件名的字符串字面值 __LINE__ 存放当前行号的整型字面值 __TIME__ 存放文件编译时间的字符串字面值 __DATE__ 存放文件编译日期的字符串字面值 函数匹配 候选函数：函数匹配的第一步是选定本次调用对应的重载函数集。 可行函数：形参数量与本次提供的实参数量相等（默认形参可以少于）；每个实参的类型与对应的形参相同，或者可以转换成形参的类型。 寻找最佳匹配（如果有的话）：该函数每个实参的匹配都不劣于其他可行函数需要的匹配；至少有一个实参的匹配优于其他可行函数提供的匹配。 如果没找到可行函数：编译器报告无匹配函数的错误；如果最佳匹配不唯一，编译器报告二义性错误。 函数指针 要声明一个函数指针，只需要用指针替换函数名： bool (*pf)(const string &, const string &); //未初始化，pf 两端括号必不可少 当把函数名作为一个值使用时，该函数自动转换为指针，也就是说取地址符是可选的。同样，我们可以直接用函数指针调用函数，解引用符也是可选的。 不同类型的函数指针之前不存在转换规则。 函数指针没有指向任何一个函数：将函数指针赋为0或者 nullptr 。 和数组类似，虽然不能定义函数类型的形参，但是可以定义指向函数的指针。此时，形参看起来是函数，实际上被当成指针使用： //形参是函数类型，会自动转化为指向函数的指针 void test(bool pf(const string &, const string &)); //等价的定义 void test(bool (*pf)(const string &, const string &)); 如果函数返回指向函数的指针，那么必须显示的将返回类型指定为指针。","tags":"读书笔记","url":"https://xutree.github.io/pages/2018/10/09/C++_Primer_Chapter_6/"},{"title":"回车与换行的区别","text":"转载自： 这里 关于换行和回车其实平时我们不太在意，所以关于两者的区别也不太清楚，在平时开发时可能会遇到一些文件处理的问题，放到不同的操作系统上出现各种坑。那么回车和换行到底有哪些区别呢？今天咱们就来总结一下。 由来 在计算机还没有出现之前，有一种叫做电传打字机（Teletype Model 33）的机械打字机，每秒钟可以打10个字符。但是它有一个问题，就是打完一行换行的时候，要用去0.2秒，正好可以打两个字符。要是在这0.2秒里面，又有新的字符传过来，那么这个字符将丢失。 于是，研制人员想了个办法解决这个问题，就是在每行后面加两个表示结束的字符。一个叫做\"回车\"，告诉打字机把打印头定位在左边界，不卷动滚筒；另一个叫做\"换行\"，告诉打字机把滚筒卷一格，不改变水平位置。 这就是\"换行\"和\"回车\"的由来。 使用 后来，计算机发明了，这两个概念也就被般到了计算机上。那时，存储器很贵，一些科学家认为在每行结尾加两个字符太浪费了，加一个就可以。于是，就出现了分歧。 回车 \\r 本义是光标重新回到本行开头，r 的英文 return，控制字符可以写成 CR ，即 Carriage Return。 换行 \\n 本义是光标往下一行（不一定到下一行行首），n 的英文 newline，控制字符可以写成 LF ，即 Line Feed。 符号 ASCII 码 意义 \\n 10 换行 LF \\r 13 回车 CR 在不同的操作系统这几个字符表现不同，比如在 WIN 系统下，这两个字符就是表现的本义，在 UNIX 类系统，换行 \\n 就表现为光标下一行并回到行首，在 MAC 上， \\r 就表现为回到本行开头并往下一行，至于 ENTER 键的定义是与操作系统有关的。通常用的 Enter 是两个加起来。 不同操作系统下的含义： \\n ：UNIX 系统行末结束符 \\n\\r ：window 系统行末结束符 \\r ：MAC OS 系统行末结束符 我们经常遇到的一个问题就是，Unix/Mac 系统下的文件在 Windows 里打开的话，所有文字会变成一行；而 Windows 里的文件在 Unix/Mac 下打开的话，在每行的结尾可能会多出一个 &#94;M 符号。 软回车和硬回车 硬回车就是普通我们按回车产生的，它在换行的同时也起着段落分隔的作用。 软回车是用 Shift + Enter 产生的，它换行，但是并不换段，即前后两段文字在 Word 中属于同一\"段\"。在应用格式时你会体会到这一点。 软回车能使前后两行的行间距大幅度缩小，因为它不是段落标记，要和法定的段落标记——硬回车区别出来。硬回车的 html 代码是 <p>..</p> ，段落的内容就夹在里面，而软回车的代码很精悍： <br> 。网页的文字如果复制到 word 中，则硬回车变为弯曲的箭头，软回车变为向下的箭头。","tags":"趣闻","url":"https://xutree.github.io/pages/2018/10/09/回车与换行的区别/"},{"title":"C++ Primer 第五章 语句","text":"空语句 使用空语句时应该加上注释，从而令读这段代码的知道该语句是有意省略的。 悬垂 else C++ 规定 else 与离它最近的尚未匹配的 if 匹配。 switch 语句 switch 语句中的 case 标签必须是 整型常量表达式 或者 可以转换成整型常量表达式的类型 。 如果某个 case 标签匹配成功，将从该标签处开始往后顺序执行所有 case 分支，除非程序显示的中断了这一过程，否则直到 switch 结尾处才停下来。在大多说情况下，在下一个 case 标签之前应该有一条 break 语句用于中断。 标签不应该孤零零的出现，它后面必须跟上一条语句或者另一个 case 标签。如果 switch 结构以一个空的 default 标签作为结束，则该 default 标签后面必须跟上一条空语句或一个空块。 不允许跨过变量的初始化语句直接跳转到该变量作用域内的另一个位置。 范围 for 在范围 for 语句中，预存了 end() 的值，一旦程序中添加（删除）元素， end 函数的值就可能变得无效，所以不能通过范围 for 语句增加或删除容器的元素。 do while 语句 应该在括号包围起来的条件后面用一个分号表示语句结束。 跳转语句 break 语句 break 语句负责终止离它最近的 while 、 do while 、 for 或 switch 语句，并从这些语句之后的第一条语句开始继续执行。 break 语句只能出现在迭代语句或者 switch 语句内部（包括嵌套在此类循环里的语句或块的内部）。 break 语句的作用范围仅限于最近的循环或者 switch 。 continue 语句 continu e语句终止最近的循环中的当前迭代并立即开始下一次迭代。 continue 语句只能出现在 for 、 while 和 do while 的循环的内部，或者嵌套在此类循环里的语句或块的内部。 和 break 语句类似的是，出现在嵌套循环中的 continue 语句也仅作用于离它最近的循环。 和 break 语句不同的是，只有当 switch 语句嵌套在迭代语句内部时，才能在 switch 里使用 continue 。 goto 语句 goto 语句的作用是从 goto 语句无条件跳转到同一函数内的另一条语句。 goto 语句和控制权转向的那条带标签的语句必须位于同一函数之内。 异常处理 throw 表达式 异常检测部分使用 throw 表达式来表示它遇到了无法处理的问题。我们说 throw 引发了异常，例如： throw runtime_error(\"Data must refer to same ISBN\"); try 语句块 异常处理部分使用 try 语句处理异常。 try 语句块以关键字 try 开始，并以一个或多个 catch 字句结束。 try 语句块中代码抛出的异常通常会被某个catch字句处理，这些字句称为异常处理代码。 try{ program-statements } catch (exception-declaration) { handler-statements } catch (exception-declaration) { handler-statements } 跟在 try 块之后的是一个或多个 catch 子句。 catch 子句包括三个部分： 关键字 catch 括号内一个（可能未命名的）对象的声明（称作异常声明） 一个块 try 语句块中 program-statements 组成程序的正常逻辑，像其他任何块一样，可以有包含声明在内的任意 C++ 语句。 try 语句块内声明的变量在块外部无法访问，特别是在 catch子 句内也无法访问。 函数在寻找代码处理的过程中退出，如果最终没能找到任何匹配的 catch 子句，程序转到名为 terminate 的标准库函数。该函数的行为与系统有关，一般情况下，执行该函数将导致程序非正常退出。 标准异常 C++ 标准库定义了一组类，用于报告标准库函数遇到的问题，这些异常类也可以在用户别写的程序中使用，它们分别定义在4个头文件中： exception 头文件 定义了最通用的异常类 exception 。它只报告异常的发生，不提供任何异常信息 stdexcept 头文件定义了几种常见的异常类 异常类 解释 exception 最常见的问题 runtime_error 只有在运行时才能检测出的问题 range_error 运行时错误：生成的结果超出了有意义的值域范围 overflow_error 运行时错误：计算上溢 underflow_error 运行时错误：计算下溢 logic_error 程序逻辑错误 domain_error 逻辑错误：参数对应的结果值不存在 invalid_argument 逻辑错误：无效参数 length_error 逻辑错误：试图创建一个超出该类型最大长度的对象 out_of_range 逻辑错误：使用一个超出有效范围的值 new 头文件 定义了 bad_alloc 异常类型 type_info 头文件 定义了 bad_cast 异常类型 标准异常库只定义了几种运算，包括创建和拷贝异常类型的对象，以及为异常类型的对象赋值。我们只能以默认初始化的方式初始化 exception 、 bad_alloc 和 bad_cas t对象，不允许为这些对象提供初始值。 其他异常类型的行为则刚好相反。应该使用 string 对象或者 C 风格字符串初始化这些类型的对象，但是不允许使用默认初始化的方式。当创建此类对象时，必须提供初始值，该初始值含有错误相关的信息。 异常类型只定义了一个名为 what 的成员函数，该函数没有任何参数，返回值是一个指向 C 风格字符串的 const char * 。该字符串的目的是提供关于异常的一些文本信息。 what 函数返回的 C 风格字符串的内容与异常对象的类型有关。如果异常类型只有一个字符串初始值，则 what 返回该字符串。对于其他无初始值的异常类型来说， what 返回的内容由编译器决定。","tags":"读书笔记","url":"https://xutree.github.io/pages/2018/10/09/C++_Primer_Chapter_5/"},{"title":"几个奇葩的 Linux 命令","text":"Linux 中有一些很奇葩的命令，可能你的发行版默认没有安装，你可以自己安装： [me@linuxbox ~]$ apt-get install 命令 (Debian) [me@linuxbox ~]$ yum install 命令 (Red Hat） [me@linuxbox ~]$ brew install 命令 （Mac） rev rev 命令反转输入的内容（来自文件或者标准输入或者管道）： [me@linuxbox ~]$ echo Hello, World! | rev !dlroW ,olleH tac cat 命令的反写，执行效果也和 cat 相反，即，将文件列表中的每一个文件输出到标准输出，行号大的优先。 sl 你可能知道命令 ls ,并经常使用它来查看文件夹的内容。但是由于错误输入有时会导致 sl ，如何在终端获得一点乐趣而不是\"command not found\"？ sl 命令！ 当你把 ls 错误打成 sl 时，一辆蒸汽机车（ s team l ocomotive）会在屏幕上驶过... yes yes命令将进入一个循环，一遍又一遍地重复相同的字符串。默认重复\"y\"，你可以指定其他字符串。 [me@linuxbox ~]$ yes \"这是一个测试\" 这是一个测试 这是一个测试 这是一个测试 这是一个测试 这是一个测试 这是一个测试 这是一个测试 利用 Ctrl C 终止。 cowsay 屏幕上会出现一只 ASCII 码拼成的奶牛。。。你可以指定奶牛要说的话。这个命令还有其他版本，如 xcowsay ， cowthink 。 figlet 这个算不上奇葩，他它利用 ASCII 码拼成你输出\b字符串的横幅，而且有许多参数可以定制。还有个 toilet 命令和 figlet 很类似。比如， figlet good ： fortune 会显示你的未来（ 😆 )。可以试试： [me@linuxbox ~]$ fortune | cowsay cmatrix 会像《黑客帝国》里那样显示\b。 Fork 炸弹 [me@linuxbox ~]$ :(){ :|:& }: 不要尝试不要尝试不要尝试... asciiquarium 水族馆 lolcat lolcat 可以在终端产生彩虹。 lolcat 是一个 RubyGem 因此它必须有你的系统上安装了 Ruby 的最新版本。利用文章开头部分的方法安装好 lolcat 后，在终端执行 gem install lolcat 安装。 [me@linuxbox ~]$ git log -1 | cowsay -f dragon-and-cow | lolcat lolcat 接受管道输入，所以你可以试试： [me@linuxbox ~]$ sl | lolcat","tags":"趣闻","url":"https://xutree.github.io/pages/2018/10/08/几个奇葩的Linux命令/"},{"title":"Linux 中的扩展和引用","text":"扩展 当我们每次在命令行按下 Enter 键时，bash 会在执行命令之前对文本进行多重处理。产生这个结果的处理过程称为扩展（expansion）。 一个 🌰 : echo * 会将当前目录下所有的非隐藏文件名打印出来。 单词分隔 单词分隔会先查找是否存在空格、制表符以及换行，然后把它们作为单词的界定符（delimiter）。所以下面的命令后面跟着4个不同的参数： [me@linuxbox ~]$ echo this is a test this is a test 路径名扩展 通过使用通配符来实现扩展的\b机制称为路径名扩展（pathname expansion）。 波浪线扩展（~） 如果把它用在一个单词的开头，那么它将被扩展为指定用户的主目录名；如果没有指定用户名，则扩展为当前用户的主目录： [me@linuxbox ~]$ ech ~ /home/me [me@linuxbox ~]$ ech ~foo /home/foo 算术扩展 shell 支持通过扩展来运行算术表达式。这允许我们把 shell 提示符当做计算器来使用： [me@linuxbox ~]$ echo $((2+2)) 4 算术扩展使用形式： $((expression)) ，其中 expression 是包含数\b值和算术操作符的算术表达式。算术扩展 只支持整数 。 运算符 运算符 描述 + 加 - 减 * 乘 / 除（结果为整数） % 取余 ** 取幂 空格在算术表达式中无意义，表达式可以嵌套： [me@linuxbox ~]$ echo $(($((5**2)) * 3)) 75 还可以使用\b一对括号来组合多个子表达式： [me@linuxbox ~]$ echo $(((5**2) * 3)) 75 数字进制 符号 描述 number 默认情况下，number 没有任何符号，将作为十进制数字 0number 在数字表达式中，以0开始的数字被视为八进制数字 0xnumber 十六进制数 base#number base 进制的 number 🌰 ： [me@linuxbox ~]$ echo $((0xff)) 255 [me@linuxbox ~]$ echo $((3#11)) 4 花括号扩展 花括号扩展可以用于创建多种文本字符串，例如 [me@linuxbox ~]$ echo Front-{A,B,C}-Back Front-A-Back Front-B-Back Front-C-Back 用于花括号扩展的模式信息可以包含一个称为 前导字符 的开头部分和一个称为 附言 的结尾部分。花括号表达式本身可以包含一些列逗号分隔的字符串，也可以包含一系列整数或者单个字符。 模式信息不能包含内嵌的\b空白。 花括号扩展最普遍的应用是创建一系列的文件或者目录： [me@linuxbox ~]$ mkdir {2009..2011}-0{1..9} {2009..2010}-{10..12} 参数扩展 shell 提供了多种参数扩展的形式。 基本参数 参数扩展的最简单形式体现在平时对变量的使用中。举例来说， $a 扩展后成为变量 a 所包含的内容，无论 a 包含什么。 简单参数可以被括号包围，如 ${a} ，当变量相邻与其他文本时，必须使用括号，否则可能让 shell 混淆。 [me@linuxbox ~]$ a=\"foo\" [me@linuxbox ~]$ echo \" $a_file \" [me@linuxbox ~]$ echo \" ${ a } _file\" foo_file 因为不存在 a_file 变量，所以 shell 输出空。 同样，对于大于9的位置参数可以通过给相应数字加上括号来访问，例如访问第11个位置参数： ${11} 空变量扩展的管理 有的参数扩展用于处理不存在的变量和空变量。这些参数扩展在处理缺失的位置参数和给参数赋默认值时很有用。 ${parameter:-word} ：如果 parameter 未被设定或者是空参数，则其扩展为 word 的值。如果\b parameter 非空，则扩展为 parameter 的值。 [ me@linuxbox ~ ] $ foo = [ me@linuxbox ~ ] $ echo $ { foo : - \"substitute value if unset\" } substitute value if unset [ me@linuxbox ~ ] $ echo $ foo [ me@linuxbox ~ ] $ foo = bar [ me@linuxbox ~ ] $ echo $ { foo : - \"substitute value if unset\" } bar [ me@linuxbox ~ ] $ echo $ foo bar ${parameter:=word} ：如果 parameter 未被设定或者是空参数，则其扩展为 word 的值；此外，word 的值也将赋给 parameter。如果\b parameter 非空，则扩展为 parameter 的值。注意：位置参数和其他特殊参数不能以这种方式赋值。 [ me@linuxbox ~ ] $ foo = [ me@linuxbox ~ ] $ echo $ { foo : = \"deafult value if unset\" } deafult value if unset [ me@linuxbox ~ ] $ echo $ foo deafult value if unset [ me@linuxbox ~ ] $ foo = bar [ me@linuxbox ~ ] $ echo $ { foo : - \"deafult value if unset\" } bar [ me@linuxbox ~ ] $ echo $ foo bar ${parameter:？word} ：如果 parameter 未被设定或者是空参数，这样扩展会致使脚本\b出错而退出，并且 word 的内容输出到标准错误。如果 parameter 非空，则扩展为 parameter 的值。 [me@linuxbox ~]$ foo= [me@linuxbox ~]$ echo ${ foo : ? \"parameter is empty\" } bash: foo: parameter is empty [me@linuxbox ~]$ echo $? 1 [me@linuxbox ~]$ foo=bar [me@linuxbox ~]$ echo ${ foo : ? \"parameter is empty\" } bar [me@linuxbox ~]$ echo $? 0 ${parameter:+word} ：如果 parameter 未被设定或者是空参数，则不产生任何扩展。若 parameter 非空，word 的值将取代 parameter 的值产生扩展；然而，parameter 的值并不发生变化。 [me@linuxbox ~]$ foo= [me@linuxbox ~]$ echo ${ foo : + \"substitute value if unset\" } [me@linuxbox ~]$ foo=bar [me@linuxbox ~]$ echo ${ foo : + \"substitute value if unset\" } substitute value if unset [me@linuxbox ~]$ echo $foo bar 返回变量名的扩展 shell 具有返回变量名的扩展。这种功能在相当特殊的情况下才会使用。 ${ ! prefix * } ${ ! prefix @ } 该扩展返回当前以 prefix 开通的变量名。根据 bash 文档，这两种形式的扩展形式执行的效果一模一样。 字符串操作 ${#parameter} ：扩展为 parameter 内包含的字符串的长度。如果 parameter 是 \"@\" 或 \"*\"，那么扩展的结果就是位置参数的个数。 [me@linuxbox ~]$ foo=\"This string is long.\" [me@linuxbox ~]$ echo \"' $foo ' is ${ #foo } characters long.\" 'This string is long.' is 20 characters long. {parameter:offset} 和 {parameter:offset:length} ：这个扩展提取一部分字符串。扩展以 offset 字符开始，直到字符串末尾，除非 length 特别指定它。 [me@linuxbox ~]$ foo=\"This string is long.\" [me@linuxbox ~]$ echo ${ foo : 5 } string is long. [me@linuxbox ~]$ echo ${ foo : 5 : 6 } string 如果 offset 为负，默认表示从字符串末尾开始。 注意，负值前必须有一个空格 ，以防和 ${parameter:-word} 扩展混淆。length 不能小于0。 [me@linuxbox ~]$ foo=\"This string is long.\" [me@linuxbox ~]$ echo ${ foo : - 5 } long. [me@linuxbox ~]$ echo ${ foo : - 5 : 2 } lo 如果参数是 \"@\"，扩展的结果则是从 offset 开始，length 为位置参数。 ${parameter#pattern} 和 ${parameter##pattern} ：pattern 是一个通配符模式，\"#\" 去除最短匹配，\"##\" 去除最长匹配。 [me@linuxbox ~]$ foo=file.txt.zip [me@linuxbox ~]$ echo ${ foo #*. } txt.zip [me@linuxbox ~]$ echo ${ foo ##*. } zip ${parameter%pattern} 和 ${parameter%%pattern} ：从尾部去除。pattern 是一个通配符模式，\"%\" 去除最短匹配，\"%%\" 去除最长匹配。 [me@linuxbox ~]$ foo=file.txt.zip [me@linuxbox ~]$ echo ${ foo %*. } file.txt [me@linuxbox ~]$ echo ${ foo %%*. } file ${parameter/pattern/string} ：查找替换，只替换第一个出现的 ${parameter//pattern/string} ：替换所有的 ${parameter/#pattern/string} ：要求匹配出现在字符串开头 ${parameter/%pattern/string} ：要求匹配出现在字符串末尾 /string 可以省略，此时匹配到的字符被删除 [me@linuxbox ~]$ foo=JPG.JPG [me@linuxbox ~]$ echo ${ foo / JPG / jpg } jpg.JPG [me@linuxbox ~]$ echo ${ foo // JPG / jpg } jpg.jpg [me@linuxbox ~]$ echo ${ foo / #JPG/jpg } jpg.JPG [me@linuxbox ~]$ echo ${ foo /% JPG / jpg } JPG.jpg 命令替换 命令替换可以把一个命令的输出作为一个扩展模式使用： [me@linuxbox ~]$ ls -l $(which cp) -rwxr-xr-x 1 root wheel 29008 10 26 2017 /bin/cp 在早期的 shell 程序中，存在命令替换的另一种语法，bash 也支持这种格式。它用反引号代替美元符号和括号： [me@linuxbox ~]$ ls -l `which cp` -rwxr-xr-x 1 root wheel 29008 10 26 2017 /bin/cp 引用 引用主要用于控制扩展。 双引号 如果把文本放在双引号中，那么 shell 使用的所有特殊字符都被看成普通字符，除了 \"$（美元符号）\"，\"\\（反斜杠）\"，\"`（反引号）\" 除外。 单词分隔、路径名扩展、波浪线扩展、花括号扩展都失效。 参数扩展、算术扩展、命令替换仍然有效。 使用双引号可以阻止单词分隔，这可以用来处理包含空白的文件名。 单引号 抑制所有扩展。 转义字符 转义字符通常用在双引号中用来有选择性的阻止扩展。 关于反斜杠转义字符（backslash escape sequence） 反斜杠除了作为转义字符外，也是一种表示法的一部分。ASCII 码表的前32个字符用来向电传打字类设备传送命令。 转义字符 含义 \\a 响铃（警告声——计算机发出哔哔声） \\b 退格 \\n 新的一行（在类 UNIX 系统中，产生的是换行效果 \\r 回车 \\t 制表 在 echo 命令中带上 -e 选项，就能够解释转义字符序列，也可以将其放在 \"$''\"中。下面的例子，实现一个简单的倒计时计时器： [me@linuxbox ~]$ sleep 10; echo -e \"Time's up\\a\" 也可以这样做： [me@linuxbox ~]$ sleep 10; echo -e \"Time's up\" $'\\a'","tags":"教程","url":"https://xutree.github.io/pages/2018/10/08/linux中的扩展和引用/"},{"title":"CSS 入门","text":"什么是 CSS CSS（ C ascading S tyle S heets），即层叠样式表。 层叠是指 CSS 将一种样式应用于另一种样式的方式。样式表控制 Web 文档的外观。 为什么使用 CSS CSS 允许你将特定样式应用于特定 HTML 元素 CSS 的主要好处是它允许您将样式与内容分开 仅使用 HTML，所有样式和格式都在同一个地方，随着页面的增长，这变得相当难以维护 CSS 三种形式 内联 CSS：inline CSS 使用内联样式是插入样式表的方法之一。 使用内联样式，将独特的样式应用于单个元素。 要使用内联样式，请将style属性添加到相关标记。 <p style= \"color:white; background-color:gray;\" > This is an example of inline styling. </p> 嵌入式/内部 CSS：Embedded/Internal CSS 内部样式在 HTML 页面的 head 部分内的 <style> 元素中定义。 <html> <head> <style> p { color:white; background-color:gray; } </style> </head> <body> <p> This is my first paragraph. </p> <p> This is my second paragraph. </p> </body> </html> 外部 CSS：External CSS 使用此方法，所有样式规则都包含在单个文本文件中，该文件以 .css 扩展名保存。 然后使用 <link> 标记在 HTML 中引用此 CSS 文件。 <link> 元素位于 head 部分内部。 <head> <link rel= \"stylesheet\" href= \"example.css\" > </head> <body> <p> This is my first paragraph. </p> <p> This is my second paragraph. </p> <p> This is my third paragraph. </p> </body> CSS 语法 CSS 由浏览器解释的样式规则组成，然后应用于文档中的相应元素。样式规则有三个部分： selector ， property 和 value 。 例如，标题颜色可以定义为： h1 { color: orange; } 选择器指向要设置样式的HTML元素。声明块包含一个或多个声明，以分号分隔。每个声明都包含一个属性名称和一个以冒号分隔的值。CSS 声明始终以分号结尾，声明组由大括号括起。 类型选择器 最常见且易于理解的选择器是类型选择器。 此选择器针对页面上的元素类型。 例如，要定位页面上的所有段落： p { color : red ; font-size : 130 % ; } id 和 clss 选择器 id 选择器允许您设置具有 id 属性的 HTML 元素的样式，而不管它们在文档树中的位置如何。 以下是 id 选择器的示例： HTML 文件： <div id= \"intro\" > <p> This paragraph is in the intro section. </p> </div> <p> This paragraph is not in the intro section. </p> CSS 文件: # intro { color : white ; background-color : gray ; } 要选择具有特定 id 的元素，请使用井号 # 字符，然后使用元素的 id 跟随它。 类选择器以类似的方式工作。 主要区别在于 id 每页只能应用一次，而类可以根据需要在页面上多次使用。 在下面的示例中，具有\"first\"类的两个段落都将受到 CSS 的影响： HTML 文件： <div> <p class= \"first\" > This is a paragraph </p> <p> This is the second paragraph. </p> </div> <p class= \"first\" > This is not in the intro section </p> <p> The second paragraph is not in the intro section. </p> CSS 文件： .first { font-size : 200 % ;} 要选择具有特定类的元素，请使用句点 . 字符，后跟类的名称。不要用数字开始一个类或 id 名称。 后代选择器 这些选择器用于选择作为另一个元素的后代的元素。 选择级别时，您可以根据需要选择多个级别。 例如，要仅定位\"intro\"部分第一段中的 <em> 元素： HTML 文件： <div id= \"intro\" > <p class= \"first\" > This is a <em> paragraph. </em></p> <p> This is the second paragraph. </p> </div> <p class= \"first\" > This is not in the intro section. </p> <p> The second paragraph is not in the intro section. </p> CSS 文件： # intro . first em { color : pink ; background-color : gray ; } 后代选择器匹配作为指定元素后代的所有元素。 注释 注释用于解释你的代码，浏览器会忽略。 /* Comment goes here */ 层叠 网页的最终外观是不同样式规则的结果。形成层叠的三种主要风格来源是： 页面作者创建的样式表 浏览器的默认样式 用户指定的样式 继承是指属性在页面中流动的方式。 除非另有定义，否则子元素通常会采用父元素的特征。","tags":"教程","url":"https://xutree.github.io/pages/2018/10/07/css_overview/"},{"title":"C++ Primer 第四章 表达式","text":"重载运算符时，其包括运算对象的类型和返回值的类型，都是由该运算符定义的；但是运算对象的个数、运算符的优先级和结合律都是无法改变的。 左值和右值 当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。 一个重要的原则：在需要右值的地方可以用左值来代替，但是不能把右值当成左值（也就是位置）使用。当一个左值被当成右值使用时，实际使用的是它的内容（值）。 要用到左值的运算符： 赋值运算符需要一个左值作为其左侧运算对象，得到的结果也仍然是一个左值 取地址符作用于一个左值运算对象，返回一个指向该运算对象的指针，这个指针是一个右值 内置解引用运算符、下标运算符、迭代器解引用运算符、 string 和 vector 的下标运算符的求值结果都是左值 内置类型和迭代器的递增递减运算符作用于左值运算对象 求值顺序 优先级规定了运算对象的组合方式，但是没有说明运算对象按照什么顺序求值。对于那些没有指定执行顺序的运算符来说，如果表达式指向并修改了同一个对象，将会引发错误并产生未定义的行为。 例如，下面的输出表达式是未定义的，我们无法推测编译器是先求 ++i 还是先输出： int i = 0; cout << i << \" \" << ++i << endl; //未定义的 有4种运算符明确规定了运算对象的求值顺序。&&、||、?:、和逗号（，）运算符。 对于f()+g()*h()+j()的表达式： 优先级规定，g() 的返回值和 h() 的返回值相乘 结合律规定，f() 的返回值先与 g() 和 h() 的乘积相加，所得结果再与 j() 的返回值相加 对于这些函数的调用顺序没有明确规定 如果 f、g、h 和 j 是无关函数，它们既不会改变同一对象的状态也不执行 IO 任务，那么函数的调用顺序不受限制。反之，如果其中某几个函数影响同一对象，则它是一条错误的表达式，将产生未定义的行为 算术运算符 +(正号)、-(负号)、*(乘)、/(除),%(求余)，+(加)、-(减) 算术运算符的运算对象和求值结果都是右值。 一元正号负号运算符对运算对象作用后，返回一个（提升后的）副本： int i = 1024; int k = -i; bool b = true; bool b2 = -b; //b2 是 true 对大多数运算符来说，布尔类型的运算对象将被提升为 int 类型。如上，b 参与运算时被提升成整数值1，对它求负-1，转换为布尔值将其作为 b2 的初始值。 在除法运算中，如果两个运算对象的符号相同则商为正，否则商为负。C++ 语言的早期版本允许结果为负值的商向上或向下取整，C++11 新标准则规定商一律向0取整（即直接切除小数部分）。 逻辑和关系运算符 运算对象和求值结果都是右值；短路求值；进行比较运算符时，除非比较的对象是布尔类型，否则不要使用布尔字面值 true 和 false 作为运算对象 赋值运算符 赋值运算符的左侧运算对象必须是一个可修改的左值 赋值运算的结果是它的左侧运算对象，并且是一个左值，结果的类型就是左侧运算对象的类型 如果赋值运算符的左右两个运算对象类型不同，则右侧运算对象将转换成左侧运算对象的类型 赋值运算满足右结合律：ival = jval = 0； ++ 和 -- 运算符 前置版本将对象本身作为左值返回，后置版本则将对象原始值的副本作为右值返回 建议：除非必须，否则不用递增递减算符的后置版本 后置递增运算符的优先级高于解引用运算符，因此 *pbeg++ 等价于 *(pbeg++)，pbeg++ 把 pbeg 的值加1，然后返回 pbeg 的初始值的副本作为其求值结果 成员访问运算符 由于解引用运算符的优先级低于逗号运算符，因此要对解引用运算符加括号 箭头运算符作用于一个指针类型的运算对象，结果是一个左值 点运算符分成两种情况：如果成员所属的对象是左值，那么结果就是左值；反之，如果成员所属的对象是右值，那么结果是右值 条件运算符 当条件运算符的两个表达式都是左值或者能转换成同一种左值类型时，运算的结果是左值；否则运算的结果是右值 条件运算符满足右结合律 位运算符 位运算符作用于整数类型的运算对象 关于符号位如何处理没有明确的规定，所以强烈建议仅将位运算符作用于处理无符号类型 移位运算符 首先令左侧运算对象的内容按照右侧运算对象的要求移动指定位数，然后将经过移动的（可能还进行了提升）左侧运算对象的拷贝作为求值结果。其中，右侧的运算对象一定不能为负，而且值必须严格小于结果的位数，否则就会产生未定义的行为。移出边界之外的位就被舍弃掉了 移位运算符满足左结合律 移位运算符的优先级比算术运算符低，比关系运算符、赋值运算符和条件运算符高 sizeof运算符 sizeof 运算符返回一条表达式或一个类型名字所占的字节数。 sizeof 运算符满足右结合律，其所得的值是一个 size_t 类型的常量表达式 两种形式 sizeof (type) sizeof expr sizeof 并不直接计算其运算对象的值。 对于 sizeof *p ： 因为 sizeof 满足右结合律并且与 * 的运算符的优先级一样，所以表达式按照从右到左的顺序结合，等价于： sizeof (*p) 其次，因为 sizeof 不实际求运算对象的值，所以即使 p 是一个无效（即未初始化）的指针也不会有什么影响 在 sizeof 的运算对象中解引用一个无效的指针仍然是一种安全的行为，因为指针实际上并没有被真正使用 sizeof 运算符的结果部分地依赖于其作用的类型： 对 char 或者类型为 char 的表达式执行 sizeof 运算，结果得1 对引用类型执行 sizeof 运算得到被引用对象所占空间的大小 对指针执行 sizeof 运算得到指针本身所占空间的大小 对解引用指针执行 sizeof 运算得到指针指向的对象所占空间的大小，指针不需有效 对数值执行 sizeof 运算符得到整个数组所占空间的大小。 sizeof 运算不会把数组转换成指针来处理 对 string 对象或者 vector 对象执行 sizeof 运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。即只取决于里面存放的数据类型，与元素的个数无关，是个编译器相关的值 逗号运算符 首先对左侧的表达式求值，然后将求值结果丢弃掉。逗号表达式真正的结果是右侧表达式的值。如果右侧运算对象是左值，那么最终的求值结果也是左值。 类型转换 何时发生隐式类型转换 在大多数表达式中，比 int 类型小的整数值首先提升为较大的整数类型 在条件中，非布尔值转换成布尔类型 初始化过程中，初始值转换成变量的类型；在赋值语句中，右侧运算对象装换成左侧运算对象的类型 如果算术运算或关系运算的运算对象有多种类型，需要转换成同一种类型 函数调用时也会发生类型转换 数组转换成指针（当数组被用作 decltype 关键字的参数，或者作为取地址符、 sizeof 即 typeid 等运算符的运算对象时，上述转换不会发生，如果用一个引用来初始化数组，上述转换也不会发生） 指针的转换 常量整数值0或者字面值 nullptr 能转换成任意指针类型 指向任意非常量的指针能转换成 void * 指向任意对象的指针能转换成 const void * 转换成常量：允许将指向非常量类型的指针转换成指向相应的常量类型的指针，对于引用也是这样。相反的转换并不存在，因为它试图删掉底层 const 类类型定义的转换 类类型能定义由编译器自动执行的转换，不过编译器每次只能执行一种类类型的转换，如果同时提出多个转换请求，这些请求将被拒绝 之前遇到过的类类型转换 string s, t = \"a value\"; //字符串字面值转换成 string 类型 wile( cin >> s) //while 的条件部分把 cin 转换成布尔值 显示转换 虽然有时不得不使用强制类型转换，但这种方法本质上是非常危险的。 命名的强制类型转换 一个命名的强制类型转换具有如下格式： cast-name<type>(expression); type 是转换的目标类型。如果 type 是引用类型，则结果是左值；expression 是要转换的值；cast-name 是 static_cast 、 dynamic_cast 、 const_cast 和 reinterpret_cast 中的一种。 dynamic_cast 支持运行时类型识别。 static_cast 任何具有明确定义的类型转换，只要不包含底层 const ，都可以使用 static_cast 。当需要把一个较大的算术类型赋给较小的类型时， static_cast 非常有用。此时，强制类型转换告诉程序的读者和编译器：我们知道并且不在乎潜在的精度损失。 static_cast 对于编译器无法自动执行的类型转换也非常有用。例如，我们可以使用它找回 void * 指针中的值: void *p = &d; double *dp = static_cast<double *>(p); const_cast const_cast 只能改变运算对象的底层 const : const char *pc; char *p = const_cast<char*>(pc);//正确，但通过p写值是未定义的行为 只有 const_cast 能改变表达式的常量属性。 reinterpret_cast einterpret_cast 通常为运算对象的位模式提供较低层次上的重新解释。 假如有以下转换： int *ip; char *pc = reinterpret_cast<char*>(ip); 我们必须牢记 pc 所指的真实对象是一个 int 而非字符，如果把 pc 当成普通的字符指针使用就可能在运行时发生错误。 string str(pc); //可能导致异常的运行时行为 reinterpret_cast 本质上依赖于机器。要想安全地使用 reinterpret_cast 必须对涉及的类型和编译器实现转换的过程都非常了解。 强制类型转换干扰了正常的类型检查，因此强烈建议避免使用强制类型转换。 旧式的强制类型转换 在早期版本的 C++ 语言中，显示地进行强制类型转换包含两种形式： type (expr); //函数形式的强制类型转换 (type) expr; //C 语言风格的强制类型转换 根据所设计的类型不同，旧式的强制类型转换分别具有与 const_cast ， static_cast 或 reinterpret_cast 相似的行为。当我们在某处执行旧式的强制类型转换时，如果换成 const_cast 和 static_cast 也合法，则其行为与相应的命名转换一致。如果替换后不合法，则旧式强制类型转换执行与 reinterpret_cast 类似的功能。 char *pc = (char*) ip; //ip是指向整数的指针 上述代码的效果与 reinterpret_cast 一样。","tags":"读书笔记","url":"https://xutree.github.io/pages/2018/10/07/C++_Primer_Chapter_4/"},{"title":"C++ Primer 第三章 字符串、向量和数组","text":"string 表示可变长的字符数组。 vector 存放的是某种给定类型对象的可变长序列。 数组和其他内置类型一样，实现与硬件密切相关，在灵活性上稍显不足。 命名空间 using 声明： using namespace::name; 例如： using std::cin; 。 头文件不应包含 using 声明，防止名字冲突。 标准库类型 string 头文件和声明 #include <string> using std :: string ; 定义和初始化 string s1; //默认初始化，空字符串 string s2 = s1; //s2是s1的副本，等价于 s2(s1) string s3 = \"hiya\"; //s3是字符串字面值的副本，等价于s3(\"hiya\") string s4(10, 'c'); //s4的内容是cccccccccc string 对象上的操作 操作 意义 os << s 将 s 写到输出流 os 中，返回 os is >> s 从 is 中读取字符串赋给 s，字符串以空白分隔，返回 is getline(is, s) 从 is 中读取一行赋给 s，返回 is s.empty() s 为空返回 true，否则返回 false s.size() 返回 s 中字符的个数 s[n] 返回 s 中第 n 个字符的引用，位置 n 从0记起 s1 + s2 返回连接后的结果 s1 = s2 用 s2 的副本代替 s1 s1 == s2 如果 s1 和 s2 中所含的字符完全一样，则他们相等 s1 != s2 string 对象的相等性判断对大小写敏感 <, <=, >, >= 利用字符在字典里的顺序进行比较，大小写敏感 读取未知数量的 string 对象 int main() { string word; while (cin >> word) cout << word << endl; return 0; } 直到遇到结束标记或者非法输入才会停止 使用 getline 读取一整行 int main() { string line; while (getline(cin,line)) cout << line << endl; return 0; } getline 函数的参数是一个输入流和一个 string 对象， getline 从给定的输入流中读入内容，直到遇到换行符为止（注意换行符也被读进来了），然后把所读的内容存入 string 对象中（注意不存换行符）。如果输入一开始就是换行符，那么所得的结果是个空 string 。 string::size_type 类型 是一个无符号类型的值。如果一个表达式中已经有 size 函数就不要再使用 int 了，这样可以避免混用 int 和 unsigned 可能带来的问题。 string 对象可以和字符字符串字面值相加，只要保证 + 号两侧的运算对象至少有一个 string 对象即可。 由于某些历史原因，也为了和 C 兼容，所以 C++ 中的字符串字面值并不是标准库 string 类型。 处理 string 对象里的字符 包含在 cctype 头文件中： 函数 意义 isalunm(c) 当 c 是字母或数字时为真 isalpha(c) 当 c 是字母时为真 iscntrl(c) 当 c 是控制字符时为真 isdigit(c) 当 c 是数字时为真 isgraph(c) 当 c 不是空格但可打印时为真 islower(c) 当 c 是小写字母时为真 isprint(c) 当 c 是可打印字符时为真（即 c 是空格或 c 具有可视形式） ispunct(c) 当 c 是标点符号时为真（即 c 不是控制字符、数字、字母、可打印空白中的一种） isspace(c) 当 c 是空白时为真（即 c 是空格、横向制表符、纵向制表符、回车符、换行符、进纸符中的一种） isupper(c) 当 c 是大写字母时为真 isxdigit(c) 当 c 是十六进制数字时为真 tolower(c) 输出 c 的小写 toupper(c) 输出 c 的大写 C++ 标准库除了定义 C++ 语言特有的功能外，也兼容了 C 语言的标准库。C 语言的头文件形如 name.h，C++ 则将这些文件命名为 cname。因此 cctype 头文件和 ctype.h 头文件的内容是一样的，只不过从命名规范上来讲更符合 C++ 语言的要求。特别地，在名为 cname 的头文件中定义的名字从属于命名空间 std 。 范围 for for (declaration: expression) statement expression 是一个对象，用于表示一个序列；declaration 负责定义一个变量，该变量将被用于访问序列中的基础元素，每次迭代，declaration 部分的变量会被初始化为 expression 部分的下一个元素值。 使用范围for输出 string str(\"some string\"); for (auto c : str) cout << c << endl; 使用范围for修改 string s(\"Hello World!\"); for (auto &c : s) c = toupper(c); cout << s << endl; 下标运算符 [ ] [ ]接收的输入参数是 string:size_type 类型的值，这个参数表示要访问的字符的位置，返回值是该位置上字符的引用。 string 对象的下标必须大于等于0而小于 s.size() 。 标准库类型 vector vector 表示对象的集合，其中所有对象的类型都相同，也常被称作容器，是一种类模板 #include <vector> using std :: vector ; 编译器根据模板创建类或函数的过程称为实例化，对于类模板，我们通过提供一些额外信息来指定模板到底实例化成什么样的类：在模板名字后面跟一对尖括号，在括号内放上信息 vector<int> ivec; vector<Sales_item> Sales_vec; vector<vector<string>> file; 在早期版本的 C++ 标准中如果 vector 的元素还是 vector （或者其他模板类型），则其定义的形式与现在的 C++11 新标准略有不同。过去，必须在外层 vector 对象的右尖括号和其元素类型之间添加一个空格，如应写成 vector<vector<int> > 初始化 默认初始化。 列表初始化。 值初始化：通常情况下，可以只提供vector对象容纳的元素数量而略去初始值。此时库会创建一个值初始化的元素初值，并把它赋给容器中的所有元素。这个初值由vector对象中元素的类型决定。内置类型：0；类类型：由类默认初始化。 添加元素 push_back ：负责把一个值当成 vector 对象的尾元素压到 vector 对象的尾端 vector<int> v2; for (int i = 0; i != 100; ++i) v2.push_back(i); 如果循环内部包含有向 vector 对象添加元素的语句，则不能使用范围 for 循环。 其他vector操作 函数 含义 v.empty() 如果 v 不含有任何元素，返回真；否则返回假 v.size() 返回 v 中元素的个数 v.push_back(t) 向 v 的尾端添加一个值为 t 的元素 v[n] 返回 v 中第 n 个位置上元素的引用 v1 = v2 用 v2 中的元素拷贝替换 v1 中的元素 v1 = 用列表中元素的拷贝替换 v1 中的元素 v1 == v2 v1 和 v2 相等当且仅当它们的元素数量相同且对应位置的元素值都相同 v1 != v2 <,<=,>,>= 以字典顺序进行比较 vector 的 size_type vector<int>::size_type //正确 vector::size_type //错误 和 string 一样， vector 对象的下标也是从0开始计算， vector 对象（以及 string 对象）的下标运算符可用于访问已存在的元素，而不能用于添加元素。 迭代器 所有标准库容器都可以使用迭代器，但只有少数的几种才同时支持下标运算符。 严格来讲， string 不属于容器类型，但是 string 支持很多与容器类型相似的操作。 vector 支持下标运算符，这点和 string 一样。 和指针不一样，获取迭代器不是使用取地址符，有迭代器的类型同时拥有返回迭代器的成员。 begin 和 end ： auto b = v.begin(), e = v.end(); 。 end 成员负责返回指向容器\"尾元素的下一位置\"的迭代器。常被称作尾后迭代器或尾迭代器。 如果容器为空，则 begin 和 end 返回的是同一个迭代器，都是尾后迭代器。 标准容器迭代器的运算符 符号 含义 *iter 返回迭代器 iter 所指元素的引用 iter->mem 解引用 iter 并获取该元素的名为 mem 的成员，等价于(*iter).mem ++iter 令 iter 指向容器中的下一个元素 --iter 令 iter 指向容器中的上一个元素 iter1 == iter2 判断两个迭代器是否相等 iter1 != iter2 如果指向同一元素或者他们是同一容器的尾后迭代器 因为 end 返回的迭代器并不实际指向某个元素，所以不能对其进行递增或解引用操作。C++ 程序员习惯性地使用 != ，其原因和他们更愿意使用迭代器而非下标的原因一样：这种编程风格在标准库提供的所有容器上都有效，因为所有标准库容器都定义了 == 和 != 。 迭代器类型 拥有迭代器的标准库类型使用 iterator 和 const_iterator 来表示迭代器的类型 vector < int > :: iterator it ; // it 能读写 vector < int > 的元素 string :: iterator it2 ; // it2 能读写 string 对象中的元素 vector < int > const_iterator it3 ; // it3 只能读元素 ， 不能写元素 string :: const_iterator it4 ; // it4 只能读字符 ， 不能写字符 begin 和 end 返回的具体类型由对象是否是常量决定，如果对象是常量， begin 和 end 返回 const_iterator ；如果对象不是常量，返回 iterator 。如果对象只需读操作而无需写操作的话最好使用常量类型迭代器。为了专门得到 const_iterator ，C++11 标准引入两个新函数： cbegin 和 cend 。任何一种可能改变容器容量的操作，都会是迭代器失效。 迭代器运算 string 和 vector 的迭代器提供了更多额外的运算符： iter + n ：迭代器加上一个整数值仍得到一个迭代器，迭代器指示的新位置与原来相比向前移动了若干个元素。结果迭代器或者指示容器内的一个元素，或者指示容器尾元素的下一位置。 iter - n ：迭代器减去一个整数值仍得一个迭代器，迭代器指示的新位置与原来相比向后移动了若干位置。结果迭代器或者指示容器内的一个元素，或者指示容器尾元素的下一位置。 iter1 - iter2 ：两个迭代器相减的结果是它们之间的距离，也就是说，将运算符右侧的迭代器向前移动差值个元素后将得到左侧的迭代器。参与运算的两个迭代器必须指向的是同一容器中的元素或者尾元素的下一位置。 >, >=, <, <= ：迭代器的关系运算符，如果迭代器指向的容器位置在另一个迭代器所指位置之前，则说前者小于后者。 数组 因为数组的大小固定，因此在对某些特殊的应用来说程序的运行时性能较好，但是相应的也损失了一些灵活性。 数组的维度必须是一个常量表达式。 默认情况下数组的元素被默认初始化。 和内置类型的变量一样，如果在函数内部定义了某种内置类型的数组，那么默认初始化会令数组含有未定义的值。 定义数组的时候必须指定数组的类型，不允许用auto关键字由初始值的列表推断类型。 字符数组可以利用字符串字面值初始化，此时注意字符串字面值末尾的空字符，也会被拷贝到字符数组中。 不允许拷贝和赋值。一些编译器支持数组的赋值，这就是所谓的编译器扩展，但一般来说，最好避免使用非标准特性，因为可能在其他编译器上无法正常工作。 理解复杂的数组声明：由内向外阅读 int *ptrs[10]; //ptrs 是含有10个整型指针的数组 int (*Parray)[10] = &arr; //Parray 是指针，指向一个含有10个整数的数组 int (&arrRef)[10] = arr; //arrRef 是引用，引用一个含有10个整数的数组 int *(&arry)[10] = ptrs; //arry 是引用，引用一个含有10个整型指针的数组 访问数组元素 数组的索引从0开始。 在使用数组下标的时候，通常将其定义为 size_t 类型。 size_t 是一种机器相关的无符号类型，它被设计的足够大以便能表示内存中任意对象的大小。 在 cstddef 头文件中定义了 size_t 类型，这个文件是 C 标准库 stddef.h 头文件的 C++ 版本。 使用数组的时候编译器一般会把它转换成指针。 通常情况下，使用取地址符来获取指向某个对象的指针，取地址符可以用于任何对象。数组的元素也是对象，对数组使用下标运算符得到该数组指定位置的元素，对数组元素应用取地址符就能得到指向该元素的指针。 数组还有一个特性：在很多时候用到数组名字的地方，编译器都会自动地将其替换为一个指向数组首元素的指针 string *p2 = nums; //等价于 p2 = &nums[0] 所以如果使用数组作为一个auto变量的初始值时，推断的类型是指针而非数组 int ia[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9,}; auto ia2(ia); // ia2 是一个整型指针，指向 ia 的第一个元素 ia2 = 42; //错误，ia2 是一个指针，不能用 int 赋值 当使用 decltype 关键字时上述转换不会发生， decltype(ia) 返回的类型是由10个整数构成的数组 decltype(ia) ia3 = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; ia3 = p; //错误，不能用整型指针给数组赋值 ia3[4] = i; //正确：把 i 的值赋给 ia3 的一个元素 为了让指针的使用更简单、更安全，C++11 新标准引入两个名为 begin 和 end 的函数，不过数组毕竟不是类类型，因此这两个函数不是成员函数。正确的使用形式是将数组作为它们的参数 int ia[] = {1, 2, 3, 4, 5, 6, 7, 8, 9}; int *beg = begin(ia); int *last = end(ia); begin 函数返回指向 ia 首元素的指针， end 函数返回指向 ia 尾元素下一位置的指针，这两个函数定义在 iterator 头文件中 两个指针相减结果的类型是一种名为 ptrdiff_t 的类型，和 size_t 一样，它也是定义在 cstddef 头文件中的机器相关的类型。因为差值可能是负值，所以它是一种带符号类型。 内置的下标运算符所用的索引值不是无符号类型，这一点和 vector 和 string 不一样 int *p = &ia[2]; int k = p[-2]; //k 是 ia[0] 那个元素 C 风格字符串 按此习惯书写的字符串存放在字符数组中并以空字符结束。 C 语言标准库提供了一组函数用于操作 C 风格字符串，它们定义在 cstring 头文件中，cstring 是 C 语言头文件 string.h 的 C++ 版本。 与旧代码的接口 任何出现字符串字面值的地方都可以用空字符结尾的字符数组来代替。不能用string对象直接初始化指向字符的指针，为了完成该功能，string专门提供了一个名为c_str的成员函数 char *str = s; //错误，不能用 string 对象初始化 char* const char *str = s.c_str(); //正确 我们无法保证 c_str 函数返回的数组一直有效，事实上，如果后续的操作改变了 s 的值就可能让之前返回的数组失去效用 使用数组初始化 vector 对象 int int_arr[] = {0, 1, 2, 3, 4, 5}; vector<int> ivec(begin(int_arr),end(int_arr)); 现代的 C++ 程序员应当尽量使用 vector 和迭代器，避免使用内置的数组和指针，应该尽量使用 string ，避免使用 C 风格的基于数组的字符串。 多维数组：要使用范围 for 语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型。 缓冲区溢出：主要原因是试图通过一个越界的索引访问容器内容。 difference_type ：由 string 和 vector 定义的一种带符号整数类型，表示两个迭代器之间的距离。","tags":"读书笔记","url":"https://xutree.github.io/pages/2018/10/06/C++_Primer_Chapter_3/"},{"title":"C++ Primer 第二章 变量和基本类型","text":"类型 下表列出了 C++ 标准规定的数据类型尺寸的最小值，同时允许编译器赋予这些类型更大的尺寸 类型 含义 最小尺寸 bool 布尔类型 未定义 char 字符 8位 wchar_t 宽字符 16位 char16_t Unicode 字符 16位 char32_t Unicode 字符 32位 short 短整型 16位 int 整型 16位 long 长整型 32位 long long 长整型 64位 float 单精度浮点数 6位有效数字 double 双精度浮点数 10位有效数字 long double 扩展精度浮点数 10位有效数字 一个 char 的空间应确保可以存放机器基本字符集中任意字符对应的数字值。也就是说，一个 char 的大小和一个机器字节一样。 wchar_t 类型用于确保可以存放机器最大扩展字符集中的任意一个字符。 C++ 语言规定，一个 int 至少和一个 short 一样大，一个 long 至少和一个 int 一样大，一个 long long 至少和一个 long 一样大。 可寻址的最小内存块成称为\"字节（byte）\"，存储的基本单元称为\"字（word）\"，它通常有几个字节组成。 在 C++ 语言中，一个字节至少能容纳机器基本字符串中的字符。大多数机器的字节由8比特构成，字则由32或64比特构成，也就是4字节或8字节。 C++ 标准指定了一个浮点数有效位数的最小值，然而大多数编译器都实现了更高的精度。通常， float 以1个字（32比特）来表示， double 以2个字（64位）来表示， long double 以3或4个字（96或128比特）来表示。一般来说， float 和 double 分别有7和16个有效位；类型 long double 则常常被用于有特殊浮点要求的硬件，它的具体实现不同，精度也各不相同。 类型 int 、 short 、 long 和 long long 都是带符号的，通过在这些类型名前添加 unsigned 就可以得到无符号类型。 char 、 signed char 和 unsigned char ， char 是否等于 signed char 由编译器决定。 C++ 标准并没有规定带符号类型应如何表示，但是约定了在表示范围内正值和负值的量应该平衡。因此，8比特的 signed char 理论上可以表示-127至127区间内的值，大多数现代计算机将实际的表示范围定为-128至127。 如何选择类型 明知数值不可能为负数，选用无符号类型。 如果数值超过了 int 的表示范围，选用 long long ，因为 long 一般和 int 有一样的尺寸。 算术表达式中不要使用 bool 或 char 。 执行浮点数运算选用 double 。因为 float 通常精度不够而且计算代价相差无几。 long double 提供的精度一般情况下是没有必要的而且计算代价大。 类型转换 非布尔 -> 布尔：0 -> false ，其他 -> ture 。 布尔 -> 非布尔： false -> 0， ture -> 1。 浮点 -> 整型：仅保留小数点前。 整型 -> 浮点：小数部分记为0，如果该整数所占的空间超过浮点类型的容量，精度可能损失。 当我们赋给无符号类型一个超过它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。 当我们赋给带符号类型一个超出它表示范围的值时，结果是未定义的。此时，程序可能继续工作、可能崩溃，也可能生成垃圾数据。 当一个算术表达式中既有无符号数又有 int 值时，那个 int 会转换成无符号数。把 int 转换成无符号数的过程和把 int 赋值给无符号变量一样。 当从一个无符号数中减去一个值时，我们必须确保结果不是负值，否则实际结果会是取模后的值。 字面值常量 整型和浮点型字面值。 字符和字符串字面值： ‘a' 和\"a\"，字符串字面值最后补'\\0' 如果两个字符串字面值位置紧邻且仅由空格、缩进和换行分隔，则它们是一个整体 布尔字面值： true 、 false 。 指针字面值： nullptr 。 指定字面值的类型 字符和字符串字面值 前缀 类型 u char16_t U char32_t L wchar_t u8 char 整型字面值 后缀 最小匹配类型 u 或 U unsigned l 或 L long ll 或 LL long long 浮点型字面值 后缀 类型 f 或 F float l 或 L long double 列表初始化 int units_sold{0} 列表初始化的重要特点：如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将报错。 默认初始化 内置类型变量 定义于任何函数之外，初始化为0 定义于函数体内的局部静态变量，初始化为0 定义于函数体内的非局部静态变量，不被初始化，试图拷贝或以其他方式访问此类值将引发错误 每个类各自决定其初始化对象的方式。 分离式编译 将程序分割为若干个文件，每个文件可被独立编译 声明 extern int i; extern 语句如果包含初始值就不再是声明，而变成定义了： extern int i = 0; 在函数体内部，试图初始化一个由 extern 关键字标记的变量将引发错误。 静态类型语言：在编译阶段执行类型检查 C++ 标识符 字母、数字、下划线，必须以字母或下划线开头，长度无限制，大小写敏感。 C++ 为标准库保留了一些名字 自定义标识符中不能连续出现两个下划线 不能以下划线紧接大写字母开头 定义在函数体外的函数不能以下划线开头 作用域操作符 :: 若左侧为空，则指代全局作用域 复合类型 引用 int &b = a; b指向a。 引用必须初始化。 引用本身不是一个对象，不能定义引用的引用。 引用必须绑定到对象上，不能绑定到字面值或者某个表达式的计算结果上。 除了两种例外，所有引用的类型都要和它所绑定的对象严格匹配： 初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可 允许将基类的引用绑定到派生类上 指针 int *b = &a; 。 指针是一个对象。 在块作用域内定义的指针如果未初始化，将拥有一个不确定的值。 除了两种例外，所有指针的类型都要和它所指向的对象严格匹配： 允许一个指向常量的指针指向一个非常量对象 允许将基类的指针绑定到派生类上 试图拷贝或以其他方式访问无效指针的值将引起错误，编译器不负责检查此类错误。 任何非零的指针对应的条件值都是true。 合法指针可以比较大小：== 或 !=。 void * 是一个特殊的指针类型，可用于存放任意对象的地址，只支持有限的操作： 拿它和别的指针比较 作为函数的输入或输出 赋给另外一个 void * 指针 理解复合类型的声明 变量的定义包括一个基本数据类型和一组声明符。 一条定义语句可能定义出不同类型的变量： int i = 1024, *p = &i, &r =i; 。 面对一条比较复杂的指针或者引用的声明语句时，从右往左阅读有助于弄清楚它的真实含义，例如： int \\*&r; 首先 r 是一个引用，其次 r 是一个指针的引用，再次 r 是一个指向整型指针的引用。 const 限定符 因为 const 对象一旦创建就无法改变其值，所以必须初始化。 当用一个对象去初始化另外一个对象，它们是不是 const 都无关紧要，常量的特性仅仅在执行改变其值的操作时才会发挥作用。 默认情况下， const 对象仅在文件内有效。 如果想在多个文件之间共享 const 对象，必须在变量的定义之前添加 extern 关键字。 const 的引用，常量引用的初始化：初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。尤其，允许为一个常量引用绑定非常量的对象、字面值甚至是一个表达式。实际上是通过绑定到一个临时量对象上实现的。 对 const 的引用可能引用一个并非 const 的对象，常量引用仅对引用可参与的操作做了限制，对于引用的对象本身是不是常量未做限制。 指针和 const 指向常量的指针 允许一个指向常量的指针指向一个非常量对象。 仅对指向常量的指针可参与的操作做了限制，对于指向的对象本身是不是常量未做限制。 const 指针 指针是对象，可以把指针本身定为常量。 常量指针必须初始化，一经初始化就不能再改变。 把*放在 const 关键字之前说明指针是一个常量。 顶层和底层 const 顶层 const ：指针本身是个常量。 底层 const ：指针所值的对象是一个常量。 更一般的，顶层 const 可以表示任意的对象是常量，这一点对任意数据类型都适用。底层 const 则与指针和引用等复合类型的基本类型部分有关。 执行对象的拷贝操作时，顶层 const 不受影响；拷入和拷出的对象必须具有相同的底层 const 资格，或者两个对象的数据类型必须能够转换。一般来说，非常量可以转换成常量，反之不行。 constexpr 和常量表达式 常量表达式：值不会改变并且在编译过程就能得到计算结果的表达式。 constexpr 变量：由编译器来验证变量的值是否是一个常量表达式，声明为 constexpr 的变量一定是一个常量，并且必须用常量表达式初始化。 字面值类型：算术类型、引用、指针、字面值常量类、枚举。 声明 constexpr 用到的类型为字面值类型。 一个 constexpr 指针的初始值必须是 nullptr 或者0，或者是存储于某个固定地址中的对象： 函数体内定义的变量一般并非存放在固定地址中， constexpr 指针不能指向这样的变量（局部静态对象除外） 定义于所有函数体之外的对象地址固定不变，能用来初始化 constexpr 指针 在 constexpr 声明中如果定义了一个指针，限定符 constexpr 仅对指针有效，与指针所指的对象无关。 constexpr 把它所定义的对象置为顶层 const 。 处理类型 类型别名 typedef double wages; using SI = Sales_item; auto 类型说明符 让编译器自己去分析表达式所属的类型。 auto 也能在一条语句中声明多个变量。因为一条声明语句只能有一个基本数据类型，所以该语句中所有变量的基本数据类型都必须一样。 当引用被用作初始化 auto 变量时，编译器以引用所引用对象的类型作为 auto 的类型。 auto 一般会忽略顶层 const ，同时底层 const 会保留下来。 如果希望推断出的 auto 类型是一个顶层 const ，需要明确指出。 auto 引用 auto &b = a; 初始值 a 的顶层 const 会保留。 decltype 类型指示符 选择并返回操作数的数据类型，编译器分析表达式得到它的类型，却不实际计算表达式的值，编译器并不实际调用f。 如果 decltype 使用的表达式是一个变量，则 decltype 返回该变量的类型（包括顶层 const 和引用在内），需要指出的是，引用从来都作为其所指对象的同义词出现，只有在 decltype 处是一个例外。 如果 decltype 使用的表达式不是一个变量，则 decltype 返回该表达式的结果对应的类型： 因为 r 是一个引用， decltype(r) 的结果是引用类型，如果想让结果类型是 r 所指的类型，可以把 r 作为表达式的一部分，显然这个表达式的结果是一个具体的值而非一个引用 如果表达式的内容是解引用操作，则 decltype 将得到引用类型 如果 decltype 使用的表达式是一个变量： 不加括号，得到该变量的类型 加括号，得到引用类型 自定义数据结构：结构体和类 记得定义末尾的分号。可以类内初始化。 头文件保护符 头文件保护符依赖于预处理变量。 预处理变量由两个状态：已定义和未定义。 #define 指令把一个名字设定为预处理变量。 #ifdef 当且仅当变量已定义时为真。 #ifndef 当且仅当变量未定义时为真。 一旦检查结果为真，则执行后续操作直到遇到 #endif 指令为止","tags":"读书笔记","url":"https://xutree.github.io/pages/2018/10/06/C++_Primer_Chapter_2/"},{"title":"利用 Mac stat 添加文件创建时间、最后修改时间","text":"Pelican 根据 .md 文件生成网页的时候需要 metadata，所以写个命令行自动添加文件创建时间、最后修改时间，这样写博客的时候只需要把 title、category 和 tags 标签填上就行了，其中用了 stat 命令。 自动添加文件创建时间、最后修改时间 stat 命令的 a, m, c, B 参数分别代表上次访问或修改时间文件，上次更改 inode 的时间或 inode 的生成时间（ UNIX 时间戳），所以我们可以通过提取这些信息实现想要的功能。唯一需要注意的是，结果是UNIX时间戳，我们需要将其转换为普通时间。 UNIX 时间，或称 POSIX 时间是 UNIX 或类 UNIX 系统使用的时间表示方式：从协调世界时1970年1月1日0时0分0秒起至现在的总秒数，不考虑闰秒。在多数 UNIX 系统上 UNIX 时间可以通过 date +%s 指令来检查。 在 Mac 系统是由 UNIX 时间戳转化为普通时间的指令为： 所以我们\b先根据 stat 获得文件的创建时间： 然后转化为普通时间： \b以下为脚本： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #! /bin/bash # 输入：需要修改的文件 filename = $1 # 提取创建时间 create_time = $( date -r $( stat -f \"%B\" $filename ) \"+%Y-%m-%d %H:%M:%S\" ) # 提取修改时间 modify_time = $( date -r $( stat -f \"%m\" $filename ) \"+%Y-%m-%d %H:%M:%S\" ) # 查找Date标签的行号 num1 = $( head -5 $filename | grep -n 'Date' | cut -d \":\" -f 1 ) # 查找Modified标签的行号 num2 = $( head -5 $filename | grep -n 'Modified' | cut -d \":\" -f 1 ) # 如果Date标签行号为空，说明不存在Date标签，则插入Date if [ -z \" $num1 \" ] ; then sed -i '' -e \"2s/&#94;//p; 2s/&#94;.*/Date: $create_time /\" $filename fi # 如果Modified标签行号为空，插入Modified if [ -z \" $num2 \" ] ; then sed -i '' -e \"3s/&#94;//p; 3s/&#94;.*/Modified: $modify_time /\" $filename else # 否则，替换Modified标签到最新时间 sed -i '' ${ num2 } d $filename sed -i '' -e \"3s/&#94;//p; 3s/&#94;.*/Modified: $modify_time /\" $filename fi 附：stat 命令详情 stat 显示有关文件的信息。 不需要读取，写入或执行指定文件的权限，但必须可搜索通向该文件的路径名中列出的所有目录。 如果没有给出参数， stat 将显示有关标准输入的文件描述符（stdin）的信息。 当作为 readlink 调用时，仅打印符号链接的目标。 如果给定的参数不是符号链接，则 readlink 将不打印任何内容并退出并显示错误。 显示的信息是通过使用给定参数调用 lstat 系统调用并解释返回的结构来获得的。 参数 -F 与 ls 命令\b的 -F 参数一样，在作为目录的每个路径名之后显示斜杠（'/'），在每个可执行的路径名后面显示星号（'*'），在每个符号链接后显示at符号（'@'）， 在每个without文件后面显示百分号（'％'），每个套接字后显示等号（'='），以及在每个FIFO文件后面显示一个垂直条（'|'）。 -F 的使用意味着 -l -f format 使用指定的格式显示信息 -L 使用 stat 而不是 lstat 。 如果文件是符号链接，则stat给出的信息是链接文件目标文件的信息，而不是链接\b文件本身 -l 将输出以 ls -lT 格式显示，即显示文件的完整时间信息，包括月，日，小时，分钟，秒和年 -n 输出不强制换行 -q 如果对 stat 或 lstat 的调用失败，则不\b显示失败消息。以 readlink 方式运行时，会自动禁止错误消息 -r 显示原始信息。即，对于stat结构（UNIX/Linux系统中定义的结构体）中的所有字段，显示原始数值（例如，自纪元以来的秒数等） -s 在\"shell输出\"中显示信息，适用于初始化变量 -t timefmt 使用指定的格式显示时间戳。 此格式直接传递给 strftime 命令 -x 从某些Linux发行版中以更详细的方式显示信息 格式 格式字符串类似于 printf 格式，因为它们以 ％ 开头，然后是一系列格式化字符，最后是一个字符，用于选择要格式化的 struct stat 字段。 如果 ％ 后面紧跟 n，t，％ 或 @ 之一，则会打印换行符，制表符，百分号或当前文件号，否则将检查字符串是否包含以下内容： 以下是任何可选标志： # 为八进制和十六进制输出选择备用输出形式。 非零八进制输出将具有前导零，并且非零十六进制输出将具有前缀\"0x\" + 断言应始终打印指示数字是正数还是负数的符号。 非负数通常不打印带符号 - 将字符串输出对齐到字段的左侧，而不是右侧 0 将左边距的填充字\b符设置为\"0\"字符，而不是空格 space 在非负有符号输出字段的前面保留一个空格。 如果同时使用 ‘+' ，则 ‘+' 将覆盖空格 以下是任何可选字段： size 可选的十进制数字字符串，指定最小字段宽度 prec 由小数点'.'和十进制数字字符串组成的可选精度，指示最大字符串长度，浮点输出中小数点后出现的位数，或数字输出中显示的最小位数 fmt 可选的输出格式说明符，它是D，O，U，X，F 或 S 之一。它们分别表示带符号的十进制输出，八进制输出，无符号十进制输出，十六进制输出，浮点输出和字符串输出。 某些输出格式不适用于所有字段。 浮点输出仅适用于 timespec 字段（a，m 和 c 字段）。 特殊输出说明符S可用于指示输出（如果适用）应为字符串格式。 可与以下标志结合使用： amc 以 strftime 格式显示日期 dr 显示实际设备名称 gu 显示组或用户名 p 以 ls -lTd 显示文件模式 N 显示文件名 T 显示文件类型 Y 在输出中插入\" -> \"。 请注意， Y 的默认输出格式是字符串，但如果明确指定，则会预先添加这四个字符 sub 可选的子字段说明符（高，中，低）。仅适用于 p，d，r 和 T 输出格式。 它可以是以下之一： H \"高\"，指定来自 r 或 d 的设备的主要编号，来自 p 的字符串形式的权限的\"用户\"位，来自 p 的数字形式的文件\"type\"位，以及 T 的长输出形式 L \"低\"，指定来自 r 或 d 的设备的次要编号，来自 p 的字符串形式的权限的\"其他\"位，来自 p 的数字形式的\"用户\"，\"组\"和\"其他\"位， 当与 T 一起使用时，文件类型的 ls -F 样式输出字符（对此使用 L 是可选的） M \"中\"，指定 p 的字符串输出形式的权限的\"组\"位，或 p 的数字形式的 \"suid\"，\"sgid\" 和 \"sticky\" 位 datum 必填字段说明符，是以下之一： d 文件所在的设备 i 文件的inode编号 p 文件类型和权限 l 文件的硬链接数 u, g 文件所有者的用户ID和组ID r 字符和块设备专用文件的设备编号 a, m, c, B 上次访问或修改时间文件，上次更改 inode 的时间或 inode 的生成时间（UNIX时间戳） z 文件大小（以字节为单位） b 分配给文件的块数 k 最佳文件系统I / O操作块大小 f 用户定义的文件标志 v Inode 生成号 以下四个字段说明符不是直接从struct stat中的数据中提取的，而是： N 文件的名称 T 文件类型，类似 ls -F ，如果给出子字段说明符H，则采用更具描述性的形式。 Y 符号链接的目标 Z 从字符或块特殊设备的rdev字段扩展为\"major，minor\"，并为所有其他设备提供大小输出 只有 ％ 和字段说明符是必需的。大多数字段说明符默认为 U 作为输出形式；p 默认输出形式是 O；a、m、c 默认输出形式是 D，Y、T、N 默认输出形式是 S。","tags":"教程","url":"https://xutree.github.io/pages/2018/10/06/mac-stat/"},{"title":"C++ Primer 第一章 开始","text":"g++ -std=c++14 -Wall -o test test.cpp iostream cin cout cerr clog << 运算符返回其左侧的运算对象 写入 endl 的效果是结束当前行，并将与设备关联的缓冲区中的内容刷到设备中。缓冲刷新操作可以保证到目前为止程序所产生的所有输出都真正写入到输出流中，而不是仅停留在内存中等待写入流 小心程序崩溃，输出可能还留在缓冲区的情况，利用 endl 标准库定义的所有名字都在命名空间 std 中 当我们使用一个 istream 对象作为条件时，其效果是检测流的状态。流有效，即流未遇到错误，那么检测成功。当遇到文件结束符（end of file），或遇到一个无效输入时， istream 对象的状态会变为无效。无效的 istream 对象会使条件为假 文件结束符：Windows 先Ctrl + Z，后Enter 或 Return；UNIX：Ctrl +D 标准库文件通常不带后缀。编译器一般不关心头文件名的形式，但有的IDE对此有特定要求 头文件包含：标准库头文件 <> 非标准库头文件 \"\" 文件重定向：从文件读入\\<infile，输出到文件>outfile cerr (无缓冲标准错误) 没有缓冲，发送给它的内容立即被输出 clog (缓冲标准错误) 有缓冲，缓冲区满时输出 cout 标准输出 cout 是在终端显示器输出， cout 流在内存中对应开辟了一个缓冲区，用来存放流中的数据，当向 cout 流插入一个 endl ，不论缓冲区是否满了，都立即输出流中所有数据，然后插入一个换行符 cerr 流对象是标准错误流，指定为和显示器关联，和 cout 作用差不多，有点不同就是 cout 通常是传到显示器输出，但可以被重定向输出到文件，而 cerr 流中的信息只能在显示器输出 clog 流也是标准错误流，作用和 cerr 一样，区别在于 cerr 不经过缓冲区，直接向显示器输出信息，而 clog 中的信息存放在缓冲区，缓冲区满或者遇到 endl 时才输出 对于为什么有 cerr 和 clog ？比如，你的程序遇到调用栈用完了的威胁（无限，没有出口的递归。你说，你到什么地方借内存，存放你的错误信息？所以有了 cerr 。其目的，就是在你最需要它的紧急情况下，还能得到输出功能的支持 缓冲区的目的，就是减少刷屏的次数——比如，你的程序输出圣经中的一篇文章。不带缓冲的话，就会每写一个字母，就输出一个字母，然后刷屏。有了缓冲，你将看到若干句子\"同时\"就出现在了屏幕上（由内存翻新到显存，然后刷新屏幕）","tags":"读书笔记","url":"https://xutree.github.io/pages/2018/10/05/C++_Primer_Chapter_1/"},{"title":"HTML 入门","text":"HTML ，即超文本标记语言（ H yper T ext M arkup L anguage）。与脚本或编程语言不同，标记语言使用标记（ tag ）来标识内容。 下面是一个 HTML tag 的例子： <p> 这是一个段落。</p> <p> 称为开始标签， </p> 称为结束标签。 网页的结构 HTML：结构 CSS：样式 JavaScript：行为 PHP 或类似语言：后端 CMS：内容管理 基本 HTML 文件结构 标签 解释 <html></html> HTML文件的所有内容都包含在其中 <head></head> HTML文件的头部包含有助于使页面工作的所有非可视元素 <body></body> 所有可视化元素都包含在body标签中 <title></title> 包含网页选项卡上现实的标题内容 <!DOCTYPE html> 声明为 HTML5 文档 <!DOCTYPE html> < html > < head > < meta charset = \"utf-8\" > < title > 第一个 HTML 例子 </ title > </ head > < body > Hello World! </ body > </ html > <!DOCTYPE> 声明 <!DOCTYPE> 声明有助于浏览器中正确显示网页。网络上有很多不同的文件，如果能够正确声明 HTML 的版本，浏览器就能正确显示网页内容。 doctype 声明是不区分大小写的，以下方式均可： <!DOCTYPE html> <!DOCTYPE HTML> <!doctype html> <!Doctype Html> 中文编码 目前在大部分浏览器中，直接\b输出中文会出现中文乱码的情况，这时候我们就需要在头部将字符声明为 <meta charset=\"utf-8\"> 。 字体标签 标签 解释 <p></p> 段落标签（浏览器会在段落前后自动添加空行） <br /> 换行而不开启新段落（它没有结束标记） <b></b> 粗体 <big></big> 大号文本 <i></i> 斜体 <small></small> 小号文本 <strong></strong> 强调（一种phrase tag） <sub></sub> 下标 <sup></sup> 上标 <ins></ins> 插入线 <del></del> 删除线 标题标签 <h1></h1> ， <h2></h2> ， <h3></h3> ， <h4></h4> ， <h5></h5> ， <h6></h6> 六种标题， <h1></h1> 字号最大。 标签属性\b 属性提供有关元素或标记的附加信息，同时还可以修改它们。例如 <p align= \"center\" > This text is aligned to center </p> 会将段落居中显示（\b <p> 标签的align属性在HTML5中不再支持）。\b 双引号是最常用的，不过使用单引号也没有问题。属性的数值可以通过像素或百分比指定，如 <hr width=\"50px\" /> <hr width=\"50%\" /> HTML 全局属性 加粗为 HTML5 新属性。 属性 描述 accesskey 设置访问元素的键盘快捷键 class 规定元素的类名（classname） contenteditable 规定是否可编辑元素的内容 contextmenu 指定一个元素的上下文菜单，当用户右击该元素，出现上下文菜单 data-* 用于存储页面的自定义数据 dir 设置元素中内容的文本方向 draggable 指定某个元素是否可以拖动 dropzone 指定是否将数据复制，移动，或链接，或删除 hidden hidden 属性规定对元素进行隐藏 id 规定元素的唯一 id lang 设置元素中内容的语言代码 spellcheck 检测元素是否拼写错误 style 规定元素的行内样式（inline style） tabindex 设置元素的 Tab 键控制次序 title 规定元素的额外信息（可在工具提示中显示） translate 指定是否一个元素的值在页面载入时是否需要翻译 HTML 标签 加粗为 HTML5 新标签。 标签 描述 abbr 定义缩写 acronym 定义只取首字母的缩写，不支持 HTML5 address 定义文档作者或拥有者的联系信息 applet HTML5 中不赞成使用，定义嵌入的 applet area 定义图像映射内部的区域 article 定义一个文章区域 aside 定义页面的侧边栏内容 audio 定义音频内容 b 定义文本粗体 base 定义页面中所有链接的默认地址或默认目标 basefont HTML5 不支持，不赞成使用，定义页面中文本的默认字体、颜色或尺寸 bdi 允许您设置一段文本，使其脱离其父元素的文本方向设置 bdo 定义文字方向 big 定义大号文本，HTML5 不支持 blockquote 定义长的引用 body 定义文档的主体 br 定义换行 button 定义一个点击按钮 canvas 定义图形，比如图表和其他图像,标签只是图形容器，您必须使用脚本来绘制图形 caption 定义表格标题 center HTML5 不支持，不赞成使用，定义居中文本 cite 定义引用(citation) code 定义计算机代码文本 col 定义表格中一个或多个列的属性值 colgroup 定义表格中供格式化的列组 command 定义命令按钮，比如单选按钮、复选框或按钮 datalist 定义选项列表，请与 input 元素配合使用该元素，来定义 input 可能的值 dd 定义定义列表中项目的描述 del 定义被删除文本 details 用于描述文档或文档某个部分的细节 dfn 定义定义项目 dialog 定义对话框，比如提示框 dir HTML5 不支持，不赞成使用，定义目录列表 div 定义文档中的节 dl 定义列表详情 dt 定义列表中的项目 em 定义强调文本 embed 定义嵌入的内容，比如插件 fieldset 定义围绕表单中元素的边框 figcaption 定义 figure 元素的标题 figure 规定独立的流内容（图像、图表、照片、代码等等） font HTML5 不支持，不赞成使用，定义文字的字体、尺寸和颜色 footer 定义 section 或 document 的页脚 form 定义了 HTML 文档的表单 frame 定义框架集的窗口或框架 frameset 定义框架集 h1-h6 定义 HTML 标题 head 定义关于文档的信息 header 定义了文档的头部区域 hr 定义水平线 html 定义 HTML 文档 i 定义斜体字 iframe 定义内联框架 img 定义图像 input 定义输入控件 ins 定义被插入文本 kbd 定义键盘文本 keygen 规定用于表单的密钥对生成器字段 label 定义 input 元素的标注 legend 定义 fieldset 元素的标题 li 定义列表的项目 link 定义文档与外部资源的关系 map 定义图像映射 mark 定义带有记号的文本，请在需要突出显示文本时使用 m 标签 menu 不赞成使用，定义菜单列表 meta 定义关于 HTML 文档的元信息 meter 定义度量衡，仅用于已知最大和最小值的度量 nav 定义导航链接的部分 noframes 定义针对不支持框架的用户的替代内容，HTML5 不支持 noscript 定义针对不支持客户端脚本的用户的替代内容 object 定义内嵌对象 ol 定义有序列表 optgroup 定义选择列表中相关选项的组合 option 定义选择列表中的选项 output 定义不同类型的输出，比如脚本的输出 p 定义段落 param 定义对象的参数 pre 定义预格式文本 progress 定义运行中的进度（进程） q 定义短的引用 rp rp 标签在 ruby 注释中使用，以定义不支持 ruby 元素的浏览器所显示的内容 rt rt 标签定义字符（中文注音或字符）的解释或发音 ruby ruby 标签定义 ruby 注释（中文注音或字符） s 不赞成使用，定义加删除线的文本 samp 定义计算机代码样本 script 定义客户端脚本 section section 标签定义文档中的节（section、区段），比如章节、页眉、页脚或文档中的其他部分 select 定义选择列表（下拉列表） small 定义小号文本 source source 标签为媒介元素（比如 video 和 audio）定义媒介资源 span 定义文档中的节 strike HTML5 不支持，不赞成使用定义加删除线文本 strong 定义强调文本 style 定义文档的样式信息 sub 定义下标文本 summary summary 标签包含 details 元素的标题，\"details\" 元素用于描述有关文档或文档片段的详细信息 sup 定义上标文本 table 定义表格 tbody 定义表格中的主体内容 td 定义表格中的单元 textarea 定义多行的文本输入控件 tfoot 定义表格中的表注内容（脚注） th 定义表格中的表头单元格 thead 定义表格中的表头内容 time 定义日期或时间，或者两者 title 定义文档的标题 tr 定义表格中的行 track track 标签为诸如 video 元素之类的媒介规定外部文本轨道 tt 定义打字机文本 u 不赞成使用定义下划线文本 ul 定义无序列表 var 定义文本的变量部分 video video 标签定义视频，比如电影片段或其他视频流 wbr 规定在文本中的何处适合添加换行符 图像标签 <img src=\"\" height=\"\" width=\"\" border=\"\" alt=\"\"/> src：图像名称 height：图像高 width：图像宽 border：边界宽度 alt：如果无法显示图像，则alt属性指定以单词形式描述图像的替代文本 链接标签 <a href=\"\" target=\"\"></a> href：目标网址 target：指定打开链接文档的位置，\b_blank值将在新窗口或新标签中打开链接 列表标签 有序列表 <html> <head> <title> first page </title> </head> <body> <ol> <li> Red </li> <li> Blue </li> <li> Green </li> </ol> </body> </html> 无序列表 <html> <head> <title> first page </title> </head> <body> <ul> <li> Red </li> <li> Blue </li> <li> Green </li> </ul> </body> </html> 表格标签 <table border= \"\" align= \"\" > <tr> <td bgcolor= \"red\" > Red </td> <td> Blue </td> <td> Green </td> </tr> <tr> <td> Yellow </td> <td colspan= \"2\" > Orange </td> </tr> </table> 其他 标签 解释 <hr /> 水平线 <!--...--> 注释 HTML 元素类型\b 在 HTML 中，大多数元素被定义为块级或内联元素。| 块级元素从新行开始，如 <h1>, <form>, <li>, <ol>, <ul>, <p>, <pre>, <table>, <div> 等 内联元素通常显示没有换行符，如 <b>, <a>, <strong>, <img>, <input>, <em>, <span> 等 <div> 元素是一个块级元素，通常用作其他 HTML 元素的容器。与一些 CSS 样式一起使用时， <div> 元素可用于设置内容块的样式。 同样， <span> 元素是一个内联元素，通常用作\b某些文本的容器。与 CSS 一起使用时， <span> 元素可用于设置文本的部分样式。 其他元素可以用作块级元素或内联元素。 这包括以下这些： APPLET - 嵌入式 Java 小程序 IFRAME - 内联框架 INS - 插入文本 MAP - 图像映射 OBJECT - 嵌入对象 SCRIPT - HTML 文档中的脚本 你可以在块元素内插入内联元素。 例如，可以在 <div> 元素中包含多个 <span> 元素。反之不行。 表单标签 HTML 表单用于从用户收集信息。使用 <form> 元素及其开始和结束标记定义表单，使用 action 属性指向将在用户提交表单后加载的网页： <body> <form action= \"\" method= \"\" > … </form> </body> method 属性指定在提交表单时使用的 HTTP 方法（GET 或 POST）： 使用 GET 时，表单数据将显示在页面地址中 如果表单正在更新数据，请使用 POST，或者包含敏感信息（密码）。POST 提供了更好的安全性，因为提交的数据在页面地址中不可见 要接受用户输入，需要相应的表单元素，例如文本字段。 <input> 元素有许多变体，具体取决于 type 属性。 它可以是文本，密码，广播，URL，提交等。 <form> <input type= \"text\" name= \"username\" /><br /> <input type= \"password\" name= \"password\" /> </form> <frame> 标签 可以使用特殊帧文档将页面划分为帧。 <frame> 标签定义 <frameset> 中的一个特定窗口（框架）。 <frameset> 中的每个 <frame> 可以具有不同的属性，例如边框，滚动，调整大小的能力等。 <frameset> 元素指定框架集中的列数或行数，以及每个框架占空间像素的百分比或数量。 <frameset cols= \"25%,50%,25%\" > <frame src= \"a.htm\" /> <frame src= \"b.htm\" /> <frame src= \"c.htm\" /> <noframes> Frames not supported! </noframes> </frameset> 使用 <noresize> 属性指定用户无法调整 <frame> 元素的大小： <frame noresize=\"noresize\"> HTML5 中不支持 <frame> 标签。 颜色 颜色值 HTML 颜色表示为十六进制值，0~\bF。零表示最低值，F表示最高值。 颜色模式 颜色以红色，绿色和蓝色光（RGB）的组合显示。 十六进制值使用＃标签符号，后跟六个十六进制字符。所有浏览器都支持 RGB 颜色值。","tags":"教程","url":"https://xutree.github.io/pages/2018/10/05/html-overview/"},{"title":"X3DOM 图像和视频纹理","text":"本章你将知道哪些图像类型和视频格式可以用作 X3DOM 的纹理，以及纹理的特性和限制。 你可以使用 PNG ， LPEG 或者 GIF 来编码你的静态纹理数据。 JPG 图像需要的内存少但是存在压缩损失而且没有 alpha 通道。 PNG 图像属于无损压缩并且有 alpha 通道， GIF 也是无损压缩并且有 alpha 通道。一般来讲：如果你不需要 alpha 通道并且图像中不包含硬边界(例如：文本)，使用 JPG ，否则使用 PNG 。你应该避免使用 GIF 。 图像 利用 ImageTexture 节点把图像作为纹理： <x3d width= '500px' height= '400px' > <scene> <shape> <appearance> <ImageTexture url= \"myTexture.png\" ><ImageTexture/> </appearance> <box> </box> </shape> </scene> </x3d> 视频 利用 MovieTexture 节点可以把视频作为纹理。但是目前还没有哪一种视频格式支持所有的用户。可以使用 X3DOM 格式 示例 来确定你的浏览器支持的格式。目前最好的解决方法是将你的视频编码成 MP4 和 OGV 格式并在 MovieTexture 节点中提供这两个选项： <x3d width= '500px' height= '400px' > <scene> <shape> <appearance> <MovieTexture url= '\"foo.mp4″,\"foo.ogv\"' ><MovieTexture/> </appearance> <box> </box> </shape> </scene> </x3d>","tags":"教程","url":"https://xutree.github.io/pages/2018/10/05/X3DOM图像和视频纹理/"},{"title":"X3DOM，HTML，CSS 和 JavaScript","text":"本节，你将学习关于 X3DOM, HTML 和 CSS的更多知识，以及怎么利用 HTML 和 CSS 技术构建出强大的 3D 应用。在本节最后，你讲学习怎么在你的应用中使用 JavaScript。我们将继续使用前一节的例子。拷贝 HelloX3DOM.html 文件并重命名为 HTMLEventsCSS.html。 X3DOM 和 CSS 我们首先来看下怎么通过 CSS 操控 X3DOM 元素。你可能已经注意到，在 HelloX3DOM.html 中，3D 内容位于一个被黑色边界包围的白色区域中。X3DOM 有一个单独的 css 文件，自从版本1.3以后，名字一直为 x3dom.css，在这个文件中可以找到关于 X3DOM 元素的所有 css 定义以及 debug 信息。假设你的页面使用灰色和橙色作为主要颜色。你可以通过许多方式改变 X3DOM 默认的 CSS 属性： 在 x3dom.css 后包含你自己的 CSS 文件(External Style Sheet) 在 x3dom.css 之后，利用 style 标签定制 css(Internal Style Sheet) 直接操纵相关元素的 style 属性(Inline Styles) 关于 CSS 有很多网上教程，例如 这里 。我们现在利用第二种方法改变 css，通常不推荐第三种方法。为了定制 x3d 代表的 X3DOM 边界，在你的 HTML 文件头部 x3dom.css 之后插入 style 标签： <html> <head> <title> My first X3DOM page </title> <script type= 'text/javascript' src= 'http://www.x3dom.org/download/x3dom.js' > </script> <link rel= 'stylesheet' type= 'text/css' href= 'http://www.x3dom.org/download/x3dom.css' ></link> <style> x3d { border:2px solid darkorange; } </style> </head> <body> <h1> Hello, X3DOM! </h1> <p> This is my first html page with some 3d objects. </p> <x3d width= '600px' height= '400px' > ... </x3d> </body> </html> 现在，X3DOM 的边界颜色已经改变了。假设你的网页已经有了橙色和灰色风格，使用 pattern.png 作为背景(背景图片在 这里 )。那么完整的 style sheet 如下所示： x3d { border : 2 px solid darkorange ; } body { font-size : 110 % ; font-family : verdana , sans-serif ; background-image : url ( 'pattern.png' ); margin : 3 em ; color : lightgray ; } h1 { color : darkorange ; } 现在你的网页看起来如下所示： 从图中可以看出，X3DOM 使用与网页相同的背景。这是一个很重要的行为：你的 X3DOM scene 是在 HTML 之上进行渲染的。让我们设置 x3d 元素为半透明背景： x3d { border : 2 px solid darkorange ; background : rgba ( 128 , 128 , 128 , 0.4 ); } 现在结果看起来如下所示： X3DOM, HTML 事件和 JavaScript 使用 HTML 和 JavaScript，你可以使用大量有用的回调函数来操纵大多数 DOM 元素。X3DOM 为 node 提供了相似的函数。例如，当我们点击红色立方体的时候，可以弹出一个文本信息，在 shape 里插入一个 onclick 函数就可以实现这个功能： <shape onclick= \"alert('Hello, click!');\" > <appearance> <material diffuseColor= '1 0 0' ></material> </appearance> <box></box> </shape> 目前，你可以对 X3DOM 使用 onmousemove ， onmousedown ， onmouseup ， onmouseover 和 onmouseout 事件。你不仅可以在 shape 节点插入事件，也可以在组节点，例如 transform 插入事件。这样你就可以使用一个回调函数捕捉多个节点的事件。 你可以在每个 DOM 元素上使用 JavaScript，所以你可以随心所欲的操纵 node 。你已经知道怎么使用 onclick 事件，让我们尝试当点击时，改变立方体的颜色。如果你从没使用过 JavaScript，这个 网站 或许可以帮助你。 首先，给你想操纵的节点一个 id ： <shape onclick= \"alert('Hello, click!');\" > <appearance> <material id= \"color\" diffuseColor= '1 0 0' ></material> </appearance> <box></box> </shape> 然后，你就可以通过下面这个函数改变颜色： <script> function changeColor() { if(document.getElementById(\"color\").getAttribute('diffuseColor')==\"1 0 0\") document.getElementById(\"color\").setAttribute('diffuseColor', '0 0 1'); else document.getElementById(\"color\").setAttribute('diffuseColor', '1 0 0'); } </script> <shape onclick=\"changeColor();\"> 下一步：自动创建 (X)HTML 如果你有大量的模型数据，你想把这些数据分配到不同的页面上。那么自动生成实际的页面而不是手动编写代码将更加有趣。你可以使用自动化工具，例如 XSLT，允许你直接将 X3DOM 文件转化为 XHTML 网页。 这里 是一个例子。","tags":"教程","url":"https://xutree.github.io/pages/2018/10/05/X3DOMHTMLCSS和JavaScript/"},{"title":"Hello，X3DOM！","text":"本教程将教会你怎么配置和运行你的第一个 X3DOM 应用。你只需要一个相容于 WebGL 的浏览器和一个文本编辑器。整个 X3DOM 应用是常规网页的一部分，并且编写方式也与HTML很相似，所以如果你的编辑器支持HTML或者XML的语法高亮那将更好，像 WebStorm 这种 Web 编程 IDE 也是可以的。如果你手头有一个网页浏览器和一个文本编辑器，并且你知道怎么在浏览器中打开网页(参考 这里 )，那么你可以开始你的第一个 X3DOM 应用了。 首先，创建一个新文件 HelloX3DOM.html 。然后将下面的内容复制粘贴进这个空文件： <html> <head> <title> My first X3DOM page </title> <script type= 'text/javascript' src= 'http://www.x3dom.org/download/x3dom.js' > </script> <link rel= 'stylesheet' type= 'text/css' href= 'http://www.x3dom.org/download/x3dom.css' ></link> </head> <body> <h1> Hello, X3DOM! </h1> <p> This is my first html page with some 3d objects. </p> </body> </html> 如果你在浏览器中打开这个文件，你会看到一个包含一个文本信息的常规HTML页面。你可能已经注意到，我们已经在我们的网页中添加了一些 X3DOM 元素，因为我们已经包含 X3DOM 作为一个 JaveScript 库，还包含了 X3DOM CSS 文件，用于规则的显示 X3DOM 元素。在上面的 HTML 代码中，我们通过 script 和 link 标签是用了 development 版本的 X3DOM。 让我们继续添加一些 3D 内容。首先，我们需要一个 x3d 元素，用来描述 X3DOM 内容在哪个 scene 显示。和 HTML 元素 p 、 div 类似， x3d 在 HTML 里定义了一个矩形范围。整个 X3DOM 的 3D 内容用 scene 描述，所以我们在 x3d 标签里添加一个 scene 标签。这种结构是来自于X3D标准。一个 scene 可以包含很多不同的 node ，例如， lights 、 groups 、 viewpoint 和 objects 。在第一个例子里，我们通过 shape 简单地定义一个3D物体。我们用 box 定义这个物体的几何形状。现在，你可以将下面的代码添加在你的 HTML 文件闭合 p 标签之后： <x3d width= '600px' height= '400px' > <scene> <shape> <box></box> </shape> </scene> </x3d> 如果你现在在浏览器中打开这个文件，会像下面这样： 由于 box 目前没有颜色，所以无法看到它，为了看到它我们需要声明 material ，X3DOM 基于 X3D 标准选择了一个白色的 material ，由于网页的背景也是白色的，所以我们看不到它。为了改变 material 的颜色，我们首先需要在 shape 中插入 appearance 。在 appearance 里面，我们就可以插入 material ，利用 material 的 diffuseColor 我们可以定义 material 的颜色，我们现在将它定义为 RGB 颜色的红色： <shape> <appearance> <material diffuseColor= '1 0 0' ></material> </appearance> <box></box> </shape> 现在，在你的浏览器中，网页将变成： 现在，你可以利用鼠标进行交互了。按住鼠标左键并移动鼠标，你可以旋转视角，按住鼠标右键并移动鼠标，你可以放大和缩小。 我们继续在这个 scene 中添加两个物体：一个蓝色的球体和一个绿色的圆锥。这和我们添加 box 类似，但是，在 sphere 和 cone 节点处，我们需要移动球和圆锥以避免他们相互重叠，因为所有的 3D 物体都默认不进行任何的坐标转换，也就是说它们会重叠在一起。像X3D和其他的图像相关标准(例如，OpenGL)一样，X3DOM 的坐标系统 Y 轴指向上，X 轴指向右，Z 轴指向外： 在添加绿色圆锥之前，我们将坐标往左移动3个单位；在添加蓝色球之前，我们将坐标往右移动3个单位。如下所示： <shape> <appearance> <material diffuseColor= '1 0 0' ></material> </appearance> <box></box> </shape> <transform translation= '-3 0 0' > <shape> <appearance> <material diffuseColor= '0 1 0' ></material> </appearance> <cone></cone> </shape> </transform> <transform translation= '3 0 0' > <shape> <appearance> <material diffuseColor= '0 0 1' ></material> </appearance> <sphere></sphere> </shape> </transform> 现在，在你的浏览器中，你将看到如下内容： 如果你在浏览器中看到了上图的结果，恭喜你！你刚刚使用了一系列的 X3D node 创建了你的第一个 X3DOM scene 。","tags":"教程","url":"https://xutree.github.io/pages/2018/10/04/X3DOM-hello/"},{"title":"X3DOM 第一课","text":"下面的指南可以作为 X3DOM 使用者和开发者的入门资料。本指南包括许多重要的内容，例如怎么配置你的环境去运行 X3DOM 的示例。如果你没有足够的时间阅读这篇入门文章，又或许你已经熟悉一点关于 X3D 的知识，你可以迅速的浏览下第3部分和第4部分的一些内容去设置你的环境，然后根据 tutorials 的指导去完成你的第一个 X3DOM 应用。 背景：什么是X3DOM，它可以用来做什么？ 无需插件即可在浏览器中显示的3D场景 X3DOM（发音：\"X-Freedom\"）是一个开源的 JaveScript 框架，用于在网页中创建 declarative 3D 场景。由于它基于标准的浏览器技术，你的浏览器不需要其他任何插件就可以显示 X3DOM 场景。概括地说，declarative 3D 意味着你可以使用结构化的文本表示去创建和显示 3D 场景，而不需要去编写代码。在 X3DOM 中，这种文本表示是表示网页的 HTML 文件的一部分。也就是说，3D 内容成为了网页元素的一部分，就像网页中的文本、链接、图片和视频一样。 X3DOM = X3D + DOM X3DOM 这个名字是由两个缩写组合而成。第一个缩写是 X3D （\"Extensible 3D Graphics\"），指代一个 3D 图形的免版税 ISO 标准。第二个缩写是 DOM （\"Document Object Model\"），描述与HTML文档的内容相关联的交互概念和分层表示。X3DOM 使用 X3D 的一个专门的子集（所谓的 HTML Profile ）来作为网页内 3D 内容的描述语言。X3D（OM)元素可以通过 DOM 操作，就像其他的 HTML 元素一样。例如，你可以动态地改变一个 3D 物体的颜色通过 JavaScript 调用相应 DOM 元素的 setAttribute(...) 函数，这就像你可以动态改变一个普通网页里一个标签的内容一样。 使用 X3DOM 的原因 使用 X3DOM 而不是其他的基于浏览器的库或者 X3D 播放器是因为 X3DOM 具有以下几个优势： 显示 X3DOM 场景不需要额外插件，因为 X3DOM 是完全基于标准浏览器技术，例如 HTML5 和 WebGL 基于 ISO 标准 X3D 的一种新的 HTML 配置，X3DOM 绝大部分都是标准一致的。这大大方便了 X3DOM 的学习 从2009年至今，X3DOM 已经具有了很大的使用者和开发者群体 如果你知道怎么创建简单的网页，你就可以利用你现有的关于 HTML 和 DOM 的知识，而不需要学习新的 API 怎么做？ 如果你想开发你的第一个 X3DOM 应用，你只需要一个浏览器和一个文本编辑器。当然，你也可以选择功能更多的 HTML 和 JavaScript 开发环境，比如 WebStorm 。 一些基本 X3D 概念：Nodes、Components 和 Profiles X3D Nodes X3D 定义每一个 3D 场景都是由一组 node 组成。每一个 node 代表 3D 场景中一个确定的部分：光线、物体、物体表面的材质等等。场景里的所用 node 排列成树结构或者图结构，整体结构被叫做 scene-graph 。每一个 node 的行为，比如材质的颜色，可以通过node的 fields 设置。例如，一个用来设置某物体表面颜色为红色（RGB编码 1 0 0）的node的 XML 描述为： <Material diffuseColor= '1 0 0' ></Material> 你可能已经意识到，描述 X3D node 的 XML 很像常规的 HTML 代码，属性值 diffuseColor 的设置也像 HTML 属性的设置一样。事实上，如果你熟悉 HTML，那么就很容易理解 X3DOM 中的 node 了。你可以在 tutorials 中学习怎样使用 node。如果你想了解更多 X3D 中 node 的概念，可以参考 external X3D documentation resources 。 X3D Components 一组具有相同功能的 node 称为 components。例如定义光线的 node， PointLight 和 SpotLight ，在 Lighting component 里。关于 Components 的全部信息可以在 这里 找到。 X3D Profiles 和 X3DOM HTML Profile X3D 标准定义了大量的 node，一些特殊用途的 node 对大多说用户来说并不重要。因此，X3D 引入了 profile 的概念，把许多组 node 放在一起成为一个包，每一个包代表一类特殊的应用。例如， CAD 包， Immersive 包是用于交互环境的。profile 是在 component 之上的一个概念。 X3DOM 使用的 X3D component 经过十分仔细的选择，以提供一个最合适的 X3D 子集来满足现代 HTML 应用的需要。X3DOM 通过定义一个特殊的 profile，即 HTML profile，来解决这一问题。这个 HTML profile 也包括一些处于试验阶段的 X3D 没有的 node 和 filed，这些 node 和 filed 是专门为 X3DOM 设计的。具体来说，有些 X3D node 在 X3DOM 里没有，而有些 node X3DOM 里有但是 X3D 里没有。你可以在 这里 找到每个 node 的起源。如果你想学习更多关于 HTML profile 的知识以及它与现有的 X3D component、profile 的关系，可以查看 这里 。 最后，X3DOM 也提供一些不在原始HTML profile 中的 X3D node。这些 node 不在 X3DOM 的标准发行版本中，只在 X3DOM-Full 版本中。 选择一个 X3DOM 版本 版本和 Components 有许多可供选择的 X3DOM 版本，你可能想知道对特殊的目的哪一个才是最好的。一般来讲，我们推荐最新的 release 版本。但是，如果你需要采用的新特性在 release 版中没有，那么 dev 版本可能更适合你。当你完成了网页应用的主要开发工作进而部署时，你可能需要用来开发的 X3DOM 的版本信息。你也可能，出于某种原因需要老版本的 X3DOM，比如你的网页应用包含了一些试验特性只在老版本出现，而在新版本中被移除了。 所有的 X3DOM release 版本，包括 dev 版本，都被打包好了，里面包括一个 JavaScript 文件（如 x3dom.js），一个 css文件（如 x3dom.css）和一个可选的 shockwave 文件（如 x3dom.swf，对于那些支持 flash 的版本），可在 这里 下载： 版本1.0到1.2的文件以 x3dom-v 标记，后面跟着版本号（如 http://x3dom.org/download/x3dom-v1.1.js ） 从版本1.3开始，x3dom.js, x3dom.css, x3dom.swf 和一个 .zip 存档文件b被放置在一个以版本号为名字的子文件夹里（如 http://x3dom.org/download/1.3/x3dom.js ） 从版本1.3开始，一些 HTML profile 之外的 component 出现了。这些 component 在文件 x3dom-full.js 中。如果你只需要使用其中一个 component，你也可以考虑仍使用 x3dom.js 然后包含所需的 component 的文件（如 http://x3dom.org/download/1.3/components/ ） 最新的稳定 release 版总是位于： http://x3dom.org/release/x3dom.js 目前的 development 版本总是位于 dec 子文件夹： http://x3dom.org/download/dev/x3dom.js 为使用最新版本 release X3DOM，你可以在你的HTML页面中包含下面的标签： <script src= \"http://www.x3dom.org/release/x3dom.js\" ></script> <link rel= \"stylesheet\" href= \"http://www.x3dom.org/release/x3dom.css\" > 为使用最新的 development 版本，使用下面的标签： <script src= \"http://www.x3dom.org/download/dev/x3dom.js\" ></script> <link rel= \"stylesheet\" href= \"http://www.x3dom.org/download/dev/x3dom.css\" > 为使用版本1.5的 X3DOM-Full 版本，使用下面的标签： <script src= \"http://www.x3dom.org/download/1.5/x3dom-full.js\" ></script> <link rel= \"stylesheet\" href= \"http://www.x3dom.org/download/1.5/x3dom.css\" > 最后，为使用1.3版本的 release X3DOM 和额外的 Geospatial component 和另外的 flash 支持，使用下面的标签： <script src= \"http://www.x3dom.org/download/1.3/x3dom.js\" ></script> <script src= \"http://www.x3dom.org/download/1.3/components/Geospatial.js\" ></script> <script src= \"http://www.x3dom.org/download/1.3/x3dom.swf\" ></script> <link rel= \"stylesheet\" href= \"http://www.x3dom.org/download/1.3/x3dom.css\" > Debugging 如果在 debug 你的应用的时候你想看到 X3DOM 的源码，只需将 x3dom.js 替换成 x3dom.debug.js 或者将 x3dom-full.js 替换成 x3dom-full.debug.js。其注意，此特性只适用于版本1.4以后的 X3DOM。相比于常规版本，debug 版本包含缩进和注释，所以比较大。所以，当你最终发布你的 Web 应用时，请不要使用 debug 版本的 js。 运行 X3DOM 应用 通过简单的 Python 服务器 一个简便的方法在服务器上来测试你的 Web 应用是使用 Python 的 HTTP 服务器模块。你只需要安装一个 Python 解释器。你可以在 这里 下载。你可以用 Python 做许多有趣的事情。首先，打开命令行窗口，定位到 X3DOM 文件夹。如果你的 Python 是2.X版本，你可以使用 SimpleHTTP 服务器模块如下所示： python -m SimpleHTTPServer 如果你的 Python 是3.x版本，如下所示： python3 -m http.server 默认情况下，服务器使用8000端口。如果你想改变端口，直接在命令后面加上端口号即可，例如： python -m SimpleHTTPServer 8023 然后，通过浏览器输入如下地址就可以到达你的服务器： http://localhost:8023 如果你在启动 Python 服务器的文件夹里放置了 index.html 文件，那么这个文件的内容就会显示在浏览器窗口里。否则，你会看到服务器所在文件夹内的文件列表。 在 Web 服务器上运行 X3DOM 通常，你会在Web服务器上运行你的 X3DOM 应用，本节针对一些普通的 Web 服务器，如 Apache 和 IIS，给出具体的方法。 Apache 是使用最多的 Web 服务器。它是开源的可以在 这里 下载。最新版本是2.4，但是版本2.2仍然被支持。 如果你的应用需要一整套 Web 服务器组件，我们推荐 XAMPP ，它包含 Apache、MySQL、PHP 和 Perl 的最新发行版。 互联网信息服务（IIS）被集成在微软的任何的最新版本的 Windows 当中。但是，对于非服务器操作系统，同时连接数会受到限制。","tags":"教程","url":"https://xutree.github.io/pages/2018/10/04/X3DOM第一课/"},{"title":"安装 Pelican","text":"安装 Pelican Pelican 目前支持最好的是 Python 2.7 和 3.3+，早期版本的 Python 已经不支持了。有许多不同的方法可以安装 Pelican，最简单的方法是使用 pip，在终端输入： pip install pelican 上面是最简单的方法，官方更为推荐的方法是利用 virtualenv 为 Pelican 建立一个虚拟环境。假设你已经安装好了 virtualenv，下面打开终端，开始为 Pelican 新建一个虚拟环境： virtualenv ~/virtualenv/pelican cd ~/virtualenv/pelican source bin/activate 当虚拟环境被创建并激活以后，然后利用 pip install pelican 安装 Pelican。 当 Pelican 安装好以后，你可以在终端输入 pelican --help 查看使用选项。 可选的 Packages\b 如果你计划用 Markdown 来书写你的网页的话，你需要安装 Markdown： pip install Markdown 通过设置 Pelican 的 pelicanconf.py 文件，你可以对生成的 HTML 文件启用增强语法。但是首先你需要安装 Typogrify ： pip install typorify 更新 更新到最新的稳定版本，使用： pip install --upgrade pelican","tags":"教程","url":"https://xutree.github.io/pages/2018/10/04/在mac上安装Pelican/"}]}