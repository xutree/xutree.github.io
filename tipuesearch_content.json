{"pages":[{"title":"Search · You Know Nothing\n","text":"\n\n\n\n\n\n\nSearch · You Know Nothing\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nYou Know Nothing\n\n\n主页\n分类\n标签\n归档\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPowered by Pelican. Theme: Elegant by Talha Mansoor\n\n\n\n\n\n\n    $(document).ready(function() {\n        $('#tipue_search_input').tipuesearch({\n            'mode': 'json',\n            'show': 10,\n            'newWindow': false,\n            'contentLocation': 'tipuesearch_content.json'\n        });\n    });\n\n\n","tags":"","url":"https://xutree.github.io/search.html"},{"title":"Page not found · You Know Nothing\n","text":"\n\n\n\n\n\n\nPage not found · You Know Nothing\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nYou Know Nothing\n\n\n主页\n分类\n标签\n归档\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n该页面不存在！\n\n\n\n\n抱歉，找不到您要查找的页面。 您尝试访问的页面似乎不存在，或者可能刚刚移动，或者它已不再存在。\n或许你想从主页重新开始。\n\n\n\n\n\n\n\n\n\n\nPowered by Pelican. Theme: Elegant by Talha Mansoor\n\n\n \n\n\n        function validateForm(query) {\n            return (query.length > 0);\n        }\n    \n\n","tags":"","url":"https://xutree.github.io/404.html"},{"title":"深入浅出 SQL","text":"1. 数据和表 数据库 是保存表和其他相关SQL的容器，数据库中的所有表应该以某种方式相互关联 表 由行（或记录 record）和列（或字段 field）组成。 行 包含某个对象的所有信息， 列 表示各个分类 创建数据库 CREATE DATABASE database_name; 使用数据库 USE database_name; 显示数据库中的表格 SHOW TABLES; 创建表格 CREATE TABLE table_name ( field1 TYPE1(length1), field2 TYPE2(length2) ); 数据类型 char(character) 事先设定好的长度 tinyint 有/无符号 smallint 有/无符号 mediumint 有/无符号 int(integer) 无符号整数 0~4294967295 int(signed) 有符号整数 -2147483648~2147483647 bigint 有/无符号 dec(decimal) 实数 date 日期 YYYY-MM-DD time（HH:MM:SS） timestamp（YYYYMMDDHHMMSS） datetime （YYYY-MM-DD HH:MM:SS）时间 varchar 可变长度文本，最长255 blob 大量文本数据 boolean 0 和 1 检查创建的表 DESC table_name; （describe） 删除表 DROP table_name; 插入行 INSERT INTO table_name (fiel1,..., fieldN) VALUES (value1,...,valueN); 可以改变field的顺序，但是相应的value也要改变 可以省略所有field，但是此时value要填入所有数据，并且顺序要正确 可以省略部分field 控制数据格式，比如创建表时 field_name TYPE(length) NOT NULL DEFAULT default_value, 2. SELECT 语句 SELECT * FROM table_name WHERE conditions; SELECT field1,...,fieldN FROM table_name WHERE conditions; 条件 逻辑 AND 、 OR 比较 < 、 > 、 <= 、 >= 、 <> 、 = 判空 IS NULL 通配符 LIKE % 任何数量未知字符 WHERE fiel1 LIKE '%im'; _ 一个未知字符 WHERE fiel1 LIKE '_im'; 连续范围 WHERE fiel1 BETWEEN a AND b; 离散范围 WHERE fiel1 IN (value1,...,valueN); NOT 可以和 NULL 、 BETWEEN 、 LIKE 和 IN 一起使用，注意 NOT 要紧接在 WHERE 或 AND 或 OR 后面 3. DELETE 语句 DELETE FROM table_name WHERE conditions; 只能删除一行或者多行 DELETE 之前先 SELECT 确认一下 4. UPDATE 语句 UPDATE table_name SET fiel1=value1,...,fieldN=valueN WHERE conditions; 可以使用基础数学运算和函数，如 UPDATE table_name SET fiel1=f(fiel1) WHERE conditions; 5. 规范化 5.1 原子性 同一列中不会有多个类型相同的值（比如爱好列里许多爱好） 不会有多个存储同类数据的列（比如三个学生类） 5.2 规范化优点 规范化表中没有重复的数据，可以减少数据库的大小 因为查询的数据较少，你的查询会更快 5.3 第一范式（First Normal Form）1NF 每个数据行必须包含具有原子性的值 每个数据行必须有主键（Primary Key） 主键必须不为 NULL ，不能被修改，插入新数据必须指定 创建表格是指定主键 PRIMARY KEY(field_name) CREATE TABLE table_name ( id INT NOT NULL AUTO_INCREMENT, field2 TYPE2(length2), PRIMARY KEY(id) ); AUTO_INCREMENT 的列在插入式可以输入 '' 让 SQL 自动递增 SHOW 命令 SHOW CREATE TABLE table_name; SHOW CREATE DATABASE database_name; SHOW COLUMNS FROM table_name; SHOW INDEX FROM table_name; SHOW WARNINGS; 6. ALTER 命令 添加新列 ALTER TABLE table_name ADD COLUMN id INT NOT NULL AUTO_INCREMENT FIRST, ADD PRIMARY KEY(id); ADD 添加列 MODIFY 修改列的数据类型或位置 CHANGE 修改列的名称和数据类型 DROP 删除列 修改表名 ALTER TABLE table_name RENAME TO new_name; 修改列名并设为主键 ALTER TABLE table_name CHANGE COLUMN field1 newfield1 INT NOT NULL AUTO_INCREMENT, ADD PRIMARY KEY(newfield1); 修改多个列，逗号隔开 ALTER TABLE table_name CHANGE COLUMN field1 newfield1 TYPE(length), CHANGE COLUMN field2 newfield2 TYPE(length); 删除某一列 ALTER TABLE table_name DROP COLUMN fiel1; 修改位置 ALTER TABLE table_name MODIFY COLUMN fieli AFTER fieldj; FIRST , SECOND , THIRD , FOURTH , BEFORE , AFTER , LAST 一些字符函数 RIGHT(field_name, count) LEFT(field_name, count) SUBSTRING_INDEX(field_name, letter, pos) 联合使用 UPDATE table_name SET file1=RIGHT(field2, 2); 7. SELECT 进阶 7.1 CASE 语法如下，缩进不影响，只是为了看起来方便 UPDATE table_name SET category = CASE WHEN drama='T' THEN 'drama' WHEN ... ... ELSE 'misc' END; 7.2 ORDER BY 多列排序 SELECT * FROM table_name ORDER BY fiel1,...,fieldN; 降序关键字 DESC 必须位于需要降序的field名字后面 SELECT * FROM table_name ORDER BY field1 ASC, field2 DESC; 7.3 GROUP BY GROUP BY 必须得配合聚合函数来用 常用聚合函数： SUM , AVG , MIN , MAX , COUNT 7.4 其他 DISTINCT 非重复 SELECT DISTINCT field1 FROM table_name; LIMIT a, b; 从a开始显示b个，SQL从零开始计数 8. 多张表的数据库设计 schema 对数据库内的数据描述（列和表），以及任何相关对象和各种连接方式的描述称为模式 外键 （foreign key）是表中的某一列，它引用到另一个表的主键 外键可能与它引用的主键名称不同 外键使用的主键被称为父键，主键所在的表又被称为父表 外键的值可以是 NULL，即使主键值不可为 NULL（通过外键约束解决） 外键值不需要唯一 8.1 外键约束 SQL 的主键和外键的作用： 外键取值规则：空值或参照的主键值 插入非空值时，如果主键表中没有这个值，则不能插入 更新时，不能改为主键表中没有的值 删除主键表记录时，你可以在建外键时选定外键记录一起级联删除还是拒绝删除 更新主键记录时，同样有级联更新和拒绝执行的选择 创建带有外键的表 CREATE TABLE table_name2 ( id INT NOT NULL AUTO_INCREMENT PRIMARY KEY, field1 TYPE(length), ..., fk_field INT NOT NULL, CONSTRAINT parenttable_parentkey_fk FOREIGN KEY (fk_field) REFERENCES parenttable (parentkey) ); 8.2 表间的关系 8.2.1 一对一 连接表时用到一对一的关系非常少。使用一对一的时机： 抽出数据或许能让你写出更快速的查询。例如大部分时间你只需查询某个 field，那么可以把次 field 单独抽出 如果有些列包含还不知道的值，可以单独存储这一列，以避免主表中出现 NULL 我们可能希望某些数据不要太常被访问。隔离这些数据即可管制访问次数 如果有一大块数据，例如 BLOB 类型，这段数据或许另存为一个表更好 8.2.2 一对多 可用外键处理 8.2.3 多对多 连接表 junction table 8.2.4 组合键 由多个数据列构成的主键，具有唯一性 8.3 数据依赖 T.x -> T.y ：在关系表 T 中，y 列函数依赖于 x 列 部分依赖：非主键列依赖于组合主键的某个部分（但不完全依赖于组合主键） 传递依赖：如果改变任何非键列可能造成其他列的改变，即为传递依赖 传递函数依赖：任何非键列与另一个非键列有关联 8.4 第二范式 2NF 先符合 1NF 没有部分函数依赖性 只要所有列都是主键的一部分或者表中有唯一主键列符合 1NF 的表也会符合 2NF（这也是指定一个 AUTO_INCREMENT 的好理由） 8.5 第三范式 3NF 先符合 2NF 没有传递函数依赖性 9. 联接与多张表的操作 LENGTH , SUBSTR 函数 AS 关键字，把查找结果填入表格或者命名别名 CREATE TABLE table_name ( ... ) AS SELECT ... FROM ...; 命名别名也可以省略 AS ，此时别名紧跟着原始表名或列名 交叉联接（直积）， CROSS JOIN 也可不写，用 , 代替 SELECT t.toy, b.boy FROM toys AS t CROSS JOIN boys AS b; 内联接就是通过查询中的条件移除了某些结果数据行后的交叉联接（ ON 也可用 WHERE 代替） SELECT somecolumns FROM table1 INNER JOIN table2 ON someconditions; 内联接：相等联接、不等联接、自然联接（ NATURAL JOIN ，利用相同列名） 10. 子查询 10.1 子查询规则 子查询都是单一 SELECT 语句 子查询总是位于 括号 内 子查询没有属于自己的分号 10.2 子查询出现的位置 SELECT 子句 选出 COLUMN LIST 作为其中一列 FROM 子句 HAVING 子句 子查询能与 INSERT , DELETE , UPDATE , SELECT 一起使用 大多数情况下子查询只能返回一个值， IN 关键字除外。 如果子查询放在 SELECT 语句中，用于表示某个欲选取的列，则一次只能从一列返回一个值。 SELECT mc.first_name, mc.last_name, (SELECT state FROM zip_code WHERE mc.zip_code=zip_code) AS state FROM my_contacts mc; 10.3 非关联子查询 子查询可以独立运行且不会引用外层查询的任何结果 非关联子查询使用 IN 、 NOT IN 来检查子查询返回的值是否为集合的成员之一 10.4 关联子查询 常见用法是找出外层查询结果中不存在与关联表里的记录 EXISTS , NOT EXISTS SELECT mc.first_name firstname, mc.last_name lastname, mc.email email FROM my_contacts mc WHERE EXISTS ( SELECT * FROM contact_interest ci WHERE mc.contact_id=ci.contact_id ); 11. 外联接、自联接和联合 11.1 外联接 内联接是表额顺序不重要，外联接时分左右表 外联接一定会提供数据行，无论该行是否能在另一个表中找出相应的匹配 LEFT OUTER JOIN 前左后右，匹配左表中的每一行及右表中符合条件的行 左联接结果集中的 NULL 表示右表中没有找到与左表相符的记录 RIGHT OUTER JOIN 前右后左，匹配右表中的每一行及左表中符合条件的行 右联接结果集中的 NULL 表示左表中没有找到与右表相符的记录 FULL OUTER JOIN 外全联接，直和，空补 NULL 11.2 自联接 通过别名，把单一表当成两张具有完全相同信息的表进行查询。 SELECT c1.name, c2.name AS boss FROM clown_info c1 INNER JOIN clown_info c2 ON c1.boss_id = c2.id; 11.3 联合 UNION 取查询的并集，规则如下： 每个 SELECT 语句中列的数量必须一致 每个 SELECT 语句包含的表达式与统计函数也必须相同 SELECT 语句的顺序不重要，不会改变结果 SQL 默认会清除联合中的重复值 列的数据类型必须相同或者可以相互转换 如需重复数据，使用 UNION ALL 如需排序，需要在最后一条 SELECT 语句中加入 ORDER BY 由 UNION 返回的数据类型不太容易分辨，可以将结果制成表： CREATE TABLE table_name AS ...; 11.4 交集和差集 INTERSECT (no mysql) EXCEPT (no mysql) 12. 约束、视图和事务 12.1 约束 前面讲的 NOT NULL 等都是约束。增加约束（更好的办法是建表时指定）(CHEAK no mysql) ALTER TABLE table_name ADD CONSTRAINT CHECK gender IN ('M', 'F'); 12.2 视图 创建视图，保存查询语句 CREATE VIEW view_name AS ...; 查看视图 SELECT * FROM view_name; FROM 子句需要表，当 SELECT 语句的结果是一个虚拟表时，若没有别名，SQL 就无法取得其中的表 优点： 视图把复杂查询简化为一个命令 即使一直改变数据库的结构，也不会破坏依赖表的应用程序 创建视图可以隐藏读者无须看到的信息 CHECK OPTION 检查每个进行 INSERT 或 DELETE 的查询，它根据视图中的 WHERE 子句判断这些查询是否可以执行 MySQL 可以利用 CHECK OPTION 模仿 CHECK CONSTRAINT 的功能 可更新视图包括引用表里所有为 NOT NULL 的列 除了使用 CHECK OPTION ，一般直接操作表执行插入、更新和删除操作 使用完毕： DROP VIRW view_name; 当数据库的使用不止一人时， CHECK CONSTRAINT 和视图均有助于维护控制权 12.3 事务 transaction 事务是一群可完成一组工作的 SQL 语句 在事务过程中，如果所有步骤无法不受干扰的完成，则不完成任一单一步骤 ACID 原则： 原子性（atomicity）：要么完成要么不完成，不可分割 一致性（consistency）：事务完成后应该维持数据库的一致性 隔离性（isolation）：每次事务都会看到具有一致性的数据库 持久性（durability）：事务完成，数据库需要正确的存储数据并保护数据免受断电和其他威胁的伤害 事务用法： START TRANSACTION; some operations here; COMMIT or ROLLBACK; 存储引擎必须是 BDB 或者 InnoDB 才支持事务 改变引擎 ALTER TABLE table_name TYPE=InnoDB; 13. 安全性 设置账号密码（MySQL 方式） SET PASSWORD FOR 'root'@'localhost'=PASSWORD('password'); 增加用户 CREATE USER newuser IDENTIFIED BY 'newpassword'; 控制权 GRANT command1(aim),command2(aim) ON table_name TO user1, user2 WITH GRANT OPTION; GRANT ALL ON table_name TO user1, user2 WITH GRANT OPTION; GRANT ALL ON database_name.* TO user1, user2 WITH GRANT OPTION; 撤回权限 REVOKE ... FROM ... 撤销具有传递性 CASCADE; 连锁撤销 RESTRICT; 有别的受影响则返回错误，并且不执行 角色（ no MySQL） CREATE ROLE role_name; GRANT command1(aim),command2(aim) ON table_name TO role_name; GRANT role_name TO user; DROP ROLE role_name; WITH ADMIN OPTION 让具有该角色的每名用户都能把角色授予他人。撤销角色和上面一样。 创建账号的同时设置权限 GRANT SELECT ON tabel TO user IDENTIFIED BY 'password'; 14. 其他 http://localhost/phpMyAdmin > ALL , < ANY SELECT DATE_FORMAT(a_data, '%M %Y') FROM some_dates; 临时表（MySQL）： CREATE TEMPORARY TABLE table_name AS ...; CREATE TEMPORARY TABLE table_name(); 类型转换 CAST(your_column, TYPE) 显示日期时间用户： SELECT CURRENT_USER(DATE, TIME); 数字函数： abs, ceil, floor, round, sign sin, cos, tan, cot, asin, acos, atan exp, ln, log, mod, power, sqrt format, radians, pi, rand, truncate 索引能加快速度，为列添加索引： ALTER TABLE table_name ADD INDEX (field);","tags":"读书笔记","url":"https://xutree.github.io/pages/2019/08/16/深入浅出SQL/"},{"title":"统计学习方法 第十二章 统计学习方法总结","text":"","tags":"读书笔记","url":"https://xutree.github.io/pages/2019/06/01/sl-12/"},{"title":"统计学习方法 第十一章 条件随机场","text":"条件随机场（conditional random field，CRF）是给定一组输入随机变量条件下另一组输出随机变量的条件概率模型，其特点是假设输出随机变量构成马尔科夫随机场。 条件随机场可以用于不同的预测问题，本节仅讨论它在标注问题的应用，因此主要讲述线性链（linear chain）条件随机场。这时，问题变成了由输入序列对输出序列预测的判别模型，形式为对数线性模型，其学习方法通常是极大似然估计或正则化的极大似然估计。 11.1 概率无向图模型 概率无向图模型（probabilistic undirected graphical model），又称为马尔科夫随机场（Markov random file），是一个可以由无向图表示的联合概率分布。 11.1.1 模型定义 图是由结点及连接结点的边组成的集合。结点和边分别记作 \\(\\textsf{v}\\) 和 \\(\\textsf{e}\\) ，结点和边的集合分别记作 \\(\\textsf{V}\\) 和 \\(\\textsf{E}\\) ，图记作 \\(\\textsf{G}=(\\textsf{V},\\textsf{E})\\) ，无向图是指边没有方向的图。 概率图模型（probabilistic graphical model）是由图表示的概率分布。设有联合概率分布 \\(P(Y)\\) ， \\(Y\\in{\\cal Y}\\) 是一组随机变量。由无向图 \\(\\textsf{G}\\) 表示概率分布，即在图 \\(\\textsf{G}\\) 中，结点 \\(\\textsf{v}\\in\\textsf{G}\\) 表示一个随机变量 \\(Y_\\textsf{v}\\) ， \\(Y=(Y_\\textsf{v})_{\\textsf{v}\\in\\textsf{V}}\\) ；边 \\(e\\in\\textsf{E}\\) 表示随机变量之间的概率依赖关系。 给定一个联合概率分布 \\(P(Y)\\) 和表示它的无向图 \\(\\textsf{G}\\) 。首先定义无向图表示的随机变量之间存在的成对马尔科夫性局（pairwise Markov property）、部马尔科夫性（local Markov property）和全局马尔科夫性（global Markov property）。分别介绍一下三个概念： 成对马尔科夫性 ：设 \\(\\textsf{u}\\) 和 \\(\\textsf{v}\\) 是无向图 \\(\\textsf{G}\\) 中任意两个没有边连接的结点，结点 \\(\\textsf{u}\\) 和 \\(\\textsf{v}\\) 分别对应随机变量 \\(Y_\\textsf{u}\\) 和 \\(Y_\\textsf{v}\\) 。其他所有结点为 \\(\\textsf{O}\\) （集合），对应的随机变量组是 \\(Y_\\textsf{O}\\) 。成对马尔科夫性是指给定随机变量组 \\(Y_\\textsf{O}\\) 的条件下随机变量 \\(Y_\\textsf{u}\\) 和 \\(Y_\\textsf{v}\\) 是条件独立的，其实意思就是说没有直连边的任意两个节点是独立的，即 $$P(Y_\\textsf{u},Y_\\textsf{v}|Y_\\textsf{O})=P(Y_\\textsf{u}|Y_\\textsf{O})P(Y_\\textsf{v}|Y_\\textsf{O})$$ 局部马尔科夫性 ：设 \\(\\textsf{v} \\in \\textsf{V}\\) 是无向图 \\(\\textsf{G}\\) 中任意一个结点， \\(\\textsf{W}\\) 是与 \\(\\textsf{v}\\) 有边连接的所有结点， \\(\\textsf{O}\\) 是 \\(\\textsf{v}\\) ， \\(\\textsf{W}\\) 以外的其他所有结点。 \\(\\textsf{v}\\) 表示的随机变量是 \\(Y_\\textsf{v}\\) ， \\(\\textsf{W}\\) 表示的随机变量组是 \\(Y_\\textsf{W}\\) ， \\(\\textsf{O}\\) 表示的随机变量组是 \\(Y_\\textsf{O}\\) 。局部马尔科夫性是指在给定随机变量组 \\(Y_\\textsf{W}\\) 的条件下随机变量 \\(\\textsf{v}\\) 与随机变量组 \\(Y_\\textsf{O}\\) 是独立的，即 $$P(Y_\\textsf{v},Y_\\textsf{O}|Y_\\textsf{W})=P(Y_\\textsf{v}|Y_\\textsf{W})P(Y_\\textsf{O}|Y_\\textsf{W})$$ 在 \\(P(Y_\\textsf{O}|Y_\\textsf{W})>0\\) 时，等价地 $$P(Y_\\textsf{v}|Y_\\textsf{W})=P(Y_\\textsf{v}|Y_\\textsf{W},Y_\\textsf{O})$$ 下图表示了局部马尔科夫性。 全局马尔科夫性 ：设结点集合 \\(\\textsf{A}\\) ， \\(\\textsf{B}\\) 是在无向图 \\(\\textsf{G}\\) 中被结点集合 \\(\\textsf{C}\\) 分开的任意结点集合，如图所示。结点集合 \\(\\textsf{A}\\) ， \\(\\textsf{B}\\) 和 \\(\\textsf{C}\\) 所对应的随机变量组分别是 \\(Y_\\textsf{A}\\) ， \\(Y_\\textsf{B}\\) 和 \\(Y_\\textsf{C}\\) 。全局马尔科夫性是指给定随机变量组 \\(Y_\\textsf{C}\\) 条件下随机变量组 \\(Y_\\textsf{A}\\) 和 \\(Y_\\textsf{B}\\) 是条件独立的，即 $$P(Y_\\textsf{A},Y_\\textsf{B}|Y_\\textsf{C})=P(Y_\\textsf{A}|Y_\\textsf{C})P(Y_\\textsf{B}|Y_\\textsf{C})$$ 上述成对的、局部的、全局的马尔科夫性定义是等价的。 定义 11.1（概率无向图模型）设有联合概率分布 \\(P(Y)\\) ，由无向图 \\(\\textsf{G}=(\\textsf{V},\\textsf{E})\\) 表示，在图 \\(\\textsf{G}\\) 中，结点表示随机变量，边表示随机变量之间的依赖关系。如果联合概率分布 \\(P(Y)\\) 满足成对、局部或全局马尔科夫性，就称此联合概率分布为概率无向图模型或马尔科夫随机场。 以上是概率无向图模型的定义，实际上，我们更关心的是如何求其联合概率分布。对给定的概率无向图模型，我们希望将整体的联合概率写成若干子联合概率的乘积的形式，也就是将联合概率进行因子分解，这样便于模型的学习与计算。事实上，概率无向图模型的最大特点就是易于因子分解。下面介绍这一结果。 11.1.2 概率无向图模型的因子分解 首先给出无向图中的团与最大团的定义。 定义 11.2（团与最大团）无向图 \\(\\textsf{G}\\) 中任何两个结点均有边连接的结点子集称为团（clique)。若 \\(\\textsf{C}\\) 是无向图 \\(\\textsf{G}\\) 的一个团，并且不能再加进任何一个 \\(\\textsf{G}\\) 的结点使其成为一个更大的团，则称此 \\(\\textsf{C}\\) 为最大团（maximal clique)。 下图表示由 4 个结点组成的无向图。图中由 2 个结点组成的团有 5 个： \\(\\{\\textsf{Y}_1,\\textsf{Y}_2\\}\\) ， \\(\\{\\textsf{Y}_2,\\textsf{Y}_3\\}\\) ， \\(\\{\\textsf{Y}_3,\\textsf{Y}_4\\}\\) 和 \\(\\{\\textsf{Y}_4,\\textsf{Y}_2\\}\\) ， \\(\\{\\textsf{Y}_1,\\textsf{Y}_3\\}\\) 。有 2 个最大团： \\(\\{\\textsf{Y}_1,\\textsf{Y}_2,\\textsf{Y}_3\\}\\) 和 \\(\\{\\textsf{Y}_2,\\textsf{Y}_3,\\textsf{Y}_4\\}\\) 。 将概率无向图模型的联合概率分布表示为其最大团上的随机变量的函数的乘积形式的操作，称为概率无向图模型的因子分解（factorization）。 给定概率无向图模型，设无向图为 \\(\\textsf{G}\\) ， \\(\\textsf{C}\\) 为 \\(\\textsf{G}\\) 上的最大团， \\(Y_\\textsf{C}\\) 表示 \\(\\textsf{C}\\) 对应的随机变量。那么概率无向图模型的联合概率分布 \\(P(Y)\\) 可分解为图中所有最大团 \\(\\textsf{C}\\) 上的函数 \\(\\Psi_{\\textsf{C}}(Y_{\\textsf{C}})\\) 的乘积形式 $$P(Y)=\\frac{1}{Z}\\prod_\\textsf{C}\\Psi_{\\textsf{C}}(Y_{\\textsf{C}})$$ 其中， \\(Z\\) 是规范化因子（normalization factor)，形式如下： $$Z=\\sum_{\\textsf{Y}}\\prod_\\textsf{C}\\Psi_{\\textsf{C}}(Y_{\\textsf{C}})$$ 规范化因子保证 \\(P(Y)\\) 构成一个概率分布。函数 \\(\\Psi_{\\textsf{C}}(Y_{\\textsf{C}})\\) 称为势函数（potential function)。这里要求势函数 ΨC(YC) 是严格正的，通常定义为指数函数： $$\\Psi_{\\textsf{C}}(Y_{\\textsf{C}})=\\exp\\{-E(Y_\\textsf{C})\\}$$ 其中 \\(E(Y_\\textsf{C})\\) 是能量函数。 定理 11.1（Hammersley-Clifford 定理）概率无向图模型的联合概率分布 \\(P(Y)\\) 可以表示为如下形式： $$P(Y)=\\frac{1}{Z}\\prod_\\textsf{C}\\Psi_{\\textsf{C}}(Y_{\\textsf{C}}) \\\\ Z=\\sum_{\\textsf{Y}}\\prod_\\textsf{C}\\Psi_{\\textsf{C}}(Y_{\\textsf{C}})$$ 其中， \\(\\textsf{C}\\) 是无向图的最大团， \\(Y_\\textsf{C}\\) 是 \\(\\textsf{C}\\) 的结点对应的随机变量， \\(\\Psi_{\\textsf{C}}(Y_{\\textsf{C}})\\) 是 \\(\\textsf{C}\\) 上定义的严格正函数，乘积是在无向图所有的最大团上进行的。 11.2 条件随机场的定义与形式 11.2.1 条件随机场的定义 条件随机场（conditional random field）是给定随机变量 \\(X\\) 条件下，随机变量 \\(Y\\) 的马尔可夫随机场。这里主要介绍定义在线性链上的特殊的条件随机场，称为线性链条件随机场（linear chain conditional random field)。 线性链条件随机场可以用于标注问题。这时，在条件概率模型 \\(P(Y|X)\\) 中， \\(Y\\) 是输出变量，表示标记序列，也把标记序列称为状态序列； \\(X\\) 是输入变量，表示观测序列。 学习时，利用训练数据集通过极大似然估计或正则化的极大\b似然估计得到条件概率模型 \\(\\hat{P}(Y|X)\\) ；预测时，对于给定的输入序列 \\(x\\) ，求出条件概率 \\(\\hat{P}(y|x)\\) 最大的输出序列 \\(y\\) 。 定义 11.3（条件随机场）设 \\(X\\) 与 \\(Y\\) 是随机变量， \\(P(Y|X)\\) 是在给定 \\(X\\) 的条件下 \\(Y\\) 的条件概率分布。若随机变量 \\(Y\\) 构成一个由无向图 \\(\\textsf{G}=(\\textsf{V},\\textsf{E})\\) 表示的马尔可夫随机场，即： $$P(Y_\\textsf{v}|X,Y_\\textsf{w},\\textsf{w}\\neq\\textsf{v})=P(Y_\\textsf{v}|X,Y_\\textsf{w},\\textsf{w}\\sim\\textsf{v})$$ 对任意结点 \\(\\textsf{v}\\) 成立，则称条件概率分布 \\(P(Y|X)\\) 为条件随机场。式中 \\(\\textsf{w}\\sim\\textsf{v}\\) 表示在图 \\(\\textsf{G}=(\\textsf{V},\\textsf{E})\\) 中与结点 \\(\\textsf{v}\\) 有边连接的所有结点 \\(\\textsf{w}\\) ， \\(\\textsf{w}\\neq\\textsf{v}\\) 表示结点 \\(\\textsf{v}\\) 以外的所有结点。其实就是说当前变量只跟与之相邻的变量有关系，而独立于没有直接连接的变量。 在定义中并没有要求 \\(X\\) 和 \\(Y\\) 具有相同的结构。现实中，一般假设 \\(X\\) 和 \\(Y\\) 有相同的图结构。这里主要考虑无向图如下图所示为线性链的情况，即 $$\\textsf{G}=(\\textsf{V}=\\{1,2,\\cdots,n\\},\\textsf{E}=\\{(i,i+1)\\}),\\ i=1,2,\\cdots,i-1$$ 在此情况下， \\(X=(X_1,X_2,\\cdots,X_n)\\) ， \\(Y=(Y_1,Y_2,\\cdots,Y_n)\\) ，最大团是相邻两个节点的集合。线性链条件随机场有下面的定义 定义 11.4（线性链条件随机场）设 \\(X=(X_1,X_2,\\cdots,X_n)\\) ， \\(Y=(Y_1,Y_2,\\cdots,Y_n)\\) 均为线性链表示的随机变量序列，若在给定随机变量序列 \\(X\\) 的条件下，随机变量序列 \\(Y\\) 的条件概率分布 \\(P(Y|X)\\) 构成条件随机场，即满足马尔可夫性 $$P(Y_i|X,Y_1,\\cdots,Y_{i−1},Y_{i+1},\\cdots,Y_n)=P(Y_i|X,Y_{i−1},Y_{i+1})$$ 则称 \\(P(Y|X)\\) 为线性链条件随机场。注意当 \\(i=1\\) 或 \\(i=n\\) 时只考虑一侧，在标注问题中， \\(X\\) 表示输入观测序列， \\(Y\\) 表示对应的输出标记序列或状态序列。 11.2.2 条件随机场的参数化形式 根据 Hammersley-Clifford 定理,可以给出线性链条件随机场 \\(P(Y|X)\\) 的因子分解式，各因子是定义在相邻两个结点上的函数。 定理 11.2（线性链条件随机场的参数\b化形式）设 \\(P(Y|X)\\) 为线性链条件随机场，则在随机变量 \\(X\\) 取值为 \\(x\\) 的条件下，随机变量 \\(Y\\) 取值为 \\(y\\) 的条件概率具有如下形式 $$P(y|x)=\\frac{1}{Z(x)}\\exp\\left(\\sum_{i,k}\\lambda_kt_k(y_{i-1},y_i,x,i)+\\sum_{i,l}\\mu_ls_l(y_i,x,i)\\right)$$ 其中 $$Z(x) = \\sum_y \\exp\\left( \\sum_{i,k}\\lambda_k t_k (y_{i-1},y_i,x,i)+ \\sum_{i,l}\\mu_l s_l(y_i,x,i) \\right)$$ 式中， \\(t_k\\) 和 \\(s_l\\) 是特征函数， \\(\\lambda_k\\) 和 \\(\\mu_l\\) 是对应的权值。 \\(Z(x)\\) 是规范化因子，求和是在所有可能的输出序列上进行的。 以上两个式子是线性链条件随机场模型的基本形式，表示给定输入序列 \\(x\\) ,对输出序列 \\(y\\) 预测的条件概率。其中 \\(t_k\\) 是定义在边上的特征函数，称为转移特征（ transition），依赖于当前和前一个位置， \\(s_l\\) 是定义在结点上的特征函数，称为状态特征（status），依赖于当前位置。 \\(t_k\\) 和 \\(s_l\\) 都依赖于位置，是局部特征函数。 通常，特征函数 \\(t_k\\) 和 \\(s_l\\) 取值为 1 或 0；当满足特征条件时取值为 1，否则为 0。条件随机场完全由特征函数和对应的权值 \\(\\lambda_k\\) ， \\(\\mu_l\\) 确定,线性链条件随机场也是对数线性模型（log linear model)。 11.2.3 条件随机场的简化形式 条件随机场还可以由简化形式表示。注意到条件随机场式中同一特征在各个位置都有定义，可以对同一个特征在各个位置求和，将局部特征函数转化为一个全局特征函数，这样就可以将条件随机场写成权值向量和特征向量的内积形式，即条件随机场的简化形式，为简便起见，首先将转移特征和状态特征及其权值用统一的符号表示。设有 \\(K_1\\) 个转移特征， \\(K_2\\) 个状态特征， \\(K = K_1 + K_2\\) ，则 $$f_k(y_{i-1},y_i,x,i)=\\begin{cases} t_k(y_{i-1},y_i,x,i),\\ k = 1,2,\\cdots,K_1 \\\\ s_t(y_i,x,i),\\ k = K_1 + l;\\ l=1,2,\\cdots,K_2 \\end{cases}$$ 然后，对转移与状态特征在各个位置 \\(i\\) 求和，记作 $$f_k(y,x) = \\sum_{i=1}&#94;nf_k(y_{i-1},y_i,x,i),\\ k = 1,2,\\cdots,K$$ 用 \\(w_k\\) 表示特征 \\(f_k(y,x)\\) 的权值，即 $$w_k = \\begin{cases} \\lambda_k, \\ k=1,2,\\cdots,K_1 \\\\ \\mu_l,\\ k=K_1+l;\\ l=1,2,\\cdots,K_2 \\end{cases}$$ 于是，条件随机场可表示为 $$\\begin{aligned} P(y|x) &= \\frac{1}{Z(x)} \\exp\\sum_{k=1}&#94;K w_k f_k(y,x) \\\\ Z(x)&= \\sum_y \\exp\\sum_{k=1}&#94;Kw_kf_k(y,x) \\end{aligned}$$ 若 \\(w\\) 表示权值向量，即 $$w= (w_1,w_2,…,w_K)&#94;\\text{T}$$ 以 \\(F(y,x)\\) 表示全局特征向量，即 $$F(y,x)=(f_1(y,x), f_2(y,x),\\cdots,f_K(y,x))&#94;\\text{T}$$ 则条件随机场可以写成向量 \\(w\\) 与 \\(F(y,x)\\) 的内积的形式 $$P_w(y|x) = \\frac{\\exp\\left(w \\cdot F(y,x)\\right ) }{Z_w(x)}$$ 其中 $$Z_w(x) = \\sum_y \\exp \\left ( w \\cdot F(y,x) \\right )$$ 11.2.4 条件随机场的矩阵形式 条件随机场还可以由矩阵表示。假设 \\(P_w(y|x)\\) 是由内积形式给出的线性链条件随机场，表示对给定观测序列 \\(x\\) ，相应的标记序列 \\(y\\) 的条件概率。引进特殊的起点和终点状态标记 \\(y_0=\\text{start}\\) ， \\(y_{n+1}=\\text{stop}\\) ，这时 \\(P_w(y|x)\\) 可以通过矩阵形式表示。 对观测序列 \\(x\\) 的每一个位置 \\(i=1,2,\\cdots,n+1\\) ，定义一个 \\(m\\) 阶矩阵（ \\(m\\) 是标记 \\(y_i\\) 取值的个数，因为 \\(x\\) 是给定的，位置 \\(i-1\\) 和位置 \\(i\\) 各有 \\(m\\) 种可能，所以是 \\(m\\) 阶矩阵，对于 \b \\(i=1\\) 是 \\(1\\times m\\) 的矩阵，对于 \\(i=n+1\\) 是 \\(m\\times 1\\) 的矩阵） $$\\begin{aligned} M_i(x) &= \\left [ M_i(y_{i-1},y_i|x)\\right ] \\\\ M_i(y_{i-1},y_i|x)&= \\exp \\left [ W_i(y_{i-1} ,y_i|x)\\right ] \\\\ W_i(y_{i-1},y_i|x)&= \\sum_{k=1}&#94;Kw_kf_k(y_{i-1},y_i,x,i) \\end{aligned}$$ 其实矩阵定义了一个状态 \\(y_{i−1}\\) 的 \\(m\\) 种\b状态到 \\(y_i\\) 的 \\(m\\) 种状态的转移的概率 $$\\begin{aligned} M_i(y_{i-1} ,y_i|x) &= \\exp\\left(\\sum_k\\lambda_kf_k(y_{i-1},y_i,x,i)\\right) \\\\ &=\\exp\\left( \\sum_k\\lambda_kt_k(y_{i-1},y_i,x,i) + \\sum_l\\mu_l s_l(y_i,x,i) \\right) \\end{aligned}$$ 举例来说，当 \\(m=3\\) 时，除了 \\(i=1\\) 或者 \\(i=n-1\\) ，每个矩阵 \\(M_i(x)\\in\\mathbb{R}&#94;{3\\times 3}\\) ，如下图所示 矩阵的形式类似于隐马尔科夫中的转移矩阵，代表了状态之间转移的概率，其形式是这样的 $$M_1(x)=\\begin{bmatrix} M_1(y_0,y_1|x) & M_1(y_0,y_3|x) & M_1(y_0,y_3|x) \\end{bmatrix} \\\\ M_2(x)=\\begin{bmatrix} M_2(y_1,y_1|x) & M_2(y_1,y_2|x) & M_2(y_1,y_3|x)\\\\ M_2(y_2,y_1|x) & M_2(y_2,y_2|x) & M_2(y_2,y_3|x)\\\\ M_2(y_3,y_1|x) & M_2(y_3,y_2|x) & M_2(y_3,y_3|x) \\end{bmatrix} \\\\ M_i(x)\\ \\ \\text{具有和}\\ M_2(x)\\ \\text{同样的形式}, \\ i = 3,\\cdots,n \\\\ M_{n+1}(x)=\\begin{bmatrix} M_{n+1}(y_1,y_n|x)\\\\ M_{n+1}(y_2,y_n|x)\\\\ M_{n+1}(y_3,y_n|x) \\end{bmatrix} \\\\$$ 这样，给定观测序列 \\(x\\) ，标记序列 \\(y\\) 的非规范化概率可以通过 \\(n+1\\) 个矩阵的乘积 \\(\\prod_{i=1}&#94;{n+1}M_i(y_{i-1},y_i|x)\\) 表示，于是，条件概率是 $$P_w(y|x) = \\frac{1}{Z_w(x)} \\prod_{i=1}&#94;{n+1} M_i(y_{i-1},y_i|x)$$ 其中， \\(Z_w(x)\\) 为规范化因子，是 \\(n+1\\) 个矩阵的乘积 $$Z_w(x) =M_1(x)M_2(x)\\cdots M_{n+1}(x)$$ 11.3 条件随机场的概率计算问题 条件随机场的概率计算问题是给定条件随机场 \\(P(Y|X)\\) ，输入序列 \\(x\\) 和输出序列 \\(y\\) ，计算条件概率 \\(P(Y_i=y_i|x)\\) ， \\(P(Y_{i-1}=y_{i-1},Y_i=y_i|x)\\) 以及相应的数学期望的问题。 11.3.1 前向-后向算法 对每个指标 \\(i=0,1,\\cdots,n+1\\) ，定义前向向量 \\(\\alpha_i(x)\\) $$\\alpha_0(y|x)=\\begin{cases}1,& y=\\text{start} \\\\ 0,& \\text{否则}\\end{cases}$$ 递推公式为 $$\\alpha_i&#94;\\text{T}(y_i|x)=\\alpha_{i-1}&#94;\\text{T}(y_{i-1}|x)[M_i(y_{i-1},y_i|x)],\\ i=1,2,\\cdots,n+1$$ 又可表示为 $$\\alpha_i&#94;\\text{T}(x)=\\alpha_{i-1}&#94;\\text{T}(x)M_i(x)$$ \\(\\alpha_i(y_i|x)\\) 表示在位置 \\(i\\) 的标记是 \\(y_i\\) 并且到位置 \\(i\\) 的前部分标记序列的非规范化概率， \\(y_i\\) 可取的值有 \\(m\\) 个，所以 \\(\\alpha_i(x)\\) 是 \\(m\\) 维列向量。 同样，对给个指标 \\(i=0,1,\\cdots,n+1\\) ，定义后向向量 \\(\\beta_i(x)\\) $$\\beta_{n+1}(y_{n+1}|x)=\\begin{cases}1,& y_{n+1}=\\text{stop} \\\\ 0,& \\text{否则}\\end{cases} \\\\ \\beta_i(y_i|x)=[M_i(y_i,y_{i+1}|x)]\\beta_{i+1}(y_{i+1}|x)$$ 又可表示为 $$\\beta_i(x)=M_{i+1}(x)\\beta_{i+1}(x)$$ \\(\\beta_i(y_i|x)\\) 表示在位置 \\(i\\) 的标记为 \\(y_i\\) 并且从 \\(i+1\\) 到 \\(n\\) 的后部分标记序列的非规范化概率。 由定义不难得到 $$Z(x)=\\alpha_n&#94;\\text{T}(x)\\cdot\\mathbf{1}=\\mathbf{1}&#94;\\text{T}\\cdot\\beta_1(x)$$ 这里， \\(\\mathbf{1}\\) 是元素均为 1 的 \\(m\\) 维列向量。 11.3.2 概率计算 $$P(Y_i=y_i|x)=\\frac{\\alpha_i&#94;\\text{T}(y_i|x)\\beta_i(y_i|x)}{Z(x)} \\\\ P(Y_{i-1}=y_{i-1},Y_i=y_i|x)=\\frac{\\alpha_{i-1}&#94;\\text{T}(y_{i-1}|x)M_i(y_{i-1},y_i|x)\\beta_i(y_i|x)}{Z(x)}$$ 其中 $$Z(x)=\\alpha_n&#94;\\text{T}(x)\\cdot\\mathbf{1}$$ 11.3.3 期望值的计算 特征函数 \\(f_k\\) 关于条件分布 \\(P(Y|X)\\) 的数学期望是 $$\\begin{eqnarray} \\text{E}_{P(Y|X)}[f_k] &=& \\sum_yP(y|x)f_k(y,x) \\\\ &=& \\sum_{i=1}&#94;{n+1}\\sum_{y_{i-1}y_i}f_k(y_{i-1},y_i,x,i)\\frac{\\alpha_{i-1}&#94;\\text{T}(y_{i-1}|x)M_i(y_{i-1},y_i|x)\\beta_i(y_i|x)}{Z(x)} \\end{eqnarray} \\\\ k=1,2,\\cdots,K$$ 假设经验分布是 \\(\\tilde{P}(X)\\) ，特征函数 \\(f_k\\) 关于联合分布 \\(P(X,Y)\\) 的数学期望是 $$\\begin{eqnarray} \\text{E}_{P(X,Y)}[f_k] &=& \\sum_{x,y}P(x,y)\\sum_{i=1}&#94;{n+1}f_k(y_{i-1},y_i,x,i) \\\\ &=& \\sum_{x}\\tilde{P}(x)\\sum_yP(y|x)\\sum_{i=1}&#94;{n+1}f_k(y_{i-1},y_i,x,i) \\\\ &=& \\sum_x\\tilde{P}(x)\\text{E}_{P(Y|X)}[f_k] \\end{eqnarray} \\\\ k=1,2,\\cdots,K$$ 这些是特征函数数学期望的一般计算公式。 对于转移特征，可以将式中的 \\(f_k\\) 换成 \\(t_k\\) ，表示为 $$t_k(y_{i-1},y_i,x,i),\\ k=1,2,\\cdots,K_1$$ 对于状态特征，可以将式中的 \\(f_k\\) 换成 \\(s_i\\) ，表示为 $$s_l(y_i,x,i),\\ k=K_1+1,\\ l=1,2,\\cdots,K_2$$ 有了本节的公式，对于给定的观测序列 \\(x\\) 和标记序列 \\(y\\) ，可以通过一次前向扫描计算 \\(\\alpha_i\\) 及 \\(Z(x)\\) ，通过一次后向扫描计算 \\(\\beta_i\\) ，从而计算所有的概率和\b特征的期望。 11.4 条件随机场的学习算法 本节讨论给定训练数据集估计条件随机场模型参数的问题。条件随机场模型实际上是定义在时序数据上的对数线性模型，其学习方法包括极大似然估计和正则化的极大似然估计。具体的优化实现算法有改进的迭代尺度法 IIS、梯度下降法和拟牛顿法。 11.4.1 改进的迭代尺度法 已知训练数据集，由此可知经验概率分布 \\(\\tilde{P}(X,Y)\\) ，训练数据的对数似然函数为 $$L(w)=L_{\\tilde{P}}(P_w)=\\log\\prod_{x,y}P_w(y|x)&#94;{\\tilde{P}(x,y)}=\\sum_{x,y}\\tilde{P}(x,y)\\log P_w(y|x)$$ 其中 $$\\begin{aligned} P_w(y|x) &= \\frac{1}{Z(x)} \\exp\\sum_{k=1}&#94;K w_k f_k(y,x) \\\\ Z(x)&= \\sum_y \\exp\\sum_{k=1}&#94;Kw_kf_k(y,x) \\end{aligned}$$ 则 $$\\begin{eqnarray} L(w) &=& \\sum_{x,y}\\tilde{P}(x,y)\\log P_w(y|x) \\\\ &=& \\sum_{x,y}\\left[\\tilde{P}(x,y)\\sum_{k=1}&#94;Kw_kf_k(y,x)-\\tilde{P}(x,y)\\log Z_w(x)\\right] \\\\ &=& \\sum_{j=1}&#94;N\\sum_{k=1}&#94;Kw_kf_k(y_j,x_j)-\\sum_{j=1}&#94;N\\log Z_w(x_j) \\end{eqnarray}$$ 改进的迭代尺度法通过迭代的方法不断优化对数似然函数改变量的下界，达到极大化对数似然函数的目的。 设参数向量 \\(w\\) 的增量是 $$\\delta=(\\delta_1,\\delta_2,\\cdots,\\delta_K)&#94;\\text{T}$$ 根据 第六章 的方法，得到关于转移特征 \\(t_k\\) 的更新方程是 $$\\begin{eqnarray} \\text{E}_{\\tilde{P}}[t_k] &=& \\sum_{x,y}\\tilde{P}(x,y)\\sum_{i=1}&#94;{n+1}t_k(y_{i-1},y_i,x,i) \\\\ &=& \\sum_{x,y}\\tilde{P}(x)P(y|x)\\sum_{i=1}&#94;{n+1}t_k(y_{i-1},y_i,x,i)\\exp(\\delta_kT(x,y)) \\end{eqnarray} \\\\ k=1,2,\\cdots,K_1$$ 关于状态特征 \\(s_l\\) 的更新方程是 $$\\begin{eqnarray} \\text{E}_{\\tilde{P}}[s_l] &=& \\sum_{x,y}\\tilde{P}(x,y)\\sum_{i=1}&#94;{n+1}s_l(y_i,x,i) \\\\ &=& \\sum_{x,y}\\tilde{P}(x)P(y|x)\\sum_{i=1}&#94;{n}s_l(y_i,x,i)\\exp(\\delta_{K_1+l}T(x,y)) \\end{eqnarray} \\\\ l=1,2,\\cdots,K_2$$ 这里， \\(T(x,y)\\) 是在数据 \\((x,y)\\) 中出现所有特征数的总和 $$T(x,y)=\\sum_{k}f_k(y,x)=\\sum_{k=1}&#94;K\\sum_{i=1}&#94;{n+1}f_k(y_{i-1},y_i,x,i)$$ 算法 11.1（条件随机场模型学习的改进的迭代尺度法） 输入：特征函数 \\(t_1,t_2,\\cdots,t_{K_1}\\) ， \\(s_1,s_2,\\cdots,s_{K_2}\\) ；经验分布 \\(\\tilde{P}(x,y)\\) 输出：参数估计值 \\(\\hat{w}\\) ；模型 \\(P_{\\hat{w}}\\) (1) 对所有 \\(k\\in\\{1,2,\\cdots,K\\}\\) ，取初值 \\(w_k=0\\) (2) 对每一 \\(k\\in\\{1,2,\\cdots,K\\}\\) (2.a) 当 \\(k=1,2,\\cdots,K_1\\) 时，令 \\(\\delta_k\\) 是下面方程的解 $$\\sum_{x,y}\\tilde{P}(x)P(y|x)\\sum_{i=1}&#94;{n+1}t_k(y_{i-1},y_i,x,i)\\exp(\\delta_kT(x,y))=\\text{E}_{\\tilde{P}}[t_k]$$ 当 \\(k=K_1+l\\) ， \\(l=1,2,\\cdots,K_2\\) 时，令 \\(\\delta_{K_1+l}\\) 是下面方程的解 $$\\sum_{x,y}\\tilde{P}(x)P(y|x)\\sum_{i=1}&#94;{n}s_l(y_i,x,i)\\exp(\\delta_{K_1+l}T(x,y))=\\text{E}_{\\tilde{P}}[s_l]$$ 其中 $$T(x,y)=\\sum_{k}f_k(y,x)=\\sum_{k=1}&#94;K\\sum_{i=1}&#94;{n+1}f_k(y_{i-1},y_i,x,i)$$ (2.b) 更新 \\(w_k\\) ： \\(w_k\\gets w_k+\\delta_k\\) (3) 如果不是所有的 \\(w_k\\) 都收敛，\b重复步骤 (2) 上面算法中 \\(T(x,y)\\) 对不同的数据 \\((x,y)\\) 取值可能不同，为了处理这个问题，定义松弛特征 $$s(x,y)=S-\\sum_{k=1}&#94;K\\sum_{i=1}&#94;{n+1}f_k(y_{i-1},y_i,x,i)$$ 式中 \\(S\\) 是一个常数。选择足够大的常数 \\(S\\) 使得对训练数据集的所有数据 \\((x,y)\\) ， \\(s(x,y)\\geq0\\) 成立。这时特征总可取 \\(S\\) 。 对于转移特征 \\(t_k\\) ， \\(\\delta_k\\) 的更新方程是 $$\\sum_{x,y}\\tilde{P}(x)P(y|x)\\sum_{i=1}&#94;{n+1}t_k(y_{i-1},y_i,x,i)\\exp(\\delta_kS)=\\text{E}_{\\tilde{P}}[t_k] \\\\ \\delta_k=\\frac{1}{S}\\log\\frac{\\text{E}_{\\tilde{P}}[t_k]}{\\text{E}_P[t_k]}$$ 其中 $$\\text{E}_P[t_k]=\\sum_x\\tilde{P}(x)\\sum_{i=1}&#94;{n+1}\\sum_{y_{i-1}y_i}t_k(y_{i-1},y_i,x,i)\\frac{\\alpha_{i-1}&#94;\\text{T}(y_{i-1}|x)M_i(y_{i-1},y_i|x)\\beta_i(y_i|x)}{Z(x)}$$ 对于状态特征 \\(s_l\\) ， \\(\\delta_k\\) 的更新方程是 $$\\sum_{x,y}\\tilde{P}(x)P(y|x)\\sum_{i=1}&#94;{n}s_l(y_i,x,i)\\exp(\\delta_{K_1+l}S)=\\text{E}_{\\tilde{P}}[s_l] \\\\ \\delta_{K_1+l}=\\frac{1}{S}\\log\\frac{\\text{E}_{\\tilde{P}}[s_l]}{\\text{E}_P[s_l]}$$ 其中 $$\\text{E}_P[s_l]=\\sum_x\\tilde{P}(x)\\sum_{i=1}&#94;{n}\\sum_{y_i}s_l(y_i,x,i)\\frac{\\alpha_{i}&#94;\\text{T}(y_{i}|x)\\beta_i(y_i|x)}{Z(x)}$$ 以上算法称为算法 S，在算法 S 中需要使常数 \\(S\\) 取足够大，这样一来，每步迭代的增量会变大，算法收敛会变慢。算法 T 试图解决这个问题。算法 T 对每个观测序列 \\(x\\) 计算其特征总数最大值 \\(T(x)\\) $$T(x)=\\max_yT(x,y)$$ 利用前向-后向递推公式，可以很容易计算 \\(T(x)=t\\) 这时，关于转移特征参数的更新方程是 $$\\begin{eqnarray} \\text{E}_{\\tilde{P}}[t_k] &=& \\sum_{x,y}\\tilde{P}(x)P(y|x)\\sum_{i=1}&#94;{n+1}t_k(y_{i-1},y_i,x,i)\\exp(\\delta_kT(x)) \\\\ &=& \\sum_x\\tilde{P}(x)\\sum_yP(y|x)\\sum_{i=1}&#94;{n+1}t_k(y_{i-1},y_i,x,i)\\exp(\\delta_kT(x)) \\\\ &=& \\sum_x\\tilde{P}(x)a_{k,t}\\exp(\\delta_k\\cdot t) \\\\ &=& \\sum_{t=1}&#94;{T_\\text{max}}a_{k,t}\\beta_k&#94;t \\end{eqnarray}$$ 这里， \\(a_{k,t}\\) 是特征 \\(t_k\\) 的期望值， \\(\\delta_k=\\log\\beta_k\\) 。 \\(\\beta_k\\) 是上面方程唯一的实根，可以用牛顿法求解，从而得到相关的 \\(\\delta_k\\) 。 同理，关于状态特征的更新方程是 $$\\begin{eqnarray} \\text{E}_{\\tilde{P}}[s_l] &=& \\sum_{x,y}\\tilde{P}(x)P(y|x)\\sum_{i=1}&#94;{n}s_l(y_i,x,i)\\exp(\\delta_{K_1+l}T(x)) \\\\ &=& \\sum_x\\tilde{P}(x)\\sum_yP(y|x)\\sum_{i=1}&#94;{n}s_l(y_i,x,i)\\exp(\\delta_{K_1+l}T(x)) \\\\ &=& \\sum_x\\tilde{P}(x)b_{l,t}\\exp(\\delta_k\\cdot t) \\\\ &=& \\sum_{t=1}&#94;{T_\\text{max}}b_{l,t}\\gamma_l&#94;t \\end{eqnarray}$$ 这里， \\(b_{l,t}\\) 是特征 \\(s_l\\) 的期望值， \\(\\delta_l=\\log\\gamma_l\\) 。 \\(\\gamma_l\\) 是上面方程唯一的实根，可以用牛顿法求解，从而得到相关的 \\(\\delta_{K_1+l}\\) 。 11.4.2 拟牛顿法 对于条件随机场模型 $$P_w(y|x)=\\frac{\\exp\\left(\\sum_{i=1}&#94;nw_if_i(x,y)\\right)}{\\sum_y\\exp\\left(\\sum_{i=1}&#94;nw_if_i(x,y)\\right)}$$ 学习的优化目标函数是 $$\\min_{w\\in\\mathbb{R}&#94;n}f(w)=\\sum_x\\tilde{P}(x)\\log\\sum_y\\exp\\left(\\sum_{i=1}&#94;nw_if_i(x,y)\\right)-\\sum_{x,y}\\tilde{P}(x,y)\\sum_{i=1}&#94;nw_if_i(x,y)$$ 其梯度函数是 $$g(w)=\\sum_{x,y}\\tilde{P}(x)P_w(y|x)f(x,y)-\\text{E}_\\tilde{P}[f]$$ 算法 11.2（条件随机场模型学习的 BFGS 算法） 输入：特征函数 \\(f_1,f_2,\\cdots,f_n\\) ；经验分布 \\(\\tilde{P}(X,Y)\\) 输出：最优参数值 \\(\\hat{w}\\) ；最优模型 \\(P_{\\hat{w}}(y|x)\\) (1) 选定初始点 \\(w&#94;{(0)}\\) ，取 \\(\\mathbf{B}_0\\) 为正定对称矩阵，置 \\(k=0\\) (2) 计算 \\(g_k=g\\left(w&#94;{(k)}\\right)\\) ，若 \\(g_k=0\\) ，则停止计算，否则转 (3) (3) 由 \\(\\mathbf{B}_kp_k=-g_k\\) 求出 \\(p_k\\) (4) 一维搜索：求 \\(\\lambda_k\\) 使得 $$f\\left(w&#94;{(k)}+\\lambda_kp_k\\right)=\\min_{\\lambda\\geq0}f\\left(w&#94;{(k)}+\\lambda p_k\\right)$$ (5) 置 \\(w&#94;{(k+1)}=w&#94;{(k)}+\\lambda_k p_K\\) (6) 计算 \\(g_{k+1}=g\\left(w&#94;{(k+1)}\\right)\\) ，若 \\(g_{k+1}=0\\) ，则停止计算；，否则按下式计算 \\(\\mathbf{B}_{k+1}\\) $$\\mathbf{B}_{k+1}=\\mathbf{B}_k+\\frac{y_ky_K&#94;\\text{T}}{y_k&#94;\\text{T}\\delta_k}-\\frac{\\mathbf{B}_k\\delta_k\\delta_k&#94;\\text{T}\\mathbf{B}_k}{\\delta_k&#94;\\text{T}\\mathbf{B}_k\\delta_k}$$ 其中 $$y_k=g_{k+1}-g_k,\\ \\delta_k=w&#94;{(k+1)}-w&#94;{(k)}$$ (7) 置 \\(k=k+1\\) ，转 (3) 11.5 条件随机场的预测算法 条件随机场的预测问题是给定条件随机场 \\(P(Y|X)\\) 和输入序列（观测序列） \\(x\\) ，求条件概率最大的输出序列（标记序列） \\(y&#94;\\star\\) ，即对观测序列进行标注。条件随机场的预测算法是著名的 维特比算法 。 由条件随机场的简化形式，得 $$\\begin{eqnarray} y&#94;\\star &=& \\arg\\max_yP_w(y|x) \\\\ &=& \\arg\\max_y\\frac{\\exp\\left(w\\cdot F(y,x)\\right)}{Z_w(x)} \\\\ &=& \\arg\\max_y\\exp(w\\cdot F(y,x)) \\\\ &=& \\arg\\max_y(w\\cdot F(y,x)) \\end{eqnarray}$$ 于是，条件随机场的预测问题成为求非规范化概率最大的最优路径问题 $$\\max_y(w\\cdot F(y,x))$$ 这里，路径表示标记序列，其中 $$w=(w_1,w_2,\\cdots,w_K)&#94;\\text{T} \\\\ F(y,x)=(f_1(y,x),f_2(y,x),\\cdots,f_K(y,x))&#94;\\text{T} \\\\ f_k(y,x)=\\sum_{i=1}&#94;nf_k(y_{i-1},y_i,x,i),\\ k=1,2,\\cdots,K$$ 这里只需要计算非规范化概率，可以大大提高效率。将优化问题改写为 $$\\max_y\\sum_{i=1}&#94;nw\\cdot F_i(y_{i-1},y_i,x)$$ 其中 $$F_i(y_{i-1},y_i,x)=(f_1(y_{i-1},y_i,x,i),f_2(y_{i-1},y_i,x,i),\\cdots,f_K(y_{i-1},y_i,x,i))&#94;\\text{T}$$ 是局部特征向量。 下面叙述维特比算法。首先求出位置 1 的各个标记 \\(j=1,2,\\cdots,m\\) 的非规范化概率 $$\\delta_1(j)=w\\cdot F_1(y_0=\\text{start},y_1=j,x),\\ j=1,2,\\cdots,m$$ 一般的，由递推公式，求出到位置 \\(i\\) 的各个标记 \\(l=1,2,\\cdots,m\\) 的非规范化概率的最大值，同时记录非规范化概率最大值的路径 $$\\delta_i(l)=\\max_{1\\leq j\\leq m}\\left\\{\\delta_{i-1}(j)+w\\cdot F_i(y_{i-1}=j,y_i=l,x)\\right\\},\\ l=1,2,\\cdots,m \\\\ \\Psi_i(l)=\\arg\\max_{1\\leq j\\leq m}\\left\\{\\delta_{i-1}(j)+w\\cdot F_i(y_{i-1}=j,y_i=l,x)\\right\\},\\ l=1,2,\\cdots,m$$ 直到 \\(i=n\\) 时终止。这时求得非规范化概率最大值是 $$\\max_y(w\\cdot F(y,x))=\\max_{1\\leq j\\leq m}\\delta_n(j)$$ 以及最优路径的终点 $$y_n&#94;\\star=\\arg\\max_{1\\leq j\\leq m}\\delta_n(j)$$ 由此最优路径终点返回 $$y_i&#94;\\star=\\Psi_{i+1}(y_{i+1}&#94;\\star),\\ i=n-1,n-2,\\cdots,1$$ 求得最优路径 \\(y&#94;\\star=(y_1&#94;\\star,y_2&#94;\\star,\\cdots,y_n&#94;\\star)&#94;\\text{T}\\) 算法 11.3（条件随机场预测的维特比算法） 输入：模型特征向量 \\(F(y,x)\\) 和权值向量 \\(w\\) ，观测序列 \\(x=(x_1,x_2,\\cdots,x_n)\\) 输出：最优路径 \\(y&#94;\\star=(y_1&#94;\\star,y_2&#94;\\star,\\cdots,y_n&#94;\\star)&#94;\\text{T}\\) (1) 初始化 $$\\delta_1(j)=w\\cdot F_1(y_0=\\text{start},y_1=j,x),\\ j=1,2,\\cdots,m$$ (2) 递推，对 \\(i=2,3,\\cdots,n\\) $$\\delta_i(l)=\\max_{1\\leq j\\leq m}\\left\\{\\delta_{i-1}(j)+w\\cdot F_i(y_{i-1}=j,y_i=l,x)\\right\\},\\ l=1,2,\\cdots,m \\\\ \\Psi_i(l)=\\arg\\max_{1\\leq j\\leq m}\\left\\{\\delta_{i-1}(j)+w\\cdot F_i(y_{i-1}=j,y_i=l,x)\\right\\},\\ l=1,2,\\cdots,m$$ (3) 终止 $$\\max_y(w\\cdot F(y,x))=\\max_{1\\leq j\\leq m}\\delta_n(j) \\\\ y_n&#94;\\star=\\arg\\max_{1\\leq j\\leq m}\\delta_n(j)$$ (4) 返回路径 $$y_i&#94;\\star=\\Psi_{i+1}(y_{i+1}&#94;\\star),\\ i=n-1,n-2,\\cdots,1$$ 求得最优路径 \\(y&#94;\\star=(y_1&#94;\\star,y_2&#94;\\star,\\cdots,y_n&#94;\\star)&#94;\\text{T}\\) if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"读书笔记","url":"https://xutree.github.io/pages/2019/05/17/sl-11/"},{"title":"统计学习方法 第十章 隐马尔科夫模型","text":"隐马尔科夫模型（hidden Markov model，HMM）是可用于标注问题的统计学模型，描述由隐藏的马尔科夫链随机生成观测序列的过程，属于生成模型。隐马尔科夫模型在语音识别、自然语言处理、生物信息、模式识别等领域有着广泛的应用。 10.1 隐马尔科夫模型的基本概念 10.1.1 隐马尔科夫模型的定义 定义 10.1（隐马尔科夫模型的定义）隐马尔科夫模型是关于时序的概率模型，描述由一个隐藏的马尔科夫链随机生成不可观测的状态随机序列，再由各个状态生成一个观测而产生观测随机序列的过程。隐藏的马尔科夫链随机生成的状态的序列称为状态序列（state sequence）；每个状态生成一个观测，由此产生的观测随机序列称为观测序列（observation sequence）。序列的每一个位置又可以看作是一个时刻 隐马尔科夫模型由初始概率分布、状态转移概率分布以及观测概率分布确定。隐马尔科夫模型的形式定义如下： 设 \\(Q\\) 是所有可能的状态的集合， \\(V\\) 是所有可能的观测的集合 $$Q=\\{q_1,q_2,\\cdots,q_N\\},\\ V=\\{v_1,v_2,\\cdots,v_M\\}$$ 其中， \\(N\\) 是可能的状态数， \\(M\\) 是可能的观测数。 \\(I\\) 是长度为 \\(T\\) 的状态序列， \\(O\\) 是对应的观测序列 $$I=\\{i_1,i_2,\\cdots,i_T\\},\\ O=\\{o_1,o_2,\\cdots,o_T\\}$$ \\(A\\) 是状态转移概率矩阵 $$A=\\left[a_{ij}\\right]_{N\\times N}$$ 其中 $$a_{ij}=P(i_{t+1}=q_j|i_t=q_i),\\ i=1,2,\\cdots,N;\\ j=1,2,\\cdots,N$$ 是在 \\(t\\) 时刻处于状态 \\(q_i\\) 的条件下 \\(t+1\\) 时刻转移到状态 \\(q_j\\) 的概率。 \\(B\\) 是观测概率矩阵 $$B=\\left[b_j(k)\\right]_{N\\times M}$$ 其中 $$b_j(k)=P(o_t=v_k|i_t=q_j),\\ k=1,2,\\cdots,M;\\ j=1,2,\\cdots,N$$ 是在 \\(t\\) 时刻处于状态 \\(q_j\\) 的条件下观测生成 \\(v_k\\) 的概率。 \\(\\pi\\) 是初始状态概率向量 $$\\pi=(\\pi_i)$$ 其中 $$\\pi_i=P(i_1=q_i),\\ i=1,2,\\cdots,N$$ 是时刻 \\(t=1\\) 处于状态 \\(q_i\\) 的概率。 隐马尔科夫模型由初始状态概率向量 \\(\\pi\\) ，状态转移概率矩阵 \\(A\\) 和观测概率矩阵 \\(B\\) 决定。 \\(\\pi\\) 和 \\(A\\) 决定状态序列， \\(B\\) 决定观测序列。隐马尔科夫模型 \\(\\lambda\\) 可以用三元符号表示，即 $$\\lambda=(A,B,\\pi)$$ 称为隐马尔科夫模型的三要素。 隐马尔科夫模型作了两个基本假设： a. 齐次马尔科夫性假设 $$P(i_t|i_{t-1},o_{t-1},\\cdots,i_1,o_1)=P(i_t|i_{t-1}),\\ t=1,2,\\cdots,T$$ b. 观测独立性假设 $$P(o_t|i_T,o_T,i_{T-1},o_{T-1},\\cdots,i_{t+1},o_{t+1},i_t,i_{t-1},o_{t-1},\\cdots,i_1,o_1)=P(o_t|i_t)$$ 隐马尔科夫模型可以用于标注问题，这时状态对应着标记。标注问题是给定观测的序列预测其对应的标记序列。可以假设标注问题的数据是由隐马尔科夫模型生成的。这样我们可以利用隐马尔科夫模型的学习与预测算法进行标注。 10.1.2 观测序列的生成过程 算法 10.1（观测序列的生成) 输入：隐马尔科夫模型 \\(\\lambda=(A,B,\\pi)\\) ，观测序列长度 \\(T\\) 输出：观测序列 \\(O=(o_1,o_2,\\cdots,o_T)\\) (1) 按照初始状态分布 \\(\\pi\\) 产生状态 \\(i_1\\) (2) 令 \\(t=1\\) (3) 按照状态 \\(i_t\\) 的观测概率分布 \\(b_{i_t}(k)\\) 生成 \\(o_t\\) (4) 按照状态 \\(i_t\\) 的状态转移概率分布 \\(\\{a_{i_ti_{t+1}}\\}\\) 产生状态 \\(i_{t+1}\\) ， \\(i_{t+1}=1,2,\\cdots,,N\\) (5) 令 \\(t=t+1\\) ；如果 \\(t<T\\) ，转 (3)；否则，终止 10.1.3 隐马尔科夫模型的 3 个基本问题 \\(\\blacksquare\\) 概率计算问题 给定模型 \\(\\lambda=(A,B,\\pi)\\) 和观测序列 \\(O=(o_1,o_2,\\cdots,o_T)\\) ，计算在模型 \\(\\lambda\\) 下观测序列 \\(O\\) 出现的概率 \\(P(O|\\lambda)\\) 。 \\(\\blacksquare\\) 学习问题 已知观测序列 \\(O=(o_1,o_2,\\cdots,o_T)\\) ，估计模型参数 \\(\\lambda=(A,B,\\pi)\\) ，使得在该模型下观测序列 \\(P(O|\\lambda)\\) 最大。即用极大似然估计的方法估计参数。 \\(\\blacksquare\\) 预测问题 也称为解码（decoding）问题。已知模型 \\(\\lambda=(A,B,\\pi)\\) 和观测序列 \\(O=(o_1,o_2,\\cdots,o_T)\\) ，求对给定观测序列条件概率 \\(P(I|O)\\) 最大的状态序列 \\(I=(i_1,i_2,\\cdots,i_T)\\) 。即给定观测序列，求最可能的对应的状态序列。 10.2 概率计算算法 10.2.1 前向算法 定义 10.2（前向概率）给定隐马尔科夫模型 \\(\\lambda\\) ，定义到时刻 \\(t\\) 部分观测序列为 \\(o_1,o_2,\\cdots,o_t\\) 且状态为 \\(q_i\\) 的概率为前向概率，记作 $$\\alpha_i(t)=P(o_1,o_2,\\cdots,o_t,t_i=q_i|\\lambda)$$ 可以递推地求得前向概率 \\(\\alpha_t(i)\\) 及观测序列概率 \\(P(O|\\lambda)\\) 。 算法 10.2（观测序列概率的前向算法） 输入：隐马尔科夫模型 \\(\\lambda\\) ，观测序列 \\(O\\) 输出：观测序列概率 \\(P(O|\\lambda)\\) (1) 初值 $$\\alpha_1(i)=\\pi_ib_i(o_1),\\ i=1,2,\\cdots,N$$ (2) 递推 $$\\alpha_{t+1}(i)=\\left[\\sum_{j=1}&#94;N\\alpha_t(j)a_{ji}\\right]b_i(o_{t+1}),\\ i=1,2,\\cdots,N$$ (3) 终止 $$P(O|\\lambda)=\\sum_{i=1}&#94;N\\alpha_T(i)$$ 利用前向概率计算 \\(P(O|\\lambda)\\) 的计算量是 \\(O(N&#94;2T)\\) 阶的，而不是直接计算的 \\(O(TN&#94;T)\\) 阶。 10.2.2 后向算法 定义 10.3（后向概率）给定隐马尔科夫模型 \\(\\lambda\\) ，定义在时刻 \\(t\\) 状态为 \\(q_i\\) 的条件下，从 \\(t+1\\) 到 \\(T\\) 的部分观测序列为 \\(o_{t+1},o_{t+2},\\cdots,o_T\\) 的概率为后向概率，记作 $$\\beta_t(i)=P(o_{t+1},o_{t+2},\\cdots,o_{T}|i_t=q_i,\\lambda)$$ 可以用递推\b的方法求得后向概率以及观测序列概率 \\(P(O|\\lambda)\\) 。 算法 10.3（观测序列概率的后向算法） 输入：隐马尔科夫模型 \\(\\lambda\\) ，观测序列 \\(O\\) 输出：观测序列概率 \\(P(O|\\lambda)\\) (1) $$\\beta_T(i)=1,\\ i=1,2,\\cdots,N$$ (2) 对 \\(t=T-1,T-2,\\cdots,1\\) $$\\beta_t(i)=\\sum_{j=1}&#94;Na_{ij}b_j(o_{t+1})\\beta_{i+1}(j),\\ i=1,2,\\cdots,N$$ (3) $$P(O|\\lambda)=\\sum_{i=1}&#94;N\\pi_ib_i(o_1)\\beta_1(i)$$ 利用前向概率和后向概率的定义可以将观测序列概率 \\(P(O|\\lambda)\\) 统一写成 $$P(O|\\lambda)=\\sum_{i=1}&#94;N\\sum_{j=1}&#94;N\\alpha_t(i)a_{ij}b_j(o_{t+1})\\beta_{t+1}(j),\\ t=1,2,\\cdots,T-1$$ 当 \\(t=1\\) 或 \\(t=T-1\\) 时，分别为后向概率和前向概率。 \b根据定义，我们可得如下等式 $$\\alpha_t(i)\\beta_t(i)=P(i_t=q_i,O|\\lambda)$$ 10.2.3 一些概率与期望值的计算 \\(\\blacksquare\\) 给定模型 \\(\\lambda\\) 和观测 \\(O\\) ，在时刻 \\(t\\) 处于状态 \\(q_i\\) 概率 记 $$\\gamma_t(i)=P(i_t=q_i|O,\\lambda)$$ 则 $$\\gamma_t(i)=P(i_t=q_i|O,\\lambda)=\\frac{P(i_t=q_i,O|\\lambda)}{P(O|\\lambda)}=\\frac{\\alpha_t(i)\\beta_t(i)}{\\sum_{j=1}&#94;N\\alpha_t(j)\\beta_t(j)}$$ \\(\\blacksquare\\) 给定模型 \\(\\lambda\\) 和观测 \\(O\\) ，在时刻 \\(t\\) 处于状态 \\(q_i\\) 概率且在时刻 \\(t+1\\) 处于状态 \\(q_j\\) 的概率 记 $$\\xi_t(i,j)=P(i_t=q_i,i_{t+1}=q_j|O,\\lambda)$$ 则 $$\\begin{eqnarray} \\xi_t(i,j) &=& P(i_t=q_i,i_{t+1}=q_j|O,\\lambda)=\\frac{P(i_t=q_i,i_{t+1}=q_j,O|\\lambda)}{P(O|\\lambda)} \\\\ &=& \\frac{P(i_t=q_i,i_{t+1}=q_j,O|\\lambda)}{\\sum_{i=1}&#94;N\\sum_{j=1}&#94;NP(i_t=q_i,i_{t+1}=q_j,O|\\lambda)} \\\\ &=& \\frac{\\alpha_t(i)a_{ij}b_j(o_{t+1})\\beta_{t+1}(j)}{\\sum_{i=1}&#94;N\\sum_{j=1}&#94;N\\alpha_t(i)a_{ij}b_j(o_{t+1})\\beta_{t+1}(j)} \\end{eqnarray}$$ \\(\\blacksquare\\) 将 \\(\\gamma_t(i)\\) 和 \\(\\xi_t(i,j)\\) 对各个时刻 \\(t\\) 求和，可以得到一些有用的期望值 \ba. 在观测 \\(O\\) 下状态 \\(i\\) 出现的期望值 $$\\sum_{t=1}&#94;T\\gamma_t(i)$$ b. 在观测 \\(O\\) 下由状态 \\(i\\) 转移的期望值 $$\\sum_{t=1}&#94;{T-1}\\gamma_t(i)$$ c. 在观察 \\(O\\) 下由状态 \\(i\\) 转移到状态 \\(j\\) 的期望值 $$\\sum_{t=1}&#94;{T-1}\\xi_t(i,j)$$ 10.3 学习算法 隐马尔科夫模型的学习，根据训练数据是否包括观测序列和对应的状态序列还是只有观测序列，可以分别由监督学习与非监督学习实现。 10.3.1 监督学习方法 假设已给训练数据包含 \\(S\\) 个长度相同的观测序列和对应的状态序列 $$\\{(O_1,I_1),(O_2,I_2),\\cdots,(O_S,I_S)\\}$$ 那么可以用极大似然估计法来估计隐马尔科夫模型的参数。 \\(\\blacksquare\\) 转移概率 \\(a_{ij}\\) 的估计 设样本中时刻 \\(t\\) 处于状态 \\(i\\) 时刻 \\(t+1\\) 转移到状态 \\(j\\) 的频数是 \\(A_{ij}\\) ，那么状态转移概率 \\(a_{ij}\\) 的估计是 $$\\hat{a}_{ij}=\\frac{A_{ij}}{\\sum_{j=1}&#94;NA_{ij}},\\ i=1,2,\\cdots,N;\\ j=1,2,\\cdots,N$$ \\(\\blacksquare\\) 观测概率 \\(b_j(k)\\) 的估计 设样本中状态为 \\(j\\) 并观测为 \\(k\\) 的频数是 \\(B_{jk}\\) ，那么状态为 \\(j\\) 观测为 \\(k\\) 的概率 \\(b_j(k)\\) 的估计是 $$\\hat{b}_j(k)=\\frac{B_{jk}}{\\sum_{k=1}&#94;MB_{jk}},\\ j=1,2,\\cdots,N;\\ k=1,2,\\cdots,M$$ \\(\\blacksquare\\) 初始状态概率 \\(\\pi_i\\) 的估计 \\(\\hat{\\pi}_i\\) 为 \\(S\\) 个样本中初始状态为 \\(q_i\\) 的频率 由于监督学习需要使用训练数据，而人工标注训练数据往往代价很高，有时就会利用非监督学习的方法。 10.3.2 Baum-Welch 算法 \b假设给定训练数据只包含 \\(S\\) 个长度为 \\(T\\) 的观测序列 \\(\\{O_1,O_2,\\cdots,O_S\\}\\) 而没有对应的状态序列，目标是学习隐马尔科夫模型的参数。 我们将观测序列数据看做观测数据 \\(O\\) ，状态序列数据看做不可观测的隐数据 \\(I\\) ，那么隐马尔科夫模型实际上是一个含有隐变量的概率模型 $$P(O|\\lambda)=\\sum_{I}P(O|I,\\lambda)P(I|\\lambda)$$ 它的参数学习可以由 EM 算法 实现。 \\(\\blacksquare\\) 确定完全数据的对数似然函数 所有观测数据写成 \\(O=(o_1,o_2,\\cdots,o_T)\\) ，所有隐数据写成 \\(I=(i_1,i_2,\\cdots,i_T)\\) ，完全数据是 $$(O,I)=(o_1,o_2,\\cdots,o_T,i_1,i_2,\\cdots,i_T)$$ 完全数据的对数似然函数是 \\(\\log P(O,I|\\lambda)\\) \\(\\blacksquare\\) EM 算法的 E 步，求 \\(Q\\) 函数 \\(Q(\\lambda,\\bar{\\lambda})\\) $$Q(\\lambda,\\bar{\\lambda})=\\sum_I\\log P(O,I|\\lambda)P(O,I|\\bar{\\lambda})$$ 其中， \\(\\bar{\\lambda}\\) 是隐马尔科夫模型的当前估计值， \\(\\lambda\\) 是要极大化的隐马尔科夫模型参数， \\(Q\\) 函数其中略去了对 \\(\\lambda\\) 而言的常数因子 \\(1/P(O|\\bar{\\lambda})\\) $$P(O,I|\\lambda)=\\pi_{i_1}b_{i_1}(o_1)a_{i_1i_2}b_{i_2}(o_2)\\cdots,a_{i_{T-1}i_T}b_{i_T}(o_T)$$ 于是 $$\\begin{eqnarray} Q(\\lambda,\\bar{\\lambda}) &=& \\sum_I\\log\\pi_{i_1}P(O,I|\\bar{\\lambda}) \\\\ &+& \\sum_I\\left(\\sum_{t=1}&#94;{T-1}\\log a_{i_ti_{t+1}}\\right)P(O,I|\\bar{\\lambda}) \\\\ &+& \\sum_I\\left(\\sum_{t=1}&#94;T\\log b_{i_t}(o_t)\\right)P(O,I|\\bar{\\lambda}) \\end{eqnarray}$$ 式中求和都是对所有训练数据的序列总长度 \\(T\\) 进行的。\b \\(\\blacksquare\\) EM 算法的 M 步：极大化 \\(Q(\\lambda,\\bar{\\lambda})\\) 求模型参数 \\(\\lambda=(A,B,\\pi)\\) 由于要极大化的参数单独出现在 3 个项中，所以只需对各项分别极大化。 a. 第一项可写成 $$\\sum_I\\log\\pi_{i_1}P(O,I|\\bar{\\lambda})=\\sum_{i=1}&#94;N\\log\\pi_iP(O,i_1=q_i|\\bar{\\lambda})$$ 注意约束条件 \\(\\sum_{i=1}&#94;N\\pi_i=1\\) ，利用拉格朗日乘子法，写出拉格朗日函数 $$\\sum_{i=1}&#94;N\\log\\pi_iP(O,i_1=q_i|\\bar{\\lambda})+\\gamma\\left(\\sum_{i=1}&#94;N\\pi_i-1\\right)$$ 求偏导\b并令结果为 0，得 $$P(O,i_1=q_i|\\bar{\\lambda})+\\gamma\\pi_i=0$$ 对 \\(i\\) 求和得到 \\(\\gamma\\) $$\\gamma=-P(O|\\bar{\\lambda})$$ 带入得 $$\\pi_i=\\frac{P(O,i_1=q_i|\\bar{\\lambda})}{P(O|\\bar{\\lambda})}$$ b. 第二项可以写成 $$\\sum_I\\left(\\sum_{t=1}&#94;{T-1}\\log a_{i_ti_{t+1}}\\right)P(O,I|\\bar{\\lambda}) \\\\ =\\sum_{i=1}&#94;N\\sum_{j=1}&#94;N\\sum_{t=1}&#94;{T-1}\\log a_{ij}P(O,i_t=q_i,i_{t+1}=q_j|\\bar{\\lambda})$$ 注意约束条件 \\(\\sum_{j=1}&#94;Na_{ij}=1\\) ，利用拉格朗日乘子法求出 $$a_{ij}=\\frac{\\sum_{t=1}&#94;{T-1}P(O,i_t=q_i,i_{t+1}=q_j|\\bar{\\lambda})}{\\sum_{t=1}&#94;{T-1}P(O,i_t=q_i|\\bar{\\lambda})}$$ c. 第三项可以写成 $$\\sum_I\\left(\\sum_{t=1}&#94;T\\log b_{i_t}(o_t)\\right)P(O,I|\\bar{\\lambda}) \\\\ =\\sum_{j=1}&#94;N\\sum_{t=1}&#94;T\\log b_j(o_t)P(O,i_t=q_j|\\bar{\\lambda})$$ 注意约束条件 \\(\\sum_{k=1}&#94;Mb_{j}(k)=1\\) ，注意，只有在 \\(o_t=v_k\\) 时， \\(b_j(o_t)\\) 对 \\(b_j(k)\\) 的偏导才不是 0，利用拉格朗日乘子法求出 $$b_j(k)=\\frac{\\sum_{t=1}&#94;TP(O,i_t=q_j|\\bar{\\lambda})\\mathbb{I}(o_t=v_k)}{\\sum_{t=1}&#94;TP(O,i_t=q_j|\\bar{\\lambda})}$$ 10.3.3 Baum-Welch 模型参数估计公式 结合 10.2 节，得到 $$ a_{ij}=\\frac{\\sum_{t=1}&#94;{T-1}\\xi_t(i,j)}{\\sum_{t=1}&#94;{T-1}\\gamma_t(i)} \\\\ b_j(k)=\\frac{\\sum_{t=1,o_t=v_k}&#94;T\\gamma_t(j)}{\\sum_{t=1}&#94;T\\gamma_t(j)} \\\\ \\pi_i=\\gamma_1(i) $$ 算法 10.4（Baum-Welch 算法） 输入：观测数据 \\(O=(o_1,o_2,\\cdots,o_T)\\) 输出：隐马尔科夫模型参数 (1) 初始化 对 \\(n=0\\) ，\b选取 \\(a_{ij}&#94;{(0)}\\) ， \\(b_j(k)&#94;{(0)}\\) ， \\(\\pi_i&#94;{(0)}\\) ，得到模型 \\(\\lambda&#94;{(0)}=\\left(A&#94;{(0)},B&#94;{(0)},\\pi&#94;{(0)}\\right)\\) (2) 递推。对 \\(n=1,2,\\cdots,\\) $$a_{ij}&#94;{(n+1)}=\\frac{\\sum_{t=1}&#94;{T-1}\\xi_t(i,j)}{\\sum_{t=1}&#94;{T-1}\\gamma_t(i)} \\\\ b_j(k)&#94;{(n+1)}=\\frac{\\sum_{t=1,o_t=v_k}&#94;T\\gamma_t(j)}{\\sum_{t=1}&#94;T\\gamma_t(j)} \\\\ \\pi_i&#94;{(n+1)}=\\gamma_1(i)$$ 右端各式按观测 \\(O=(o_1,o_2,\\cdots,o_T)\\) 和模型 \\(\\lambda&#94;{(n)}=\\left(A&#94;{(n)},B&#94;{(n)},\\pi&#94;{(n)}\\right)\\) 计算，式中 $$\\gamma_t(i)=\\frac{\\alpha_t(i)\\beta_t(i)}{\\sum_{j=1}&#94;N\\alpha_t(j)\\beta_t(j)}\\\\ \\xi_t(i,j)=\\frac{\\alpha_t(i)a_{ij}b_j(o_{t+1})\\beta_{t+1}(j)}{\\sum_{i=1}&#94;N\\sum_{j=1}&#94;N\\alpha_t(i)a_{ij}b_j(o_{t+1})\\beta_{t+1}(j)}$$ (3) 终止。得到模型参数 \\(\\lambda&#94;{(n+1)}=\\left(A&#94;{(n+1)},B&#94;{(n+1)},\\pi&#94;{(n+1)}\\right)\\) 10.4 预测算法 10.4.1 近似算法 近似算法的思想是，在每个时刻 \\(t\\) 选择在该时刻最有可能出现的状态 \\(i_t&#94;\\star\\) ，从而得到一个状态序列\b \\(I&#94;\\star=(i_1&#94;\\star,i_2&#94;\\star,\\cdots,i_T&#94;\\star)\\) ，并将它作为预测的结果。 给定隐马尔科夫模型和观测序列，在时刻 \\(t\\) 处于状态 \\(q_i\\) 的概率 \\(\\gamma_t(i)\\) 是 $$\\gamma_t(i)=\\frac{\\alpha_t(i)\\beta_t(i)}{\\sum_{j=1}&#94;N\\alpha_t(j)\\beta_t(j)}$$ 在每一时刻 \\(t\\) 最有可能的状态 \\(i_t&#94;\\star\\) 是 $$i_t&#94;\\star=\\arg\\max_{1\\leq i\\leq N}[\\gamma_t(i)],\\ i=1,2,\\cdots,T$$ 从而得到状态序列 \\(I&#94;\\star=(i_1&#94;\\star,i_2&#94;\\star,\\cdots,i_T&#94;\\star)\\) 近似算法的优点是计算简单，其缺点是不能保证预测的状态序列整体是最有可能的状态序列，因为预测的状态序列可能有实际不发生的部分。事实上，上述方法得到的状态序列中有可能存在转移概率为 0 的相邻状态。尽管如此，近似算法仍然是有用的。 10.4.2 维特比算法 维特比算法实际上用动态规划隐马尔可夫模型预测问题，即，用动态规划（dynamic programming）求概率最大路径(最优路径)。这时一条路径对应着一个状态序列。 根据动态规划原理，最优路径具有这样的特征：如果最优路径在时刻 \\(t\\) 通过节点 \\(i_t&#94;\\star\\) ，那么这一路径中\"从节点 \\(i_1&#94;\\star\\) 到终点 \\(i_T&#94;\\star\\) 的部分路径\"对于\"从节点 \\(i_1&#94;\\star\\) 到终点 \\(i_T&#94;\\star\\) 的所有可能的部分路径\"来说必须是最优的。 根据这一原理，我们只需从时刻 \\(t=1\\) 开始，递推的计算在时刻 \\(t\\) 状态为 \\(i\\) 的各条部分路径的最大概率，直至得到时刻 \\(t=T\\) 时状态为 \\(i\\) 的各条路径的最大概率。时刻 \\(t=T\\) 的最大概率即为最优路径的概率 \\(P&#94;\\star\\) ，最优路径的终点 \\(i_T&#94;\\star\\) 也就同时得到了。 之后，为了找出最优路径的各个节点，从终结点 \\(i_T&#94;\\star\\) 开始，由后向前逐步求得节点 \\(i_{T-1}&#94;\\star,\\cdots,i_1&#94;\\star\\) ，得到最优路径 \\(I&#94;\\star=(i_1&#94;\\star,i_2&#94;\\star,\\cdots,i_T&#94;\\star)\\) 。这就是维特比算法。 首先定义在时刻 \\(t\\) 状态为 \\(i\\) 的所有单个路径 \\((i_1,i_2,\\cdots,i_t)\\) 中概率最大值为 $$\\delta_t(i)=\\max_{i_1,i_2,\\cdots,i_{t-1}}P(i_t=i,i_{t-1},\\cdots,i_1,o_t,\\cdots,o_1|\\lambda),\\ i=1,2,\\cdots,N$$ 得递推公式 $$\\begin{eqnarray} \\delta_{t+1}(i) &=& \\max_{i_1,i_2,\\cdots,i_{t}}P(i_{t+1}=i,i_{t},\\cdots,i_1,o_{t+1},\\cdots,o_1|\\lambda) \\\\ &=& \\max_{1\\leq j\\leq N}[\\delta_t(ja_{ji})]b_i(o_{t+1}),\\ i=1,2,\\cdots,N;\\ t=1,2,\\cdots,T-1 \\end{eqnarray}$$ 定义在时刻 \\(t\\) 状态为 \\(i\\) 的所有单个路径 \\((i_1,i_2,\\cdots,i_{t-1},i)\\) 中概率最大的路径的第 \\(t-1\\) 个节点为 $$\\psi_t(i)=\\arg\\max_{1\\leq j\\leq N}[\\delta_{t-1}(j)a_{ji}],\\ i=1,2,\\cdots,N$$ 算法 10.5（维特比算法） 输入：模型 \\(\\lambda=(A,B,\\pi)\\) 和观测 \\(O=(o_1,o_2,\\cdots,o_T)\\) 输出：最优路径 \\(I&#94;\\star=(i_1&#94;\\star,i_2&#94;\\star,\\cdots,i_T&#94;\\star)\\) (1) 初始化 $$\\delta_1(i)=\\pi_ib_i(o_1),\\ i=1,2,\\cdots,N \\\\ \\psi_1(i)=0,\\ i=1,2,\\cdots,N$$ (2) 递推，对 \\(t=2,3,\\cdots,T\\) $$\\delta_t(i)=\\max_{1\\leq j\\leq N}[\\delta_{t-1}(j)a_{ji}]b_i(o_t),\\ i=1,2,\\cdots,N \\\\ \\psi_t(i)=\\arg\\max_{1\\leq j\\leq N}[\\delta_{t-1}(j)a_{ji}],\\ i=1,2,\\cdots,N$$ (3) 终止 $$P&#94;\\star=\\max_{1\\leq i\\leq N}\\delta_T(i) \\\\ i_T&#94;\\star=\\arg\\max_{1\\leq i\\leq N}[\\delta_T(i)]$$ (4) 最优路径回溯，对 \\(t=T-1,T-2,\\cdots,1\\) $$i_t&#94;\\star=\\psi_{t+1}(i_{t+1}&#94;\\star)$$ 求得最优路径 \\(I&#94;\\star=(i_1&#94;\\star,i_2&#94;\\star,\\cdots,i_T&#94;\\star)\\) if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"读书笔记","url":"https://xutree.github.io/pages/2019/04/19/sl-10/"},{"title":"统计学习方法 第九章 EM 算法及其推广","text":"EM 算法是一种迭代算法，用于含有隐变量（hidden varibale）的概率模型参数的极大似然估计，或极大后验概率估计。EM 算法每次的迭代分两步：E 步，求期望（expectation）；M 步，求极大（maximization）。所以这一算法被称为期望极大算法（expectation maximization）。 9.1 EM 算法的引入 概率模型有时既含有观测变量（observable variable），又含有隐变量或潜在变量（latent variable）。如果概率模型的变量都是观测变量，那么给定数据，可以直接用极大似然估计法，或贝叶斯估计法估计模型参数。但是，当模型含有隐变量时，就不能简单的使用这些估计方法。EM 算法就是含有隐变量的概率模型参数的极大似然估计法，或极大后验概率估计法。 9.1.1 EM 算法 一般的，用 \\(Y\\) 表示观测随机变量的数据， \\(Z\\) 表示隐随机变量的数据。 \\(Y\\) 和 \\(Z\\) 连在一起称为完全数据（complete-data），观测数据 \\(Y\\) 又称为不完全数据（incomplete-data）。假设给定观测数据 \\(Y\\) ，其概率分布是 \\(P(Y|\\theta)\\) ，其中 \\(\\theta\\) 是需要估计的模型参数，那么不完全数据了 \\(Y\\) 的似然函数是 \\(P(Y|\\theta)\\) ，对数似然函数是 \\(L(\\theta)=\\log P(Y|\\theta)\\) ；假设 \\(Y\\) 和 \\(Z\\) 的联合概率分布是 \\(P(Y,Z|\\theta)\\) ，那么完全数据的对数似然函数是 \\(\\log P(Y,Z|\\theta)\\) 。 EM 算法通过迭代求 \\(L(\\theta)=\\log P(Y|\\theta)\\) 的极大似然估计。 算法 9.1（EM 算法） 输入：观测变量数据 \\(Y\\) ，隐变量数据 \\(Z\\) ，联合分布 \\(P(Y,Z|\\theta)\\) ，条件分布 \\(P(Z|Y,\\theta)\\) 输出：模型参数 \\(\\theta\\) (1) 选择参数的初值 \\(\\theta&#94;{(0)}\\) ，开始迭代 (2) E 步：记 \\(\\theta&#94;{(i)}\\) 为第 \\(i\\) 次迭代参数 \\(\\theta\\) 的估计值。在第 \\(i+1\\) 次迭代的 E 步，计算 $$\\begin{eqnarray} Q\\left(\\theta,\\theta&#94;{(i)}\\right) &=& \\text{E}_Z\\left[\\log P(Y,Z|\\theta)|Y,\\theta&#94;{(i)}\\right] \\\\ &=& \\sum_{Z}\\log P(Y,Z|\\theta)P(Z|Y,\\theta&#94;{(i)}) \\end{eqnarray}$$ 这里， \\(P(Z|Y,\\theta&#94;{(i)})\\) 是在给定观测数据 \\(Y\\) 和当前的参数估计 \\(\\theta&#94;{(i)}\\) 下隐变量数据 \\(Z\\) 的条件概率分布 (3) M 步：求极大，更新 \\(\\theta\\) $$\\theta&#94;{(i+1)}=\\arg\\max_{\\theta}Q\\left(\\theta,\\theta&#94;{(i)}\\right)$$ (4) 重复 (2)，(3)，直到收敛 \\(Q\\) 函数是 EM 算法的核心。 定义 9.1（ \\(Q\\) 函数）完全数据的对数似然函数 \\(\\log P(Y,Z|\\theta)\\) 关于在给定观测数据 \\(Y\\) 的当前参数 \\(\\theta&#94;{(i)}\\) 下对未观测数据 \\(Z\\) 的条件概率分布 \\(P\\left(Z|Y,\\theta&#94;{(i)}\\right)\\) 的期望称为 \\(Q\\) 函数，即 $$Q\\left(\\theta,\\theta&#94;{(i)}\\right)=\\text{E}_Z\\left[\\log P(Y,Z|\\theta)|Y,\\theta&#94;{(i)}\\right]$$ 关于 EM 算法需要注意：参数的初值可以任意选择，但需注意 EM 算法对初值是敏感的；给出停止迭代的条件，一般是对较小的正数 \\(\\epsilon_1\\) ， \\(\\epsilon_2\\) ，若满足 $$\\|\\theta&#94;{(i+1)}-\\theta&#94;{(i)}\\|<\\epsilon_1 $$ 或 $$\\left\\|Q\\left(\\theta&#94;{(i+1)},\\theta&#94;{(i)}\\right)-Q\\left(\\theta&#94;{(i)},\\theta&#94;{(i)}\\right)\\right\\|<\\epsilon_2$$ 则迭代停止。 9.1.2 EM 算法的推导 首先 $$\\begin{eqnarray} L(\\theta) &=& \\log P(Y|\\theta)=\\log\\sum_ZP(Y,Z|\\theta) \\\\ &=& \\log\\left(\\sum_ZP(Y|Z,\\theta)P(Z|\\theta)\\right) \\end{eqnarray}$$ 则 $$\\begin{eqnarray} L\\left(\\theta\\right)-L(\\theta&#94;{(i)}) &=& \\log\\left(\\sum_ZP(Y|Z,\\theta)P(Z|\\theta)\\right)-\\log P(Y|\\theta&#94;{(i)}) \\\\ &=& \\log\\left(\\sum_ZP(Z|Y,\\theta&#94;{(i)})\\frac{P(Y|Z,\\theta)P(Z|\\theta)}{P(Z|Y,\\theta&#94;{(i)})}\\right)-\\log P(Y|\\theta&#94;{(i)}) \\\\ &\\geq& \\sum_Z P(Z|Y,\\theta&#94;{(i)})\\log\\frac{P(Y|Z,\\theta)P(Z|\\theta)}{P(Z|Y,\\theta&#94;{(i)})}-\\log P(Y|\\theta&#94;{(i)}) \\\\ &=& \\sum_ZP(Z|Y,\\theta&#94;{(i)})\\log\\frac{P(Y|Z,\\theta)P(Z|\\theta)}{P(Z|Y,\\theta&#94;{(i)})P(Y|\\theta&#94;{(i)})} \\end{eqnarray}$$ 令 $$B(\\theta,\\theta&#94;{(i)})\\equiv L(\\theta&#94;{(i)})+\\sum_ZP(Z|Y,\\theta&#94;{(i)})\\log\\frac{P(Y|Z,\\theta)P(Z|\\theta)}{P(Z|Y,\\theta&#94;{(i)})P(Y|\\theta&#94;{(i)})}$$ 则只需要最大化 \\(B(\\theta,\\theta&#94;{(i)})\\) ，故 $$\\begin{eqnarray} \\theta&#94;{(i+1)} &=& \\arg\\max_\\theta\\left(L(\\theta&#94;{(i)})+\\sum_ZP(Z|Y,\\theta&#94;{(i)})\\log\\frac{P(Y|Z,\\theta)P(Z|\\theta)}{P(Z|Y,\\theta&#94;{(i)})P(Y|\\theta&#94;{(i)})}\\right) \\\\ &=& \\arg\\max_\\theta\\left(\\sum_ZP(Z|Y,\\theta&#94;{(i)})\\log\\left(P(Y|Z,\\theta)P(Z|\\theta)\\right)\\right) \\\\ &=& \\arg\\max_\\theta\\left(\\sum_ZP(Z|Y,\\theta&#94;{(i)})\\log P(Y,Z|\\theta)\\right) \\\\ &=& \\arg\\max_\\theta Q(\\theta,\\theta&#94;{(i)}) \\end{eqnarray}$$ EM 算法不能保证\b全局最优。 9.2 EM 算法的收敛性 定理 9.1 设 \\(P(Y|\\theta)\\) 为观测数据的似然函数， \\(\\theta&#94;{(i)}\\) 为 EM 算法得到的参数估计序列， \\(P(Y|\\theta&#94;{(i)})\\) 为对应的似然函数序列，则 \\(P(Y|\\theta&#94;{(i)})\\) 是单调递增的，即 $$P(Y|\\theta&#94;{(i+1)})\\geq P(Y|\\theta&#94;{(i)})$$ 定理 9.2 设 \\(L(\\theta)=\\log P(Y|\\theta)\\) 为观测数据的对数似然函数， \\(\\theta&#94;{(i)}\\) 为 EM 算法得到的参数估计序列， \\(L(\\theta&#94;{(i)})\\) 为对应的\b对数似然函数序列。 (1) 如果 \\(P(Y|\\theta)\\) 有界，则 \\(L(\\theta&#94;{(i)})=\\log P(Y|\\theta&#94;{(i)})\\) 收敛到某一值 \\(L&#94;\\star\\) (2) 在函数 \\(Q(\\theta,\\theta')\\) 与 \\(L(\\theta)\\) 满足一定条件下，由 EM 算法得到的参数估计序列 \\(\\theta&#94;{(i)}\\) 的收敛值 \\(\\theta&#94;\\star\\) 是 \\(L(\\theta)\\) 的稳定点 在应用中，初始值的选择很重要，常用的办法是选取几个不同的初值进行迭代，然后对得到的各个\b\b估计值加以比较，从中选择最好的。 9.3 EM 算法在高斯混合模型学习中的应用 EM 算法的一个重要应用是高斯混合模型的参数估计。高斯混合模型应用广泛，在许多情况下，EM 算法是学习高斯混合模型（Gaussian misture model）的有效方法。 9.3.1 高斯混合模型 定义 9.2（高斯混合模型）高斯混合模型是指具有如下形式的概率分布模型： $$P(y|\\theta)=\\sum_{k=1}&#94;K\\alpha_k\\phi(y|\\theta_k)$$ 其中， \\(\\alpha_k\\) 是系数， \\(\\alpha_k\\geq0\\) ， \\(\\sum_{k=1}&#94;K\\alpha_k=1\\) ； \\(\\phi(y|\\theta_k)\\) 是高斯分布密度， \\(\\theta_k=(\\mu_k,\\sigma_k&#94;2)\\) $$\\phi(y|\\theta_k)=\\frac{1}{\\sqrt{2\\pi}\\sigma_k}\\exp\\left(-\\frac{(y-\\mu_k)&#94;2}{2\\sigma_k&#94;2}\\right)$$ 称为第 \\(k\\) 个分模型。 一般混合模式可以由任意概率分布密度函数代替高斯分布密度。 9.3.2 高斯混合模型参数估计的 \bEM 算法 假设观测数据 \\(y_1,y_2,\\cdots,y_N\\) 由高斯混合模型\b生成 $$P(y|\\theta)=\\sum_{k=1}&#94;K\\alpha_k\\phi(y|\\theta_k)$$ 其中 \\(\\theta=(\\alpha_1,\\alpha_2,\\cdots,\\alpha_K;\\theta_1,\\theta_2,\\cdots,\\alpha_K)\\) 。我们用 EM 算法估计高斯混合模型的参数 \\(\\theta\\) 。 \\(\\blacksquare\\) 明确隐变量，写成完全数据的对数似然函数 引入隐变量 \\(\\gamma_{jk}\\) $$\\gamma_{jk}=\\begin{cases} 1, & 第\\ j\\ 个观测来自第\\ k\\ 个分模型 \\\\ 0, & 否则 \\end{cases} \\\\ j=1,2,\\cdots,N;\\ k=1,2,\\cdots,K$$ 于是，完全数据似然函数可以写成： $$\\begin{eqnarray} P(y,\\gamma|\\theta) &=& \\prod_{j=1}&#94;NP(y_j,\\gamma_{j1},\\gamma_{j2},\\cdots,\\gamma_{jK}|\\theta) \\\\ &=& \\prod_{k=1}&#94;K\\prod_{j=1}&#94;N\\left[\\alpha_k\\phi(y_j|\\theta_k)\\right]&#94;{\\gamma_{jk}} \\\\ &=& \\prod_{k=1}&#94;K\\alpha_k&#94;{n_k}\\prod_{j=1}&#94;N\\left[\\phi(y_j|\\theta_k)\\right]&#94;{\\gamma_{jk}} \\\\ &=& \\prod_{k=1}&#94;K\\alpha_k&#94;{n_k}\\prod_{j=1}&#94;N\\left[\\frac{1}{\\sqrt{2\\pi}\\sigma_k}\\exp\\left(-\\frac{(y_j-\\mu_k)&#94;2}{2\\sigma_k&#94;2}\\right)\\right]&#94;{\\gamma_{jk}} \\end{eqnarray}$$ 其中 $$n_k=\\sum_{j=1}&#94;N\\gamma_{jk},\\ \\sum_{k=1}&#94;Kn_k=N$$ 那么，完全数据的对数似然函数为 $$\\log P(y,\\gamma|\\theta)=\\sum_{k=1}&#94;K\\left\\{n_k\\log\\alpha_k+\\sum_{j=1}&#94;N\\gamma_{jk}\\left[\\log\\left(\\frac{1}{\\sqrt{2\\pi}}\\right)-\\log\\sigma_k-\\frac{1}{2\\sigma_k&#94;2}(y_j-\\mu_k)&#94;2\\right]\\right\\}$$ \\(\\blacksquare\\) EM 算法的 E 步：确定 \\(Q\\) 函数 $$\\begin{eqnarray} Q\\left(\\theta,\\theta&#94;{(i)}\\right) &=& \\text{E}\\left[\\log P(y,\\gamma|\\theta)|y,\\theta&#94;{(i)}\\right] \\\\ &=& \\text{E}\\left\\{\\sum_{k=1}&#94;K\\left\\{n_k\\log\\alpha_k+\\sum_{j=1}&#94;N\\gamma_{jk}\\left[\\log\\left(\\frac{1}{\\sqrt{2\\pi}}\\right)-\\log\\sigma_k-\\frac{1}{2\\sigma_k&#94;2}(y_j-\\mu_k)&#94;2\\right]\\right\\}\\right\\} \\\\ &=& \\sum_{k=1}&#94;K\\left\\{\\sum_{j=1}&#94;N\\text{E}[\\gamma_{jk}]\\log\\alpha_k+\\sum_{j=1}&#94;N\\text{E}[\\gamma_{jk}]\\left[\\log\\left(\\frac{1}{\\sqrt{2\\pi}}\\right)-\\log\\sigma_k-\\frac{1}{2\\sigma_k&#94;2}(y_j-\\mu_k)&#94;2\\right]\\right\\} \\end{eqnarray}$$ 这里需要计算 \\(\\text{E}[\\gamma_{jk}|y,\\theta]\\) ，记为 \\(\\hat{\\gamma}_{jk}\\) $$\\begin{eqnarray} \\hat{\\gamma}_{jk} &=& \\text{E}[\\gamma_{jk}|y,\\theta]=P(\\gamma_{jk}=1|y,\\theta) \\\\ &=& \\frac{P(\\gamma_{jk}=1,y_j|\\theta)}{\\sum_{k=1}&#94;KP(\\gamma_{jk}=1,y_j|\\theta)} \\\\ &=& \\frac{P(y_j|\\gamma_{jk}=1,\\theta)P(\\gamma_{jk}=1|\\theta)}{\\sum_{k=1}&#94;KP(y_j|\\gamma_{jk}=1,\\theta)P(\\gamma_{jk}=1|\\theta)} \\\\ &=& \\frac{\\alpha_k\\phi(y_j|\\theta_k)}{\\sum_{k=1}&#94;K\\alpha_k\\phi(y_j|\\theta_k)} \\end{eqnarray}$$ 其中 $$j=1,2,\\cdots,N;\\ k=1,2,\\cdots,K$$ \\(\\hat{\\gamma_{jk}}\\) 是在当前模型参数下第 \\(j\\) 个观测数据来及第 \\(k\\) 分模型的概率，称为分模型 \\(k\\) 对观测数据 \\(y_j\\) 的响应度。 将 \\(\\hat{\\gamma_{jk}}=\\text{E}[\\gamma_{jk}]\\) 及 \\(n_k=\\sum_{j=1}&#94;N\\text{E}[\\gamma_{jk}]\\) 带入上式，得 $$Q\\left(\\theta,\\theta&#94;{(i)}\\right)=\\sum_{k=1}&#94;K\\left\\{n_k\\log\\alpha_k+\\sum_{j=1}&#94;N\\gamma_{jk}\\left[\\log\\left(\\frac{1}{\\sqrt{2\\pi}}\\right)-\\log\\sigma_k-\\frac{1}{2\\sigma_k&#94;2}(y_j-\\mu_k)&#94;2\\right]\\right\\}$$ \\(\\blacksquare\\) 确定 EM 算法的 M 步 即令各偏导为零，得： $$\\hat{\\mu}_k\\equiv\\frac{\\partial Q}{\\partial \\mu_k}=\\frac{\\sum_{j=1}&#94;N\\hat{\\gamma}_{jk}y_j}{\\sum_{j=1}&#94;N\\hat{\\gamma}_{jk}} \\\\ \\hat{\\sigma_k}&#94;2\\equiv\\frac{\\partial Q}{\\partial \\sigma_k&#94;2}=\\frac{\\sum_{j=1}&#94;N\\hat{\\gamma}_{jk}(y_j-\\mu_k)&#94;2}{\\sum_{j=1}&#94;N\\hat{\\gamma}_{jk}} \\\\ \\hat{\\alpha}_k\\equiv\\frac{\\partial Q}{\\partial \\alpha_k}=\\frac{n_k}{N}=\\frac{\\sum_{j=1}&#94;N\\hat{\\gamma}_{jk}}{N} \\\\ k=1,2,\\cdots,K$$ 算法 9.2（高斯混合模型参数估计的 EM 算法） 输入：观测数据 \\(y_1,y_2,\\cdots,y_N\\) ，高斯混合模型 输出：高斯混合模型参数 (1) 取参数的初始值开始迭代 (2) E 步：根据当前模型参数，计算分模型 \\(k\\) 对观测数据 \\(y_j\\) 的响应度 $$\\hat{\\gamma}_{jk}=\\frac{\\alpha_k\\phi(y_j|\\theta_k)}{\\sum_{k=1}&#94;K\\alpha_k\\phi(y_j|\\theta_k)},\\ j=1,2,\\cdots,N;\\ k=1,2,\\cdots,K$$ (3) M 步：计算新一轮迭代的模型参数 $$\\hat{\\mu}_k=\\frac{\\sum_{j=1}&#94;N\\hat{\\gamma}_{jk}y_j}{\\sum_{j=1}&#94;N\\hat{\\gamma}_{jk}} \\\\ \\hat{\\sigma_k}&#94;2=\\frac{\\sum_{j=1}&#94;N\\hat{\\gamma}_{jk}(y_j-\\mu_k)&#94;2}{\\sum_{j=1}&#94;N\\hat{\\gamma}_{jk}} \\\\ \\hat{\\alpha}_k=\\frac{n_k}{N}=\\frac{\\sum_{j=1}&#94;N\\hat{\\gamma}_{jk}}{N} \\\\ k=1,2,\\cdots,K$$ (4) 重复 (2)，(3)，直到收敛 if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"读书笔记","url":"https://xutree.github.io/pages/2019/04/04/sl-9/"},{"title":"统计学习方法 第八章 提升方法","text":"提升（boosting）方法是一种常用的统计学习方法，应用广泛且有效。\b在分类问题中，它\b通过改变训练样本的权重，学习多个分类器，并将这些分类器进行线性组合，提高分类的性能。 8.1 提升方法 AdaBoost 算法 8.1.1 提升方法的基本思想 提升方法是一种可以用来减小监督式学习中偏差的机器学习元算法。面对的问题是迈可·肯斯（Michael Kearns）提出的：一组\"弱学习者\"的集合能否生成一个\"强学习者\"？弱学习者一般是指一个分类器，它的结果只比随机分类好一点点；强学习者指分类器的结果非常接近真值。 大多数的提升方法都是改变训练数据的概率分布（训练数据的权值分布），针对不同的训练数据分布调用弱学习算法学习一系列弱分类器。这样对于提升方法来说，有两个问题需要回答： 在每一轮如何改变训练数据的权值或概率分布 如何将弱分类器组合为一个强分类器 关于第一个问题，AdaBoost 的做法是，提高那些被前一轮分类器错误分类样本的权值，而降低那些被正确分类样本的权值。至于第二个问题，即弱分类器的组合，AdaBoost 采取加权多数表决的方法，具体的加大分类误差率小的弱分类器的权值，使其在表决中起较大的作用。 8.1.2 AdaBoost 算法 算法 8.1（AdaBoost） 输入：训练数据集 $$T=\\{(x_1,y_1),(x_2,y_2),\\cdots,(x_N,y_N)\\}$$ 其中 \\(x_i\\in{\\cal X}\\subseteq\\mathbb{R}&#94;n\\) ， \\(y_i\\inΥ=\\{−1,+1\\}\\) ；弱学习算法 输出：最终分类器 \\(G(x)\\) (1) 初始化训练数据的权值分布 $$D_1= (w_{11},\\cdots,w_{1i},w_{1N}),\\ w_{1i}=\\frac{1}{N},\\ i=1,2,\\cdots,N$$ (2) 对 \\(m=1,2,\\cdots,M\\) (2.a) 使用具有权值分布 \\(D_m\\) 的训练数据集学习，得到基本分类器 $$G_m(x):{\\cal X} \\rightarrow \\{-1,+1\\}$$ (2.b) 计算 \\(G_m(x)\\) 在训练数据集上的分类误差率 $$e_m = \\sum_{i=1}&#94;NP(G_m(x_i)\\neq y_i)=\\sum_{i=1}&#94;Nw_{mi}\\mathbb{I}(G_m(x_i)\\neq y_i)$$ (2.c) 计算 \\(G_m(x)\\) 的系数 $$\\alpha_m=\\frac{1}{2}\\log\\frac{1-e_m}{e_m}$$ 这里的对数是自然对数 (2.d) 更新训练数据集的权值分布 $$D_{m+1}=(w_{m+1,1},\\cdots,w_{m+1,i},\\cdots,w_{m+1,N}) \\\\ w_{m+1,i}=\\frac{w_{mi}}{Z_m}\\exp(-\\alpha_my_iG_m(x_i)),\\ i=1,2,\\cdots,N$$ 这里， \\(Z_m\\) 是规范化因子 $$Z_m=\\sum_{i=1}&#94;{N}w_{mi}\\exp\\left(-\\alpha_my_iG_m(x_i)\\right)$$ 它使 \\(D_{m+1}\\) 成为一个概率分布 (3) 构建基本分类器的线性组合 $$f(x)=\\sum_{m=1}&#94;{M}\\alpha_mG_m(x)$$ 得到最终分类器 $$G(x)=\\text{sign}(f(x))=\\text{sign}\\left(\\sum_{m=1}&#94;M\\alpha_mG_m(x)\\right)$$ \\(\\alpha_m\\) 表示 \\(G_m(x)\\) 在最终分类器中的重要性。当 \\(e_m\\leq\\frac{1}{2}\\) 时， \\(\\alpha_m\\geq0\\) ，并且 \\(\\alpha_m\\) 随着 \\(e_m\\) 的减小而增大。 更新数据的权值方案也可以写为 $$w_{m+1,i}=\\begin{cases} \\frac{w_{mi}}{Z_m}\\text{e}&#94;{-\\alpha_m}, & G_m(x_i)=y_i \\\\ \\frac{w_{mi}}{Z_m}\\text{e}&#94;{\\alpha_m}, & G_m(x_i)\\neq y_i \\end{cases}$$ 显然，正确分类样本的权值在缩小，错误分类样本的权值在增大，误分类样本的权值被放大 $$\\text{e}&#94;{2\\alpha_m}=\\frac{1-e_m}{e_m}$$ 8.2 AdaBoost 算法的训练误差分析 定理 8.1（AdaBoost 的训练误差界）AdaBoost 算法最终分类器的训练误差界为 $$\\frac{1}{N}\\sum_{i=1}&#94;N\\mathbb{I}\\left(G(x_i)\\neq y_i\\right)\\leq\\frac{1}{N}\\sum_{i=1}&#94;N\\exp(-y_if(x_i))=\\prod_{m=1}&#94;MZ_m$$ 其中 $$G(x)=\\text{sign}(f(x))=\\text{sign}\\left(\\sum_{m=1}&#94;M\\alpha_mG_m(x)\\right) \\\\ f(x)=\\sum_{m=1}&#94;{M}\\alpha_mG_m(x) \\\\ Z_m=\\sum_{i=1}&#94;{N}w_{mi}\\exp\\left(-\\alpha_my_iG_m(x_i)\\right)$$ 证明 ：当 \\(G(x_i)\\neq y_i\\) 时， \\(y_if(x_i)<0\\) ，因而 \\(\\exp(-y_if(x_i))\\geq1\\) ，前半部分成立。 对于后半部分，注意到 $$w_{mi}\\exp(-\\alpha_my_iG_m(x_i))=Z_mw_{m+1,i}$$ 则 $$\\begin{eqnarray} \\frac{1}{N} &\\sum_i& \\exp(-y_if(x_i)) \\\\ &=& \\frac{1}{N}\\sum_i\\exp\\left(-y_i\\sum_{m=1}&#94;{M}\\alpha_mG_m(x_i)\\right) \\\\ &=& \\frac{1}{N}\\sum_i\\prod_{m=1}&#94;M\\exp\\left(-y_i\\alpha_mG_m(x_i)\\right) \\\\ &=& \\sum_iw_{1i}\\prod_{m=1}&#94;M\\exp\\left(-y_i\\alpha_mG_m(x_i)\\right) \\\\ &=& Z_1\\sum_iw_{2i}\\prod_{m=2}&#94;M\\exp\\left(-y_i\\alpha_mG_m(x_i)\\right) \\\\ &=& Z_1Z_2\\sum_iw_{3i}\\prod_{m=3}&#94;M\\exp\\left(-y_i\\alpha_mG_m(x_i)\\right) \\\\ &=& \\cdots \\\\ &=& \\prod_{m=1}&#94;MZ_m \\end{eqnarray}$$ 这一定理说明，可以在每一轮选取适当的 \\(G_m\\) 使得 \\(Z_m\\) 最小，从而使训练误差下降最快。 定理 8.2（二类分类问题 AdaBoost 的训练误差界） $$\\prod_{m=1}&#94;MZ_m=\\prod_{m=1}&#94;M\\left[2\\sqrt{e_m(1-e_m)}\\right]=\\prod_{m=1}&#94;M\\sqrt{(1-4\\gamma_m&#94;2)}\\leq\\exp\\left(-2\\sum_{m=1}&#94;M\\gamma_m&#94;2\\right)$$ 这里， \\(\\gamma_m=\\frac{1}{2}-e_m\\) 证明 ：对二类分类问题 $$\\begin{eqnarray} Z_m &=& \\sum_{i=1}&#94;Nw_{mi}\\exp(-\\alpha_my_iG_m(x_i)) \\\\ &=& \\sum_{y_i=G_m(x_i)}w_{mi}\\text{e}&#94;{-\\alpha_m}+\\sum_{y_i\\neq G_m(x_i)}w_{mi}\\text{e}&#94;{\\alpha_m} \\\\ &=& (1-e_m)\\text{e}&#94;{-\\alpha_m}+e_m\\text{e}&#94;{\\alpha_m} \\\\ &=& 2\\sqrt{e_m(1-e_m)}=\\sqrt{1-4\\gamma_m&#94;2} \\end{eqnarray}$$ 后半部分证明可以由 \\(\\text{e}&#94;x\\) 和 \\(\\sqrt{1-x}\\) 在点 \\(x=0\\) 的泰勒展开式推出不等式 $$\\sqrt{1-4\\gamma_m&#94;2}\\leq\\exp(-2\\gamma_m&#94;2)$$ 进而得到。 推论 8.1 如果存在 \\(\\gamma>0\\) ，对所有的 \\(m\\) 有 \\(\\gamma_m\\geq\\gamma\\) ，则 $$\\frac{1}{N}\\sum_{i=1}&#94;N\\mathbb{I}\\left(G(x_i)\\neq y_i\\right)\\leq\\exp(-2M\\gamma&#94;2)$$ 这表明在此条件下，AdaBoost 训练误差关于训练次数 \\(M\\) 以指数速率下降。 8.3 AdaBoost 算法的解释 AdaBoost \b算法还有另外一个解释，即可以\b认为 AdaBoost 算法是模型为加法模型，损失函数\b为指数函数，学习算法为前向分步算法时的二类分类学习方法。 8.3.1 前向分步算法 考虑加法模型（additive model） $$f(x)=\\sum_{m=1}&#94;M\\beta_mb(x;\\gamma_m)$$ 其中， \\(b\\left(x;\\gamma_{m}\\right)\\) 为基函数， \\(\\beta_{m}\\) 为基函数系数， \\(\\gamma_{m}\\) 为基函数参数。 在给定训练数据及损失函数 \\(L\\left(y,f\\left(x\\right)\\right)\\) 的条件下，学习加法模型 \\(f\\left(x\\right)\\) 成为经验风险极小化问题 $$\\begin{align*} \\\\ & \\min_{\\beta_{m},\\gamma_{m}} \\sum_{i=1}&#94;{N} L \\left( y_{i}, \\sum_{m=1}&#94;{M} \\beta_{m} b\\left(x_{i};\\gamma_{m}\\right) \\right) \\end{align*}$$ 通常这是一个复杂的优化问题。前向分步算法（forward stagewise algorithm）\b求解这一问题的想法是：因为学习是加法模型，如果能够从前向后，每一步只学习一个基函数及其系数，逐步逼近优化目标函数式，那么就可以简化优化的复杂度。具体的，每步只需优化如下损失函数 $$\\begin{align*} \\\\ & \\min_{\\beta,\\gamma} \\sum_{i=1}&#94;{N} L \\left( y_{i}, \\beta b\\left(x_{i};\\gamma\\right) \\right) \\end{align*}$$ \b算法 8.2（前向分步算法） 输入：训练数据集 $$T=\\left\\{(x_{1},y_{1}),(x_{2},y_{2}),\\cdots,(x_{N},y_{N})\\right\\}$$ 损失函数 \\(L\\left(y,f\\left(x\\right)\\right)\\) ；基函数集 \\(\\left\\{b\\left(x;\\gamma\\right)\\right\\}\\) 输出：加法模型 \\(f\\left(x\\right)\\) (1) 初始化 \\(f_{0}\\left(x\\right)=0\\) (2) 对 \\(m=1,2,\\cdots,M\\) (2.a) 极小化损失函数 $$\\begin{align*} \\\\ & \\left(\\beta_{m},\\gamma_{m}\\right) = \\arg \\min_{\\beta,\\gamma} \\sum_{i=1}&#94;{N} L \\left( y_{i},f_{m-1} \\left(x_{i}\\right) + \\beta b\\left(x_{i};\\gamma \\right)\\right) \\end{align*}$$ 得到参数 \\(\\beta_{m}\\) ， \\(\\gamma_{m}\\) (2.b) 更新 $$\\begin{align*} \\\\& f_{m} \\left(x\\right) = f_{m-1} \\left(x\\right) + \\beta_{m} b\\left(x;\\gamma_{m}\\right) \\end{align*}$$ (3) 得到加法模型 $$\\begin{align*} \\\\ & f \\left( x \\right) = f_{M} \\left( x \\right) = \\sum_{m=1}&#94;{M} \\beta_{m} b \\left( x; \\gamma_{m} \\right) \\end{align*}$$ 8.3.2 前向分布算法与 AdaBoost 定理 8.3 AdaBoost 算法是前向分布加法算法的特例。这时模型是由基本分类器组成的加法模型，损失函数是指数函数。 证明 ：加法模型等价于 AdaBoost 的最终分类器 $$f(x)=\\sum_{m=1}&#94;{M}\\alpha_{m}G_{m}(x)$$ 由基本分类器 \\(G_{m}(x)\\) 及其系数 \\(\\alpha_{m}\\) 组成， \\(m=1,2,\\cdots,M\\) 。前向分布算法逐一学习基本函数，这一过程与 AdaBoost 算法逐一学习基本分类器的过程一致。下面证明前向分布算法的损失函数是指数损失函数（exponential loss function） $$L(y,f(x))=exp[-yf(x)]$$ 时，其学习的具体操作等价于 AdaBoost 算法学习的具体操作。 假设经过 \\(m-1\\) 轮迭代前向分布算法已经得到 \\(f_{m-1}(x)\\) ： $$\\begin{eqnarray} f_{m-1}(x) &=& f_{m-2}(x)+\\alpha_{m-1}G_{m-1}(x) \\\\ &=& \\alpha_{1}G_{1}(x)+\\cdots +\\alpha_{m-1}G_{m-1}(x) \\end{eqnarray}$$ 在第 \\(m\\) 轮得到 \\(\\alpha_{m}\\) ， \\(G_{m}(x)\\) 和 \\(f_{m}(x)\\) $$f_{m}(x)=f_{m-1}(x)+\\alpha_{m}G_{m}(x)$$ 目标是使前向算法得到的 \\(\\alpha_{m}\\) 和 \\(G_{m}\\) 使 \\(f_{m}(x)\\) 在训练数据集 \\(T\\) 上的指数损失最小，即： $$\\left(\\alpha_{m},G_{m}(x)\\right)=\\arg\\underset{\\alpha,G}{\\min}\\sum_{i=1}&#94;{N}\\exp\\left[-y_{i}(f_{m-1}(x_{i})+\\alpha G(x_{i}))\\right]$$ 可以表示成： $$(\\alpha_{m},G_{m}(x))=\\arg\\underset{\\alpha,G}{\\min}\\sum_{i=1}&#94;{N}\\overline{w}_{mi}\\exp[-y_{i}\\alpha G(x_{i})]$$ 其中 $$\\overline{w}_{mi}=\\exp[-y_{i}f_{m-1}(x_{i})]$$ \\(\\overline{w}_{mi}\\) 不依赖于 \\(\\alpha\\) ，也不依赖于 \\(G\\) \b，但依赖于 \\(f_{m-1}(x)\\) ，随着每一轮迭代而发生改变。 首先求 \\(G_{m}&#94;{\\star}(x)\\) ，进一步展开： $$\\begin{eqnarray} \\sum_{i=1}&#94;{N}\\overline{w}_{mi}\\exp[-y_{i}\\alpha G(x_{i})] &=& \\sum_{i=1}&#94;{N}\\overline{w}_{mi}\\text{e}&#94;{-\\alpha}\\mathbb{I}(y_{i}=G(x_{i}))+\\sum_{i=1}&#94;{N}\\overline{w}_{mi}\\text{e}&#94;{\\alpha}\\mathbb{I}(y_{i}\\neq G(x_{i})) \\\\ &=& \\text{e}&#94;{-\\alpha}\\sum_{i=1}&#94;{N}\\overline{w}_{mi}\\mathbb{I}(y_{i}=G(x_{i}))+\\text{e}&#94;{\\alpha}\\sum_{i=1}&#94;{N}\\overline{w}_{mi}\\mathbb{I}(y_{i}\\neq G(x_{i})) \\\\ &+& \\text{e}&#94;{-\\alpha}\\sum_{i=1}&#94;{N}\\overline{w}_{mi}\\mathbb{I}(y_{i}\\neq G(x_{i}))-e&#94;{-\\alpha}\\sum_{i=1}&#94;{N}\\overline{w}_{mi}\\mathbb{I}(y_{i}\\neq G(x_{i})) \\\\ &=& \\text{e}&#94;{-\\alpha}\\sum_{i=1}&#94;{N}\\overline{w}_{mi}+(\\text{e}&#94;{\\alpha}-\\text{e}&#94;{-\\alpha})\\sum_{i=1}&#94;{N}\\overline{w}_{mi}\\mathbb{I}(y_{i}\\neq G(x_{i})) \\end{eqnarray}$$ 所以最小化 \\(G(x)\\) 由下式得到： $$G_{m}&#94;{\\star}(x)=\\arg\\underset{G}{\\min}\\sum_{i=1}&#94;{N}\\overline{w}_{mi}\\mathbb{I}(y_{i}\\neq G(x_{i}))$$ 之后我们求解 \\(\\alpha_{m}&#94;{\\star}\\) ： $$\\sum_{i=1}&#94;{N}\\overline{w}_{mi}\\exp[-y_{i}\\alpha G(x_{i})]=\\sum_{y_{i}=G_{m}(x_{i})}\\overline{w}_{mi}\\text{e}&#94;{-\\alpha}+\\sum_{y_{i}\\neq G_{m}(x_{i})}\\overline{w}_{mi}\\text{e}&#94;{\\alpha}\\\\ =\\text{e}&#94;{-\\alpha}\\sum_{i=1}&#94;{N}\\overline{w}_{mi}+(\\text{e}&#94;{\\alpha}-\\text{e}&#94;{-\\alpha})\\sum_{i=1}&#94;{N}\\overline{w}_{mi}\\mathbb{I}(y_{i}\\neq G(x_{i}))$$ 对 \\(\\alpha\\) 求导： $$\\frac{\\partial }{\\partial \\alpha}\\left(\\text{e}&#94;{-\\alpha}\\sum_{i=1}&#94;{N}\\overline{w}_{mi}+(\\text{e}&#94;{\\alpha}-\\text{e}&#94;{-\\alpha})\\sum_{i=1}&#94;{N}\\overline{w}_{mi}\\mathbb{I}(y_{i}\\neq G(x_{i}))\\right)\\\\ =-\\text{e}&#94;{-\\alpha}\\sum_{i=1}&#94;{N}\\overline{w}_{mi}+(\\text{e}&#94;{\\alpha}+\\text{e}&#94;{-\\alpha})\\sum_{i=1}&#94;{N}\\overline{w}_{mi}\\mathbb{I}(y_{i}\\neq G(x_{i}))=0$$ 即得： $$\\frac{\\text{e}&#94;{\\alpha}+\\text{e}&#94;{-\\alpha}}{\\text{e}&#94;{-\\alpha}}=\\frac {\\sum_{i=1}&#94;{N}\\overline{w}_{mi}}{\\sum_{i=1}&#94;{N}\\overline{w}_{mi}\\mathbb{I}(y_{i}\\neq G(x_{i}))} \\\\ \\alpha_{m}&#94;{\\star}=\\frac{1}{2}\\log\\frac{1-e_{m}}{e_{m}}$$ 其中 \\(e_{m}\\) 是分类错误率： $$e_{m}=\\frac {\\sum_{i=1}&#94;{N}\\overline{w}_{mi}\\mathbb{I}(y_{i}\\neq G(x_{i}))}{\\sum_{i=1}&#94;{N}\\overline{w}_{mi}}=\\sum_{i=1}&#94;{N}w_{mi}\\mathbb{I}(y_{i}\\neq G(x_{i}))$$ 这里的 \\(\\alpha_{m}&#94;{\\star}\\) 与 AdaBoost 算法的 \\(\\alpha_{m}\\) 完全一致。 再看一下每一轮的权值更新，由： $$f_{m}(x)=f_{m-1}(x)+\\alpha_{m}G_{m}(x)$$ 以及 $$\\overline{w}_{mi}=\\exp[-y_{i}f_{m-1}(x_{i})]$$ 可得： $$\\overline{w}_{m+1,i}=\\overline{w}_{m,i}\\exp[-y_{i}\\alpha_{m}G_{m}(x)]$$ 这与 AdaBoost 算法的样本权值的更新，只相差规范会因子，因此等价。 8.4 提升树 提升树是以分类或回归树为基本分类器的提升方法。提升树被认为是统计学习中性能最好的方法之一。 8.4.1 提升树模型 提升方法实际采用加法模型（即基函数的线性组合）与前向分布算法。以决策树为基函数的提升方法称为提升树（boosting tree）。对分类问题决策树是二叉分类树，对回归问题决策树是二叉回归树。只有一个条件的基本分类器可以看做是由一个根结点直接连接两个叶结点简单决策树，即所谓的决策树桩（decision stump）。提升树模型可以表示为决策树的加法模型： $$f_{M}(x)=\\sum_{m=1}&#94;{M}T(x;\\Theta_{m})$$ 其中， \\(T(x;\\Theta_{m})\\) 表示决策树； \\(\\Theta_{m}\\) 为决策树的参数； \\(M\\) 为树的个数。提升树中树之间没有权重，或者说它们的权重都是一样的，树之间是独立的，训练样本之间也没有权重的概念，这是提升树和随机森林、AdaBoost 之间的区别。 8.4.2 提升树算法 提升树算法采用前向分步算法。首先确定初始提升树 \\(f_{0}(x)=0\\) ，第 \\(m\\) 步的模型是： $$f_{m}(x)=f_{m-1}(x)+T(x;\\Theta_{m})$$ 其中， \\(f_{m-1}(x)\\) 为当前模型，通过经验风险最小化确定下一决策树的参数 \\(\\Theta_{m}\\) ： $$\\hat {\\Theta}_{m}=\\arg\\underset{\\Theta_{m}}{\\min}\\sum_{i=1}&#94;{N}L(y_{i},f_{m-1}(x_{i})+T(x_{i};\\Theta_{m})$$ 不同问题的提升树有不同的学习算法，其主要区别在于使用的损失函数不同。包含用平凡误差损失函数的回归问题，用指数损失函数的分类问题，以及用一般损失函数的一般决策问题。对于二分类问题，提升树只需将 Adaboost 算法的基本分类器限制为二分类即可，可以说这时的提升树算法是 Adaboost 算法的特殊情况。下面主要讨论下回归问题。 已知训练数据集 $$\\begin{align*} \\\\& T = \\left\\{ \\left( x_{1}, y_{1} \\right), \\left( x_{2}, y_{2} \\right), \\cdots, \\left( x_{N}, y_{N} \\right) \\right\\} \\end{align*} \\\\ $$ 其中， \\(x_{i} \\in \\mathcal{X} \\subseteq \\mathbb{R}&#94;{n}\\) ， \\(y_{i} \\in \\mathcal{Y} \\subseteq \\mathbb{R}\\) ， \\(i = 1, 2,\\cdots, N\\) 。 将输入空间 \\(\\mathcal{X}\\) 划分为 \\(J\\) 个互不相交的区域 \\(R_{1},R_{2},\\cdots,R_{J}\\) ，且在每个区域上确定输出的常量 \\(c_{j}\\) ，则回归树 $$\\begin{align*} \\\\& T \\left(x; \\varTheta\\right) = \\sum_{j=1}&#94;{J} c_{j} \\mathbb{I} \\left(x \\in R_{j}\\right) \\end{align*} \\\\$$ 其中，参数 $$\\varTheta = \\left\\{ \\left(R_{1}, c_{1}\\right),\\left(R_{2}, c_{2}\\right),\\cdots,\\left(R_{J}, c_{J}\\right) \\right\\}$$ 表示树的区域划分和各区域上的常数。 \\(J\\) 是回归树的复杂度即叶结点个数。 回归提升树使用前向分布算法 $$\\begin{align*} \\\\& f_{0}=0 \\\\ & f_{m}\\left(x\\right) = f_{m-1}\\left(x\\right) + T \\left(x; \\varTheta_{m}\\right),\\ m=1,2,\\cdots,M\\\\ & f_{M} = \\sum_{m=1}&#94;{M} T \\left(x; \\varTheta_{m}\\right) \\end{align*} \\\\$$ 在前向分布算法的第 \\(m\\) 步给定当前模型 \\(f_{m-1}\\left(x\\right)\\) ，模型参数 $$\\begin{align*} \\\\& \\hat \\varTheta_{m} = \\arg \\min_{\\varTheta_{m}} \\sum_{i=1}&#94;{N} L \\left( y_{i}, f_{m-1}\\left(x_{i}\\right) + T \\left( x_{i}; \\varTheta_{m} \\right) \\right) \\end{align*} \\\\ $$ 得到第 \\(m\\) 棵树的参数 \\(\\hat \\varTheta_{m}\\) 当采用平方误差损失函数 $$\\begin{align*} \\\\& L \\left( y, f_{m-1}\\left(x\\right)+T\\left(x;\\varTheta_{m}\\right)\\right) \\\\ & = \\left[y-f_{m-1}\\left(x\\right)-T\\left(x;\\varTheta_{m}\\right)\\right]&#94;{2} \\\\ & = \\left[r-T\\left(x;\\varTheta_{m}\\right)\\right]&#94;{2}\\end{align*} \\\\ $$ 其中， \\(r=y-f_{m-1}\\left(x\\right)\\) 是当前\b模型拟合数据的残差。 算法 8.3（回归问题的提升树方法） 输入：训练数据集 $$T = \\left\\{ \\left( x_{1}, y_{1} \\right), \\left( x_{2}, y_{2} \\right), \\cdots, \\left( x_{N}, y_{N} \\right) \\right\\}$$ \\(x_{i} \\in \\mathcal{X} \\subseteq R&#94;{n}\\) ， \\(y_{i} \\in \\mathcal{Y} \\subseteq R\\) ， \\(i = 1, 2, \\cdots, N\\) 输出：回归提升树 \\(f_{M}\\left(x\\right)\\) (1) 初始化 \\(f_{0}\\left(x\\right)=0\\) (2) 对 \\(m=1,2,\\cdots,M\\) (2.) 计算残差 $$\\begin{align*} \\\\ & r_{mi}=y_{i}-f_{m-1}\\left(x_{i}\\right),\\quad i=1,2,\\cdots,N \\end{align*}$$ (2.b) 拟合残差 \\(r_{mi}\\) 学习一个回归树，得到 \\(T\\left(x;\\varTheta_{m}\\right)\\) (2.c) 更新 $$f_{m}=f_{m-1}\\left(x\\right)+T\\left(x;\\varTheta_{m}\\right)$$ (3) 得到回归提升树 $$\\begin{align*} \\\\ & f_{M} \\left( x \\right) = \\sum_{m=1}&#94;{M} T \\left(x;\\varTheta_{m}\\right) \\end{align*}$$ 8.4.3 梯度提升 提升树用加法模型与前向分布算法实现学习的优化过程。当损失函数是平方损失函数时，每一步优化是很简单的，但是对一般损失函数而言，往往每一步优化并不那么容易。因此Freidman提过了梯度提升（gradient boosting）。这是利用最速下降法的近似方法，其关键是利用损失函数的负梯度在当前模型的值： $$-\\left [ \\frac{\\partial L(y_{i},f(x_{i}))}{\\partial f(x_{i})} \\right]_{f(x)=f_{m-1}(x)}$$ 作为回归问题提升树算法中的残差近似值，拟合一个回归树。 算法 8.4（梯度提升算法） 输入：训练数据集 $$T = \\left\\{ \\left( x_{1}, y_{1} \\right), \\left( x_{2}, y_{2} \\right), \\cdots, \\left( x_{N}, y_{N} \\right) \\right\\}$$ \\(x_{i} \\in \\mathcal{X} \\subseteq \\mathbb{R}&#94;{n}\\) ， \\(y_{i} \\in \\mathcal{Y} \\subseteq \\mathbb{R}\\) ， \\(i = 1, 2, \\cdots, N\\) ，最大迭代次数 \\(M\\) ，损失函数 \\(L\\left(y,f\\left(x\\right)\\right)\\) 输出：回归树 \\(\\hat f\\left(x\\right)\\) (1) 初始化 $$\\begin{align*} \\\\ & f_{0}\\left(x\\right) = \\arg \\min_{c} \\sum_{i=1}&#94;{N} L \\left(y_{i},c\\right) \\end{align*}$$ (2) 对 \\(m=1,2,\\cdots,M\\) (2.a) 对 \\(i=1,2,\\cdots,N\\) 计算 $$\\begin{align*} \\\\ & r_{mi}=- \\left[ \\dfrac {\\partial L \\left(y_{i},f\\left(x_{i}\\right) \\right)}{\\partial f \\left(x_{i} \\right)}\\right]_{f\\left(x\\right)=f_{m-1}\\left(x\\right)} \\end{align*}$$ (2.b) 对 \\(r_{mi}\\) 拟合回归树，得到第 \\(m\\) 棵树的叶结点区域 \\(R_{mj}\\) ， \\(j=1,2,\\cdots,J\\) (2.c) 对 \\(j=1,2,\\cdots,J\\) ，计算 $$\\begin{align*} \\\\ & c_{mj}=\\arg \\min_{c} \\sum_{x_{i} \\in R_{mj}} L \\left( y_{i},f_{m-1} \\left(x_{i}\\right)+c \\right) \\end{align*}$$ (2.d) 更新 \\(f_{m}\\left(x\\right)= f_{m-1}\\left(x\\right) + \\sum_{j=1}&#94;{J} c_{mj} \\mathbb{I} \\left(x \\in R_{mj} \\right)\\) (3) 得到回归树 $$\\begin{align*} \\\\ & \\hat f \\left( x \\right) = f_{M} \\left( x \\right) = \\sum_{m=1}&#94;{M} \\sum_{j=1}&#94;{J} c_{mj} \\mathbb{I} \\left( x \\in R_{mj} \\right) \\end{align*}$$ if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"读书笔记","url":"https://xutree.github.io/pages/2019/03/23/sl-8/"},{"title":"统计学习方法 第七章 支持向量机（4）——序列最小最优化算法","text":"7.4 序列最小最优化算法 序列最小优化算法（Sequential minimal optimization, SMO）是一种用于解决支持向量机训练过程中所产生优化问题的算法。SMO 由微软研究院的约翰·普莱特于 1998 年发明，目前被广泛使用于 SVM 的训练过程中，并在通行的 SVM 库 LIBSVM 中得到实现。1998 年，SMO 算法发表在 SVM 研究领域内引起了轰动，因为先前可用的 SVM 训练方法必须使用复杂的方法，并需要昂贵的第三方二次规划工具。而 SMO 算法较好地避免了这一问题。 SMO 算法主要用于解决如下凸二次\b规划的对偶问题 $$\\min_{\\alpha} \\frac{1}{2}\\sum_{i=1}&#94;N\\sum_{j=1}&#94;N\\alpha_i\\alpha_jy_iy_jK(x_i,x_j)-\\sum_{i=1}&#94;N\\alpha_i \\\\ \\text{s.t.}\\ \\ \\ \\ \\begin{eqnarray} \\sum_{i=1}&#94;N\\alpha_iy_i &=& 0 \\\\ 0\\leq\\alpha_i\\leq C,\\ i &=& 1,2,\\cdots,N \\end{eqnarray}$$ 在这个问题中，变量是拉格朗日乘子，一个变量 \\(\\alpha_i\\) 对应一个样本点 \\((x_i,y_i)\\) ，变量的总数等于训练样本容量 \\(N\\) 。 \bSMO 算法是一种启发式算法，基本思路是：如果所有变量的解都满足此最优化问题的 KKT 条件，那么这么最优化问题的解就得到了。因为 KKT 条件是该最优化问题的充要条件。否则，选择两个变量，固定其他变量，针对这两个变量构建一个二次规划问题，这个二次规划问题的关于这两个变量的解应该更接近原始二次规划问题的解，重要的是，这两个变量可以通过解析方法来求解，这样就可以大大提高整个算法的计算速度。 整个 SMO 算法有两大部分组成，第一部分就是选择这两个变量的启发式的方法，第二部分是求解这两个变量的解析方法。 7.4.1 两个变量二次规划的求解方法 不失一般性，假设选择的两个变量是 \\(\\alpha_1\\) ， \\(\\alpha_2\\) ，其他变量 \\(\\alpha_i\\ (i=3,4,\\cdots,N)\\) 是固定的。于是 SMO 的最优化问题的子问题可以写成： $$\\min_{\\alpha_1,\\alpha_2}\\ \\ \\begin{eqnarray} W(\\alpha_1,\\alpha_2) &=& \\frac{1}{2}K_{11}\\alpha_1&#94;2+\\frac{1}{2}K_{22}\\alpha_2&#94;2+y_1y_2K_{12}\\alpha_1\\alpha_2 \\\\ &-& (\\alpha_1+\\alpha_2)+y_1\\alpha_1\\sum_{i=3}&#94;Ny_i\\alpha_iK_{i1}+y_2\\alpha_2\\sum_{i=3}&#94;Ny_i\\alpha_iK_{i2} \\end{eqnarray}$$ $$\\text{s.t.}\\ \\ \\ \\ \\begin{eqnarray} \\alpha_1y_1+\\alpha_2y_2=-\\sum_{i=3}&#94;N\\alpha_iy_i &=& \\varsigma \\\\ 0\\leq\\alpha_i\\leq C,\\ i = 1,2,\\cdots,&N& \\end{eqnarray}$$ 其中， \\(K_{ij}=K(x_i,x_j)\\) ， \\(\\varsigma\\) 是常数，并忽略了不含 \\(\\alpha_{1}\\) ， \\(\\alpha_2\\) 的常数项。 上图中显示了 \\(\\alpha_{1}\\) ， \\(\\alpha_2\\) 的取值范围，即位于平行于对角线的线段之上。\b所以两变量最优化问题实际上为单变量最优化问题，不妨考虑变量 \\(\\alpha_2\\) 的最优化问题。 假设二次规划问题的初始可行解是 \\(\\alpha_1&#94;\\text{old}\\) ， \\(\\alpha_2&#94;\\text{old}\\) ，最优解为 \\(\\alpha_1&#94;\\text{new}\\) ， \\(\\alpha_2&#94;\\text{new}\\) ，并且假设在沿着约束方向未经剪辑时 \\(\\alpha_2\\) 的最优解为 \\(\\alpha_2&#94;\\text{new,unc}\\) 。 由于 \\(\\alpha_2&#94;\\text{new}\\) 需要满足不等式约束 \\(0\\leq\\alpha_2&#94;\\text{new}\\leq C\\) ，所以最优值 \\(\\alpha_2&#94;\\text{new}\\) 的取值范围必须满足 $$L\\leq \\alpha_2&#94;\\text{new} \\leq H$$ 下面求解 \\(L\\) 和 \\(H\\) ： \\(\\blacksquare\\) 若 \\(y_1\\neq y_2\\) 则由 $$\\alpha_1&#94;\\text{new}y_1+\\alpha_2&#94;\\text{new}y_2=\\varsigma=\\alpha_1&#94;\\text{old}y_1+\\alpha_2&#94;\\text{old}y_2$$ 得 $$\\begin{eqnarray} \\alpha_2&#94;\\text{new} &=& \\alpha_1&#94;\\text{old}\\frac{y_1}{y_2}+\\alpha_2&#94;\\text{old}\\frac{y_2}{y_2}-\\alpha_1&#94;\\text{new}\\frac{y_1}{y_2} \\\\ &=& \\alpha_2&#94;\\text{old}-\\alpha_1&#94;\\text{old}+\\alpha_1&#94;\\text{new} \\end{eqnarray}$$ 利用 $$\\alpha_1&#94;\\text{new}\\in[0,C]$$ 得 $$\\alpha_2&#94;\\text{new}\\in[\\alpha_2&#94;\\text{old}-\\alpha_1&#94;\\text{old},C+\\alpha_2&#94;\\text{old}-\\alpha_1&#94;\\text{old}]$$ 再结合 $$\\alpha_2&#94;\\text{new}\\in[0,C]$$ 得 $$L=\\max(0,\\alpha_2&#94;\\text{old}-\\alpha_1&#94;\\text{old}) \\\\ H=\\min(C,C+\\alpha_2&#94;\\text{old}-\\alpha_1&#94;\\text{old})$$ \\(\\blacksquare\\) 若 \\(y_1=y_2\\) 则由 $$\\alpha_1&#94;\\text{new}y_1+\\alpha_2&#94;\\text{new}y_2=\\varsigma=\\alpha_1&#94;\\text{old}y_1+\\alpha_2&#94;\\text{old}y_2$$ 得 $$\\begin{eqnarray} \\alpha_2&#94;\\text{new} &=& \\alpha_1&#94;\\text{old}\\frac{y_1}{y_2}+\\alpha_2&#94;\\text{old}\\frac{y_2}{y_2}-\\alpha_1&#94;\\text{new}\\frac{y_1}{y_2} \\\\ &=& \\alpha_1&#94;\\text{old}+\\alpha_2&#94;\\text{old}-\\alpha_1&#94;\\text{new} \\end{eqnarray}$$ 利用 $$\\alpha_1&#94;\\text{new}\\in[0,C]$$ 得 $$\\alpha_2&#94;\\text{new}\\in[\\alpha_1&#94;\\text{old}+\\alpha_2&#94;\\text{old}-C,\\alpha_1&#94;\\text{old}+\\alpha_2&#94;\\text{old}]$$ 再结合 $$\\alpha_2&#94;\\text{new}\\in[0,C]$$ 得 $$L=\\max(0,\\alpha_1&#94;\\text{old}+\\alpha_2&#94;\\text{old}-C) \\\\ H=\\min(C,\\alpha_1&#94;\\text{old}+\\alpha_2&#94;\\text{old})$$ 记 $$g(x)=\\sum_{i=1}&#94;N\\alpha_iy_iK(x_i,x)+b$$ 令 $$E_i=g(x_i)-y_i=\\left(\\sum_{j=1}&#94;N\\alpha_jy_jK(x_j,x_i)+b\\right)-y_i$$ 当 \\(i=1,2\\) 时， \\(E_i\\) 为函数 \\(g(x)\\) 对输入 \\(x_i\\) 的预测值与真实输出 \\(y_i\\) 之差。 定理 7.6 两个变量最优化问题沿着约束方向未经剪辑时的解是 $$\\alpha_2&#94;\\text{new,unc}=\\alpha_2&#94;\\text{old}+\\frac{y_2(E_1-E_2)}{\\eta}$$ 其中 $$\\eta=K_{11}+K_{22}-2K_{12}=\\|\\Phi(x_1)-\\Phi(x_2)\\|&#94;2$$ \\(\\Phi(x)\\) 是输入空间到特征空间的映射。经剪辑后 \\(\\alpha_2\\) 的解是 $$\\alpha_2&#94;\\text{new}=\\begin{cases} H, & \\alpha_2&#94;\\text{new,unc}>H \\\\ \\alpha_2&#94;\\text{new,unc}, & L\\leq\\alpha_2&#94;\\text{new,unc}\\leq H \\\\ L, & \\alpha_2&#94;\\text{new,unc}<L \\end{cases}$$ 由 \\(\\alpha_2&#94;\\text{new}\\) 求得 \\(\\alpha_1&#94;\\text{new}\\) 是 $$\\alpha_1&#94;\\text{new}=\\alpha_1&#94;\\text{old}+y_1y_2(\\alpha_2&#94;\\text{old}-\\alpha_2&#94;\\text{new})$$ 7.4.2 变量的选择方法 可以采用启发式的方法选择每次迭代中需要优化的向量。第一个向量可以选取不满足支持向量机 KKT 条件的向量，亦即不满足 $$y_{i}g(x_i)\\begin{cases} \\geq1 & \\alpha_{i}=0 \\\\ =1 & 0<\\alpha_{1}<C \\\\ \\leq1 & \\alpha_{i}=C \\end{cases}$$ 的向量。其中 $$g(x)=\\sum_{i=1}&#94;N\\alpha_iy_iK(x_i,x)+b$$ 而第二个向量可以选择使得 \\(|E_{1}-E_{2}|\\) 最大的向量。 7.4.3 计算阈值 \\(b\\) 和差值 \\(\\text{E}_i\\) 在每次完成两个变量的优化后，都要重新计算阈值 \\(b\\) 。 \\(\\blacksquare\\) 当 \\(0<\\alpha_1&#94;\\text{new}<C\\) 时 $$y_{i}g(x_i)=1\\longrightarrow g(x_i)=y_i\\ (利用\\ y_i&#94;2=1)$$ 于是 $$b_1&#94;\\text{new}=y_1-\\sum_{i=3}&#94;N\\alpha_iy_iK_{i1}-\\alpha_1&#94;\\text{new}y_1K_{11}-\\alpha_2&#94;\\text{new}y_2K_{21}$$ 由 \\(E_1\\) 的定义式有 $$E_1=\\sum_{i=3}&#94;N\\alpha_iy_iK_{i1}+\\alpha_1&#94;\\text{old}y_1K_{11}+\\alpha_2&#94;\\text{old}y_2K_{21}+b&#94;\\text{old}-y_1$$ 连立两式，得 $$b_1&#94;\\text{new}=-E_1-y_1K_{11}\\left(\\alpha_1&#94;\\text{new}-\\alpha_1&#94;\\text{old}\\right)-y_2K_{21}\\left(\\alpha_2&#94;\\text{new}-\\alpha_2&#94;\\text{old}\\right)+b&#94;\\text{old}$$ \\(\\blacksquare\\) 当 \\(0<\\alpha_2&#94;\\text{new}<C\\) 时 同理 $$b_2&#94;\\text{new}=-E_2-y_1K_{12}\\left(\\alpha_1&#94;\\text{new}-\\alpha_1&#94;\\text{old}\\right)-y_2K_{22}\\left(\\alpha_2&#94;\\text{new}-\\alpha_2&#94;\\text{old}\\right)+b&#94;\\text{old}$$ \\(\\blacksquare\\) 当 \\(0<\\alpha_1&#94;\\text{new}<C\\) 且 \\(0<\\alpha_2&#94;\\text{new}<C\\) 时 $$b_1&#94;\\text{new}=b_2&#94;\\text{new}$$ \\(\\blacksquare\\) 当 \\(\\alpha_1&#94;\\text{new}\\) ， \\(\\alpha_2&#94;\\text{new}\\) 是 0 或 \\(C\\) 时 \\(b_{1}&#94;\\text{new}\\) ， \\(b_{2}&#94;\\text{new}\\) 和它们之间的数都是满足 KKT 条件的阈值，这时选择它们的中点，即 $$b&#94;\\text{new}=\\frac{b_{1}&#94;\\text{new}+b_{2}&#94;\\text{new}}{2}$$ 在每次完成两个变量的优化之后，还必须更新对应的 \\(E_i\\) 值。 \\(E_i\\) 值的更新需要用到 \\(b&#94;\\text{new}\\) 值，以及所有支持向量对应的 \\(\\alpha_j\\) $$E_i&#94;\\text{new}=\\sum_{S}y_j\\alpha_jK(x_i,x_j)+b&#94;\\text{new}-y_i$$ 其中 \\(S\\) 是所有支持向量 \\(x_j\\) 的集合。 7.4.4 SMO 算法 输入：训练数据集 \\(T=\\{(x_1,y_1),(x_2,y_2),\\cdots,(x_N,y_N)\\}\\) ，其中 \\(x_i\\in{\\cal X}=\\mathbb{R}&#94;n\\) ， \\(y_i\\in{\\cal Y}=\\{+1,-1\\}\\) ， \\(i=1,2,\\cdots,N\\) ，适当的核函数 \\(K(x,z)\\) ，惩罚参数 \\(C>0\\) ，精度 \\(\\epsilon\\) 输出：近似解 \\(\\hat{\\alpha}\\) (1) 取初值 \\(\\alpha&#94;{(0)}=0\\) ， \\(b_0=0\\) ，令 \\(k=0\\) (2) 计算 \\(\\eta\\) $$\\eta=K_{11}+K_{22}-2K_{12}=\\|\\Phi(x_1)-\\Phi(x_2)\\|&#94;2$$ (3) 选取优化变量 \\(\\alpha_1&#94;{(k)}\\) ， \\(\\alpha_2&#94;{(k)}\\) (4) 计算误差 $$E_i&#94;{k}=\\left(\\sum_{j=1}&#94;N\\alpha_j&#94;{(k)}y_jK(x_j,x_i)+b_k\\right)-y_i,\\ i=1,2$$ (5) 计算边界 $$\\begin{cases} L=\\max(0,\\alpha_2&#94;{(k)}-\\alpha_1&#94;{(k)}),\\ H=\\min(C,C+\\alpha_2&#94;{(k)}-\\alpha_1&#94;{(k)}) & 当\\ y_1\\neq y_2 \\\\ L=\\max(0,\\alpha_1&#94;{(k)}+\\alpha_2&#94;{(k)}-C),\\ H=\\min(C,\\alpha_1&#94;{(k)}+\\alpha_2&#94;{(k)}) & 当\\ y_1=y_2 \\end{cases}$$ (6) 求解 \\(\\alpha_2&#94;{(k+1)}\\) $$\\alpha_2&#94;{(k+1)}=\\alpha_2&#94;{(k)}+\\frac{y_2(E_1&#94;{k}-E_2&#94;k)}{\\eta}$$ (7) 剪辑 \\(\\alpha_2&#94;{(k+1)}\\) $$\\alpha_2&#94;{(k+1)}=\\begin{cases} H, & \\alpha_2&#94;{(k+1)}>H \\\\ \\alpha_2&#94;{(k+1)}, & L\\leq\\alpha_2&#94;{(k+1)}\\leq H \\\\ L, & \\alpha_2&#94;{(k+1)}<L \\end{cases}$$ (8) 求解 \\(\\alpha_1&#94;{(k+1)}\\) $$\\alpha_1&#94;{(k+1)}=\\alpha_1&#94;{(k)}+y_1y_2\\left(\\alpha_2&#94;{(k)}-\\alpha_2&#94;{(k+1)}\\right)$$ (9) 更新 \\(b_{k+1}\\) $$b_{1(k+1)}=-E_1-y_1K_{11}\\left(\\alpha_{1}&#94;{(k+1)}-\\alpha_{1}&#94;{(k)}\\right)-y_2K_{21}\\left(\\alpha_{2}&#94;{(k+1)}-\\alpha_{2}&#94;{(k)}\\right)+b_k$$ $$b_{2(k+1)}=-E_2-y_1K_{12}\\left(\\alpha_{1}&#94;{(k+1)}-\\alpha_{1}&#94;{(k)}\\right)-y_2K_{22}\\left(\\alpha_{2}&#94;{(k+1)}-\\alpha_{2}&#94;{(k)}\\right)+b_k$$ $$b_{k+1}=\\frac{b_{1(k+1)}+b_{2(k+1)}}{2}$$ (10) \b更新 \\(E_i&#94;{k+1}\\) $$E_i&#94;{k+1}=\\sum_{S}y_j\\alpha_jK\\left(x_i&#94;{(k)},x_j\\right)+b_{k+1}-y_i&#94;{(k)}$$ 其中 \\(S\\) 是所有支持向量 \\(x_j\\) 的集合 (11) 更新 \\(\\alpha=\\alpha&#94;{(k+1)}\\) ，若在精度 \\(\\epsilon\\) 范围内满足停机条件 $$\\sum_{i=1}&#94;N\\alpha_iy_i=0 \\\\ 0\\leq\\alpha_i\\leq C,\\ i=1,2,\\cdots,N \\\\ y_i\\cdot g(x_i)=\\begin{cases} \\geq1, & \\{x_i|\\alpha_i=0\\} \\\\ =1, & \\{x_i|0<\\alpha_i<C\\} \\\\ \\leq 1, & \\{x_i|\\alpha_i=C\\} \\end{cases}$$ 其中 \\(g(x_i)=\\sum_{j=1}&#94;N\\alpha_jy_jK(x_j,x_i)+b\\) ，则转 (12)，否则令 \\(k=k+1\\) ，转 (3) (12) 取 \\(\\hat{\\alpha}=\\alpha&#94;{(k+1)}\\) if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"读书笔记","url":"https://xutree.github.io/pages/2019/03/12/sl-7_4/"},{"title":"统计学习方法 第七章 支持向量机（2）——线性支持向量机","text":"7.2 线性支持向量机 假设给定一个特征空间上的训练数据集 $$T=\\{(x_1,y_1),(x_2,y_2),\\cdots,(x_N,y_N)\\}$$ 其中 \\(x_i\\in{\\cal X}=\\mathbb{R}&#94;n\\) ， \\(y_i\\in{\\cal Y}=\\{+1,-1\\}\\) ， \\(i=1,2,\\cdots,N\\) 。再假设训练数据集不是线性可分的。通常情况是，训练数据中有一些特异点（outlier），将这些特异点除去后，剩下大部分的样本点组成的集合是线性可分的。 线性不可分意味着某些样本点 \\((x_i,y_i)\\) 不能满足函数间隔大于等于 1 的约束条件，为了解决这个问题，可以对每个样本点 \\((x_i,y_i)\\) 引进一个松弛\b变量 \\(\\xi_i\\geq0\\) ，使函数间隔加上松弛变量大于等于 1。这样，\b约束条件\b变为 $$y_i(w\\cdot x_i+b)\\geq1-\\xi_i$$ 同时，对每个松弛变量支付一个代价，目标函数由原来的 \\(\\frac{1}{2}\\|w\\|&#94;2\\) 变成 $$\\frac{1}{2}\\|w\\|&#94;2+C\\sum_{i=1}&#94;N\\xi_i$$ 这里， \\(C>0\\) 称为惩罚参数。一般由应用问题决定， \\(C\\) 值大时对误分类的惩罚增加， \\(C\\) 值小时对误分类的惩罚减小。 线性不可分的线性支持向量机的学习问题变成如下凸二次规划（convex quadratic programming）问题（原始问题）： $$\\min_{w,b,\\xi}\\ \\frac{1}{2}\\|w\\|&#94;2+C\\sum_{i=1}&#94;N\\xi_i\\\\ \\text{s.t.}\\ \\ \\ \\ \\begin{eqnarray} y_i\\left(w\\cdot x_i+b\\right) &\\geq& 1-\\xi_i,\\ i=1,2,\\cdots,N \\\\ \\xi_i &\\geq& 0,\\ i=1,2,\\cdots,N \\end{eqnarray}$$ 原始问题关于 \\((w,b,\\xi)\\) 的解是存在的。可以证明 \\(w\\) 的解是唯一的，但 \\(b\\) 的解可能不唯一，\b而是存在于一个区间。 定义 7.5（线性支持向量机）对于给定的线性不可分的训练数据集，通过求解下面的凸二次规划问题 $$\\min_{w,b,\\xi}\\ \\frac{1}{2}\\|w\\|&#94;2+C\\sum_{i=1}&#94;N\\xi_i\\\\ \\text{s.t.}\\ \\ \\ \\ \\begin{eqnarray} y_i\\left(w\\cdot x_i+b\\right) &\\geq& 1-\\xi_i,\\ i=1,2,\\cdots,N \\\\ \\xi_i &\\geq& 0,\\ i=1,2,\\cdots,N \\end{eqnarray}$$ 即软间隔最大化问题，得到的分离超平面为 $$w&#94;\\star\\cdot x+b&#94;\\star=0$$ 以及相应的分类决策函数 $$f(x)=\\text{sign}(w&#94;\\star\\cdot x+b&#94;\\star)$$ 称为线性支持向量机。 7.2.2 学习的对偶算法 定义 拉格朗日函数 ： $$L(w,b,\\xi,\\alpha,\\mu)=\\frac{1}{2}\\|w\\|&#94;2+C\\sum_{i=1}&#94;N\\xi_i-\\sum_{i=1}&#94;N\\alpha_iy_i(w\\cdot x_i+b) \\\\ +\\sum_{i=1}&#94;N\\alpha_i-\\sum_{i=1}&#94;N\\alpha_i\\xi_i-\\sum_{i=1}&#94;N\\mu_i\\xi_i$$ 其中， \\(\\alpha_i\\geq0\\) ， \\(\\mu_i\\geq0\\) 。 根据拉格朗日对偶性，原始问题的对偶问题是极大极小问题： $$\\max_{\\alpha,\\mu}\\min_{w,b,\\xi}L(w,b,\\xi,\\alpha,\\mu)$$ \\(\\blacksquare\\) 求 \\(\\min_{w,b,\\xi}L(w,b,\\alpha,\\mu)\\) 求偏导\b\b并令偏导为 0 $$\\nabla_wL(w,b,\\xi,\\alpha,\\mu)=w-\\sum_{i=1}&#94;N\\alpha_iy_ix_i=0 \\\\ \\nabla_bL(w,b,\\xi,\\alpha,\\mu)=-\\sum_{i=1}&#94;N\\alpha_iy_i=0 \\\\ \\nabla_{\\xi_i} L(w,b,\\xi,\\alpha,\\mu)=C-\\alpha_i-\\mu_i=0$$ 得 $$w=\\sum_{i=1}&#94;N\\alpha_iy_ix_i \\\\ \\sum_{i=1}&#94;N\\alpha_iy_i=0 \\\\ C-\\alpha_i-\\mu_i=0$$ 利用上面三式，得 $$L(w,b,\\xi,\\alpha,\\mu)=-\\frac{1}{2}\\sum_{i=1}&#94;N\\sum_{j=1}&#94;N\\alpha_i\\alpha_jy_iy_j(x_i\\cdot x_j)+\\sum_{i=1}&#94;N\\alpha_i$$ 即 $$\\min_{w,b,\\xi}L(w,b,\\xi,\\alpha,\\mu)=-\\frac{1}{2}\\sum_{i=1}&#94;N\\sum_{j=1}&#94;N\\alpha_i\\alpha_jy_iy_j(x_i\\cdot x_j)+\\sum_{i=1}&#94;N\\alpha_i$$ \\(\\blacksquare\\) 求 \\(\\min_{w,b,\\xi}L(w,b,\\xi,\\alpha,\\mu)\\) 对 \\(\\alpha\\) ， \\(\\mu\\) 的极大 即是求对偶问题 $$\\max_{\\alpha,\\mu} -\\frac{1}{2}\\sum_{i=1}&#94;N\\sum_{j=1}&#94;N\\alpha_i\\alpha_jy_iy_j(x_i\\cdot x_j)+\\sum_{i=1}&#94;N\\alpha_i \\\\ \\text{s.t.}\\ \\ \\ \\ \\begin{eqnarray} \\sum_{i=1}&#94;N\\alpha_iy_i &=& 0 \\\\ C-\\alpha_i &-& \\mu_i = 0 \\\\ \\alpha_i \\geq 0\\ i &=& 1,2,\\cdots,N \\\\ \\mu_i\\geq0\\ i &=& 1,2,\\cdots,N \\end{eqnarray}$$ 也就是下面等价的最小化问题 $$\\min_{\\alpha} \\frac{1}{2}\\sum_{i=1}&#94;N\\sum_{j=1}&#94;N\\alpha_i\\alpha_jy_iy_j(x_i\\cdot x_j)-\\sum_{i=1}&#94;N\\alpha_i \\\\ \\text{s.t.}\\ \\ \\ \\ \\begin{eqnarray} \\sum_{i=1}&#94;N\\alpha_iy_i &=& 0 \\\\ 0\\leq\\alpha_i\\leq C,\\ i &=& 1,2,\\cdots,N \\end{eqnarray}$$ 原始最优化问题和对偶最优化问题满\b足拉格朗日对偶性 定理 2 的条件，所以存在 \\(w&#94;\\star\\) ， \\(b&#94;\\star\\) 和 \\(\\alpha&#94;\\star\\) 使 \\(w&#94;\\star\\) ， \\(b&#94;\\star\\) 是原始问题的解， \\(\\alpha&#94;\\star\\) 是对偶问题的解。 定理 7.3 设 \\(\\alpha&#94;\\star=\\left(\\alpha_1&#94;\\star,\\alpha_2&#94;\\star,\\cdots,\\alpha_N&#94;\\star\\right)&#94;\\text{T}\\) 是对偶最优问题的解，则存在下标 \\(j\\) ，使得 \\(0<\\alpha_i&#94;\\star<C\\) ，并且可按下式求得原始最优化问题的解 $$w&#94;\\star=\\sum_{i=1}&#94;N\\alpha_i&#94;\\star y_ix_i \\\\ b&#94;\\star=y_j-\\sum_{i=1}&#94;N\\alpha_i&#94;\\star y_i(x_i\\cdot x_j)$$ 由此定理可知，分离超平面可以写成 $$\\sum_{i=1}&#94;N\\alpha_i&#94;\\star y_i(x\\cdot x_i)+b&#94;\\star=0$$ 分类决策函数可以写成 $$f(x)=\\text{sign}\\left(\\sum_{i=1}&#94;N\\alpha_i&#94;\\star y_i(x\\cdot x_i)+b&#94;\\star\\right)$$ 分类决策函数只依赖于输入 \\(x\\) 和训练样本输入的内积。上式称为线性支持向量机的对偶形式。 算法 7.3（线性支持向量机学习算法） 输入：线性可分训练数据集 \\(T=\\{(x_1,y_1),(x_2,y_2),\\cdots,(x_N,y_N)\\}\\) ，其中 \\(x_i\\in{\\cal X}=\\mathbb{R}&#94;n\\) ， \\(y_i\\in{\\cal Y}=\\{+1,-1\\}\\) ， \\(i=1,2,\\cdots,N\\) 输出：分离超平面和分类决策函数 (1) 选择惩罚参数 \\(C>0\\) ，构造并求解约束最优化问题 $$\\min_{\\alpha} \\frac{1}{2}\\sum_{i=1}&#94;N\\sum_{j=1}&#94;N\\alpha_i\\alpha_jy_iy_j(x_i\\cdot x_j)-\\sum_{i=1}&#94;N\\alpha_i \\\\ \\text{s.t.}\\ \\ \\ \\ \\begin{eqnarray} \\sum_{i=1}&#94;N\\alpha_iy_i &=& 0 \\\\ 0\\leq\\alpha_i\\leq C,\\ i &=& 1,2,\\cdots,N \\end{eqnarray}$$ 求得最优解 \\(\\alpha&#94;\\star=\\left(\\alpha_1&#94;\\star,\\alpha_2&#94;\\star,\\cdots,\\alpha_N&#94;\\star\\right)&#94;\\text{T}\\) (2) 计算 $$w&#94;\\star=\\sum_{i=1}&#94;N\\alpha_i&#94;\\star y_ix_i$$ 并选择 \\(\\alpha&#94;\\star\\) 的一个分量满足 \\(0<\\alpha_i&#94;\\star<C\\) ，计算 $$b&#94;\\star=y_j-\\sum_{i=1}&#94;N\\alpha_i&#94;\\star y_i(x_i\\cdot x_j)$$ (3) 求得分离超平面 $$\\sum_{i=1}&#94;N\\alpha_i&#94;\\star y_i(x\\cdot x_i)+b&#94;\\star=0$$ 分类决策函数 $$f(x)=\\text{sign}\\left(\\sum_{i=1}&#94;N\\alpha_i&#94;\\star y_i(x\\cdot x_i)+b&#94;\\star\\right)$$ 7.2.3 支持向量 在线性不可分\b的情况下，将对偶问题的解 $$\\alpha&#94;\\star=\\left(\\alpha_1&#94;\\star,\\alpha_2&#94;\\star,\\cdots,\\alpha_N&#94;\\star\\right)&#94;\\text{T}$$ 中对应于 \\(\\alpha_i&#94;\\star>0\\) 的样本点 \\((x_i,y_i)\\) 的实例 \\(x_i\\) 称为\b支持向量（软间隔的支持向量）。实例 \\(x_i\\) \b到间隔边界的距离是 $$\\frac{\\xi_i}{\\|w\\|}$$ 若 \\(\\alpha_i&#94;\\star<C\\) ，则 \\(\\xi_i=0\\) ，支持向量 \\(x_i\\) 正好落在间隔边界上 若 \\(\\alpha_i&#94;\\star=C\\) 且 \\(\\xi_i=0\\) ，则分类正确，支持向量 \\(x_i\\) 正好落在间隔边界上 若 \\(\\alpha_i&#94;\\star=C\\) 且 \\(0<\\xi_i<1\\) ，则分类正确，支持向量 \\(x_i\\) 在间隔边界和分离超平面之间 若 \\(\\alpha_i&#94;\\star=C\\) 且 \\(\\xi_i=1\\) ，则支持向量 \\(x_i\\) 在分离超平面上 若 \\(\\alpha_i&#94;\\star=C\\) 且 \\(\\xi_i>1\\) ，则分类错误，支持向量 \\(x_i\\) 位于分离超平面误分类一侧\b 7.2.4 合页损失函数 线性支持向量机学习还有另外一种解释，就是最小化以下目标函数： $$\\sum_{i=1}&#94;N[1-y_i(w\\cdot x_i+b)]_++\\lambda\\|w\\|&#94;2$$ 目标函数的第一项是经验损失或经验风险，函数 $$L(y(w\\cdot x+b))=[1-y(w\\cdot x+b)]_+$$ 称为合页损失函数（hinge loss function）。下标 \"+\" 表示以下取正值的函数： $$[z]_+=\\begin{cases} z, & z>0 \\\\ 0, & z\\leq0\\end{cases}$$ 也就是说当样本被正确分类且函数间隔（确信度）大于 1 时，损失是 0。目标函数的第二项是系数为 \\(\\lambda\\) 的 \\(w\\) 的 \\(L_2\\) 范数，是正则化项。 定理 7.4 线性支持向量机原始优化问题 $$\\min_{w,b,\\xi}\\ \\frac{1}{2}\\|w\\|&#94;2+C\\sum_{i=1}&#94;N\\xi_i\\\\ \\text{s.t.}\\ \\ \\ \\ \\begin{eqnarray} y_i\\left(w\\cdot x_i+b\\right) &\\geq& 1-\\xi_i,\\ i=1,2,\\cdots,N \\\\ \\xi_i &\\geq& 0,\\ i=1,2,\\cdots,N \\end{eqnarray}$$ 等价于\b最优化问题 $$\\min_{w,b}\\sum_{i=1}&#94;N[1-y_i(w\\cdot x_i+b)]_++\\lambda\\|w\\|&#94;2$$ \b\b下图中绘制了合页损失函数。图中还画出了 0-1 损失函数，可以\b认为 0-1 损失函数是二类分类问题的真正的损失函数，而合页损失函数是 0-1 损失函数的上界。由于 0-1 损失函数不是连续可导的，直接优化由其构成的目标函数比较困难，可以认为线性支持向量机是优化由 0-1 损失函数的上界（合页损失函数）构成的目标函数，这时的上界损失函数又称为代理损失函数（surrogate loss function）。 相比于感知机损失函数，合页损失函数不仅要求正确分类，而且确信度足够高时损失才为 0，也就是说，合页损失函数对学习有更高的要求。 if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"读书笔记","url":"https://xutree.github.io/pages/2019/02/11/sl-7_2/"},{"title":"统计学习方法 第七章 支持向量机（1）——线性可分支持向量机","text":"支持向量机（support vector machines，SVM）是一种二分类模型。它的基本模型是定义在特征空间上的间隔最大的线性分类器，间隔最大使它有别于 感知机 ；支持向量机还包括核技巧，这使它成为实质上的非线性分类器。 支持向量机的学习策略就是间隔最大化，可形式化为一个求解凸二次规划（convex quadratic programming）的问题，也等价于正则化的合页损失函数的最小化问题。支持向量机的学习算法是求解凸二次规划的最优化算法。 支持向量机学习方法包含构建由间至繁的模型： 线性可分支持向量机（linear support vector machine in linearly separable case）：数据线性可分，通过硬间隔最大化（hard margin maximization），学习一个线性分类器 线性支持向量机（linear support vector machine）：数据近似\b线性可分，通过软间隔最大化（soft margin maximization），学习一个线性分类器，又称软间隔支持向量机 非线性支持向量机（non-linear support vector machine）：数据线性不可分，通过核技巧（kernel trick）及软间隔最大化，学习一个非线性分类器 7.1 线性可分支持向量机与硬间隔最大化 7.1.1 线性可分支持向量机 一般的，当训练数据集线性可分时，存在无穷多个分离超平面可将两类数据正确分开。感知机利用分类误差最小的策略，求得分离\b超平面，不过这是的解有无穷多个。线性可分支持向量机利用间隔最大化求解\b最优分离超平面，这时，解是唯一的。 定义 7.1（线性可分支持向量机）给定线性可分训练数据集，通过间隔最大化或等价的求解相应的凸二次规划问题学习得到的分离超平面为 $$w&#94;\\star\\cdot x+b&#94;\\star=0$$ 以及相应的分类决策函数 $$f(x)=\\text{sign}(w&#94;\\star\\cdot x+b&#94;\\star)$$ 称为线性可分支持向量机。 7.1.2 \b函数间隔和几何间隔 定义 7.2（函数间隔）对于给定的训练数据集 \\(T\\) 和超平面 \\((w,b)\\) ，定义超平面 \\((w,b)\\) 关于样本点 \\((x_i,y_i)\\) 的函数间隔为 $$\\hat{\\gamma}_i=y_i(w\\cdot x_i+b)$$ 定义超平面 \\((w,b)\\) 关于训练数据集 \\(T\\) 的函数间隔为 $$\\hat{\\gamma}=\\min_{i=1,2,\\cdots,N}\\hat{\\gamma}_i$$ 函数间隔（functional margin）可以表示分类预测的正确性和确信度，但是具有不确定因子，我们需要对分离超平面的法向量 \\(w\\) 加以约束，使得间隔是确定的。这时函数间隔就成了几何间隔（geometric margin）。 定义 7.2（几何间隔）对于给定的训练数据集 \\(T\\) 和超平面 \\((w,b)\\) ，定义超平面 \\((w,b)\\) 关于样本点 \\((x_i,y_i)\\) 的几何间隔为 $$\\gamma_i=y_i\\left(\\frac{w}{\\|w\\|}\\cdot x_i+\\frac{b}{\\|w\\|}\\right)$$ 定义超平面 \\((w,b)\\) 关于训练数据集 \\(T\\) 的几何间隔为 $$\\gamma=\\min_{i=1,2,\\cdots,N}\\gamma_i$$ 易知： $$\\gamma_i=\\frac{\\hat{\\gamma}_i}{\\|w\\|} \\\\ \\gamma=\\frac{\\hat{\\gamma}}{\\|w\\|}$$ 如果超平面参数 \\(w\\) 和 \\(b\\) 成比例变化（超平面没有改变），函数间隔也按此比例变化，几何间隔不变。 7.1.3 间隔最大化 间隔最大化的直观解释：对训练数据集找到几\b何间隔最大的超平面意味着以充分大的确定度对训练数据进行分类。这样的超平面对未知的新实例有很好的分类预测能力。 最大间隔分离超平面 求解几何间隔最大的分离超平面问题即求解下面的约束最优化问题： $$\\max_{w,b}\\ \\gamma \\\\ \\text{s.t.}\\ \\ \\ \\ y_i\\left(\\frac{w}{\\|w\\|}\\cdot x_i+\\frac{b}{\\|w\\|}\\right)\\geq\\gamma,\\ i=1,2,\\cdots,N$$ 可改写为： $$\\max_{w,b}\\ \\frac{\\hat{\\gamma}}{\\|w\\|} \\\\ \\text{s.t.}\\ \\ \\ \\ y_i\\left(w\\cdot x_i+b\\right)\\geq\\hat{\\gamma},\\ i=1,2,\\cdots,N$$ 对于上式来说，假设将分离超平面 \\((w,b)\\) 按比例改变为 \\((\\lambda w,\\lambda b)\\) ，这时函数间隔变为 \\(\\lambda \\hat{\\gamma}\\) ，所以对目标函数和约束条件都没有影响。那么，如果我们做如下变换： $$(w,b)\\to(\\frac{1}{\\hat{\\gamma}}w,\\frac{1}{\\hat{\\gamma}}b)$$ 则函数间隔变为 1，故上述问题可改写为\b： $$\\max_{w,b}\\ \\frac{1}{\\|w\\|} \\\\ \\text{s.t.}\\ \\ \\ \\ y_i\\left(w\\cdot x_i+b\\right)\\geq 1,\\ i=1,2,\\cdots,N$$ 注意到最大化 \\(\\frac{1}{\\|w\\|}\\) 和最小化 \\(\\frac{1}{2}\\|w\\|&#94;2\\) 是等价的，于是问题变为： $$\\min_{w,b}\\ \\frac{1}{2}\\|w\\|&#94;2 \\\\ \\text{s.t.}\\ \\ \\ \\ y_i\\left(w\\cdot x_i+b\\right)-1\\geq0,\\ i=1,2,\\cdots,N$$ 这是一个凸二次规划问题。 凸优化问题是指约束最优化问题 $$\\min_w\\ f(w) \\\\ \\text{s.t.}\\ \\ \\ \\ \\begin{eqnarray} g_i(x) &\\leq0&,\\ i=1,2\\cdots,k \\\\ h_i(w) &=& 0,\\ i=1,2,\\cdots,l \\end{eqnarray} $$ 其中，目标函数 \\(f(w)\\) 和约束函数 \\(g_i(w)\\) 都是 \\(\\mathbb{R}&#94;n\\) 上的连续可微凸函数，约束函数 \\(h_i(w)\\) 是 \\(\\mathbb{R}&#94;n\\) 上的仿射函数（即满足 \\(h_i(w)=a\\cdot w+b\\) 的形式）。 算法 7.1（线性可分支持向量机学习算法——最大间隔法） 输入：线性可分训练数据集 \\(T=\\{(x_1,y_1),(x_2,y_2),\\cdots,(x_N,y_N)\\}\\) ，其中 \\(x_i\\in{\\cal X}=\\mathbb{R}&#94;n\\) ， \\(y_i\\in{\\cal Y}=\\{+1,-1\\}\\) ， \\(i=1,2,\\cdots,N\\) 输出：最大间隔分离超平面和分类决策函数 (1) 构造并求解约束最优化问题 $$\\min_{w,b}\\ \\frac{1}{2}\\|w\\|&#94;2 \\\\ \\text{s.t.}\\ \\ \\ \\ y_i\\left(w\\cdot x_i+b\\right)-1\\geq0,\\ i=1,2,\\cdots,N$$ 求得最优解 \\(w&#94;\\star\\) ， \\(b&#94;\\star\\) (2) 由此得到分离超平面 $$w&#94;\\star\\cdot x+b&#94;\\star=0$$ 分类决策函数 $$f(x)=\\text{sign}(w&#94;\\star\\cdot x+b&#94;\\star)$$ \b上面的算法就是最大间隔法（maximum margin method）。 最大间隔\b分离超平面的存在唯一性 定理 7.1（最大间隔分离超平面的存在唯一性）若训练数据集线性可分，则可将训练数据集中的样本点完全正确分开的最大间隔分离超平面存在且唯一。 支持向量和间隔边界 在线性可分情况下，训练数据集的样本点中与\b分离超平面距离最近的样本点的实例称为支持向量（support vector）。支持向量是约束条件 $$y_i\\left(w\\cdot x_i+b\\right)-1\\geq0,\\ i=1,2,\\cdots,N$$ 等号成立的点，即 $$y_i(w\\cdot x_i+b)-1=0$$ 对 \\(y_i=+1\\) 的正例点，支持向量在超平面 $$H_1:\\ w\\cdot x+b=1$$ 上。对 \\(y_i=-1\\) 的负例点，支持向量在超平面 $$H_2:\\ w\\cdot x+b=-1$$ 上。 注意到 \\(H_1\\) 和 \\(H_2\\) 平行，之间的距离称为间隔（margin）。间隔依赖于分离超平面的法向量，等于 \\(\\frac{2}{\\|w\\|}\\) ， \\(H_1\\) 和 \\(H_2\\) 称为间隔边界。 所有的支持向量都精确的落在边缘上。不管空间的维度有多大，或者数据集合有多大，支持向量的个数一般很少，都可以像 2 个这么小。在决定分离超平面时，只有支持向量起着至关重要的作用，其他的点并不起作用。所以支持向量机是由这些很少的、很\"重要的\"训练数据决定的。 7.1.4 学习的对偶算法 为了求解线性可分支持向量机的最优化问题 $$\\min_{w,b}\\ \\frac{1}{2}\\|w\\|&#94;2 \\\\ \\text{s.t.}\\ \\ \\ \\ y_i\\left(w\\cdot x_i+b\\right)-1\\geq0,\\ i=1,2,\\cdots,N$$ 可以构造对偶问题。这样做的优点，一是对偶问题往往更容易求解；二是自然引入核函数，进而推广到非线性分类问题。 定义 拉格朗日函数 ： $$L(w,b,\\alpha)=\\frac{1}{2}\\|w\\|&#94;2-\\sum_{i=1}&#94;N\\alpha_iy_i(w\\cdot x_i+b)+\\sum_{i=1}&#94;N\\alpha_i$$ 其中， \\(\\alpha_i\\geq0\\) ， \\(\\alpha=(\\alpha_1,\\alpha_2,\\cdots,\\alpha_N)&#94;\\text{T}\\) 为拉格朗日乘子向量。 根据拉格朗日对偶性，原始问题的对偶问题是极大极小问题： $$\\max_\\alpha\\min_{w,b}L(w,b,\\alpha)$$ \\(\\blacksquare\\) 求 \\(\\min_{w,b}L(w,b,\\alpha)\\) 求偏导\b\b并令偏导为 0 $$\\nabla_wL(w,b,\\alpha)=w-\\sum_{i=1}&#94;N\\alpha_iy_ix_i=0 \\\\ \\nabla_bL(w,b,\\alpha)=-\\sum_{i=1}&#94;N\\alpha_iy_i=0$$ 得 $$w=\\sum_{i=1}&#94;N\\alpha_iy_ix_i \\\\ \\sum_{i=1}&#94;N\\alpha_iy_i=0$$ 利用上面两式，得 $$L(w,b,\\alpha)=-\\frac{1}{2}\\sum_{i=1}&#94;N\\sum_{j=1}&#94;N\\alpha_i\\alpha_jy_iy_j(x_i\\cdot x_j)+\\sum_{i=1}&#94;N\\alpha_i$$ 即 $$\\min_{w,b}L(w,b,\\alpha)=-\\frac{1}{2}\\sum_{i=1}&#94;N\\sum_{j=1}&#94;N\\alpha_i\\alpha_jy_iy_j(x_i\\cdot x_j)+\\sum_{i=1}&#94;N\\alpha_i$$ \\(\\blacksquare\\) 求 \\(\\min_{w,b}L(w,b,\\alpha)\\) 对 \\(\\alpha\\) 的极大 即是求对偶问题 $$\\max_\\alpha -\\frac{1}{2}\\sum_{i=1}&#94;N\\sum_{j=1}&#94;N\\alpha_i\\alpha_jy_iy_j(x_i\\cdot x_j)+\\sum_{i=1}&#94;N\\alpha_i \\\\ \\text{s.t.}\\ \\ \\ \\ \\begin{eqnarray} \\sum_{i=1}&#94;N\\alpha_iy_i &=& 0 \\\\ \\alpha_i \\geq 0,\\ i &=& 1,2,\\cdots,N \\end{eqnarray}$$ 也就是下面等价的最小化问题 $$\\min_\\alpha \\frac{1}{2}\\sum_{i=1}&#94;N\\sum_{j=1}&#94;N\\alpha_i\\alpha_jy_iy_j(x_i\\cdot x_j)-\\sum_{i=1}&#94;N\\alpha_i \\\\ \\text{s.t.}\\ \\ \\ \\ \\begin{eqnarray} \\sum_{i=1}&#94;N\\alpha_iy_i &=& 0 \\\\ \\alpha_i \\geq 0,\\ i &=& 1,2,\\cdots,N \\end{eqnarray}$$ 原始最优化问题和对偶最优化问题满\b足拉格朗日对偶性 定理 2 的条件，所以存在 \\(w&#94;\\star\\) ， \\(b&#94;\\star\\) 和 \\(\\alpha&#94;\\star\\) 使 \\(w&#94;\\star\\) ， \\(b&#94;\\star\\) 是原始问题的解， \\(\\alpha&#94;\\star\\) 是对偶问题的解。 对线性可分\b训练数据集，假设对偶最优化问题的解是 $$\\alpha&#94;\\star=\\left(\\alpha_1&#94;\\star,\\alpha_2&#94;\\star,\\cdots,\\alpha_N&#94;\\star\\right)&#94;\\text{T}$$ 可以由下面的定理求得 \\(w&#94;\\star\\) 和 \\(b&#94;\\star\\) 。 定理 7.2 设 \\(\\alpha&#94;\\star=\\left(\\alpha_1&#94;\\star,\\alpha_2&#94;\\star,\\cdots,\\alpha_N&#94;\\star\\right)&#94;\\text{T}\\) 是对偶最优问题的解，则存在下标 \\(j\\) ，使得 \\(\\alpha_j&#94;\\star>0\\) ，并且可按下式求得原始最优化问题的解 $$w&#94;\\star=\\sum_{i=1}&#94;N\\alpha_i&#94;\\star y_ix_i \\\\ b&#94;\\star=y_j-\\sum_{i=1}&#94;N\\alpha_i&#94;\\star y_i(x_i\\cdot x_j)$$ 由此定理可知，分离超平面可以写成 $$\\sum_{i=1}&#94;N\\alpha_i&#94;\\star y_i(x\\cdot x_i)+b&#94;\\star=0$$ 分类决策函数可以写成 $$f(x)=\\text{sign}\\left(\\sum_{i=1}&#94;N\\alpha_i&#94;\\star y_i(x\\cdot x_i)+b&#94;\\star\\right)$$ 分类决策函数只依赖于输入 \\(x\\) 和训练样本输入的内积。上式称为线性可分支持向量机的对偶形式。 算法 7.2（线性可分支持向量机学习算法） 输入：线性可分训练数据集 \\(T=\\{(x_1,y_1),(x_2,y_2),\\cdots,(x_N,y_N)\\}\\) ，其中 \\(x_i\\in{\\cal X}=\\mathbb{R}&#94;n\\) ， \\(y_i\\in{\\cal Y}=\\{+1,-1\\}\\) ， \\(i=1,2,\\cdots,N\\) 输出：分离超平面和分类决策函数 (1) 构造并求解约束最优化问题 $$\\min_\\alpha \\frac{1}{2}\\sum_{i=1}&#94;N\\sum_{j=1}&#94;N\\alpha_i\\alpha_jy_iy_j(x_i\\cdot x_j)-\\sum_{i=1}&#94;N\\alpha_i \\\\ \\text{s.t.}\\ \\ \\ \\ \\begin{eqnarray} \\sum_{i=1}&#94;N\\alpha_iy_i &=& 0 \\\\ \\alpha_i \\geq 0,\\ i &=& 1,2,\\cdots,N \\end{eqnarray}$$ 求得最优解 \\(\\alpha&#94;\\star=\\left(\\alpha_1&#94;\\star,\\alpha_2&#94;\\star,\\cdots,\\alpha_N&#94;\\star\\right)&#94;\\text{T}\\) (2) 计算 $$w&#94;\\star=\\sum_{i=1}&#94;N\\alpha_i&#94;\\star y_ix_i$$ 并选择 \\(\\alpha&#94;\\star\\) 的一个正分量 \\(\\alpha_j&#94;\\star>0\\) ，计算 $$b&#94;\\star=y_j-\\sum_{i=1}&#94;N\\alpha_i&#94;\\star y_i(x_i\\cdot x_j)$$ (3) 求得分离超平面 $$\\sum_{i=1}&#94;N\\alpha_i&#94;\\star y_i(x\\cdot x_i)+b&#94;\\star=0$$ 分类决策函数 $$f(x)=\\text{sign}\\left(\\sum_{i=1}&#94;N\\alpha_i&#94;\\star y_i(x\\cdot x_i)+b&#94;\\star\\right)$$ 由公式知 \\(w&#94;\\star\\) ， \\(b&#94;\\star\\) 只依赖于训练数据中对于与 \\(\\alpha_i&#94;\\star>0\\) 的样本点 \\((x_i,y_i)\\) ，我们将这些实例点称为支持向量。 其中 \\(b&#94;\\ast\\) 的计算是根据如下事实： 在最优解 \\(\\alpha&#94;\\star=\\left(\\alpha_1&#94;\\star,\\alpha_2&#94;\\star,\\cdots,\\alpha_N&#94;\\star\\right)&#94;\\text{T}\\) 中， \\(\\alpha_j&#94;\\star>0\\) 的样本点才是支持向量，而对于支持向量 \\((x_j,y_j)\\) 来说，其一定位于方程 \\(y_j(w&#94;\\ast\\cdot x_j + b)=1\\) 上，又因为 \\(|y_j|=1\\) ，故 \\(y_j=w&#94;\\ast\\cdot x_j + b\\) ，得出 $$b&#94;\\ast=y_j-w&#94;\\ast\\cdot x_j=y_j-\\sum_{i=1}&#94;N\\alpha_i&#94;\\star y_i(x_i\\cdot x_j)$$ if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"读书笔记","url":"https://xutree.github.io/pages/2019/02/11/sl-7_1/"},{"title":"统计学习方法 第七章 支持向量机（3）——非线性支持向量机","text":"7.3 非线性支持向量机与核函数 对解线性分类问题，线性分类支持向量机是一种非常有效的方法。但是，有时分类问题是非线性的，这时可以使用非线性支持向量机。 7.3.1 核技巧 非线性分类问题 非线性分类问题是指通过利用非线性模型才能很好的进行分类的问题。如果能用一个超曲面把正负例正确分开，则称这个问题是非线性可分问题。 非线性问题往往不好求解，所以希望能用解线性分类问题的方法解决这个问题。所采取的方法是进行一个非线性变换。 用线性方法求解非线性问题分为两步： 使用一个变换将原空间的数据映射到新空间 在新空间里用线性分类学习方法从训练数据集中学习到分类模型 核技巧（kernel trick）应用到支持向量机，其基本思想就是通过一个非线性变换将输入空间（欧式空间 \\(\\mathbb{R}&#94;n\\) 或离散空间）对应于一个特征空间（希尔伯特空间 \\({\\cal H}\\) 。在数学里，希尔伯特空间 Hilbert space，即完备的内积空间，也就是说一个带有内积的完备向量空间。希尔伯特空间是有限维欧几里得空间的一个推广，使之不局限于实数的情形和有限的维数，但又不失完备性），使得在输入空间中的超曲面模型对应于特征空间中的超平面模型（支持向量机）。 核函数的定义 定义 7.6（核函数）设 \\({\\cal X}\\) 是输入空间（欧式空间 \\(\\mathbb{R}&#94;n\\) 的子集或离散空间），又设 \\({\\cal H}\\) 为特征空间（希尔伯特空间），如果存在一个从 \\({\\cal X}\\) 到 \\({\\cal H}\\) 的映射 $$\\phi(x):{\\cal X}\\to{\\cal H}$$ 使得对所有的 \\(x,z\\in{\\cal X}\\) ，函数 \\(K(x,z)\\) 满足条件 $$K(x,z)=\\phi(x)\\cdot\\phi(z)$$ 则称 \\(K(x,z)\\) 为核函数， \\(\\phi(x)\\) 为映射函数，式中 \\(\\cdot\\) 为内积运算。 核技巧的想法是，在学习和预测中只定义核函数 \\(K(x,z)\\) ，而不显示的定义映射函数 \\(\\phi\\) 。通常，直接计算 \\(K(x,z)\\) 比较容易，而通过内积计算 \\(K(x,z)\\) 并不容易。 特征空间 \\({\\cal H}\\) 一般是高维或无穷维的，对于给定的核 \\(K(x,z)\\) ，特征空间核映射函数的取法并不唯一，可以取不同的特征空间，即便是在同一特征空间里也可以取不同的映射。 例 7.3 假设输入空间是 \\(\\mathbb{R}&#94;2\\) ，核函数是 \\(K(x,z)=(x\\cdot z)&#94;2\\) ，试找出其相关的特征空间 \\({\\cal H}\\) 和映射 \\(\\phi(x):\\mathbb{R}&#94;2\\to{\\cal H}\\) 解 ：取特征空间 \\({\\cal H}=\\mathbb{R}&#94;3\\) ，记 \\(x=\\left(x&#94;{(1)},x&#94;{(2)}\\right)&#94;\\text{T}\\) ， \\(z=\\left(z&#94;{(1)},z&#94;{(2)}\\right)&#94;\\text{T}\\) ，由于 $$\\begin{eqnarray} (x\\cdot z)&#94;2 &=& \\left(x&#94;{(1)}z&#94;{(1)}+x&#94;{(2)}z&#94;{(2)}\\right)&#94;2 \\\\ &=& \\left(x&#94;{(1)}z&#94;{(1)}\\right)&#94;2+2x&#94;{(1)}z&#94;{(1)}x&#94;{(2)}z&#94;{(2)}+\\left(x&#94;{(2)}z&#94;{(2)}\\right)&#94;2 \\end{eqnarray}$$ 所以可以取映射 $$\\phi(x)=\\left(\\left(x&#94;{(1)}\\right)&#94;2,\\sqrt{2}x&#94;{(1)}x&#94;{(2)},\\left(x&#94;{(2)}\\right)&#94;2\\right)&#94;\\text{T}$$ 容易验证 $$\\phi(x)\\cdot\\phi(z)=(x\\cdot z)&#94;2=K(x,z)$$ 仍取 \\({\\cal H}=\\mathbb{R}&#94;3\\) 以及 $$\\phi(x)=\\frac{1}{\\sqrt{2}}\\left(\\left(x&#94;{(1)}\\right)&#94;2-\\left(x&#94;{(2)}\\right)&#94;2,2x&#94;{(1)}x&#94;{(2)},\\left(x&#94;{(1)}\\right)&#94;2+\\left(x&#94;{(2)}\\right)&#94;2\\right)&#94;\\text{T}$$ 同样有 \\(\\phi(x)\\cdot\\phi(z)=(x\\cdot z)&#94;2=K(x,z)\\) 还可以取 \\({\\cal H}=\\mathbb{R}&#94;4\\) 和 $$\\phi(x)=\\left(\\left(x&#94;{(1)}\\right)&#94;2,x&#94;{(1)}x&#94;{(2)},x&#94;{(1)}x&#94;{(2)},\\left(x&#94;{(2)}\\right)&#94;2\\right)&#94;\\text{T}$$ 核技巧在支持向量机中的应用 注意到在线性支持向量机的对偶问题中，无论是目标函数还是决策函数（分离超平面）都只涉及输入实例与实例之间的内积。在对偶问题的目标函数中的内积可以用核函数来代替。此时对偶问题的目标函数变为 $$W(\\alpha)=\\frac{1}{2}\\sum_{i=1}&#94;N\\sum_{j=1}&#94;N\\alpha_i\\alpha_jy_iy_jK(x_i,x_j)-\\sum_{i=1}&#94;N\\alpha_i$$ 同样，分类决策函数中的内积也用核函数代替，变为 $$f(x)=\\text{sign}\\left(\\sum_{i=1}&#94;{N_s}\\alpha_i&#94;\\star y_iK(x_i,x)+b&#94;\\star\\right)$$ 学习是隐式的在特征空间进行的，不需要显式的定义特征空间和映射函数。在实际应用中，往往依赖领域知识直接选择核函数，核函数选择的有效性需要通过实验验证。 7.3.2 正定核 已知映射函数 \\(\\phi(x)\\) ，可以通过内积求得核函数 \\(K(x,z)\\) ，不用构造映射 \\(\\phi(x)\\) 能否直接判断一个给定的函数 \\(K(x,z)\\) 是不是核函数呢？我们有如下关于\b正定核函数（positive definite kernel function）的定理。 定理 7.5（正定核的充要条件）设 \\(K:{\\cal X}\\times{\\cal X}\\to\\mathbb{R}\\) 是对称函数，则 \\(K(x,z)\\) 为正定核的充要条件是对任意 \\(x_i\\in{\\cal X}\\) ， \\(K(x,z)\\) 对应的 Gram 矩阵 $$K=\\left[K(x_i,x_j)\\right]_{m\\times m}$$ 是半正定矩阵。 7.3.3 常用核函数 (a) 多项式核函数（polynomial kernel function） $$K(x,z)=(x\\cdot z+1)&#94;p$$ 对应的支持向量\b机是一个 \\(p\\) 次多项式分类器。决策函数为 $$f(x)=\\text{sign}\\left(\\sum_{i=1}&#94;{N_s}a_i&#94;\\star y_i(x_i\\cdot x+1)&#94;p+b&#94;\\star\\right)$$ (b) 高斯核函数（Gaussian kernel function） $$K(x,z)=\\exp\\left(-\\frac{\\|x-z\\|&#94;2}{2\\sigma&#94;2}\\right)$$ 对应的支持向量机是高斯径向基函数（radial basis function）分类器。决策函数为 $$f(x)=\\text{sign}\\left(\\sum_{i=1}&#94;{N_s}a_i&#94;\\star y_i\\exp\\left(-\\frac{\\|x-z\\|&#94;2}{2\\sigma&#94;2}\\right)+b&#94;\\star\\right)$$ (c) 字符串核函数（string kernel function）它与一般的核函数不同。其他核函数一般定义在欧氏空间上，而字符串核函数是定义在字符串集合上的核函数。字符串核函数被广泛用在文本分类、信息检索等方面。可以由动态规划快速的\b计算。 7.3.4 非线性支持向量分类机 定义 7.8（非线性支持向量机）从非线性\b分类训练集，通过核函数与软间隔最大化，或凸二次规划，学习得到的分类决策函数 $$f(x)=\\text{sign}\\left(\\sum_{i=1}&#94;{N}\\alpha_i&#94;\\star y_iK(x_i,x)+b&#94;\\star\\right)$$ 称为非线性支持向量机， \\(K(x,z)\\) 是正定核函数。 算法 7.4（非线性支持向量机学习算法） 输入：训练数据集 \\(T=\\{(x_1,y_1),(x_2,y_2),\\cdots,(x_N,y_N)\\}\\) ，其中 \\(x_i\\in{\\cal X}=\\mathbb{R}&#94;n\\) ， \\(y_i\\in{\\cal Y}=\\{+1,-1\\}\\) ， \\(i=1,2,\\cdots,N\\) 输出：分类决策函数 (1) 选择适当的核函数 \\(K(x,z)\\) 和惩罚参数 \\(C>0\\) ，构造并求解约束最优化问题 $$\\min_{\\alpha} \\frac{1}{2}\\sum_{i=1}&#94;N\\sum_{j=1}&#94;N\\alpha_i\\alpha_jy_iy_jK(x_i,x_j)-\\sum_{i=1}&#94;N\\alpha_i \\\\ \\text{s.t.}\\ \\ \\ \\ \\begin{eqnarray} \\sum_{i=1}&#94;N\\alpha_iy_i &=& 0 \\\\ 0\\leq\\alpha_i\\leq C,\\ i &=& 1,2,\\cdots,N \\end{eqnarray}$$ 求得最优解 \\(\\alpha&#94;\\star=\\left(\\alpha_1&#94;\\star,\\alpha_2&#94;\\star,\\cdots,\\alpha_N&#94;\\star\\right)&#94;\\text{T}\\) (2) 选择 \\(\\alpha&#94;\\star\\) 的一个分量满足 \\(0<\\alpha_i&#94;\\star<C\\) ，计算 $$b&#94;\\star=y_j-\\sum_{i=1}&#94;N\\alpha_i&#94;\\star y_iK(x_i,x_j)$$ (3) 构造分类决策函数 $$f(x)=\\text{sign}\\left(\\sum_{i=1}&#94;N\\alpha_i&#94;\\star y_iK(x,x_i)+b&#94;\\star\\right)$$ 当 \\(K(x,z)\\) 是正定核函数时，最优化问题是凸二次规划问题，解是存在的。 if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"读书笔记","url":"https://xutree.github.io/pages/2019/02/11/sl-7_3/"},{"title":"统计学习方法 第六章 逻辑回归与最大熵模型","text":"逻辑回归（logistic regression）是统计学习中的经典分类方法。最大熵是概率模型学习的一个准则，将其推广到分类问题得到最大熵模型（maximum entropy model）。 逻辑回归模型和最大熵模型都属于对数线性模型。 6.1 逻辑回归模型 6.1.1 逻辑分布 定义 6.1（逻辑分布）设 \\(X\\) 是连续随机变量， \\(X\\) 服从\b逻辑分布是指 \\(X\\) 具有下列分布函数和密度函数： $$\\begin{eqnarray} F(x) &=& P(X\\leq x)=\\frac{1}{1+\\text{e}&#94;{-(x-\\mu)/\\gamma}} \\\\ f(x) &=& F'(x)=\\frac{\\text{e}&#94;{-(x-\\mu)/\\gamma}}{\\gamma(1+\\text{e}&#94;{-(x-\\mu)/\\gamma})&#94;2} \\end{eqnarray}$$ 式中， \\(\\mu\\) 为位置参数， \\(\\gamma>0\\) 为形状参数。 下图中绘制了对于不用 \\(\\gamma\\) 逻辑分布函数和概率密度函数。分布函数是一条 S 形曲线（sigmoid curve）。该曲线以点 \\(\\left(\\mu,\\frac{1}{2}\\right)\\) 为中心对称，即满足 $$F(-x+\\mu)+F(x+\\mu)=1$$ 曲线在中心附近增长速度较快，在两端增长速度较慢。\b 6.1.2 二项逻辑回归模型 二项逻辑回归模型（binomial logistic regression model）是一种\b分类模型，由条件概率 \\(P(Y|X)\\) 表示，形式为参数化的逻辑分布。这里，随机变量 \\(X\\) 取值为实数，随机变量 \\(Y\\) 取值为 1 或 0，我们通过监督学习的方法来估计模型参数。 定义 6.2 （逻辑回归模型）二项逻辑回归模型是如下的条件概率分布： $$\\begin{eqnarray} P(Y=1|x) &=& \\frac{\\exp(w\\cdot x+b)}{1+\\exp(w\\cdot x+b)} \\\\ P(Y=0|x) &=& \\frac{1}{1+\\exp(w\\cdot x+b)} \\end{eqnarray}$$ 这里， \\(x\\in\\mathbb{R}&#94;n\\) 是输入， \\(Y\\in\\{0,1\\}\\) 是输出， \\(w\\in\\mathbb{R}&#94;n\\) 和 \\(b\\in\\mathbb{R}\\) 是参数（分别称为权重向量和偏置）， \\(w\\cdot x\\) 是内积。 对于\b给定的输入实例 \\(x\\) ，按照定义 6.2 可以求得 \\(P(Y=1|x)\\) 和 \\(P(Y=0|x)\\) 。逻辑回归比较两个概率值的大小，将实例 \\(x\\) 分到概率值较大的那一类。 有时为了方便，将权重向量和输入向量加以扩充，即 $$w=\\left(w&#94;{(1)},w&#94;{(2)},\\cdots,w&#94;{(n)},b\\right)&#94;\\text{T}\\\\ x=\\left(x&#94;{(1)},x&#94;{(2)},\\cdots,x&#94;{(n)},1\\right)&#94;\\text{T}$$ 这时，逻辑回归模型如下： $$\\begin{eqnarray} P(Y=1|x) &=& \\frac{\\exp(w\\cdot x)}{1+\\exp(w\\cdot x)} \\\\ P(Y=0|x) &=& \\frac{1}{1+\\exp(w\\cdot x)} \\end{eqnarray}$$ 一个事件的几率（odds）是指该事件发生的概率与该事件不发生的概率的比值，该事件的对数几率（log odds）或 logit 函数是 $$\\text{logit}(p)=\\log\\frac{p}{1-p}$$ 对逻辑回归而言，由扩充后的回归模型得 $$\\text{logit}\\left(P(Y=1|x)\\right)=\\log\\frac{P(Y=1|x)}{1-P(Y=1|x)}=w\\cdot x$$ 也就是说，输出 \\(Y=1\\) 的对数几率是输入 \\(x\\) 的线性函数，或者说，输出 \\(Y=1\\) 的对数几率是由输入 \\(x\\) 的线性函数表示的模型，即逻辑回归模型。 换一个角度看，考虑对输入 \\(x\\) 进行分类的线性函数 \\(w\\cdot x\\) （扩充后的），其值域为实数域。通过逻辑回归模型定义式可以将线性函数 \\(w\\cdot x\\) 转换为概率 $$P(Y=1|x)=\\frac{\\exp(w\\cdot x)}{1+\\exp(w\\cdot x)}$$ 上面的分布实际上是逻辑分布。这是，线性函数的值越接近 \\(+\\infty\\) ，概率值就越接近 1；线性函数的值越接近\b \\(-\\infty\\) ，概率在就越接近 0。这样的模型就是逻辑回归模型。 6.1.3 模型参数估计 逻辑回归模型学习时，对于给定的训练数据集 $$T=\\{(x_1,y_1),(x_2,y_2),\\cdots,(x_N,y_N)\\}$$ 其中 \\(x_i\\in\\mathbb{R}&#94;n\\) ， \\(y_i\\in\\{0,1\\}\\) ，可以应用极大似然估计法估计模型参数，从而得到逻辑回归模型。 设 $$P(Y=1|x) = \\pi(x) \\\\ P(Y=0|x) = 1-\\pi(x)$$ 似然函数为 $$\\prod_{i=1}&#94;N\\left[\\pi(x_i)\\right]&#94;{y_i}\\left[1-\\pi(x_i)\\right]&#94;{1-y_i}$$ 对数似然函数为 $$\\begin{eqnarray} L(w) &=& \\sum_{i=1}&#94;N\\left[y_i\\log\\pi(x_i)+(1-y_i)\\log(1-\\pi(x_i))\\right] \\\\ &=& \\sum_{i=1}&#94;N\\left[y_i\\log\\frac{\\pi(x_i)}{1-\\pi(x_i)}+\\log(1-\\pi(x_i))\\right] \\\\ &=& \\sum_{i=1}&#94;N[y_i(w\\cdot x_i)-\\log(1+\\exp(w\\cdot x_i))] \\end{eqnarray}$$ 对 \\(L(w)\\) 求极大值，得到 \\(w\\) 的估计值。 这样，问题就变成以对数似然函数为目标函数的最优化问题。逻辑回归\b学习中通常采用的方法是梯度下降法和拟牛顿法。 假设 \\(w\\) 的极大似然估计值是 \\(\\hat{w}\\) ，那么学到的逻辑回归模型为 $$P(Y=1|x)=\\frac{\\exp(\\hat{w}\\cdot x)}{1+\\exp(\\hat{w}\\cdot x)} \\\\ P(Y=0|x)=\\frac{1}{1+\\exp(\\hat{w}\\cdot x)}$$ 6.1.4 多项逻辑\b回归 可以将二项回归模型推广到多项逻辑回归模型（multi-nominal logistic regression \bmodel），用于多类分类。 假设离散型随机变量 \\(Y\\) 的取值集合是 \\(\\{1,2,\\cdots,K\\}\\) ，那么多项逻辑回归模型是 $$P(Y=k|x)=\\frac{\\exp(w_k\\cdot x)}{1+\\sum_{k=1}&#94;{K-1}\\exp(w_k\\cdot x)},k=1,2,\\cdots,K-1 \\\\ P(Y=K|x)=\\frac{1}{1+\\sum_{k=1}&#94;{K-1}\\exp(w_k\\cdot x)}$$ 这里， \\(x\\in\\mathbb{R}&#94;{n+1}\\) ， \\(w_k\\in\\mathbb{R}&#94;{n+1}\\) 二项逻辑回归的参数估计法也可以推广到多项逻\b辑回归。 6.2 最大熵模型 最大熵模型（maximum entropy model）由最大熵原理推导实现。 6.2.1 最大熵原理 最大熵原理是概率模型学习的一个准则。最大熵原理认为：学习概率模型时，在所\b有可能的概率模型（分布）中，熵最大的模型时最好的模型。 通常用约束条件来确定概率模型的集合，所以，最大熵原理也可以表述为在\b满足约束条件的模型集合中选取熵最大的模型。 假设离散随机变量 \\(X\\) 的\b概率分布是 \\(P(X)\\) ，则其熵是 $$H(P)=-\\sum_xP(x)\\log P(x)$$ 熵满足下列不等式 $$0\\leq H(P)\\leq\\log |X|$$ 式中， \\(|X|\\) 是 \\(X\\) 取值个数，当且仅当 \\(X\\) 的分布是均匀分布时右边的等号成立。也就是说，当 \\(X\\) 服从均匀分布时，熵最大。 6.2.2 最大熵模型的定义 最大熵原理是统计学习的一般原理，将它应用到分类得到最大熵模型。 假设分类模型是一个条件概率分布 \\(P(Y|X)\\) ，给定一个训练数据集 $$T=\\{(x_1,y_1),(x_2,y_2),\\cdots,(x_N,y_N)\\}$$ 学习的目标是用最大熵原理选择最好的分类模型。 首先考虑模型应该满足的条件。给定训练数据集，可以确定联合概率分布 \\(P(X,Y)\\) 和边缘分布 \\(P(X)\\) 的经验分布，分别用 \\(\\tilde{P}(X,Y)\\) 和 \\(\\tilde{P}(X)\\) 表示 $$\\tilde{P}(X=x,Y=y)=\\frac{v(X=x,Y=y)}{N} \\\\ \\tilde{P}(X=x)=\\frac{v(X=x)}{N}$$ 其中， \\(v(\\cdot)\\) 表示频数， \\(N\\) 是训练样本容量。 用特征函数（feature function） \\(f(x,y)\\) 描述输入 \\(x\\) 和输出 \\(y\\) 之间的某一个事实。其定义是 $$f(x,y)=\\begin{cases} 1, & x\\ 与\\ y\\ 满足某一事实 \\\\ 0, & 否则 \\end{cases}$$ 它是一个二值函数（一般的，特征函数可以是任意的实值函数）。 特征函数 \\(f(x,y)\\) 关于经验分布 \\(\\tilde{P}(X,Y)\\) 的期望值，用 \\(\\text{E}_{\\tilde{P}}(f)\\) 表示 $$\\text{E}_{\\tilde{P}}(f)=\\sum_{x,y}\\tilde{P}(x,y)f(x,y)$$ 特征函数 \\(f(x,y)\\) 关于模型 \\(P(Y|X)\\) 与经验分布 \\(\\tilde{P}(X)\\) 的期望值，用 \\(\\text{E}_P(f)\\) 表示 $$\\text{E}_P(f)=\\sum_{x,y}\\tilde{P}(x)P(y|x)f(x,y)$$ 如果模型能够获取训练数据中的信息，那么就可以假设这两个期望值相等，即 $$\\text{E}_P(f)=\\text{E}_{\\tilde{P}}(f)$$ 即 $$\\sum_{x,y}\\tilde{P}(x)P(y|x)f(x,y)=\\sum_{x,y}\\tilde{P}(x,y)f(x,y)$$ 我们将上式作为模型学习的约束条件。假如有 \\(n\\) 个特征函数 \\(f_i(x,y)\\) ， \\(i=1,2,\\cdots,n\\) ，那么就有 \\(n\\) 个约束条件。 定义 6.3（最大熵模型）假设满足所有约束条件的模型集合为 $${\\cal C}\\equiv\\left\\{P\\in{\\cal P}|\\text{E}_P(f_i)=\\text{E}_{\\tilde{P}}(f_i),i=1,2,\\cdots,n\\right\\}$$ 定义在条件概率分布 \\(P(Y|X)\\) 上的条件熵为 $$H(P)=-\\sum_{x,y}\\tilde{P}(x)P(y|x)\\log P(y|x)$$ 则模型集合 \\({\\cal C}\\) 中条件熵 \\(H(P)\\) 最大的模型称为最大熵模型。式中的对数为自然对数。 6.2.3 最大熵模型的学习 最大熵模型的学习过程就是求解最大熵模型的过程。最大熵模型的学习可以形式化为约束最优化问题。 对于给定的训练数据集 $$T=\\{(x_1,y_1),(x_2,y_2),\\cdots,(x_N,y_N)\\}$$ 以及特征函数 $$f_i(x,y),\\ i=1,2,\\cdots,n$$ 最大熵模型的学习等价于约束优化问题： $$\\max_{P\\in{\\cal C}}\\ \\ \\ \\ \\ H(P)=-\\sum_{x,y}\\tilde{P}(x)P(y|x)\\log P(y|x) \\\\ \\text{s.t.}\\ \\ \\ \\ \\ \\text{E}_P(f_i)=\\text{E}_{\\tilde{P}}(f_i),\\ i=1,2,\\cdots,n \\\\ \\sum_{y}P(y|x)=1$$ 按照最优化问题的习惯，将求最大值问题改写为等价的求最小值问题： $$\\min_{P\\in{\\cal C}}\\ \\ \\ \\ \\ -H(P)=\\sum_{x,y}\\tilde{P}(x)P(y|x)\\log P(y|x) \\\\ \\text{s.t.}\\ \\ \\ \\ \\ \\text{E}_P(f_i)-\\text{E}_{\\tilde{P}}(f_i)=0,\\ i=1,2,\\cdots,n \\\\ \\sum_{y}P(y|x)=1$$ 这里，将约束最优化问题的原始问题转换为无约束最优化的对偶问题，通过求解对偶问题求解原始问题。 首先，引进拉格朗日乘子 \\(w_0,w_1,w_2,\\cdots,w_n\\) ，定义拉格朗日函数 $$\\begin{eqnarray} L(P,w) &\\equiv& -H(P)+w_0\\left(1-\\sum_yP(y|x)\\right)+\\sum_{i=1}&#94;nw_i\\left(\\text{E}_P(f_i)-\\text{E}_{\\tilde{P}}(f_i)\\right) \\\\ &=& \\sum_{x,y}\\tilde{P}(x)P(y|x)\\log P(y|x)+w_0\\left(1-\\sum_yP(y|x)\\right) \\\\ &+& \\sum_{i=1}&#94;nw_i\\left(\\sum_{x,y}\\tilde{P}(x,y)f_i(x,y)-\\sum_{x,y}\\tilde{P}(x)P(y|x)f_i(x,y)\\right) \\end{eqnarray}$$ 最优化的原始问题是 $$\\min_{P\\in{\\cal C}}\\max_wL(P,w)$$ 对偶问题是 $$\\max_w\\min_{P\\in{\\cal C}}L(P,w)$$ 由于拉格朗日函数 \\(L(P,w)\\) 是 \\(P\\) 的凸函数，原始问题的解和对偶问题的解是等价的。 首先，求解对偶问题内部的极小化问题，\b记作 $$\\Psi(w)=\\min_{P\\in{\\cal C}}L(P,w)=L(P_w,w)$$ \\(\\Psi(w)\\) 称为对偶函数，同时，将其解记作 $$P_w=\\arg\\min_{P\\in{\\cal C}}L(P,w)=P_w(y|x)$$ 通过令偏导数等于 0 $$\\begin{eqnarray} \\frac{\\partial L(P,w)}{\\partial P(y|x)} &=& \\sum_{x,y}\\tilde{P}(x)\\left(\\log P(y|x)+1\\right)-\\sum_yw_0-\\sum_{x,y}\\left(\\tilde{P}(x)\\sum_{i=1}&#94;nw_if_i(x,y)\\right) \\\\ &=& \\sum_{x,y}\\tilde{P}(x)\\left(\\log P(y|x)+1-w_0-\\sum_{i=1}&#94;nw_if_i(x,y)\\right) \\end{eqnarray}$$ 在 \\(\\tilde{P}(x)>0\\) 的\b情况下，解得 $$\\begin{eqnarray} P(y|x) &=& \\exp\\left(\\sum_{i=1}&#94;nw_if_i(x,y)+w_0-1\\right) \\\\ &=& \\frac{\\exp\\left(\\sum_{i=1}&#94;nw_if_i(x,y)\\right)}{\\exp(1-w_0)} \\end{eqnarray}$$ 由于 \\(\\sum_yP(y|x)=1\\) ，得 $$P_w(y|x)=\\frac{1}{Z_w(x)}\\exp\\left(\\sum_{i=1}&#94;nw_if_i(x,y)\\right)$$ 其中 $$Z_w(x)=\\sum_y\\exp\\left(\\sum_{i=1}&#94;nw_if_i(x,y)\\right)$$ 称为规范化因子； \\(f_i(x,y)\\) 是\b特征函数， \\(w_i\\) 是特征函数的权值。由以上两式表示的 \\(P_w(y|x)\\) 就是最大熵模型， \\(w\\) 是最大熵模型中的参数向量。 之后，求解对偶问题外部的极大化问题 $$\\max_w\\Psi(w)$$ 将其解记为 \\(w&#94;\\star\\) ，即 $$w&#94;\\star=\\arg\\max_w\\Psi(w)$$ 故最终的最大熵模型是 $$P&#94;\\star=P_{w&#94;\\star}=P_{w&#94;\\star}(y|x)$$ 6.2.4 极大似然估计 \b从最大熵模型学习中可以看出，最大熵模型是由下面两个式子表示的条件概率分布： $$P_w(y|x)=\\frac{1}{Z_w(x)}\\exp\\left(\\sum_{i=1}&#94;nw_if_i(x,y)\\right) \\\\ Z_w(x)=\\sum_y\\exp\\left(\\sum_{i=1}&#94;nw_if_i(x,y)\\right)$$ 下面证明，对偶函数的极大化等价于最大熵模型的极大似然估计。 最大似然函数的一般形式是样本集中各个样本的联合概率： $$L(x_1,x_2,\\cdots,x_N;\\theta)=\\prod_{i=1}&#94;{N} p(x_i;\\theta)$$ 其中利用了数据是独立同分布产生的假设。 \\(x_1,x_2,\\cdots,x_N\\) 是样本具体观测值。随机变量 \\(X\\) 是离散的，所以它的取值范围是一个集合，假设样本集的大小为 \\(N\\) ， \\(X\\) 的取值有 \\(K\\) 个，分别是 \\(c_1,c_2,\\cdots,c_K\\) 。用 \\(v(X=c_i)\\) 表示在观测值中样本 \\(c_i\\) 出现的频数。则： $$L(x_1,x_2,\\cdots,x_N;\\theta)=\\prod_{i=1}&#94;{k}p(v_i;\\theta)&#94;{v(X=c_i)}$$ 对等式两边同时开 \\(N\\) 次方，可得： $$L(x_1,x_2,\\cdots,x_N;\\theta)&#94;{\\frac{1}{N}}=\\prod_{i=1}&#94;{k}p(v_i;\\theta)&#94;{\\frac{v(X=c_i)}{N}}$$ 因为经验概率 \\(\\tilde{p}(x)=\\frac{v(X=c_i)}{N}\\) ，所以： $$L(x_1,x_2,\\cdots,x_N;\\theta)&#94;{\\frac{1}{N}}=\\prod_{x}p(x;\\theta)&#94;{\\tilde{p}(x)}$$ 很明显对 \\(L(x_1,x_2,\\cdots,x_N;\\theta)\\) 求最大值和对 \\(L(x_1,x_2,\\cdots,x_N;\\theta)&#94;{\\frac{1}{N}}\\) 求最大值的优化的结果是一样的。整理上式所以最终的最大似然函数可以表示为： $$L(x;\\theta)=\\prod_{x} p(x;\\theta)&#94;{\\tilde{p}(x)}$$ 已知\b训练数据的经验概率分布 \\(\\tilde{P}(X,Y)\\) ，条件概率分布 \\(P(Y|X)\\) 的对数似然函数表示为： $$L_{\\tilde{P}}(P_w)=\\log\\prod_{x,y}P(y|x)&#94;{\\tilde{P}(x,y)}=\\sum_{x,y}\\tilde{P}(x,y)\\log P(y|x)$$ 当条件概率分布 \\(P(y|x)\\) 是最大熵模型时，对数似然函数为 $$\\begin{eqnarray} L_{\\tilde{P}}(P_w) &=& \\sum_{x,y}\\tilde{P}(x,y)\\log P(y|x) \\\\ &=& \\sum_{x,y}\\tilde{P}(x,y)\\sum_{i=1}&#94;nw_if_i(x,y)-\\sum_{x,y}\\tilde{P}(x,y)\\log Z_w(x) \\\\ &=& \\sum_{x,y}\\tilde{P}(x,y)\\sum_{i=1}&#94;nw_if_i(x,y)-\\sum_x\\tilde{P}(x)\\log Z_w(x) \\end{eqnarray}$$ 再看对偶函数 \\(\\Psi(w)\\) : $$\\begin{eqnarray} \\Psi(w) &=& \\sum_{x,y}\\tilde{P}(x)P_w(y|x)\\log P_w(y|x)+w_0\\left(1-\\sum_yP_w(y|x)\\right) \\\\ &+& \\sum_{i=1}&#94;nw_i\\left(\\sum_{x,y}\\tilde{P}(x,y)f_i(x,y)-\\sum_{x,y}\\tilde{P}(x)P_w(y|x)f_i(x,y)\\right) \\\\ &=& \\sum_{x,y}\\tilde{P}(x,y)\\sum_{i=1}&#94;nw_if_i(x,y) \\\\ &+& \\sum_{x,y}\\tilde{P}(x)P_w(y|x)\\left(\\log P_w(y|x)-\\sum_{i=1}&#94;nw_if_i(x,y)\\right) \\\\ &=& \\sum_{x,y}\\tilde{P}(x,y)\\sum_{i=1}&#94;nw_if_i(x,y)-\\sum_{x,y}\\tilde{P}(x)P_w(y|x)\\log Z_w(x) \\\\ &=& \\sum_{x,y}\\tilde{P}(x,y)\\sum_{i=1}&#94;nw_if_i(x,y)-\\sum_{x}\\tilde{P}(x)\\log Z_w(x) \\end{eqnarray}$$ 其中利用了 \\(\\sum_yP(y|x)=1\\) 。 比较易得 \\(\\Psi(w)=L_{\\tilde{P}}(P_w)\\) ，于是证明了最大熵学习中的对偶函数极大化等价于最大熵模型的极大似然估计这一事实。这样，最大熵模型的学习问题就转换为具体\b求解对数似然函数极大化或对偶函数极大化的问题。 可以将最大熵模型写成更一般的形式： $$P_w(y|x)=\\frac{1}{Z_w(x)}\\exp\\left(\\sum_{i=1}&#94;nw_if_i(x,y)\\right) \\\\ Z_w(x)=\\sum_y\\exp\\left(\\sum_{i=1}&#94;nw_if_i(x,y)\\right)$$ 这里， \\(x\\in\\mathbb{R}&#94;n\\) 为输入， \\(y\\in\\{1,2,\\cdots,K\\}\\) 为输出， \\(w\\in\\mathbb{R}&#94;n\\) 为权值向量， \\(f_i(x,y)\\) ， \\(i=1,2,\\cdots,n\\) 为任意实值特征函数。 最大熵模型与逻辑回归模型有着\b类似的形式，它们又称为对数线性模型（log linear model）。模型学习就是在给定的训练数据条件下对模型进行极大似然估计或正则化的极大似然估计。 6.3 \b模型学习的最优化算法 6.3.1 改进的迭代尺度法 改进的迭代尺度法（improved iterative scaling，IIS）是一种最大熵模型学习的最优化算法。 已知最大熵模型： $$P_w(y|x)=\\frac{1}{Z_w(x)}\\exp\\left(\\sum_{i=1}&#94;nw_if_i(x,y)\\right) \\\\ Z_w(x)=\\sum_y\\exp\\left(\\sum_{i=1}&#94;nw_if_i(x,y)\\right)$$ 对数似然函数为： $$L(w)=\\sum_{x,y}\\tilde{P}(x,y)\\sum_{i=1}&#94;nw_if_i(x,y)-\\sum_x\\tilde{P}(x)\\log Z_w(x) $$ 目标是通过极大似然估计学习模型参数，即求对数似然函数的极大值 \\(w&#94;\\star\\) 。 首先建立对数似然函数改变量的下界 $$\\begin{eqnarray} L(w+\\delta)-L(w) &=& \\sum_{x,y}\\tilde{P}(x,y)\\log P_{w+\\delta}(y|x)-\\sum_{x,y}\\tilde{P}(x,y)\\log P_{w}(y|x) \\\\ &=& \\sum_{x,y}\\tilde{P}(x,y)\\sum_{i=1}&#94;n\\delta_if_i(x,y)-\\sum_x\\tilde{P}(x)\\log \\frac{Z_{w+\\delta}(x)}{Z_w(x)} \\end{eqnarray}$$ 利用不等式 $$-\\log\\alpha\\geq1-\\alpha,\\alpha>0$$ 得 $$\\begin{eqnarray} L(w+\\delta)-L(w) &\\geq& \\sum_{x,y}\\tilde{P}(x,y)\\sum_{i=1}&#94;n\\delta_if_i(x,y)+1-\\sum_x\\tilde{P}(x)\\frac{Z_{w+\\delta}(x)}{Z_w(x)} \\\\ &=& \\sum_{x,y}\\tilde{P}(x,y)\\sum_{i=1}&#94;n\\delta_if_i(x,y)+1 \\\\ &-& \\sum_x\\tilde{P}(x)\\sum_yP_w(y|x)\\exp\\left(\\sum_{i=1}&#94;n\\delta_if_i(x,y)\\right) \\end{eqnarray}$$ 将右端记为 $$A(\\delta|w)=\\sum_{x,y}\\tilde{P}(x,y)\\sum_{i=1}&#94;n\\delta_if_i(x,y)+1-\\sum_x\\tilde{P}(x)\\sum_yP_w(y|x)\\exp\\left(\\sum_{i=1}&#94;n\\delta_if_i(x,y)\\right)$$ 于是有 $$L(w+\\delta)-L(w)\\geq A(\\delta|w)$$ 如果能找到适当的 \\(\\delta\\) \b 使下界 \\(A(\\delta|w)\\) 提高，那么对数似然函数也会提高，然而 \\(A(\\delta|w)\\) 中的 \\(\\delta\\) 是个向量，不易同时优化，IIS 试图\b一次只优化其中一个变量 \\(\\delta_i\\) ，而固定其他变量 \\(\\delta_j\\) ， \\(i\\neq j\\) 。 为达到这一目的，IIS 进一步降低下界 \\(A(\\delta|w)\\) 。引入一个量 $$f&#94;\\sharp(x,y)=\\sum_if_i(x,y)$$ 因为 \\(f_i\\) 是二值函数，故 \\(f&#94;\\sharp(x,y)\\) 表示所有特征在 \\((x,y)\\) 出现的次数，这样 \\(A(\\delta|w)\\) 可改写为 $$\\begin{eqnarray} A(\\delta|w) &=& \\sum_{x,y}\\tilde{P}(x,y)\\sum_{i=1}&#94;n\\delta_if_i(x,y)+1 \\\\ &-& \\sum_x\\tilde{P}(x)\\sum_yP_w(y|x)\\exp\\left(f&#94;\\sharp(x,y)\\sum_{i=1}&#94;n\\frac{\\delta_if_i(x,y)}{f&#94;\\sharp(x,y)}\\right) \\end{eqnarray}$$ \b利用指数函数的凸性以及对任意 \\(i\\) ，有 $$\\frac{f_i(x,y)}{f&#94;\\sharp(x,y)}\\geq0\\ 且\\ \\sum_{i=1}&#94;n\\frac{f_i(x,y)}{f&#94;\\sharp(x,y)}=1$$ 根据琴生不等式（Jensen's inequality），得到 $$\\exp\\left(\\sum_{i=1}&#94;n\\frac{f_i(x,y)}{f&#94;\\sharp(x,y)}\\delta_if&#94;\\sharp(x,y)\\right)\\leq\\sum_{i=1}&#94;n\\frac{f_i(x,y)}{f&#94;\\sharp(x,y)}\\exp\\left(\\delta_if&#94;\\sharp(x,y)\\right)$$ 于是得到对数似然函数改变量的一个新的（\b相对不紧的）下界 $$\\begin{eqnarray} B(\\delta|w) &=& \\sum_{x,y}\\tilde{P}(x,y)\\sum_{i=1}&#94;n\\delta_if_i(x,y)+1 \\\\ &-& \\sum_x\\tilde{P}(x)\\sum_yP_w(y|x)\\sum_{i=1}&#94;n\\left(\\frac{f_i(x,y)}{f&#94;\\sharp(x,y)}\\right)\\exp\\left(\\delta_if&#94;\\sharp(x,y)\\right) \\end{eqnarray}$$ 求 \\(B(\\delta|w)\\) 对 \\(\\delta_i\\) 的偏导数 $$\\begin{eqnarray} \\frac{\\partial B(\\delta|w)}{\\partial \\delta_i} &=& \\sum_{x,y}\\tilde{P}(x,y)f_i(x,y) \\\\ &-& \\sum_x\\tilde{P}(x)\\sum_yP_w(y|x)f_i(x,y)\\exp\\left(\\delta_if&#94;\\sharp(x,y)\\right) \\end{eqnarray}$$ 上式只含有 \\(\\delta_i\\) ，令偏导数等于 0 得到 $$\\sum_x\\tilde{P}(x)\\sum_yP_w(y|x)f_i(x,y)\\exp\\left(\\delta_if&#94;\\sharp(x,y)\\right)=\\text{E}_{\\tilde{P}}(f_i)$$ 于是，依次对 \\(\\delta_i\\) 求解上述方程就可以求出 \\(\\delta\\) 。 算法 6.1（改进的迭代尺度算法 IIS） 输入：特征函数 \\(f_1,f_2,\\cdots,f_n\\) ；经验分布函数 \\(\\tilde{P}(X,Y)\\) ，模型 \\(P_w(y|x)\\) 输出：最优参数值 \\(w_i&#94;\\star\\) ；最优模型 \\(P_{w&#94;\\star}\\) (1) 对所有 \\(i\\in\\{1,2,\\cdots,n\\}\\) ，取初值 \\(w_i=0\\) (2) 对每一 \\(i\\in\\{1,2,\\cdots,n\\}\\) ： (2.a) 令 \\(\\delta_i\\) 是方程 $$\\sum_x\\tilde{P}(x)\\sum_yP_w(y|x)f_i(x,y)\\exp\\left(\\delta_if&#94;\\sharp(x,y)\\right)=\\text{E}_{\\tilde{P}}(f_i)$$ 的解，这里 $$f&#94;\\sharp(x,y)=\\sum_{i=1}&#94;nf_i(x,y)$$ (2.b) 更新： \\(w_i\\leftarrow w_i+\\delta_i\\) (3) 如果不是所有 \\(w_i\\) 都收敛，重复步骤 (2) 这一算法关键步骤是 (2.a)，如果 \\(f&#94;\\sharp\b(x,y)\\) 是常数，即对任意的 \\(x\\) ， \\(y\\) ，有 \\(f&#94;\\sharp(x,y)=M\\) ，那么 \\(\\delta_i\\) 可以显示的表示为 $$\\delta_i=\\frac{1}{M}\\log\\frac{\\text{E}_\\tilde{P}(f_i)}{\\text{E}_P(f_i)}$$ 如果 \\(f&#94;\\sharp(x,y)\\) 不是常数，就必须数值计算求 \\(\\delta_i\\) ，简单有效的方法是牛顿法，由于方程有单根，因此牛顿法恒收敛，且收敛速度很快。 6.3.2 拟牛顿法 最大熵模型学习还可以应用牛顿法或拟牛顿法。 对于最大熵模型 $$P_w(y|x)=\\frac{\\exp\\left(\\sum_{i=1}&#94;nw_if_i(x,y)\\right)}{\\sum_y\\exp\\left(\\sum_{i=1}&#94;nw_if_i(x,y)\\right)}$$ 目标函数为： $$\\min_{w\\in\\mathbb{R}&#94;n}\\ \\ f(w)=\\sum_x\\tilde{P}(x)\\log\\sum_y\\exp\\left(\\sum_{i=1}&#94;nw_if_i(x,y)\\right)-\\sum_{x,y}\\tilde{P}(x,y)\\sum_{i=1}&#94;nw_if_i(x,y) $$ 梯度： $$g(w)=\\left(\\frac{\\partial f(w)}{\\partial w_1},\\frac{\\partial f(w)}{\\partial w_2},\\cdots,\\frac{\\partial f(w)}{\\partial w_n}\\right)&#94;\\text{T}$$ 其中 $$\\frac{\\partial f(w)}{\\partial w_i}=\\sum_{x,y}\\tilde{P}(x)P_w(y|x)f_i(x,y)-\\text{E}_{\\tilde{P}}(f_i),i=1,2,\\cdots,n$$ 算法 6.2（最大熵模型学习的 BFGS）算法 输入：特征函数 \\(f_1,f_2,\\cdots,f_n\\) ；经验分布 \\(\\tilde{P}(x,y)\\) ，目标函数 \\(f(w)\\) ，梯度 \\(g(w)=\\nabla f(w)\\) ，精度要求 \\(\\epsilon\\) 输出：最优化参数值 \\(w&#94;\\star\\) ；最优模型 \\(P_{w&#94;\\star}(y|x)\\) (1) 选定初始点 \\(w&#94;{(0)}\\) ，取 \\({\\bf B_0}\\) 为正定对称矩阵，置 \\(k=0\\) (2) 计算 \\(g_k=g(w&#94;{(k)})\\) ，若 \\(\\|g_k\\|<\\epsilon\\) \b，则停止计算，得 \\(w&#94;\\star=w&#94;{(k)}\\) ；否则，转到 (3) (3) 由 \\({\\bf B_k}p_k=-g_k\\) 求出 \\(p_k\\) (4) 一维搜索：求 \\(\\lambda_k\\) 使得 $$f(w&#94;{(k)}+\\lambda_kp_k)=\\min_{\\lambda\\geq0}f(w&#94;{(k)}+\\lambda p_k)$$ (5) 置 \\(w&#94;{(k+1)}=w&#94;{(k)}+\\lambda_k p_k\\) (6) 计算 \\(g_{k+1}=g(w&#94;{(k+1)})\\) ，若 \\(\\|g_{k+1}\\|<\\epsilon\\) \b\b，则停止计算，得 \\(w&#94;\\star=w&#94;{(k+1)}\\) ；否则，按照下式求出 \\({\\bf B_{k+1}}\\) $${\\bf B_{k+1}}={\\bf B_k}+\\frac{y_ky_k&#94;\\text{T}}{y_k&#94;\\text{T}\\delta_k}-\\frac{{\\bf B_k}\\delta_k\\delta_k&#94;\\text{T}{\\bf B_k}}{\\delta_k&#94;\\text{T}{\\bf B_k}\\delta_k}$$ 其中， $$y_k=g_{k+1}-g_k,\\delta_k=w&#94;{(k+1)}-w&#94;{(k)}$$ (7) 置 \\(k=k+1\\) ，转到 (3) if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"读书笔记","url":"https://xutree.github.io/pages/2019/02/09/sl-6/"},{"title":"统计学习方法 第五章 决策树","text":"决策树（decision tree）是一种基本的分类与回归方法。其主要优点是 模型具有可读性 ， \b分类速度快 。决策树学习通常包括三个步骤： 特征选择 、 决策树的生成 和 决策树的修剪 。 5.1 决策树模型与学习 5.1.1 决策树模型 定义 5.1 （决策树）分类决策树模型是一种描述对实例进行分类的树形结构。决策树由节点（node）和有向边（directed edge）组成。节点有两种类型：内部节点（internal node）和叶节点（leaf node）。内部节点表示一个特征或属性，叶节点表示一个类。 5.1.2 决策树学习 假设给定训练数据集 $$T=\\{(x_1,y_1),(x_2,y_2),\\cdots,(x_N,y_N)\\}$$ 其中输入实例（向量）为 $$x_i=\\left(x_i&#94;{(1)},x_i&#94;{(2)},\\cdots,x_i&#94;{(n)}\\right)$$ \\(n\\) 为特征个数。类标记为 $$y_i\\in\\{c_1,c_2,\\cdots,c_K\\}$$ 其中 \\(i\\in\\{1,2,\\cdots,N\\}\\) ， \\(N\\) 为样本容量。 学习的目的是根据给定的训练数据集构建一个决策树模型，使它能够对实例进行正确的分类。 决策树\b学习本质上是从训练数据集中归纳出一组分类\b规则。与训练集不相矛盾的决策树可能有多个也可能一个也没有，我们需要的是一个与训练集矛盾较小的决策树，同时具有很好的泛化能力。 决策树学习的损失函数通常是正则化的极大似然函数。决策树学习的策略是以损失函数为目标函数的最小化。 当损失函数确定以后，学习问题变成在损失函数意义下选择最有决策树的问题，因为从所有可能的决策树中选取最优决策树是 NP 完全问题，所以现实中决策树学习算法通常采用启发式方法，近似求解这一最优化问题。这样得到的决策树\b是次最优（sub-optimal）的。 5.2 特征选择 5.2.1 特征选择的问题 特征选择在于选取对训练数据具有分类能力的特征。这样就可以提高决策树学习的效率。如果利用一个特征进行分类的结果与随机分类的结果没有很大差别，则称这个特征是\b没有分类能力的。通常特征选取的准则是信息增益或信息增益比。 5.2.2 信息\b增益 \b为了便于说明，首先给出熵与条件熵的定义。 熵（entropy）是表示随机变量不确定性的度量。 设 \\(X\\) 是一个离散随机变量，其概率分布为 $$P(X=x_i)=p_i,i=1,2,\\cdots,n$$ 则，随机变\b量 \\(X\\) 的熵定义为 $$H(X)=-\\sum_{i=1}&#94;np_i\\log p_i$$ 若 \\(p_i=0\\) ，定义 \\(0\\log0=0\\) 。通常，上式中对数的底为 2 或自然对数 e，这时熵的单位分别为比特（bit）或纳特（nat）。 设有随机变量 \\((X,Y)\\) ，其联合概率分布为 $$P(X=x_i,Y=y_j)=p_{ij},i=1,2,\\cdots,n;j=1,2,\\cdots,m$$ 条件熵（conditional entropy） \\(H(Y|X)\\) \b\b表示在已知随机变量 \\(X\\) 的条件下随机变量 \\(Y\\) 的不确定性，定义为 \\(X\\) 给定条件下 \\(Y\\) 的条件概率分布的熵对 \\(X\\) 的数学期望 $$H(Y|X)=\\sum_{i=1}&#94;np_iH(Y|X=x_i)$$ 这里 \\(p_i=P(X=x_i),i=1,2,\\cdots,n\\) 当熵和条件熵中的概率由数据估计（特别是极大似然估计）得到时，所对应的熵和条件熵分别称为经验熵（empirical entropy）和经验条件熵（empirical conditional \bentropy）。 信息增益（\binformation gain）表示得知特征 \\(X\\) 的信息而使类 \\(Y\\) 的信息的不确定度减少的程度。 定义 5.2 （信息增益）特征 \\(A\\) 对训练数据集 \\(D\\) 的信息增益 \\(g(D,A)\\) ，定义为集合 \\(D\\) 的经验熵 \\(H(D)\\) 与特征 \\(A\\) 给定条件下 \\(D\\) 的\b经验条件熵 \\(H(D|A）\\) 之差 $$g(D,A)=H(D)-H(D|A)$$ 一般的，熵与条件熵之差称为互信息（mutual information）。决策树\b学习中的信息增益等价于训练数据集中类和特征的互信息。 根据信息增益准则的特征选择方法是：对训练数据集（或子集） \\(D\\) ，计算其每个特征的信息增益，选择信息增益最大的特征。 设训练数据集为 \\(D\\) ， \\(|D|\\) 表示其样本容量。设有 \\(K\\) 个类 \\(C_k\\) ， \\(k=1,2\\cdots,K\\) ， \\(|C_k|\\) 为属于类 \\(C_k\\) 的样本个数。设特征 \\(A\\) 有 \\(n\\) 个不同的取值 ，根据特征 \\(A\\) 的取值将 \\(D\\) 划分为 \\(n\\) 个子集， \\(|D_i|\\) 为 \\(D_i\\) 的样本个数。记子集 \\(D_i\\) 中属于类 \\(C_k\\) 的样本的集合为 \\(D_{ik}\\) ， \\(|D_{ik}|\\) 为 \\(D_{ik}\\) 的样本个数，于是信息增益的算法如下 算法 5.1 （信息增益的\b算法） 输入：训练数据集 \\(D\\) 和特征 \\(A\\) 输出：特征 \\(A\\) 对训练数据集 \\(D\\) 的信息增益 \\(g(D,A)\\) (1) 计算数据集 \\(D\\) 的经验熵 \\(H(D)\\) $$H(D)=-\\sum_{k=1}&#94;K\\frac{|C_k|}{|D|}\\log_2\\frac{|C_k|}{|D|}$$ (2) 计算特征 \\(A\\) 对数据集 \\(D\\) 的经验条件熵 \\(H(D|A)\\) $$H(D|A)=\\sum_{i=1}&#94;n\\frac{|D_i|}{|D|}H(D_i)=-\\sum_{i=1}&#94;n\\frac{|D_i|}{|D|}\\sum_{k=1}&#94;K\\frac{|D_{ik}|}{|D_i|}\\log_2\\frac{|D_{ik}|}{|D_i|}$$ (3) 计算信息增益 $$g(D,A)=H(D)-H(D|A)$$ 5.2.3 信息增益比 以信息增益作为划分训练集的特征，存在偏向于选择取值较多的特征的问题。使用信息增益比（information gain ratio）可以对这一问题进行校正。这是特征选择的\b另一准则。 首先说明下为何信息增益会偏向选择取值较多的特性：假设特征 \\(A\\) 有 \\(N\\) 个不同取值（意味着每一个样本的\b特征 \\(A\\) 都有一个不同的值），则易知 \\(H(D|A)=0\\) ，故一定会选取这个特性\b，但是这个特性（例如仅仅是不同训练数据的标号）可能对分类无用。 定义 5.3 （信息增益比）特征 \\(A\\) 对训练数据集 \\(D\\) 的信息增益比 \\(g_R(D,A)\\) 定义为其信息增益 \\(\bg(D,A)\\) 与训练数据集 \\(D\\) 关于特征 \\(A\\) 的值的熵 \\(H_A(D)\\) 之比 $$g_R(D,A)=\\frac{g(D,A)}{H_A{(D)}}$$ 其中 $$H_A(D)=-\\sum_{i=1}&#94;n\\frac{|D_i|}{|D|}\\log_2\\frac{|D_i|}{|D|}$$ \\(n\\) 是特征 \\(A\\) 取值的个数。 5.3 决策树的生成 5.3.1 ID3 \b算法 ID3 算法的核心是在决策树各个节点上应用信息增益准则选择特征，递归的构建\b决策树，直到所有特征的信息增益均很小或\b没有特征可以选择为止。 算法 5.2 （ID3 算法） 输入：训练数据集 \\(D\\) ，特征集 \\(A\\) ，阈值 \\(\\epsilon\\) 输出：决策树 \\(T\\) (1) 若 \\(D\\) 中所有实例属于同一类 \\(C_k\\) ，则 \\(T\\) 为单节点树，并将类 \\(C_k\\) 作为该节点的类标记，返回 \\(T\\) (2) 若 \\(A=\\varnothing\\) ，则 \\(T\\) 为单节点树，并将 \\(\bD\\) 中实例数最大的类 \\(C_k\\) 作为该节点的类标记，返回 \\(T\\) (3) 否则，按算法 5.1 计算 \\(A\\) 中哥特征对 \\(D\\) 的信息增益，选择信息增益最大的特征 \\(A_g\\) (4) 如果 \\(A_g\\) 的信息增益小于阈值 \\(\\epsilon\\) ，则置 \\(T\\) 为单节点树，并将 \\(D\\) 中实例数最大的类 \\(C_k\\) 作为该节点的类标记，返回 \\(T\\) (5) 否则，对 \\(A_g\\) 的每一个可能值 \\(a_i\\) ，依 \\(A_g=a_i\\) 将 \\(D\\) 分割为若干非空子集 \\(D_i\\) ，将 \\(D_i\\) 中实例数最大的类作为标记，构建子节点，由节点及其子节点构成数 \\(T\\) ，返回 \\(T\\) (6) 对第 \\(i\\) 个子节点，以 \\(D_i\\) 为训练集，以 \\(A-\\{A_g\\}\\) 为特征集递归的调用步骤 (1)~(5)，得到子树 \\(T_i\\) ，返回 \\(T_i\\) ID3 算法只有树的生成。所以该算法生成的树容易产生过拟合。 5.3.2 C4.5 的生成算法 C4.5 算法与 ID3 算法相似，C4.5 算法对 ID3 算法进行了改进，用信息增益比选择特征。其他步骤相同。 5.4 决策树的剪枝 决策树生成算法递归的产生决策树，直到不能继续下去为止。这样产生的树往往对训练数据的分类很准确，但对未知的测试数据的分类却没有那么准确，即出现过拟合现象。 过拟合产生的\b\b原因是学习时过多的考虑如何提高对训练数据的正确分类，从而构建出过于复杂的决策树。 解决这个问题的办法是\b对\b已生成的决策树进行简化——剪枝（pruning）。也就是从生成的决策树上剪掉一些子树或者叶节点。 决策树的剪枝往往通过极小化决策树整体的损失函数或代价函数来实现。 设树 \\(T\\) 的叶节点个数为 \\(|T|\\) ， \\(t\\) 是树 \\(T\\) 的叶节点，该叶节点有 \\(N_t\\) 个样本点，其中 \\(k\\) 类的样本点有 \\(N_{tk}\\) 个， \\(k=1,2,\\cdots,K\\) ， \\(H_t(T)\\) 为叶节点 \\(t\\) 上的经验熵， \\(\\alpha\\geq0\\) 为参数，则决策树学习的损失函数可以定义为 $$C_{\\alpha}(T)=\\sum_{t=1}&#94;{|T|}N_tH_t(T)+\\alpha|T|$$ 其中经验熵为 $$H_t(T)=-\\sum_{k=1}&#94;K\\frac{N_{tk}}{N_t}\\log\\frac{N_{tk}}{N_t}$$ 令 $$C(T)=\\sum_{t=1}&#94;{|T|}N_tH_t(T)=-\\sum_{t=1}&#94;{|T|}\\sum_{k=1}&#94;KN_{tk}\\log\\frac{N_{tk}}{N_t}$$ 则 $$C_\\alpha(T)=C(T)+\\alpha|T|$$ 上式中， \\(C(T)\\) 表示模型对训练数据的预测误差， \\(|T|\\) 表示模型复杂度，参数 \\(\\alpha\\geq0\\) 控制两者之间的影响。 剪枝，就是当 \\(\\alpha\\) 确定时，选择损失函数最小的模型。 决策树生成学习局部的模型，而决策树剪枝学习整体的模型。 上式中定义的损失函数的极小化等价于正则化的极大似然估计。即 $$C(T)=\\sum_{t=1}&#94;{|T|}N_tH_t(T)=-\\sum_{t=1}&#94;{|T|}\\sum_{k=1}&#94;KN_{tk}\\log\\frac{N_{tk}}{N_t}=-\\log\\prod_{t=1}&#94;{|T|}\\prod_{k=1}&#94;{K}\\left(\\frac{N_{tk}}{N_t}\\right)&#94;{N_{tk}}$$ 所以，利用损失函数最小原则进行剪枝就是用正则化的最大似然估计进行模型选择。 算法 5.4 （树的剪枝算法） 输入：生成算法产生的整个树 \\(T\\) ，参数 \\(\\alpha\\) 输出：修剪后的子树 \\(T_\\alpha\\) (1) 计算每个节点的经验熵 (2) 递归的从树的叶节点向上回缩：设一组叶节点回缩到其父节点之前与之后的整体树分别为 \\(T_B\\) 和 \\(T_A\\) ，其对应的损失函数分别是 \\(C_\\alpha(T_B)\\) 和 \\(C_\\alpha(T_A)\\) ，如果 $$C_\\alpha(T_A)\\leq C_\\alpha(T_B)$$ 则进行剪枝，即将父节点变为新的叶节点 (3) 返回 (2)，直至不能继续为止，得到损失函数最小的子树 \\(T_\\alpha\\) 因为步骤 (2) 中只考虑两个树的损失函数的差，其计算可以在局部进行，所以可以用动态规划算法实现。 5.5 CRAT 算法 分类与回归树（classification and regression tree）模型是应用广泛的决策树学习方法，既可以用于分类也可以用于回归。 CART 是在给定输入随机变量 \\(X\\) 条件下输出随机变量 \\(Y\\) 的条件概率分布的\b学习方法。CART 假设决策树是二叉树，内部\b节点特征的取值为\"是\"和\"否\"。左分的取值是\"是\"，右分支的取值是\"否\"。 CRAT 算法由以下两步组成： 决策树生成：基于训练数据集生成决策树，生成的决策树要\b尽量大 决策树剪枝：用验证数据集\b对已生成的树进行剪枝并选择最优子树，这时用损失函数最小作为剪枝的标准 5.5.1 CART 生成 决策树的生成就是递归的构建二叉决策树的过程，对回归树用平方误差最小化准则，对分类树用基尼指数（Gini index）最小化准则，进行特征选择，生成二叉树。 回归树的生成 假设 \\(X\\) 和 \\(Y\\) 分别为输入和输出变量，并且 \\(Y\\) 是连续变量，给定训练数据集 $$D=\\{(x_1,y_1),(x_2,y_2),\\cdots,(x_N,y_N)\\}$$ 一个回归树对应着输入空间（特征空间）的一个划分以及在划分的单元上的输出值。假设已经将输入空间划分为 \\(M\\) 个单元 \\(R_1,R_2,\\cdots,R_M\\) ，并且每个单元 \\(R_m\\) 上有一个固定的输出值 \\(c_m\\) ，于是，回归树模型可表示为 $$f(x)=\\sum_{m=1}&#94;Mc_m\\mathbb{I}(x\\in R_m)$$ 当输入空间的划分确定时，可以用平方误差 $$\\sum_{x_i\\in R_m}\\left(y_i-f(x_i)\\right)&#94;2$$ 来表示回归树对于训练数据集的预测误差，用平方误差最小的准则求解每个单元上的\b最优输出值。 易知，单元 \\(R_m\\) 上的 \\(c_m\\) 的最优值 \\(\\hat{c}_m\\) 是 \\(R_m\\) 上所有输入实例 \\(x_i\\) 对于的输出 \\(y_i\\) 的均值，即 $$\\hat{c}_m=\\text{ave}(y_i|x_i\\in R_m)$$ 问题是怎么对输入空间进行划分。 这里采用启发式的方法，选择第 \\(j\\) 个特征 \\(x&#94;{(j)}\\) 和它的取值 \\(s\\) ，作为切分变量（splitting variable）和切分点（splitting point），并定义两个区域 $$\\begin{eqnarray} R_1(j,s) &=& \\{x|x&#94;{(j)}\\leq s\\} \\\\ R_2(j,s) &=& \\{x|x&#94;{(j)}>s\\} \\end{eqnarray}$$ 然后对于固定的 \\(j\\) 可以找到最优\b切分的 \\(s\\) ，具体的，求解 $$\\min_{j,s}\\left[\\min_{c_1}\\sum_{x_i\\in R_1(j,s)}(y_i-c_1)&#94;2+\\min_{c_2}\\sum_{x_i\\in R_2(j,s)}(y_i-c_2)&#94;2\\right]$$ 历遍所有输入变量，找到最优的切分变量 \\(j\\) ，构成一个对 \\((j,s)\\) 。依次将输入空间划分为两个区域。接着，对每个区域重复上述划分过程，直到满足停止条件为止。这种方法生成的回归树通常称为最小二乘回归树（least squares regression tree）。 算法 5.5 （最小二乘回归树生成算法） 输入：训练数据集 \\(D\\) 输出：回归树 \\(f(x)\\) 在训练数据集所在的输入空间中，递归的将每个区域划分为两个子区域并决定每个子区域的输出值，构建二叉决策树 (1) 选择最优切分变量 \\(j\\) 和切分点 \\(s\\) ，求解 $$\\min_{j,s}\\left[\\min_{c_1}\\sum_{x_i\\in R_1(j,s)}(y_i-c_1)&#94;2+\\min_{c_2}\\sum_{x_i\\in R_2(j,s)}(y_i-c_2)&#94;2\\right]$$ 遍历 \\(j\\) ，对固定的切分变量 \\(j\\) 扫描切分点 \\(s\\) ，选择使上式最小的对 \\((j,s)\\) (2) 用选定的对 \\((j,s)\\) 划分区域并决定相应的输出值 $$\\begin{eqnarray} R_1(j,s) &=& \\{x|x&#94;{(j)}\\leq s\\} \\\\ R_2(j,s) &=& \\{x|x&#94;{(j)}>s\\} \\end{eqnarray}\\\\ \\hat{c}_m=\\frac{1}{N_m}\\sum_{x_i\\in R_m(j,s)}y_i,x\\in R_m,m=1,2$$ (3) 继续对两个子区域调用步骤 (1)，(2)，直到满足停止条件 (4) 将输入空间划分为 \\(M\\) 个区域 \\(R_1,R_2,\\cdots,R_M\\) ，生成决策树 $$f(x)=\\sum_{m=1}&#94;M\\hat{c}_m\\mathbb{I}(x\\in R_m)$$ 分类树的生成 分类树用基尼指数选择最优特征，同时决定该特征的最优二值切分点。 定义 5.4 （基尼指数）分类问题中，假设有 \\(K\\) 个类，样本点属于第 \\(k\\) 类的概率为 \\(p_k\\) ，则概率分布的基尼指数定义为 $$\\text{Gini}(p)=\\sum_{k=1}&#94;Kp_k(1-p_k)=1-\\sum_{k=1}&#94;Kp_k&#94;2$$ 对于二分类问题，若样本点属于第一个类的概率是 \\(p\\) ，则概率分布的基尼指数为 $$\\text{Gini}(p)=2p(1-p)$$ 对于给定的样本集合 \\(D\\) ，其基尼指数为 $$\\text{Gini}(D)=1-\\sum_{k=1}&#94;K\\left(\\frac{|C_k|}{|D|}\\right)&#94;2$$ 这里， \\(C_k\\) 是属于第 \\(k\\) 类的样本子集， \\(K\\) 是类的个数。 如果样本集合 \\(D\\) 根据特征 \\(A\\) 是否取某一可能值 \\(a\\) 被分割成 \\(D_1\\) 和 \\(D_2\\) 两部分，\b即 \b $$D_1=\\{(x,y)\\in D|A(x)=a\\},D_2=D-D_1$$ 则在特征 A 的条件下，集合 D 的基尼指数定义为 $$\\text{Gini}(D,A)=\\frac{|D_1|}{|D|}\\text{Gini}(D_1)+\\frac{|D_2|}{|D|}\\text{Gini}(D_2)$$ 基尼指数 \\(\\text{Gini}(D)\\) 表示集合 \\(D\\) 的不确定性，基尼指数 \\(\\text{Gini}(D,A)\\) 表示经 \\(A=a\\) 分割后集合 \\(D\\) 的不确定性。基尼指数\b数值越大，样本集合的不确定性也就越大，这一点与熵类似。 \b 算法 5.6 （CART 生成算法） 输入：训练数据集 \\(D\\) ，停止计算的条件 输出：CART 决策树 根据训练数据集，从根节点开始，递归的对每\b个节点进行以下操作，构建二叉决策树： (1) 设节点的训练数据集为 \\(D\\) ，计算现有\b特征对该数据集的基尼指数。此时，对每一个特征 \\(A\\) ，对其可能取的每个值 \\(a\\) ，根据样本点对 \\(A=a\\) 的测试为\"是\"或\"否\"将 \\(D\\) 分割为两部分，计算 \\(A=a\\) 时的基尼指数 (2) 在所有\b可能的特征 \\(A\\) 以及它们所有可能的切分点 \\(a\\) 中，选择基尼指数最小的特征及其对应的切分点作为最优特征和最优切分点。依最优特征和最优切分点，从现节点生成两个子节点，将训练数据集依特征分配到两个子节点去 (3) 对两个子节点递归的调用 (1)、(2)，直至满足停止条件 (4) 生成 CART 决策树 算法停止的条件是节点中的样本个数少于预定阈值，或样本集的基尼指数小于预定阈值（样本基本属于同一类），或者没有更多特征。 5.5.2 CART 剪枝 CART 剪枝算法从\"完全生长\"的决策树的底端剪去一些子树，使决策树变小（模型变简单），从而能够对未知数据有更准确的预测。 CART 剪枝算法由两步组成： 从生成算法产生的\b决策树\b \\(T_0\\) 底部开始不断剪枝，直到 \\(T_0\\) 的根节点，行成一个子树序列 $$\\{T_0,T_1,\\cdots,T_n\\}$$ 通过交叉验证法在独立的验证数据集上对子树序列进行测试，从中选择最优子树 剪枝，形成一个子树序列 在剪枝过程中，计算子树的损失函数： $$C_\\alpha(T)=C(T)+\\alpha|T|$$ 其中， \\(T\\) 为任意子树， \\(C(T)\\) 为对训练数据的预测误差（如基尼指数）， \\(|T|\\) 为子树的叶节点个数， \\(\\alpha\\geq0\\) 为参数， \\(C_\\alpha(T)\\) 为参数是 \\(\\alpha\\) 时的子树 \\(T\\) 的整体损失。参数 \\(\\alpha\\) 权衡训练数据的拟合程度与模型的复杂度。 对固定的 \\(\\alpha\\) ，一定存在使损失函数 \\(C_\\alpha(T)\\) 最小的子树，将其表示为 \\(T_\\alpha\\) 。 \\(T_\\alpha\\) 在损失函数 \\(C_\\alpha(T)\\) 最小的意义下是最\b优的。容易验证这样的最优子树是唯一的。当 \\(\\alpha\\) 大的时候，最优子树 \\(T_\\alpha\\) 偏小；当 \\(\\alpha\\) 小的时候，最优子树 \\(T_\\alpha\\) 偏大。极端情况下，如果 \\(\\alpha=0\\) ，那么整体树是最优的。当 \\(\\alpha\\to+\\infty\\) 时，根节点组成的单节点树是最优的。 Breiman 等人证明：可以用递归的方法对树进行剪枝.将 \\(\\alpha\\) 从小增大： $$0=\\alpha_0<\\alpha_1<\\cdots<\\alpha_n<+\\infty$$ 产生一系列的区间： $$[\\alpha_i,\\alpha_{i+1}),i=0,1,\\cdots,n$$ 剪枝得到的子树序列对应着区间 \\(\\alpha\\in[\\alpha_i,\\alpha_{i+1}),i=0,1,\\cdots,n\\) 的最优子树序列： $$\\{T_0,T_1,\\cdots,T_n\\}$$ 序列中的子树是嵌套的。 具体的，从整体树 \\(T_0\\) 开始剪枝。对 \\(T_0\\) 的任意内部节点 \\(t\\) ，以 \\(t\\) 为单节点树的损失函数是 $$C_\\alpha(t)=C(t)+\\alpha$$ 以 \\(t\\) 为根节点的子树 \\(T_t\\) 的损失函数是 $$C_\\alpha(T_t)=C(T_t)+\\alpha|T_t|$$ 当 \\(\\alpha=0\\) 及 \\(\\alpha\\) 充分小时，有不等式 $$C_\\alpha(T_t)<C_\\alpha(t)$$ 当 \\(\\alpha\\) 增大时，在某一 \\(\\alpha\\) 有 $$C_\\alpha(T_t)=C_\\alpha(t)$$ 当 \\(\\alpha\\) 再增大时，有 $$C_\\alpha(T_t)>C_\\alpha(t)$$ 综上所述，只要 $$\\alpha=\\frac{C(t)-C(T_t)}{|T_t|-1}$$ 则 \\(T_t\\) 与 \\(t\\) 有相同的损失函数值，而 \\(t\\) 的节点少，对 \\(T_t\\) 进行剪枝。 所以，对 \\(T_0\\) 中每一内部节点 \\(t\\) ，计算 $$g(t)=\\frac{C(t)-C(T_t)}{|T_t|-1}$$ 它表示剪枝后整体损失函数减少的程度。在 \\(T_0\\) 中剪去 \\(g(t)\\) 最小的 \\(T_t\\) （这里我们是要得到一系列的 \\(\\alpha\\) 区间，所以是剪去最小的），将得到的子树作为 \\(T_1\\) ，同时将最小的 \\(g(t)\\) 设为 \\(\\alpha_1\\) 。 \\(T_1\\) 为区间 \\([\\alpha_1,\\alpha_2)\\) 的最优子树。 如此剪枝下去，直到得到根节点。在这一过程中，不断的增加 \\(\\alpha\\) 的值，产生新的区间。 在剪枝得到的子树序列中通过交叉验证选取最优子树 \\(T_\\alpha\\) 具体的，利用独立的\b验证数据集，测试子树序列中各棵子树的平方误差或基尼指数。平方误差或基尼指数小的决策树被认为是最优的决策树。 算法 5.7 （CART \b剪枝算法） 输入：CART 算法生成的决策树 \\(T_0\\) 输出：最优决策树 \\(T_\\alpha\\) (1) 设 \\(k=0,T=T_0\\) (2) 设 \\(\\alpha=+\\infty\\) (3) 自下而上的对各个内部节点 \\(t\\) 计算 \\(C(T_t)\\) ， \\(|T_t|\\) 以及 $$\\begin{eqnarray} g(t) &=& \\frac{C(t)-C(T_t)}{|T_t|-1} \\\\ \\alpha &=& \\min(\\alpha,g(t)) \\end{eqnarray}$$ 这里， \\(T_t\\) 表示以 \\(t\\) 为根节点的子树， \\(C(T_t)\\) 是对训练数据的预测误差， \\(|T_t|\\) 是 \\(T_t\\) 的叶节点个数 (4) 对 \\(g(t)=\\alpha\\) 的\b内部节点 \\(t\\) 进行剪枝，并对叶节点 \\(t\\) 以多数表决法决定其类，得到树 \\(T\\) (5) 设 \\(k=k+1.\\alpha_k=\\alpha,T_k=T\\) (6) 如果 \\(T_k\\) 不是由根节点及两个叶节点构成的树，则返回到步骤 (3)；否则，令 \\(T_k=T_n\\) (7) \b采用交叉验证法在\b子树序列 \\(T_0,T_1,\\cdots,T_n\\) 中选择最优子树 \\(T_\\alpha\\) if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"读书笔记","url":"https://xutree.github.io/pages/2019/02/07/sl-5/"},{"title":"统计学习方法 第四章 朴素贝叶斯法","text":"朴素贝叶斯（naive Bayes）法是基于贝叶斯定理与特征条件独立假设的分类方法。朴素贝叶斯法实现简单，学习和预测效率都很高，是一种常用的方法。 4.1 朴素贝叶斯法的学习与分类 4.1.1 基本方法 设输入特征向量 $$x\\in{\\cal X}\\subseteq\\mathbb{R}&#94;n$$ 输出类标记 $$y\\in{\\cal Y}=\\{c_1,c_2,\\cdots,c_K\\}$$ \\(X\\) 是定义在输入空间 \\({\\cal X}\\) 上的随机变量， \\(Y\\) 是定义在输出空间 \\({\\cal Y}\\) 上的随机变量， \\(P(X,Y)\\) 是 \\(X\\) 和 \\(Y\\) 的联合概率分布。训练数据集 $$T=\\{(x_1,y_1),(x_2,y_2),\\cdots,(x_N,y_N)\\}$$ 由 \\(P(X,Y)\\) 独立同分布产生。 朴素贝叶斯法通过训练数据集学习联合概率分布 \\(P(X,Y)\\) 。具体地，学习以下先验概率分布及条件概率分布。先验概率分布 $$P(Y=c_k),k=1,2,\\cdots,K$$ 条件概率分布 $$P(X=x|Y=c_k)=P(X&#94;{(1)}=x&#94;{(1)},\\cdots,X&#94;{(n)}=x&#94;{(n)}|Y=c_k),k=1,2,\\cdots,K$$ 于是学习到联合概率分布 $$P(X,Y)=P(X=x|Y=c_k)P(Y=c_k)$$ 条件概率分布 \\(P(X=x|Y=c_k)\\) 由指数级数量的参数，其估计实际是不可行的。事实上，假设 \\(x&#94;{(i)}\\) 可取值有 \\(S_j\\) 个， \\(Y\\) 可取值有 \\(K\\) 个，那么参数个数为 \\(K\\prod_{j=1}&#94;nS_j\\) 。 朴素贝叶斯法对条件概率分布作了条件独立性的假设。这是一个较强的假设，朴素贝叶斯法也由此得名。具体的，条件独立性假设是 $$\\begin{eqnarray} P(X=x|Y=c_k) &=& P(X&#94;{(1)}=x&#94;{(1)},\\cdots,X&#94;{(n)}=x&#94;{(n)})|Y=c_k)\\\\ &=& \\prod_{j=1}&#94;nP(X&#94;{(j)}=x&#94;{(j)}|Y=c_k) \\end{eqnarray}$$ 朴素贝叶斯法实际上学习到生成数据的机制，所以属于生成模型。条件独立假设等于是说分类的特征在类确定的条件下都是条件独立的。这一假设使朴素贝叶斯法变得简单，但有时会牺牲一定的分类准确率。 利用朴素贝叶斯法对给定输入 \\(x\\) 分类是，将后验概率最大的类作为 \\(x\\) 的类输出，后验概率根据贝叶斯定理计算 $$P(Y=c_k|X=x)=\\frac{P(X=x|Y=c_k)P(Y=c_k)}{\\sum_kP(X=x|Y=c_k)P(Y=c_k)}$$ 利用条件独立假设 $$P(Y=c_k|X=x)=\\frac{P(Y=c_k)\\prod_jP(X&#94;{(j)}=x&#94;{(j)}|Y=c_k)}{\\sum_kP(Y=c_k)\\prod_jP(X&#94;{(j)}=x&#94;{(j)}|Y=c_k)}$$ 这是朴素贝叶斯法的基本公式，于是朴素贝叶斯分类器可表示为 $$y=f(x)=\\arg\\max_{c_k}\\frac{P(Y=c_k)\\prod_jP(X&#94;{(j)}=x&#94;{(j)}|Y=c_k)}{\\sum_kP(Y=c_k)\\prod_jP(X&#94;{(j)}=x&#94;{(j)}|Y=c_k)}$$ 注意到上式中分母对所有 \\(c_k\\) 都为 \\(P(X=x)\\) ，所以 $$y=f(x)=\\arg\\max_{c_k}P(Y=c_k)\\prod_jP(X&#94;{(j)}=x&#94;{(j)}|Y=c_k)$$ 4.1.2 后验概率最大化的含义 朴素贝叶斯法将实例分类到后验概率最大的类中，这等价于期望风险最小化。假设 0-1 损失函数 $$L(Y,f(X))=\\begin{cases}1,&Y\\neq f(X)\\\\0,& Y=f(X)\\end{cases}$$ 式中 \\(f(X)\\) 是分类决策函数。这时期望风险函数为 $$\\begin{eqnarray} R_\\text{exp}(f) &=& \\text{E}[L(Y,f(X))]=\\int_{{\\cal X}\\times{\\cal Y}}L(y,f(x))P(x,y)dxdy\\\\ &=& \\int_{\\cal X}\\int_{\\cal Y}L(y,f(x))P(y|x)P(x)dxdy\\\\ &=& \\int_{\\cal X} \\left[\\int_{\\cal Y}L(y,f(x))P(y|x)dy\\right] P(x)dx \\end{eqnarray}$$ 期望是对联合概率分布 \\(P(X,Y)\\) 取的。由此取条件期望 $$R_\\text{exp}(f)=\\text{E}_X\\sum_{k=1}&#94;K[L(c_k,f(X))]P(c_k|X)$$ 为了使期望风险最小化，只需对 \\(X=x\\) 逐个极小化，得 $$\\begin{eqnarray}f(x) &=& \\arg\\min_{y\\in{\\cal Y}}\\sum_{k=1}&#94;KL(c_k,y)P(c_k|X=x)\\\\&=&\\arg\\min_{y\\in\\cal Y}\\sum_{k=1}&#94;KP(y\\neq c_k|X=x)\\\\&=&\\arg\\min_{y\\in{\\cal Y}}(1-P(y=c_k|X=x))\\\\&=&\\arg\\max_{y\\in\\cal Y}P(y=c_k|X=x)\\end{eqnarray}$$ 这样一来，根据期望风险最小化准则就得到了后验概率最大化准则 $$f(x)=\\arg\\max_{c_k}P(c_k|X=x)$$ 即朴素贝叶斯法采用的原理。 4.2 朴素贝叶斯法的参数估计 4.2.1 极大似然估计 对于 $$y=f(x)=\\arg\\max_{c_k}P(Y=c_k)\\prod_jP(X&#94;{(j)}=x&#94;{(j)}|Y=c_k)$$ 朴素贝叶斯学习意味着估计 \\(P(Y=c_k)\\) 和 \\(P(X&#94;{(j)}=x&#94;{(j)}|Y=c_k)\\) 。可以应用极大似然估计法估计相应的概率。 先验概率 \\(P(Y=c_k)\\) 的极大似然估计是 $$P(Y=c_k)=\\frac{\\sum_{i=1}&#94;N\\mathbb{I}(y_i=c_k)}{N},k=1,2,\\cdots,K$$ 设第 \\(j\\) 个特征 \\(x&#94;{(j)}\\) 可能的取值集合为 \\(\\{a_{j1},a_{j2},\\cdots,a_{jS_j}\\}\\) ，条件概率的极大似然估计是 $$P(X&#94;{(j)}=a_{jl}|Y=c_k)=\\frac{\\sum_{i=1}&#94;N\\mathbb{I}(x_i&#94;{(j)}=a_{jl},y_i=c_k)}{\\sum_{i=1}&#94;N\\mathbb{I}(y_i=c_k)}\\\\ j=1,2,\\cdots,n; l=1,2,\\cdots,S_j; k=1,2,\\cdots,K$$ 4.2.2 学习与分类算法 算法 4.1 朴素贝叶斯法（naive Bayes algorithm）\b 输入： (a) 训练数据集 $$T=\\{(x_1,y_1),(x_2,y_2),\\cdots,(x_N,y_N)\\}$$ 其中 $$x_i=\\left(x_i&#94;{(1)},x_i&#94;{(2)},\\cdots,x_i&#94;{(n)}\\right)&#94;\\text{T}$$ \\(x_i&#94;{(j)}\\) 是第 \\(i\\) \b个样本的第 \\(j\\) 个特征，且 $$x_i&#94;{(j)}\\in\\{a_{j1},a_{j2},\\cdots,a_{jS_j}\\}$$ $$y_i\\in\\{c_1,c_2,\\cdots,c_K\\}$$ (b) 实例 \\(x\\) 输出：实例 \\(x\\) 的分类 (1) 计算先验概率及条件概率 $$\\begin{eqnarray} P(Y=c_k) &=& \\frac{\\sum_{i=1}&#94;N\\mathbb{I}(y_i=c_k)}{N} \\\\ P(X&#94;{(j)}=a_{jl}|Y=c_k) &=& \\frac{\\sum_{i=1}&#94;N\\mathbb{I}(x_i&#94;{(j)}=a_{jl},y_i=c_k)}{\\sum_{i=1}&#94;N\\mathbb{I}(y_i=c_k)} \\end{eqnarray}\\\\ j=1,2,\\cdots,n; l=1,2,\\cdots,S_j; k=1,2,\\cdots,K$$ (2) 对于给定的实例 \\(x=\\left(x&#94;{(1)},x&#94;{(2)},\\cdots,x&#94;{(n)}\\right)&#94;\\text{T}\\) ，计算 $$P(Y=c_k)\\prod_{j=1}P(X&#94;{(j)}=x&#94;{(j)}|Y=c_k),k=1,2,\\cdots,K$$ (3) 确定实例 \\(x\\) 的类 $$y=f(x)=\\arg\\max_{c_k}P(Y=c_k)\\prod_jP(X&#94;{(j)}=x&#94;{(j)}|Y=c_k)$$ 4.2.3 贝叶斯估计 用极大似然估计可能会出现所要估计的概率值为 0 的情况。这时会影响到后验概率的计算结果，使分类产生偏差。解决这一问题的方法是采用贝叶斯估计。 先验概率的贝叶斯估计是 $$P_\\lambda(Y=c_k)=\\frac{\\sum_{i=1}&#94;N\\mathbb{I}(y_i=c_k)+\\lambda}{N+K\\lambda},k=1,2,\\cdots,K$$ 条件概率的贝叶斯估计是 $$P_\\lambda(X&#94;{(j)}=a_{jl}|Y=c_k)=\\frac{\\sum_{i=1}&#94;N\\mathbb{I}(x_i&#94;{(j)}=a_{jl},y_i=c_k)+\\lambda}{\\sum_{i=1}&#94;N\\mathbb{I}(y_i=c_k)+S_j\\lambda}\\\\ j=1,2,\\cdots,n; l=1,2,\\cdots,S_j; k=1,2,\\cdots,K$$ 式中 \\(\\lambda\\geq0\\) ，等价于在随机变量各个取值的频数上赋予一个非负数。当 \\(\\lambda=0\\) 时，就是极大似然估计。常取 \\(\\lambda=1\\) ，这是称为拉普拉斯平滑（Laplace smoothing）。 显然 $$\\begin{eqnarray} P_\\lambda(X&#94;{(j)}=a_{jl}|Y=c_k) &\\geq& 0 \\\\ \\sum_{l=1}&#94;{S_j}P_\\lambda(X&#94;{(j)}=a_{jl}|Y=c_k) &=& 1 \\end{eqnarray}$$ 表明这的确是一种概率分布。 if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"读书笔记","url":"https://xutree.github.io/pages/2019/01/29/sl-4/"},{"title":"为 Torch 安装特定版本的 libpng","text":"为了跑别人的程序，遇到了下面的问题 libpng warning: Application built with libpng-1.4.12 but running with 1.6.35 利用 brew info libpng 查询本机安装版本，输出如下 /usr/local/Cellar/libpng/1.6.29 (26 files, 1.2MB) Poured from bottle on 2017-06-25 at 21:23:18 /usr/local/Cellar/libpng/1.6.31 (26 files, 1.2MB) Poured from bottle on 2017-08-22 at 12:35:00 /usr/local/Cellar/libpng/1.6.34 (26 files, 1.2MB) Poured from bottle on 2017-12-04 at 23:07:49 /usr/local/Cellar/libpng/1.6.35 (26 files, 1.2MB) Poured from bottle on 2018-10-07 at 17:36:58 用下面代码查看了 brew 中 libpng 的 commit 信息 cd $(brew --repository)/Library/Taps/homebrew/homebrew-core git log master -- Formula/libpng.rb 发现并没有版本 1.4.12，于是自己编译 cd /usr/local/src curl --remote-name --location http://download.sourceforge.net/libpng/libpng-1.4.12.tar.gz tar -xzvf libpng-1.4.12.tar.gz cd libpng-1.4.12 ./configure --prefix=/usr/local/Cellar/libpng/1.4.12 make make install 上面的 prefix 我设置为 brew 安装 libpng 的位置。安装好以后执行 brew switch libpng 1.4.12 切换到 1.4.12 版本。还有最后一步工作，之前 Torch 是 luarocks 使用 libpng-1.6.35 编译，现在要重新编译 luarocks remove image luarocks install image 参考： https://github.com/torch/image/issues/137 https://mac-dev-env.patrickbougie.com/libpng/ https://stackoverflow.com/questions/3987683/homebrew-install-specific-version-of-formula","tags":"教程","url":"https://xutree.github.io/pages/2019/01/22/Torch_libpng/"},{"title":"统计学习方法 第三章 k 近邻法","text":"\\(k\\) 近邻法（ \\(k\\) -nearest neighbor， \\(k\\) -NN）是一种\b基本分类与回归方法。 \\(k\\) 近邻法的输入为实例的特征向量，输出为实例的类别，可以取多类。 \\(k\\) 近邻法假设给定一个训练集数据，其中的实例类别已定。分类时，对新的实例，根据其 \\(k\\) 个最近邻的训练实例的类别，通过多数表决等方式进行预测。因此， \\(k\\) 近邻法不具有显式的学习过程。 \\(k\\) 近邻法实际上利用训练数据集对特征向量空间进行划分，并\b作为其分类的模型。 \\(k\\) 值得选择、距离度量以及分类决策规则是 \\(k\\) 近邻法的三个基本要素。 3.1 \\(k\\) 近邻算法 算法 3.1 （ \\(k\\) 近邻法） 输入：训练数据集 $$T=\\{(x_1,y_1),(x_2,y_2),\\cdots,(x_N,y_N)\\}$$ 其中 $$x_i\\in{\\cal X}\\subseteq\\mathbb{R}&#94;n$$ 为实例的特征空间， $$y_i\\in{\\cal Y}=\\{c_1,c_2,\\cdots,c_K\\}$$ 为实例的类别； 实例特征向量 \\(x\\) 输出：实例 \\(x\\) 所属的类 \\(y\\) (1) 根据给定的距离度量，在训练集 \\(T\\) 中找出与 \\(x\\) 最邻近的 \\(k\\) 个点，涵盖这 \\(k\\) 个点的 \\(x\\) 的邻域记作 \\(N_k(x)\\) (2) 在 \\(N_k(x)\\) 中根据分类决策规则（如多数表决）决定 \b \\(x\\) 的类别 \\(y\\) $$y=\\arg\\max_{c_j}\\sum_{x_i\\in N_k(x)}\\mathbb{I}(y_i=c_j),i=1,2,\\cdots,N; j=1,2,\\cdots,K$$ 式中， \\(\\mathbb{I}\\) \b 为指示函数 \\(k\\) 近邻法的特殊情况是 \\(k=1\\) \b 的情形，称为最近邻算法。对于输入的实例点（特征向量） \\(x\\) ，最邻近法将数据集中与 \\(x\\) 最邻近点的类作为 \\(x\\) 的类。 3.2 \\(k\\) 近邻模型 \\(k\\) 近邻法使用的模型实际上对应于特征空间的划分。模型由三个基本要素——距离度量， \\(k\\) 值得选取和分类决策规则决定。 3.2.1 距离度量 特征空间中两个实例点的距离是两个实例点相似程度的反应。 \\(k\\) 近邻模型的特征空间一般是 \\(n\\) 维实数向量空间 \\(\\mathbb{R}&#94;n\\) 。使用的距离是欧氏距离，也可以使用其他距离，例如更一般的 \\(L_p\\) 距离或 Minkowski 距离。 设特征空间 \\({\\cal X}\\) 是 \\(n\\) 维实数向量空间 \\(\\mathbb{R}&#94;n\\) ， \\(x_i,x_j\\in{\\cal X}\\) ， \\(x_i=\\left(x_i&#94;{(1)},x_i&#94;{(2)},\\cdots,x_i&#94;{(n)}\\right)&#94;\\text{T}\\) ， \\(x_j=\\left(x_j&#94;{(1)},x_j&#94;{(2)},\\cdots,x_j&#94;{(n)}\\right)&#94;\\text{T}\\) ， \\(x_i,x_j\\) 的 \\(L_p\\) 距离定义为 $$L_p(x_i,x_j)=\\left(\\sum_{l=1}&#94;n\\left|x_i&#94;{(l)}-x_j&#94;{(l)}\\right|&#94;p\\right)&#94;\\frac{1}{p}$$ 3.2.2 \\(k\\) 值的选择 \\(k\\) 值得选择会对 \\(k\\) 近邻法的结果产生重大影响。 如果选择较小的 \\(k\\) 值，就相当于用较小的邻域中的训练实例进行预测。\"学习\"的近似误差（approximation error）会减小，只有与输入实例较近的（相似的）训练实例才会对预测结果起作用。但缺点是\"学习\"的估计误差（estimation error）会增大，预测结果会对近邻的实例点非常敏感。如果邻近的实例点恰巧是噪声点，预测就会出错。换句话说， \\(k\\) 值得减小就意味着整体模型变的复杂，容易发生过拟合。 如果 \\(k\\) 值选择过大，就相当于用较大邻域中的训练实例进行预测。其优点是可以减小学习的估计误差，但缺点是学习的近似误差会增大。这时与输入实例较远的（不相似的）训练实例也会对预测起作用，使预测发生错误。 \\(k\\) 值的增大意味着整体的模型变得简单。 如果 \\(k=N\\) ，那么无论输入的实例是什么，都将简单的预测它属于在训练实例中最多的类，这时，模型过于简单，是不可取的。 在应用中， \\(k\\) 值一般取一个比较小的数值，通常采用交叉验证法来选取最优的 \\(k\\) 值。 3.2.3 分类决策规则 \\(k\\) 近邻法中的分类决策规则往往是多数表决，即由输入实例的 \\(k\\) 个邻近的训练实例中的多数类决定输入实例的类。 多数表决规则（majority voting rule）有如下解释：如果分类的损失函数是 0-1 损失函数，分类函数为 $$f:\\mathbb{R}&#94;n\\longrightarrow\\{c_1,c_2,\\cdots,c_K\\}$$ 那么误分类的概率是 $$P(Y\\neq f(X))=1-P(Y=f(X))$$ 对于给定的实例 \\(x\\in{\\cal X}\\) ，其最邻近的 \\(k\\) 个训练实例点构成集合 \\(N_k(x)\\) 。如果涵盖 \\(N_k(x)\\) 的区域类别是 \\(c_j\\) ，那么误分类率是 $$\\frac{1}{k}\\sum_{x_i\\in N_k(x)}\\mathbb{I}(y_i\\neq c_j)=1-\\frac{1}{k}\\sum_{x_i\\in N_k(x)}\\mathbb{I}(y_i= c_j)$$ 要使误分类率最小即经验风险最小，就要使 \\(\\sum_{x_i\\in N_k(x)}\\mathbb{I}(y_i= c_j)\\) 最大，所以多数表决规则等价于经验风险最小化。 3.3 \\(k\\) 近邻法的实现： \\(kd\\) 树 为了对训练数据进行快速 \\(k\\) 近邻搜索，我可以采取 \\(kd\\) 树方法（此 \\(k\\) 是计算机科学中的叫法）。 \\(kd\\) 树是每个节点都为 \\(k\\) 维点的二叉树。所有非叶子节点可以视作用一个超平面把空间分割成两个半空间。节点左边的子树代表在超平面左边的点，节点右边的子树代表在超平面右边的点。选择超平面的方法如下：每个节点都与k维中垂直于超平面的那一维有关。因此，如果选择按照x轴划分，所有 \\(x\\) 值小于指定值的节点都会出现在左子树，所有 \\(x\\) 值大于指定值的节点都会出现在右子树。这样，超平面可以用该x值来确定，其法线为 \\(x\\) 轴的单位向量。 3.3.1 构造 \\(kd\\) 树 有很多种方法可以选择轴垂直分割面（axis-aligned splitting planes），所以有很多种创建 \\(kd\\) 树的方法。 最典型的方法如下： 随着树的深度轮流选择轴当作分割面。（例如：在三维空间中根节点是 \\(x\\) 轴垂直分割面，其子节点皆为 \\(y\\) 轴垂直分割面，其孙节点皆为 \\(z\\) 轴垂直分割面，其曾孙节点则皆为 \\(x\\) 轴垂直分割面，依此类推） 点由垂直分割面之轴座标的中位数区分并放入子树 这个方法产生一个平衡的 \\(kd\\) 树。每个叶节点的高度都十分接近。然而，平衡的树不一定对每个应用都是最佳的。 3.3.2 搜索 \\(kd\\) 树 最邻近搜索用来找出在树中与输入点最接近的点。 \\(kd\\) 树最邻近搜索的过程如下： 从根节点开始，递归的往下移。往左还是往右的决定方法与插入元素的方法一样(如果输入点在分区面的左边则进入左子节点，在右边则进入右子节点) 一旦移动到叶节点，将该节点当作\"目前最佳点\" 解开递归，并对每个经过的节点运行下列步骤： 如果目前所在点比目前最佳点更靠近输入点，则将其变为目前最佳点 检查另一边子树有没有更近的点，如果有则从该节点往下找 当根节点搜索完毕后完成最邻近搜索 如果实例点是随机分布的， \\(kd\\) 树搜索的平均计算复杂度是 \\(O(\\log N)\\) ，这里 \\(N\\) 是训练实例数。 \\(kd\\) 树更适用于训练实例数远大于空间维度时的 \\(k\\) 近邻搜索。当空间维度接近训练实例数时，它的效率会迅速下降，几乎接近线性扫描。 if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"读书笔记","url":"https://xutree.github.io/pages/2019/01/20/sl-3/"},{"title":"统计学习方法 第二章 感知机","text":"感知机（perceptron）是二分类的线性分类模型，其输入是实例的特征向量，输出为实例的类别，取 +1 和 -1 二值。感知机对应于输入空间（特征空间）中将实例划分为正负类别的分离超平面，属于判别模型。 2.1 感知机模型 定义 2.1（感知机）假设输入空间（特征空间）是 \\({\\cal X}\\subseteq\\mathbb{R}&#94;n\\) ，输出空间是 \\({\\cal Y}=\\{+1,-1\\}\\) 。输入 \\(x\\in{\\cal X}\\) 表示实例的特征向量，对应于输入空间（特征空间）的点；输出 \\(y\\in{\\cal Y}\\) 表示实例的类别。由输入空间到输出空间的如下函数： $$f(x)=\\text{sign}(w\\cdot x+b)$$ 称为感知机。其中， \\(w\\) 和 \\(b\\) 为感知机模型参数， \\(w\\in\\mathbb{R}&#94;n\\) 叫做权值（weight）或权值向量（weight vector）， \\(b\\in\\mathbb{R}\\) 叫做偏置（bias）， \\(w\\cdot x\\) 表示 \\(w\\) 和 \\(x\\) 的内积。sign 是符号函数，即： $$\\text{sign}(x)=\\begin{cases}+1, & x\\geq0 \\\\ -1, & x<0\\end{cases}$$ 感知机是一种线性分类模型。感知机模型的假设空间是定义在特征空间中的所有线性分类模型（linear classification model）或线性分类器（linear classifier），即函数集合\b： \\(\\{f|f(x)=w\\cdot x+b\\}\\) 。 感知机的几何解释：对于线性方程 $$w\\cdot x+b=0$$ 对应于特征空间 \\(\\mathbb{R}&#94;n\\) 中的一个超平面 \\(S\\) ，称为分离超平面（separating hyperplane），其中 \\(w\\) 是超平面的法向量， \\(b\\) 是超平面的截距。这个超平面将特征空间划分为两个部分。 2.2 感知机学习策略 2.2.1 数据集的线性可分性 定义 2.2 （数据集的线性可分性）给定\b一个数据集 $$T=\\{(x_1,y_1),(x_2,y_2),\\cdots,(x_N,y_N)\\}$$ 其中， \\(x_i\\in{\\cal X}=\\mathbb{R}&#94;n\\) ， \\(y_i\\in{\\cal Y}=\\{+1,-1\\}\\) ， \\(i=1,2,\\cdots,N\\) ，如果存在某个超平面 \\(S\\) $$w\\cdot x+b=0$$ 能够将数据集的正负实例完全正确的划分到超平面的两侧，则称数据集 \\(T\\) 是线性可分数据集（linearly separable data set）\b；否则，则称数据集 \\(T\\) 线性不可分。\b 2.2.2 感知机学习策略 为了\b找出超平面，需要一个学习策略，即定义（经验）损失函数并将损失函数极小化。 损失函数的一个自然选择是误分类点的总数。但是，这样的损失函数不是参数 \\(w\\) 、 \\(b\\) \b 的连续可导函数，不易优化。损失函数的另一个选择是误分类点\b到超平面 \\(S\\) 的总距离，这是感知机所采用的。 \b首先，输入空间 \\(\\mathbb{R}&#94;n\\) 中任一点 \\(x_0\\) 到超平面 \\(S\\) 的距离为： $$\\frac{1}{||w||}|w\\cdot x+b|$$ 这里， \\(||w||\\) 是 \\(w\\) 的 \\(L_2\\) 范数。 其次，注意到对于误分类点数据 \\((x_i,y_i)\\) ，下式成立： $$-y_i(w\\cdot x_i+b)>0$$ 因此，误分类点到超平面的总距离为： $$-\\frac{1}{||w||}\\sum_{x_i\\in M}y_i(w\\cdot x_i+b)$$ 其中， \\(M\\) 是误分类点集合。不考虑 \\(\\frac{1}{||w||}\\) ，就得到感知机学习的损失函数。 \b给定训练数据集： $$T=\\{(x_1,y_1),(x_2,y_2),\\cdots,(x_N,y_N)\\}$$ 感知机 \\(\\text{sign}(w\\cdot x+b)\\) 学习的损失函数\b定义为： $$L(w,b)=-\\sum_{x_i\\in M}y_i(w\\cdot x_i+b)$$ 感知机学习的策略是在假设空间中选取使上面的损失函数最小的模型参数 \\(w\\) ， \\(b\\) ，即感知机模型。 2.3 感知机学习算法 \b为最优化上节的损失函数，采取随机梯度下降法（stochastic gradient descent）。 2.3.1 感知机学习算法的原始形式 感知机学习算法是对以下最优化问题的\b算法。给定训练数据集： $$T=\\{(x_1,y_1),(x_2,y_2),\\cdots,(x_N,y_N)\\}$$ 其中 \\(x_i\\in{\\cal X}=\\mathbb{R}&#94;n\\) ， \\(y_i\\in{\\cal Y}=\\{+1,-1\\}\\) ， \\(i=1,2,\\cdots,N\\) ，求参数 \\(w\\) ， \\(b\\) ，使其为以下损失函数极小化的一个解： $$\\min_{w,b} L(w,b)=-\\sum_{x_i\\in M}y_i(w\\cdot x_i+b)$$ 其中， \\(M\\) 是误分类点集合。 随机梯度下降法步骤如下：首先，任意选取一个超平面 \\(w_0\\) ， \\(b_0\\) ，然后用梯度下降法不断地极小化目标函数。极小化过程不是一次使 \\(M\\) 中所有误分类法的梯度下降，而是一次随机选取一个误分类点使其梯度下降。 假设误分类\b点集合 \\(M\\) 是固定的，那么损失函数 \\(L(w,b)\\) 的梯度为： $$\\begin{eqnarray} \\nabla_wL(w,b) &=& -\\sum_{x_i\\in M}y_ix_i \\\\ \\nabla_bL(w,b) &=& -\\sum_{x_i\\in M}y_i \\end{eqnarray}$$ 随机选取一个误分类点 \\((x_i,y_i)\\) 对 \\(w\\) ， \\(b\\) 进行更新： $$\\begin{eqnarray} w &\\longleftarrow& w+\\eta y_ix_i \\\\ b &\\longleftarrow& b+\\eta y_i \\end{eqnarray}$$ 式中 \\(\\eta\\ (0<\\eta\\leq 1)\\) 是步长，也称学习率（learning rate）。 算法 2.1 （感知机学习算法的原始形式) 输入：训练数据集 $$T=\\{(x_1,y_1),(x_2,y_2),\\cdots,(x_N,y_N)\\}$$ 其中 $$x_i\\in{\\cal X}=\\mathbb{R}&#94;n,y_i\\in{\\cal Y}=\\{+1,-1\\},i=1,2,\\cdots,N$$ 学习率 $$\\eta\\ (0<\\eta\\leq 1)$$ 输出：\b \\(w\\) ， \\(b\\) ； 感知机模型 $$f(x)=\\text{sign}(w\\cdot x+b)$$ (1) 选取初值 \\(w_0\\) ， \\(b_0\\) (2) 在训练集中选取数据 \\((x_i,y_i)\\) (3) 如果 \\(y_i(w\\cdot x_i+b)\\leq 0\\) $$\\begin{eqnarray} w &\\longleftarrow& w+\\eta y_ix_i \\\\ b &\\longleftarrow& b+\\eta y_i \\end{eqnarray}$$ (4) 转至 (2)，直至训练集中没有误分类点 2.3.2 算法的收敛性 为便于推导，将偏置并入权重向量，记为 \\(\\hat{w}=(w&#94;\\text{T},b)&#94;\\text{T}\\) ，同样也将输入向量加以扩充，加进常数 1，记作 \\(\\hat{x}=(x&#94;\\text{T},1)&#94;\\text{T}\\) 。这样， \\(\\hat{x}\\in\\mathbb{R}&#94;{n+1}\\) ， \\(\\hat{w}\\in\\mathbb{R}&#94;{n+1}\\) ，显然 \\(\\hat{w}\\cdot\\hat{x}=w\\cdot x+b\\) 。 定理 2.1 （Novikoff）设训练集 $$T=\\{(x_1,y_1),(x_2,y_2),\\cdots,(x_N,y_N)\\}$$ 线性可分，则 (1). 存在满足条件 \\(||\\hat{w}_\\text{opt}||=1\\) 的超平面 $$\\hat{w}_\\text{opt}\\cdot\\hat{x}=w_\\text{opt}\\cdot x_+b_\\text{opt}=0$$ 将训练数据集完全正确分开；切存在 \\(\\gamma>0\\) ，对所有 \\(i=1,2,\\cdots,N\\) $$y_i(\\hat{w}_\\text{opt}\\cdot\\hat{x}_i)=y_i(w_\\text{opt}\\cdot x_i+b_\\text{opt})\\geq\\gamma$$ (2). 令 $$R=\\max_{1\\leq i\\leq N}||\\hat{x}_i||$$ ，则感知机算法 2.1 在训练数据集上的误分类次数 \\(k\\) 满足不等式 $$k\\leq\\left(\\frac{R}{\\gamma}\\right)&#94;2$$ 证明：（1）由\b线性可分性的定义即可证明，其中： $$\\gamma=\\min_i\\{y_i(w_\\text{opt}\\cdot x_i+b_\\text{opt})\\}$$ （2）感知机算法从 \\(\\hat{w}_0\\) 开始，如果实例被误分类，则更新权重。令 \\(\\hat{w}_{k-1}\\) 是第 \\(k\\) 个误分类实例之前的扩充权重向量，即： $$\\hat{w}_{k-1}=(w_{k-1}&#94;\\text{T},b_{k-1})&#94;\\text{T}$$ 则第 \\(k\\) 个被误分类实例的条件是 $$y_i(\\hat{w}_{k-1}\\cdot\\hat{x}_i)=y_i(w_{k-1}\\cdot x_i+b_{k-1})\\leq0$$ 若 \\((x_i,y_i)\\) 是被 \\(\\hat{w}_{k-1}\\) 误分类的数据，则 \\(w\\) 和 \\(b\\) 的更新为 $$\\begin{eqnarray} w_k &\\longleftarrow& w_{k-1}+\\eta y_ix_i \\\\ b_k &\\longleftarrow& b_{k-1}+\\eta y_i \\end{eqnarray}$$ 即 $$\\hat{w}_k\\longleftarrow \\hat{w}_{k-1}+\\eta y_i\\hat{x}_i$$ 下面推导两个不等式： i. \\(\\hat{w}_k\\cdot\\hat{w}_\\text{opt}\\geq k\\eta\\gamma\\) $$\\hat{w}_k\\cdot\\hat{w}_\\text{opt}=(\\hat{w}_{k-1}+\\eta y_i\\hat{x}_i)\\cdot\\hat{w}_\\text{opt}\\geq\\hat{w}_{k-1}\\cdot\\hat{w}_\\text{opt}+\\eta\\gamma\\geq\\cdots\\geq k\\eta\\gamma$$ ii. \\(||\\hat{w}_k||&#94;2\\leq k\\eta&#94;2R&#94;2\\) $$ \\begin{eqnarray} ||\\hat{w}_k||&#94;2 &=& ||\\hat{w}_{k-1}+\\eta y_i\\hat{x}_i||&#94;2 \\\\ &=& ||\\hat{w}_{k-1}||&#94;2+2\\eta y_i\\hat{w}_{k-1}\\cdot\\hat{x}_i+\\eta&#94;2||\\hat{x}_i||&#94;2 \\\\ &\\leq& ||\\hat{w}_{k-1}||&#94;2+\\eta&#94;2||\\hat{x}_i||&#94;2 \\\\ &\\leq& ||\\hat{w}_{k-1}||&#94;2+\\eta&#94;2R&#94;2\\leq\\cdots\\leq k\\eta&#94;2R&#94;2 \\end{eqnarray}$$ 由上述两个不等式 $$k\\eta\\gamma\\leq\\hat{w}_k\\cdot\\hat{w}_\\text{opt}\\leq||\\hat{w}_k||\\ ||\\hat{w}_\\text{opt}||\\leq\\sqrt{k}\\eta R$$ 于是 $$k\\leq\\left(\\frac{R}{\\gamma}\\right)&#94;2$$ 定理表明，误分类次数是有上界的，经过有限次搜索可以找到将训练数据完全正确分开的分离超平面。 感知机学习算法存在许多解，这些解既依赖于初值的选择，也依赖于迭代过程中误分类点的选择顺序。 当训练集线性不可分时，感知机学习算法不收敛，迭代结果会发生震荡。 2.3.3 感知机学习算法的对偶形式 对偶形式的基本想法是，将 \\(w\\) 和 \\(b\\) 表示为实例 \\(x_i\\) 和\b标记 \\(y_i\\) 的线性组合的形式，通过求解其系数而求得 \\(w\\) 和 \\(b\\) 。不失一般性，在算法 2.1 中可以假设初始值 \\(w_0\\) 和 \\(b_0\\) 均为 0，对误分类点 \\((x_i,y_i)\\) 通过 $$\\begin{eqnarray} w &\\longleftarrow& w+\\eta y_ix_i \\\\ b &\\longleftarrow& b+\\eta y_i \\end{eqnarray}$$ 逐步修改 \\(w\\) ， \\(b\\) ，设修改 \\(n\\) 次（随机梯度下降，一个点可能被选择多次），则 \\(w\\) 和 \\(b\\) 关于 \\((x_i,y_i)\\) 的增量分别\b是 \\(\\alpha_iy_ix_i\\) 和 \\(\\alpha_iy_i\\) 这里 $$\\alpha_i=n_i\\eta$$ 这样，从学习\b过程不难看出，最后学习到的 \\(w\\) 和 \\(b\\) 可以分别表示为 $$\\begin{eqnarray} w &=& \\sum_{i=1}&#94;N\\alpha_iy_ix_i \\\\ b &=& \\sum_{i=1}&#94;N\\alpha_iy_i \\end{eqnarray}$$ 这里， \\(\\alpha_i\\geq0\\) ， \\(i=1,2,\\cdots,N\\) ，当 \\(\\eta=1\\) 时，表示第 \\(i\\) 个实例点由于误分类而进行更新的次数。实例点更新次数越多，意味着它\b距离分离超平面越近，也就越难正确分类。换句话说，这样的实例对学习结果影响很大。 算法 2.2 （感知机学习算法的对偶形式） 输入：训练数据集 $$T=\\{(x_1,y_1),(x_2,y_2),\\cdots,(x_N,y_N)\\}$$ 其中 $$x_i\\in{\\cal X}=\\mathbb{R}&#94;n,y_i\\in{\\cal Y}=\\{+1,-1\\},i=1,2,\\cdots,N$$ 学习率 $$\\eta\\ (0<\\eta\\leq 1)$$ 输出：\b \\(\\alpha\\) ， \\(b\\) ； 感知机模型 $$f(x)=\\text{sign}(\\sum_{j=1}&#94;N\\alpha_jy_jx_j\\cdot x+b)$$ 其中 \\(\\alpha=(\\alpha_1,\\alpha_2,\\cdots,\\alpha_N)&#94;\\text{T}\\) (1) \\(\\alpha\\longleftarrow0\\) ， \\(b\\longleftarrow0\\) (2) 在训练集中选取数据 \\((x_i,y_i)\\) (3) 如果 \\(y_i\\left(\\sum_{j=1}&#94;N\\alpha_jy_jx_j\\cdot x_i+b\\right)\\leq 0\\) $$\\begin{eqnarray} \\alpha_i &\\longleftarrow& \\alpha_i+\\eta \\\\ b &\\longleftarrow& b+\\eta y_i \\end{eqnarray}$$ (4) 转至 (2)，直至训练集中没有误分类点 对偶形式中\b训练实例仅以内积的形式出现。为了方便，可以预先将训练集中实例间的内积计算出来并以矩阵的形式存储，这个矩阵就是所谓的 Gram 矩阵（Gram matrix） $$G=[x_i\\cdot x_j]_{N\\times N}$$ if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"读书笔记","url":"https://xutree.github.io/pages/2019/01/06/sl-2/"},{"title":"统计学习方法 第一章 统计学习方法概论","text":"1.1 统计学习 1.1.1 特点 统计学习（statistical learning）是关于计算机基于 数据 构建概率统计模型并运用模型对数据进行 预测与分析 的一门学科。 赫尔伯特·西蒙（Herbert A.Simon）对\"学习\"给出如下定义：如果一个系统能够通过执行某个过程改变它的性能，这就是学习。 1.1.2 对象 统计学习的对象是数据。 统计学习关于数据的基本假设是同类数据具有一定的统计规律性，这是统计学习的前提。 1.1.3 目的 统计学习用于对数据进行预测和分析，特别是对未知新数据进行预测与分析。 1.1.4 方法 监督学习（supervised learning） 非监督学习（unsupervised learning） 半监督学习（semi-supervised learning） 强化学习（reinforcement learning） 1.1.5 统计学习方法三要素 模型（model） ：即假设空间（hypothesis space），假设空间是一个集合，这个集合包含要学习的模型 策略（strategy） ：模型选择的准则 算法（algorithm） ：模型学习的算法 1.2 监督学习 监督学习（supervised learning）的任务是学习一个模型，使模型能够对任意给定的输入，对其相应的输出做出一个好的预测。 1.2.1 基本概念 输入空间（input space） ：输入的所有可能取值的集合，表示为 \\({\\cal X}\\) 输出空间（output space） ：输出的所有可能取值的集合，表示为 \\({\\cal Y}\\) 实例（instance） ：每个具体的输入，通常由特征向量（feature vector）表示 特征空间（feature space） ：所有特征向量存在的空间，每一维度对应一个特征 训练数据（training data） ：由输入（或特征向量）与输出对组成 联合概率分布（joint probability distribution） ：监督学习假设输入与输出的随机变量 \\(X\\) 和 \\(Y\\) 遵循联合概率分布 \\(P(X,Y)\\) 假设空间（hypothesis space） ：模型属于由输入空间到输出空间的映射的集合，这个集合就是假设空间。假设空间的确定意味着学习范围的确定 注1 ：输入和输出空间可以使有限集也可以是整个欧式空间；输入与输出空间可以使用一个空间，也可以是不同的空间；通常输出空间远小于输入空间。 注2 ：有时假设输入空间与特征空间为相同的空间，对它们不予区分；有时假设输入空间与特征空间为不同的空间，将实例从输入空间映射到特征空间。模型实际上都是定义在特征空间上的。 注3 ：在学习过程中，假设联合概率分布存在，但对于学习系统来说，联合概率分布的具体定义是未知的。训练数据与测试数据被看作是依联合概率分布 \\(P(X,Y)\\) 独立同分布（independent and identically distribution）产生的。统计学习假设数据存在一定的统计规律， \\(X\\) 和 \\(Y\\) 遵循联合概率分布 \\(P(X,Y)\\) 就是监督学习关于数据的基本假设。 在监督学习过程中，将输入和输出看做是定义在输入（特征）空间与输出空间上的随机变量的取值。输入、输出变量用大写字母表示，输入、输出变量所取的值用小写字母表示。 输入实例 \\(x\\) 的\b特征向量记作 $$x=\\left(x&#94;{(1)},x&#94;{(2)},\\dots,x&#94;{(n)}\\right)&#94;\\text{T}$$ \b \\(x&#94;{(i)}\\) 表示 \\(x\\) 的第 \\(i\\) 个特征。 多个输入变量的第 \\(i\\) 个记作 $$x_i=\\left(x_i&#94;{(1)},x_i&#94;{(2)},\\dots,x_i&#94;{(n)}\\right)&#94;\\text{T}$$ 训练集： \\(T=\\{(x_1,y_1),(x_2,y_2),\\dots,(x_N,y_N)\\}\\) 监督学习的模型可以是概率模型或非概率模型，由条件概率分布 \\(P(Y|X)\\) 或决策函数（decision function） \\(Y=f(X)\\) 表示。对具体的输入进行相应的输出预测时，写作 \\(P(y|x)\\) 或 \\(y=f(x)\\) 。 1.3 统计学习三要素 1.3.1 模型 统计学习首要考虑的问题是学习什么样的模型。模型的假设空间包含所有可能的条件概率分布或决策函数。假设空间中的模型一般有无穷多个。 假设空间用 \\(\\cal{F}\\) 表示。假设空间可以定义为决策函数或条件概率分布的集合 $${\\cal F}=\\{f|Y=f_\\theta(X),\\theta \\in \\mathbb R&#94;n\\}$$ 或 $${\\cal F}=\\{P|P_\\theta(Y|X),\\theta \\in \\mathbb R&#94;n\\}$$ \b 参数向量 \\(\\theta\\) 取值于 \\(n\\) 维欧式空间 \\(\\mathbb R&#94;n\\) ，称为参数空间（parameter space）。 1.3.2 策略 有了模型的假设空间，统计学习接着需要考虑的是按照什么样的准则学习或选择最优的模型。 损失函数和风险函数 \b损失函数（loss function）或代价函数（cost function）用来度量预测错误的程度。损失函数是 \\(f(X)\\) 和 \\(Y\\) 的非负实值函数，记作 \\(L(Y,f(X))\\) 。 统计学习常用的损失函数有以下几种： 0-1 损失函数（0-1 loss function） $$L(Y,f(X))=\\begin{cases} 1, & Y\\neq f(X) \\\\ 0, & Y=f(X) \\end{cases}$$ 平方损失函数（quadratic loss function） $$L(Y,f(X))=(Y-f(X))&#94;2$$ 绝对损失函数（absolute loss function） $$L(Y,f(X))=|Y-f(X)|$$ 对数损失函数（logarithmic loss function）或对数似然损失函数（log-likelihood loss function） $$L(Y,P(Y|X))=-\\log P(Y|X)$$ 风险函数（risk function）或期望损失（expected loss）：\b理论上模型 \\(f(X)\\) 关于联合分布 \\(P(X,Y)\\) 平均意义下的损失，记作 \\(R_\\text{exp}\\) 。 $$R_\\text{exp}(f)=\\text{E}_P[L(Y,f(X))]=\\int_{{\\cal X}\\times{\\cal Y}}L(y,f(x))P(x,y)dxdy$$ 经验风险（empirical risk）或经验损失（empirical loss）：模型 \\(f(X)\\) 关于训数据集的平均损失，记作 \\(R_\\text{emp}\\) 。 $$R_\\text{emp}(f)=\\frac{1}{N}\\sum_{i=1}&#94;NL\\left(y_i,f(x_i)\\right)$$ 经验风险最小化 \b经验风险最小化（empirical risk minimization，ERM）策略认为：经验风险最小的模型是最优的模型。即求解下面的最优化问题 $$ \\min_{f\\in {\\cal F}} \\frac{1}{N}\\sum_{i=1}&#94;NL\\left(y_i,f(x_i)\\right)$$ 其中 \\({\\cal F}\\) 是假设空间。 当样本容量足够大时，经验风险最小化能保证有很好的学习效果。例如，极大似然估计（maximum likelihood estimation）就是经验风险最小化的一个例子。当模型是条件概率分布，损失函数是对数损失函数时，经验风险最小化就等价于极大似然估计。 但是，当样本容量很小时，经验风险最小化学习的效果就未必很好，会产生\"过拟合（over-fitting）现象\"。 结构风险最小化 结构风险最小化（structural risk minimization，SRM）是为了防止过拟合而提出来的策略。结构风险最小化等价于正则化（regularization）。结构风险在经验风险上加上表示模型复杂度的正则化项（regularizer）或罚项（penalty term），定义如下 $$R_\\text{srm}=\\frac{1}{N}\\sum_{i=1}&#94;NL\\left(y_i,f(x_i)\\right)+\\lambda J(f)$$ 其中 \\(J(f)\\) 为模型的复杂度，是定义在假设空间 \\({\\cal F}\\) 上的泛函。模型 \\(f\\) 越复杂， \\(J(f)\\) 越大。也就是说，复杂度表示了对复杂模型的惩罚， \\(\\lambda\\geq 0\\) 是系数，用以权衡经验风险和模型复杂度。 结构风险小需要经验风险与模型复杂度同时小，结构风险小的模型往往对训练数据以及未知的测试数据都有较好的预测。结构化风险最小化策略认为：结构风险最小的模型是最优的模型。即求解下面的最优化问题 $$ \\min_{f\\in {\\cal F}} \\frac{1}{N}\\sum_{i=1}&#94;NL\\left(y_i,f(x_i)\\right)+\\lambda J(f)$$ 贝叶斯估计中的最大后验概率估计（maximum posterior probability estimation，MAP）就是结构化风险最小化的一个例子。当模型是条件概率分布，损失函数是对数损失函数，模型复杂度由模型的先验概率表示时，结构风险最小化就等价于最大后验概率估计。 1.3.3 算法 算法是指学习\b模型的具体计算方法。统计学习基于训练数据集，根据学习策略，从假设空间中选择最优模型，最后需要考虑用什么样的计算方法求解最优模型。 如果最优化问题有显式的解析解，这个最优化问题就比较简单，但通常解析解不存在，这就需要用数值方法求解。如何保证找到\b全局最优解，并使求解的过程非常高效，就成为一个重要问题。 1.4 模型评估与模型选择 1.4.1 训练误差 假设学习到的模型是 \\(Y=\\hat{f}(X)\\) ，训练误差（training error）是模型 \\(Y=\\hat{f}(X)\\) 关于训练数据集的平均损失 $$R_\\text{emp}(\\hat{f})=\\frac{1}{N}\\sum_{i=1}&#94;NL(y_i,\\hat{f}(x_i))$$ 其中 \\(N\\) 是训练样本容量。 1.4.2 测试误差 测试误差是模型 \\(Y=\\hat{f}(X)\\) 关于测试数据集的平均损失 $$e_\\text{test}(\\hat{f})=\\frac{1}{N'}\\sum_{i=1}&#94;{N'}L(y_i,\\hat{f}(x_i))$$ 其中 \\(N'\\) 是测试样本容量。 例如，当损失函数是 0-1 损失时，测试误差就变成了常见的测试数据集上的误差率（error rate） $$e_\\text{test}=\\frac{1}{N'}\\sum_{i=1}&#94;{N'}{\\mathbb I}(y_i\\neq \\hat{f}(x_i))$$ 这里 \\({\\mathbb I}\\) 是指示函数，即 \\(y_i\\neq \\hat{f}(x_i)\\) 时为 1，否则为 0。 相应的，常见的测试数据集上的准确率（accuracy）为 $$r_\\text{test}=\\frac{1}{N'}\\sum_{i=1}&#94;{N'}{\\mathbb I}(y_i=\\hat{f}(x_i))$$ 训练误差的大小，对判断给定的问题是不是一个\b容易学习的问题是有\b意义的，但本质上不重要。 测试误差反应了学习方法对未知的测试数据集的预测\b能力，是学习中的重要概念。 1.4.3 过拟合 当假设空间含有不同复杂度（例如，不同的参数个数）的模型时，就要面临模型选择（model selection）的问题。我们希望选择或学习一个合适的模型。 如果一味追求提高对训练数据的预测能力，所选模型的复杂度则往往会比真模型更高，这种现象称为过拟合。 过拟合是指学习时选择的模型所包含的参数过多，以致于出现这一模型对\b已知数据预测得很好，但对未知数据预测很差的现象。 训练误差与测试误差和模型复杂度关系如下： \b 1.5 正则化与交叉验证 正则化与交叉验证是两种常用的模型选择方法。 1.5.1 正则化 正则化是结构风险最小化策略的实现。正则化项一般是模型\b复杂度的单调递增函数，模型越复杂，正则化值就越大。 正则化一般形式形式 $$ \\min_{f\\in {\\cal F}} \\frac{1}{N}\\sum_{i=1}&#94;NL\\left(y_i,f(x_i)\\right)+\\lambda J(f)$$ \b其中，第一项是经验风险，第二项是正则化项， \\(\\lambda\\geq 0\\) 为调整两者关系之间的系数。 正则化项可以取不同的形式。例如：回归问题中，损失函数是平方损失，正则化项可以是参数向量的 \\(L_2\\) 范数 $$L(w)=\\frac{1}{N}\\sum_{i=1}&#94;N\\left(f(x_i;w)-y_i\\right)&#94;2+\\frac{\\lambda}{2}||w||&#94;2$$ 这里， \\(||w||\\) 表示参数向量 \\(w\\) 的 \\(L_2\\) 范数。 1.5.2 交叉验证 另一种常用的模型选择方法是交叉验证（cross validation）。 如果给定的样本数据充足，进行模型选择的一种简单方法是随机的将数据集切成三部分：训练集、验证集和测试集。训练集用来训练模型，验证集用于模型选择，测试集用于\b最终对学习方法的评估。 但是，在许多实际应用中数据是不充足的。为了选择好的模型，可以采用交叉验证的方法。 交叉验证的基本思想是重复的使用数据：把给定的数据进行切分，将切分的数据集组合\b为训练集与测试集，在此基础上反复进行训练、测试以及模型选择。 简单交叉验证 首先随机的将已给数据分成两部分：训练集、测试集。然后用训练集在各种条件下（例如，不同的参数个数）训练模型，从而得到不同的模型。然后，在测试集上评价各个模型的测试误差，选出测试误差最小的模型。 \\(S\\) 折交叉验证 应用最多的是 \\(S\\) 折交叉验证（S-fold cross validation），方法如下：首先随机的将已给数据切分\b为 \\(S\\) 个互不相交的大小相同的子集；然后利用 \\(S-1\\) 个子集的数据训练模型，利用余下的子集测试模型；将这一过程对可能的 \\(S\\) 种选择重复进行；最后选出 \\(S\\) 次评估中平均测试误差最小的模型。 留一交叉验证 \\(S\\) 折交叉验证的特殊情形是 \\(S=N\\) ，称为留一交叉验证（leave-one-out cross validation），往往在数据缺乏的情况下使用。这里 \\(N\\) 是给定数据集的容量。 1.6 泛化能力 1.6.1 泛化误差 学习方法的泛化能力（generalization ability）是指由该学习方法学到的模型对未知数据的预测能力。 泛化误差（generalization error）：如果学到的模型是 \\(\\hat{f}\\) ，那么用这个模型对未知数据预测的误差即为泛化误差。 $$R_\\text{exp}(\\hat{f})=\\text{E}_P[L(Y,f(X))]=\\int_{{\\cal X}\\times{\\cal Y}}L(y,\\hat{f}(x))P(x,y)dxdy$$ 实际上，泛化误差就是所学习到的模型的期望风险。 1.6.2 泛化误差上界 学习方法的泛化能力分析往往使用过研究泛化误差的概率上界进行的，简称为泛化误差上界（generalization error bound）。也就是说，可以通过比较两种学习方法的泛化误差上界的大小来比较它们的优劣。 泛化误差上界具有如下性质： 它是样本容量的函数，当样本容量增加时，泛化误差上界趋于 0 它是假设空间容量（capacity）的函数，假设空间容量越大，模型就越难学，泛化误差上界就越大 1.6.3 二分类问题的泛化误差上界 考虑二分类问题。已知训练数据集 \\(T=\\{(x_1,y_1),(x_2,y_2),\\dots,(x_N,y_N)\\}\\) ，它是从联合概率\b分布 \\(P(X,Y)\\) 独立同分布产生的， \\(X\\in \\mathbb R&#94;n\\) ， \\(Y\\in \\{-1,1\\}\\) 。假设空间是函数的有限集合 \\({\\cal F}=\\{f_1.f_2.\\dots,f_d\\}\\) ， \\(d\\) 是函数个数。设 \\(f\\) 是从 \\({\\cal F}\\) 中选取的函\b数。损失函数是 0-1 损失。关于 \\(f\\) 的期望风险和经验风险分别是 $$\\begin{eqnarray} R_\\text{exp}(f)&=&\\text{E}_P[L(Y,f(X))]\\\\ R_\\text{emp}(f)&=&\\frac{1}{N}\\sum_{i=1}&#94;NL(y_i,f(x_i)) \\end{eqnarray}$$ 经验风险最小化函数是 $$f_N=\\arg \\min_{f\\in{\\cal F}}R_\\text{emp}(f)$$ 人们更关心的是 \\(f_N\\) 的泛化能力 $$R(f_N)=\\text{E}_P[L(Y,f_N(X))]$$ 定理 1.1（泛化误差上界）对二分类问题，当假设空间是有限个函数的集合 \\({\\cal F}=\\{f_1.f_2.\\dots,f_d\\}\\) 时，对任意一个函数 \\(f\\in{\\cal F}\\) ，至少以概率 \\(1-\\delta\\) ，以下不等式成立 $$R(f)\\leq R_\\text{emp}(f)+\\epsilon(d,N,\\delta)$$ 其中， $$\\epsilon(d,N,\\delta)=\\sqrt{\\frac{1}{2N}\\left(\\log d+\\log \\frac{1}{\\delta}\\right)}$$ 上述定理表明：训练误差越小，泛化误差也越小；当 \\(N\\) 趋于无穷时，第二项为 0；假设空间包含的函数越多，泛化误差越大。 证明：在证明过程中要用到 Hoeffding 不等式，先叙述如下： Hoeffding 不等式适用于有界的随机变量。设有两两独立的一系列随机变量 \\(X_{1},\\dots ,X_{n}\\) 。假设对所有的 \\(1\\leq i\\leq n\\) ， \\(X_{i}\\) 都是几乎有界的变量，即满足 $$\\mathbb {P} (X_{i}\\in [a_{i},b_{i}])=1$$ 那么这 \\(n\\) 个随机变量的经验期望 $$\\overline {X}={\\frac {X_{1}+\\cdots +X_{n}}{n}}$$ 满足以下的不等式 $$\\begin{eqnarray} \\mathbb {P}({\\overline {X}}-\\mathbb {E} [{\\overline {X}}]\\geq t) &\\leq& \\exp \\left(-{\\frac {2t&#94;{2}n&#94;{2}}{\\sum_{i=1}&#94;{n}(b_{i}-a_{i})&#94;{2}}}\\right)\\\\ \\mathbb {P} (|{\\overline {X}}-\\mathbb {E} [{\\overline {X}}]|\\geq t)&\\leq& 2\\exp \\left(-{\\frac {2t&#94;{2}n&#94;{2}}{\\sum_{i=1}&#94;{n}(b_{i}-a_{i})&#94;{2}}}\\right) \\end{eqnarray}$$ 对任意函数 \\(f\\in{\\cal F}\\) ， \\(R_\\text{emp}(f)\\) 是 \\(N\\) 个随机变量 \\(L(Y,f(X))\\) 的样本均值， \\(R(f)\\) 是随机变量 \\(L(Y,f(X))\\) 的期望值。如果损失函数取值于区间 [0,1]，则由 Hoeffding 不等式得到，对 \\(\\epsilon>0\\) ，以下不等式成立 $$P(R(f)-R_\\text{emp}(f)\\geq\\epsilon)\\leq\\exp (-2N\\epsilon&#94;2)$$ 由于 \\({\\cal F}=\\{f_1;f_2,\\dots,f_d\\}\\) 是一个有限集合，故 $$\\begin{eqnarray} P\\left(\\exists f\\in{\\cal F}:R(f)-R_\\text{emp}(f\\right)\\geq\\epsilon)&=&P\\left(\\bigcup_{f\\in{\\cal F}}\\{R(f)-R_\\text{emp}(f)\\geq\\epsilon\\}\\right)\\\\ &\\leq&\\sum_{f\\in{\\cal F}}P(R(f)-R_\\text{emp}(f)\\geq\\epsilon)\\\\ &\\leq& d\\exp(-2N\\epsilon&#94;2) \\end{eqnarray}$$ 或者等价的，对任意的 \\(f\\in{\\cal F}\\) ，\b有 $$P(R(f)-R_\\text{emp}(f)\\geq\\epsilon))\\geq1-d\\exp(-2N\\epsilon&#94;2)$$ 令 $$\\delta=d \\exp(-2N\\epsilon&#94;2)$$ 则 $$P(R(f)<R_\\text{emp}(f)+\\epsilon)\\geq1-\\delta$$ \b证毕。 1.7 生成模型与判别模型 监督学习方法也可以分为生成方法（generative approach）和判别方法（discriminative approach）。所学到的模型分别称为生成模型（generative model）和判别模型（discriminative model）。 1.7.1 生成方法 生成方法由数据学习联合概率分布 \\(P(X,Y)\\) ，然后求出条件概率分布 \\(P(Y|X)\\) 作为预测的模型，即生成模型 $$P(Y|X)=\\frac{P(X,Y)}{P(X)}$$ 这样的方法之所以称为生成方法，是因为模型\b表示了给定输入 \\(X\\) 产生输出 \\(Y\\) 的\b生成关系。 典型的生成模型有：朴素贝叶斯法和隐马尔科夫模型。 1.7.2 判别方法 判别方法由数据直接学习策略函数 \\(f(X)\\) 或者条件概率分布 \\(P(Y|X)\\) 作为预测的模型。判别方法关心的是对给定的输入 \\(X\\) ，应该预测什么样的输出 \\(Y\\) 。 典型的判别模型有： \\(k\\) 近邻法，感知机，决策树，logistic 回归模型，最大熵模型，支持向量机，提升方法和条件随机场等。 1.7.3 \b不同方法的特点 生成方法： 生成方法可以还原出联合概率分布 \\(P(X,Y)\\) ，而判别方法则不能 生成方法的学习收敛速度更快，即当样本容量增加时，学到的模型可以更快的收敛到真实模型 当存在隐变量时，仍可以使用生成方法，\b此时判别方法就不能用了 判别方法： 判别方法直接学习的是条件概率 \\(P(Y|X)\\) 或决策函数 \\(f(X)\\) ，直接面对预测，往往学习的准确率更高 由于直接学习 \\(P(Y|X)\\) 或 \\(f(X)\\) ，可以对数据进行各种程度上的抽象、定义特征并使用特征，因此可以简化学习问题 1.8 分类问题 在监督学习中，当输出变量 \\(Y\\) 取有限个离散值时，预测问题便成为分类问题。 分类器（classifier） ：从数据中学习到的一个分类模型或分类决策函数。 评价分类器性能的指标一般是 分类准确率（accuracy） ：对于给定的测试数据集，分类器正确分类的样本数与总样本数之比。 对于二分类问题常用的评价指标是 精确率（precision） 和 召回率（recall） 。 通常以关注的类为正类，其他类为负类，分类器在测试数据集上的预测或\b正确或不正确，4 种情况出现的总数分别记为： TP：将正类预测为正类的数目 FN：将正类预测为负类的数目 FP：将负类预测为正类的数目 TN：将负类预测为负类的数目 精确率定义 $$P=\\frac{TP}{TP+FP}$$ 召回率定义 $$R=\\frac{TP}{TP+FN}$$ \\(F_1\\) 值 $$\\frac{2}{F_1}=\\frac{1}{P}+\\frac{1}{R}\\longrightarrow F_1=\\frac{2TP}{2TP+FP+FN}$$ 许多统计学习方法可以用于分类，包括 \\(k\\) 近邻法，感知机，朴素贝叶斯法，决策树，\b决策列表，logistic 回归模型，支持向量机，提升方法，贝叶斯网络，神经网络，Winnow 等。 一个分类应用的例子：垃圾邮件、非垃圾邮件分类。 1.9 标注问题 标注（tagging）也是一个监督学习问题，可以认为标注问题是分类问题的一个推广，标注问题又是更复杂的结构预测（structure prediction）问题的简单形式。 标注问题的输入是一个观测序列，输出是一个标记序列或状态序列。标注问题的\b目标在于学习一个模型，使它能够对观测序列给出标记序列作为预测。注意，可能的标记个数是有限的，但其组合所成的\b标记序列的个数是依序列长度呈指数级增长的。 评价标注模型的指标和分类模型一样，常用的有标注准确率、精确率和召回率。 标注常用的统计学习方法有：隐马尔科夫模型，条件随机场。 一个标注的例子：对英文文章进行标注，英文单词是一个观察，英文句子是一个观察序列，标记表示名词短语的\"开始\"、\"结束\"和\b\"其他\"。 1.10 回归问题 回归（regression）是监督学习的另一个重要问题。回归用于预测\b输入变量（自变量）和输出变量（因变量）之间的关系，特别是当输入变量的值发生变化时，输出变量的值随之发生的变化。回归问题等价于函数拟合：选择一条函数曲线使其很好的拟合已知数据且很好的预测未知数据。 回归问题按照输入变量的个数，分为一元回归和多元回归；按照输入变量和输出变量之间的关系分为线性回归和非线性回归。 回归学习中最常用的损失函数是平方损失函数，在此情况下，回归问题可以用最小二乘法（least squares）求解。 一个回归\b的例子\b：市场趋势预测。 if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"读书笔记","url":"https://xutree.github.io/pages/2019/01/04/sl-1/"},{"title":"深度学习 第五章 机器学习基础","text":"大部分机器学习算法都有超参数（必须在学习算法外设定），我们将探讨如何使用额外的数据设置超参数。机器学习本质上属于应用统计学，更多地关注与如何用计算机统计地估计复杂函数，不太关注为这些函数提供置信区间，因此我们会探讨两种统计学的主要方法：频率派估计和贝叶斯推断。大多数深度学习算法都是基于被称为随机梯度下降得算法求解的。 5.1 学习算法 Mitchell 对\"学习\"提供了一个简洁的定义：\"对于某类任务 \\(T\\) 和性能度量 \\(P\\) ，一个计算机程序被认为可以从经验 \\(E\\) 中学习是指，通过经验 \\(E\\) 改进后，它在任务 \\(T\\) 上由性能度量 \\(P\\) 衡量的性能有所提升。\" 5.1.1 任务 \\(T\\) 通常机器学习任务定义为机器学习系统应该如何处理 样本 （example）。样本是指我们从某些希望机器学习系统处理的对象或事件中收集到的已经量化的 特征 （feature）的集合。 我们通常会将样本表示成一个向量 \\(\\boldsymbol x\\in\\mathbb{R}&#94;n\\) ，其中向量的每一个元素 \\(x_i\\) 是一个特征。 机器学习可以解决很多类型的任务。一些非常常见的机器学习任务列举如下： 分类 输入缺失分类 回归 转录 机器翻译 结构化输出 异常检测 合成和采样 缺失值填补 去噪 密度估计或概率质量函数估计 5.1.2 性能度量 \\(P\\) if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"读书笔记","url":"https://xutree.github.io/pages/2018/12/07/dl-5/"},{"title":"深度学习 第四章 数值计算","text":"4.1 上溢和下溢 数值 上溢 （overflow）：大量级的数被近似为正无穷或负无穷时发生上溢，进一步运算导致无限值变为非数字。 数值 下溢 （underflow）：接近零的数被四舍五入为0时发生下溢。被零除，取零的对数，进一步运算会变为非数字。 必须对上溢和下溢进行数值稳定的一个例子是 softmax 函数。 在数学，尤其是概率论和相关领域中，softmax 函数或称归一化指数函数，是逻辑函数的一种推广。它能将一个含任意实数的 \\(K\\) 维向量 \\(\\boldsymbol {z}\\) \"压缩\"到另一个 \\(K\\) 维实向量 \\(\\sigma(\\boldsymbol z)\\) 中，使得每一个元素的范围都在 \\((0,1)\\) 之间，并且所有元素的和为 1。该函数的形式通常按下面的式子给出： $$\\text{softmax}(\\boldsymbol x)_i=\\frac{\\text{e}&#94;{x_i}}{\\sum_{j=1}&#94;K\\text{e}&#94;{x_j}}$$ Softmax 函数实际上是有限项离散概率分布的梯度对数归一化。因此，softmax函数在包括 多项逻辑回归，多项线性判别分析，朴素贝叶斯分类器和人工神经网络等的多种基于概率的多分类问题方法中都有着广泛应用。 Softmax 函数可以通过执行下面的替换进行稳定： $$\\boldsymbol z=\\boldsymbol x-\\max_{i}x_i$$ 在实现深度学习算法时，底层库的开发者应该牢记数值问题。 4.2 病态条件 考虑函数 \\(f(\\boldsymbol x)=\\boldsymbol A&#94;{-1}\\boldsymbol x\\) 。当 \\(\\boldsymbol A\\in\\mathbb{R}&#94;{n\\times n}\\) 具有特征分解时，其条件数为： $$\\max_{i,j}\\left\\lvert\\frac{\\lambda_i}{\\lambda_j}\\right\\rvert$$ 是最大和最小特征值的模之比。当条件数很大时，矩阵求逆对输入的误差特别敏感。 4.3 基于导数的优化方法 4.3.1 梯度、方向导数、Jacobian 和 Hessian 矩阵 梯度向量：由多维输入一维输出的一阶导数构成 雅克比矩阵：由多维输入多维输出的一阶导数构成 海森矩阵：由多维输入一维输出的二阶导数构成 4.3.1.1 梯度 在向量微积分中， 标量场 的 梯度 （gradient）是一个 向量场 。标量场中某一点的梯度指向在这点标量场增长最快的方向（当然要比较的话必须固定方向的长度），梯度的绝对值是长度为 1 的方向中函数最大的增加率 多维函数的梯度是相对于一个向量求导的导数，记作 $$\\nabla_{\\boldsymbol x}f(\\boldsymbol x)$$ 此结果是一个列向量，第 \\(i\\) 个元素是 \\(f\\) 关于 \\(x_i\\) 的偏导数（partial derivation）。 4.3.1.2 方向导数 方向导数 （directional derivation）是函数 \\(f\\) 在 \\(\\boldsymbol u\\) 方向上的斜率。是函数 \\(f(\\boldsymbol x+\\alpha\\boldsymbol u)\\) 关于 \\(\\alpha\\) 的导数（在 \\(\\alpha=0\\) 时取得），根据链式法则： $$\\begin{eqnarray} \\frac{\\partial f(\\boldsymbol x+\\alpha\\boldsymbol u)}{\\partial\\alpha} &=& \\frac{\\partial f(\\boldsymbol x+\\alpha\\boldsymbol u)}{\\partial(\\boldsymbol x+\\alpha\\boldsymbol u)}\\frac{\\partial(\\boldsymbol x+\\alpha\\boldsymbol u)}{\\partial \\alpha} \\\\ &=& \\nabla_{{\\boldsymbol x}&#94;\\text{T}}f(\\boldsymbol x)\\boldsymbol u \\end{eqnarray}$$ 注意等号右边第一项为标量对向量的导数，需要转置。再利用 \\(\\alpha=0\\) ，并注意等式左边为标量，对等式两边同时转置，得方向导数为： $$\\boldsymbol u&#94;\\text{T}\\nabla_{\\boldsymbol x}f(\\boldsymbol x)$$ 如果函数 \\(f(\\boldsymbol x)\\) 在点 \\(\\boldsymbol x\\) 处可微，则沿着任意非零向量 \\(\\boldsymbol u\\) 的方向导数都存在。对赋范向量空间或内积空间有： $$\\nabla_{\\boldsymbol u}f(\\boldsymbol x)=\\boldsymbol u\\cdot \\nabla_{\\boldsymbol x}f(\\boldsymbol x)=\\boldsymbol u&#94;\\text{T}\\nabla_{\\boldsymbol x}f(\\boldsymbol x)$$ 其中， \\(\\cdot\\) 是内积运算。 4.3.1.3 雅克比矩阵 有时我们需要计算 输入和输出都是向量 的函数的所有偏导数。包含所有这样的偏导数的矩阵被称为 雅可比矩阵 （Jacobian matrix）。 具体来说，对于函数 \\(f:\\mathbb{R}&#94;m\\to\\mathbb{R}&#94;n\\) ， \\(f\\) 的雅克比矩阵 \\(\\boldsymbol J\\in\\mathbb{R}&#94;{n\\times m}\\) 定义为： $$J_{i,j}=\\frac{\\partial}{\\partial x_j}f(\\boldsymbol x)_i$$ 即 $$\\boldsymbol J=\\begin{bmatrix} \\frac{\\partial f(\\boldsymbol x)_1}{\\partial x_1} & \\frac{\\partial f(\\boldsymbol x)_1}{\\partial x_2} & \\cdots & \\frac{\\partial f(\\boldsymbol x)_1}{\\partial x_m} \\\\ \\frac{\\partial f(\\boldsymbol x)_2}{\\partial x_1} & \\frac{\\partial f(\\boldsymbol x)_2}{\\partial x_2} & \\cdots & \\frac{\\partial f(\\boldsymbol x)_2}{\\partial x_m} \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ \\frac{\\partial f(\\boldsymbol x)_n}{\\partial x_1} & \\frac{\\partial f(\\boldsymbol x)_n}{\\partial x_2} & \\cdots & \\frac{\\partial f(\\boldsymbol x)_n}{\\partial x_m} \\\\ \\end{bmatrix} =\\begin{bmatrix} \\left(\\nabla_{\\boldsymbol x}f(\\boldsymbol x)_1\\right)&#94;\\text{T} \\\\ \\left(\\nabla_{\\boldsymbol x}f(\\boldsymbol x)_2\\right)&#94;\\text{T} \\\\ \\vdots \\\\ \\left(\\nabla_{\\boldsymbol x}f(\\boldsymbol x)_n\\right)&#94;\\text{T} \\end{bmatrix}$$ 它的每一行都是由相应的函数的梯度向量的转置构成的。当目标函数为标量函数时，Jacobi 矩阵就是梯度向量。雅克比矩阵也记为： $$J_f(x_1,x_2,\\cdots,x_m)\\ \\ 或\\ \\ \\frac{\\partial (f(\\boldsymbol x)_1,f(\\boldsymbol x)_2,\\cdots,f(\\boldsymbol x_n)}{\\partial (x_1,x_2,\\cdots,x_m)}$$ 如果 \\(\\boldsymbol x_0\\) 是 \\(\\mathbb{R}&#94;m\\) 中的一点， \\(f\\) 在 \\(\\boldsymbol x_0\\) 点可微分，根据数学分析， \\(J_{f}(\\boldsymbol x_0)\\) 是在这点的导数。在此情况下， \\(J_{f}(\\boldsymbol x_0)\\) 这个线性映射即 \\(f\\) 在点 \\(\\boldsymbol x_0\\) 附近的 最优线性逼近 ，也就是说当 \\(\\boldsymbol x\\) 足够靠近点 \\(\\boldsymbol x_0\\) 时，我们有 $$f(\\boldsymbol x)=f(\\boldsymbol x_0)+J_f(\\boldsymbol x_0)(\\boldsymbol x-\\boldsymbol x_0)$$ 如果 \\(m=n\\) ，那么 \\(f\\) 是从 \\(n\\) 维空间到 \\(n\\) 维空间的函数，且它的雅可比矩阵是一个方块矩阵。于是我们可以取它的行列式，称为 雅可比行列式 。 在某个给定点的雅可比行列式提供了 \\(f\\) 在接近该点时的表现的重要信息。例如，如果连续可微函数 \\(f\\) 在 \\(\\boldsymbol x\\) 点的雅可比行列式不是零，那么它在该点附近具有反函数。这称为 反函数定理 。 更进一步，如果 \\(\\boldsymbol x\\) 点的雅可比行列式是正数，则 \\(f\\) 在 \\(\\boldsymbol x\\) 点的取向不变；如果是负数，则 \\(f\\) 的取向相反。而从雅可比行列式的绝对值，就可以知道函数 \\(f\\) 在 \\(\\boldsymbol x\\) 点的缩放因子；这就是它出现在换元积分法中的原因。 4.3.1.4 海森矩阵 海森矩阵 （Hessian matrix）是一个 多变量实值函数 的二阶偏导数组成的方块矩阵。假如有一实函数 \\(f(\\boldsymbol x)\\) ，如果 \\(f\\) 所有的二阶偏导数都存在，那么 \\(f\\) 的海森矩阵的第 \\(ij\\) 项即： $$H(f)(\\boldsymbol x)_{ij}=\\frac{\\partial&#94;2}{\\partial x_i\\partial x_j}f(\\boldsymbol x)$$ 即 $$\\boldsymbol H(f)=\\begin{bmatrix} \\frac{\\partial&#94;2 f}{\\partial x_1&#94;2} & \\frac{\\partial&#94;2 f}{\\partial x_1\\partial x_2} & \\cdots & \\frac{\\partial&#94;2 f}{\\partial x_1\\partial x_m} \\\\ \\frac{\\partial&#94;2 f}{\\partial x_2\\partial x_1} & \\frac{\\partial&#94;2 f}{\\partial x_2&#94;2} & \\cdots & \\frac{\\partial&#94;2 f}{\\partial x_2\\partial x_m} \\\\ \\vdots & \\vdots & \\ddots & \\vdots \\\\ \\frac{\\partial&#94;2 f}{\\partial x_m\\partial x_1} & \\frac{\\partial&#94;2 f}{\\partial x_m\\partial x_2} & \\cdots & \\frac{\\partial&#94;2 f}{\\partial x_m&#94;2} \\\\ \\end{bmatrix}=\\boldsymbol J_{\\nabla_f(\\boldsymbol x)}(\\boldsymbol x)$$ 海森矩阵的混合偏导数是海森矩阵非主对角线上的元素。假如他们是连续的，那么求导顺序没有区别，即 $${\\frac {\\partial }{\\partial x_1}}\\left({\\frac {\\partial f}{\\partial x_2}}\\right)={\\frac {\\partial }{\\partial x_2}}\\left({\\frac {\\partial f}{\\partial x_1}}\\right)$$ 上式也可写为 $$f_{x_1x_2}=f_{x_2x_1}$$ 也就是说，如果 \\(f\\) 函数在区域 \\(D\\) 内的每个二阶导数都是连续函数，那么 \\(f\\) 的海森矩阵在 \\(D\\) 区域内为对称矩阵。 二阶导数测试 （second derivation test）：当函数 \\(f:\\mathbb{R}&#94;n\\to\\mathbb{R}\\) 二阶连续可导时，Hessian 矩阵 \\(\\boldsymbol H\\) 在临界点 \\(\\boldsymbol x_{0}\\) (即，所有一阶偏导数都为零)上是一个 \\(n\\times n\\) 阶的对称矩阵。计算在 临界点 \\(\\boldsymbol x_{0}\\) 的海森矩阵： 当 \\(\\boldsymbol H\\) 是正定矩阵时（所有\b特征值都是正的），临界点 \\(x_{0}\\) 是一个局部的极小值 当 \\(\\boldsymbol H\\) 是负定矩阵时（所有\b特征值都是正的），临界点 \\(x_{0}\\) 是一个局部的极大值 \\(\\boldsymbol H=0\\) ，需要更高阶的导数来帮助判断 在其余情况下，临界点 \\(x_{0}\\) 不是局部极值 实值函数 \\(f\\) 在特定方向 \\(\\boldsymbol d\\) 上的二阶导数为： $$\\nabla_{\\boldsymbol d}(\\nabla_{\\boldsymbol d}f)=\\nabla_{\\boldsymbol d}(\\boldsymbol d&#94;\\text{T}\\nabla f)=\\nabla(\\boldsymbol d&#94;\\text{T}\\nabla f)\\boldsymbol d=\\boldsymbol d&#94;\\text{T}\\nabla(\\nabla f)\\boldsymbol d=\\boldsymbol d&#94;\\text{T}\\boldsymbol {Hd}$$ 当 \\(\\boldsymbol d\\) 是 \\(\\boldsymbol H\\) 的一个特征向量时，这个方向的二阶导数就是对应的特征值。对于其他的方向 \\(\\boldsymbol d\\) ，方向二阶导数是所有特征值的加权平均，权重在 0 和 1 之间。最大特征值确定最大二阶导数，最小特征确定最下二阶导数。 4.3.2 梯度下降法 我们经常最小化具有多维输入的函数： \\(f:\\mathbb{R}&#94;n\\to\\mathbb{R}\\) 。为了使\"最小化\"的概念有意义，输出必须是一维的（标量）。 为最小化 \\(f\\) ，我们希望找到使 \\(f\\) 下降得最快的方向。计算方向导数： $$\\min_{\\boldsymbol u,\\boldsymbol u&#94;\\text{T}\\boldsymbol u=1}\\boldsymbol u&#94;\\text{T}\\nabla_{\\boldsymbol x}f(\\boldsymbol x) \\\\ =\\min_{\\boldsymbol u,\\boldsymbol u&#94;\\text{T}\\boldsymbol u=1}\\|\\boldsymbol u\\|_2\\|\\nabla_{\\boldsymbol x}f(\\boldsymbol x)\\|_2\\cos\\theta \\\\ =\\min_{\\boldsymbol u}\\cos\\theta$$ 其中 \\(\\theta\\) 是 \\(\\boldsymbol u\\) 与梯度的夹角。这表明当 \\(\\boldsymbol u\\) 与梯度方向相反时，函数下降最快。即梯度向量指向上坡，负梯度向量指向下坡。我们在负梯度方向上移动可以减小 \\(f\\) ，这被称为 最速下降法 （method of steepest descent）或 梯度下降 （gradient descent）。 最速下降建议新的点为： $$\\boldsymbol x'=\\boldsymbol x-\\epsilon\\nabla_{\\boldsymbol x}f(\\boldsymbol x)$$ 其中 \\(\\epsilon\\) 为 学习率 （learning rate），是一个确定步长大小的正标量。我们可以通过几种不同的方式选择 \\(\\epsilon\\) 。普遍的方式是选择一个小常数。有时我们通过计算，选择使方向导数消失的步长。还有一种方法是根据几个 \\(\\epsilon\\) 计算 \\(f(\\boldsymbol x-\\epsilon\\nabla_{\\boldsymbol x}f(\\boldsymbol x))\\) ，并选择其中能产生最小目标函数值的 \\(\\epsilon\\) 。这种策略称为线搜索。 我们可以通过（方向）二阶导数预期一个梯度下降步骤能表现得多好。函数 \\(f(\\boldsymbol x)\\) 在当前点 \\(\\boldsymbol x&#94;{(0)}\\) 的二阶泰勒近似为： $$\\begin{eqnarray} f(\\boldsymbol x) &\\approx& f(\\boldsymbol x&#94;{(0)})+(\\boldsymbol x-\\boldsymbol x&#94;{(0)})&#94;\\text{T}\\nabla_{\\boldsymbol x}f(\\boldsymbol x&#94;{(0)}) \\\\ &+& \\frac{1}{2}(\\boldsymbol x-\\boldsymbol x&#94;{(0)})&#94;\\text{T}\\boldsymbol H(f)(\\boldsymbol x&#94;{(0)})(\\boldsymbol x-\\boldsymbol x&#94;{(0)})\b \\end{eqnarray}$$ 如果我们使用学习率 \\(\\epsilon\\) ，那么新的点 \\(\\boldsymbol x\\) 将会是 \\(\\boldsymbol x&#94;{(0)}-\\epsilon\\nabla_{\\boldsymbol x}f(\\boldsymbol x&#94;{(0)})\\) ，带入上式，令 \\(\\boldsymbol g=\\nabla_{\\boldsymbol x}f(\\boldsymbol x&#94;{(0)})\\) ， \\(\\boldsymbol H=\\boldsymbol H(f)(\\boldsymbol x&#94;{(0)})\\) 得： $$f(\\boldsymbol x&#94;{(0)}-\\epsilon\\boldsymbol g) \\approx f(\\boldsymbol x&#94;{(0)})-\\epsilon\\boldsymbol g&#94;\\text{T}\\boldsymbol g+\\frac{1}{2}\\epsilon&#94;2\\boldsymbol g&#94;\\text{T}\\boldsymbol H\\boldsymbol g$$ 上式是关于 \\(\\epsilon\\) 的二次函数，所以，当 \\(\\boldsymbol g&#94;\\text{T}\\boldsymbol H\\boldsymbol g\\) 为零或负时，增加 \\(\\epsilon\\) 将永远使得 \\(f\\) 下降；当 \\(\\boldsymbol g&#94;\\text{T}\\boldsymbol H\\boldsymbol g\\) 为正时，则使近似泰勒级数下降最多的最优步长为： $$\\epsilon&#94;\\ast=\\frac{\\boldsymbol g&#94;\\text{T}\\boldsymbol g}{\\boldsymbol g&#94;\\text{T}\\boldsymbol H\\boldsymbol g}$$ 最坏的情况下， \\(\\boldsymbol d\\) 与 \\(\\boldsymbol H\\) 最大特征值 \\(\\lambda_{\\max}\\) 对应的特征向量对齐，则最优步长是 \\(\\frac{1}{\\lambda_\\max}\\) 。当我们要最小化的函数能用二次函数很好的近似的情况下，海森矩阵的特征值决定了学习率的量级。 最速下降在梯度的每一个元素为零时收敛（或在实践中，近似为零）。在某些情况下，我们也许能够避免运行该迭代算法，并通过解方程 \\(\\nabla_{\\boldsymbol x}f(\\boldsymbol x)=0\\) 直接跳到临界点。 虽然梯度下降被限制在连续空间中的优化问题，但不断向更好的情况移动一小步的一般概念可以推广到离散空间。递增带有离散参数的目标函数称为 爬山 （hill climbing）算法。 4.3.3 牛顿法 \b 梯度下降法利用函数一阶导数的信息，在局部位置用\b一阶方程（一维对应直线，二维对应平面，高维对应超平面）拟合函数，然后沿着拟合函数函数值减小方向下降。 牛顿法则利用函数一阶和二阶导数的信息，在局部位置用二阶方程（一维对应二次曲线，二维对应二次曲面，高维对应超二次曲面）拟合函数，然后沿着拟合函数函数值减小方向下降。 梯度下降法和牛顿法相比，两者都是迭代求解，不过梯度下降法是梯度求解，而牛顿法是用二阶的海森矩阵的逆矩阵求解。相对而言，使用牛顿法收敛更快（迭代更少次数）。但是每次迭代的时间比梯度下降法长。 目标函数 \\(f(\\boldsymbol x)\\) 在 \\(\\boldsymbol x&#94;{(0)}\\) 处的二阶泰勒展开式为： $$f(\\boldsymbol x+\\boldsymbol x&#94;{(0)})=f(\\boldsymbol x&#94;{(0)})+\\boldsymbol x&#94;\\text{T}\\nabla_{\\boldsymbol x}f(\\boldsymbol x&#94;{(0)})+\\frac{1}{2}\\boldsymbol x&#94;\\text{T}\\boldsymbol H(f)(\\boldsymbol x&#94;{(0)})\\boldsymbol x$$ 当 \\(\\boldsymbol x&#94;{(0)}\\) 固定时， \\(\\boldsymbol x\\) 取多少可以使 \\(f(\\boldsymbol {x+x}&#94;{\b(0)})\\) 最小呢，由于上式是 \\(\\boldsymbol x\\) 的二次函数，对 \\(\\boldsymbol x\\) 求偏导得临界点： $$\\boldsymbol x&#94;\\ast=\\boldsymbol x&#94;{(0)}-\\boldsymbol H(f)(\\boldsymbol x&#94;{(0)})&#94;{-1}\\nabla_{\\boldsymbol x}f(\\boldsymbol x&#94;{(0)})$$ 如果 \\(f\\) 是一个正定二次函数，牛顿法只要使用上式一次就可以跳到函数的最小点。如果 \\(f\\) 不是一个真正的二次但能在局部近似为正定二次，牛顿法则需要多次迭代应用上式。 仅使用梯度信息的优化算法称为 一阶优化算法 （first-order optimization algorithms），如梯度下降。使用\b Hessian 矩阵的优化算法称为 二阶优化算法 （second-order optimization algorithms），如牛顿法。 if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"读书笔记","url":"https://xutree.github.io/pages/2018/11/24/dl-4/"},{"title":"深度学习 第三章 概率与信息论","text":"3.1 随机变量 随机变量 （random variable）是可以随机的取不同值的变量。通常用无格式字体（plain typeface）中的小写字母来表示随机变量本身，而用手写体中的小写字母来表示随机变量能够取到的值。例如， \\(x_1\\) 和 \\(x_2\\) 都是随机变量 x 的可能取值。 3.2 概率分布 概率分布 （probability distribution）用来描述随机变量每一个可能取到的状态的可能性的大小。 概率质量函数 （probability mass function，PMF）离散型变量的概率分布。 概率密度函数 （probability density function，PDF）连续型变量的概率分布。 3.3 边缘概率 边缘概率分布 （marginal probability distribution）是一种定义在子集上的概率分布。 $$p(x)=\\int p(x,y)dy$$ 3.4 条件概率 条件概率 （conditional probability）就是事件在另外一个事件已经发生条件下的发生概率。 $$P(\\text{y}=y|\\text{x}=x)=\\frac{P(\\text{y}=y,\\text{x}=x)}{P(\\text{x}=x)}$$ 3.5 独立性和条件独立性 独立性 （independent） $$\\forall x\\in\\text{x},y\\in\\text{y} \\\\ p(\\text{x}=x,\\text{y}=y)=p(\\text{x}=x)p(\\text{y}=y)$$ 记为 x \\(\\perp\\) y。 条件独立 （conditionally independent） $$\\forall x\\in\\text{x},y\\in\\text{y},z\\in\\text{z} \\\\ p(\\text{x}=x,\\text{y}=y|\\text{z}=z)=p(\\text{x}=x|\\text{z}=z)p(\\text{y}=y|\\text{z}=z)$$ 记为 x \\(\\perp\\) y \\(\\mid\\) z。 3.6 期望、方差和协方差 期望 （expectation） $$\\mathbb{E}_{\\text{x}\\sim P}\\left[\\text{x}\\right]=\\sum_xxP(x)\\ 或\\ \\mathbb{E}_{\\text{x}\\sim p}\\left[\\text{x}\\right]=\\int_xxP(x)dx$$ 约定 \\(\\mathbb{E}[\\cdot]\\) 表示对方括号内的所有随机变量的值求平均。如随机变量明确，则可以省略下标。 性质： $$\\mathbb{E}[a\\text{x}+b\\text{y}]=a\\mathbb{E}[\\text{x}]+b\\mathbb{E}[\\text{y}]$$ 方差 （variance） $$\\text{Var}\\left(\\text{x}\\right)=\\mathbb{E}\\left[\\left(\\text{x}-\\mathbb{E}[\\text{x}]\\right)&#94;2\\right]=\\mathbb{E}\\left[\\text{x}&#94;2\\right]-\\left(\\mathbb{E}[\\text{x}]\\right)&#94;2$$ 方差的平方根称为 标准差 （standard deviation）。 性质： $$\\text{Var}(\\text{x})\\geq0 \\\\ \\text{Var}(\\text{x}+\\text{const})=\\text{Var}(\\text{x}) \\\\ \\text{Var}(a\\text{x})=a&#94;2\\text{Var}(\\text{x}) \\\\ \\text{Var}(a\\text{x}+b\\text{y})=a&#94;2\\text{Var}(\\text{x})+b&#94;2\\text{Var}(\\text{y})+2ab\\ \\text{Cov}(\\text{x},\\text{y}) \\\\ \\text{Var}(\\text{x}-\\text{y})=\\text{Var}(\\text{x})+\\text{Var}(\\text{y})-2\\ \\text{Cov}(\\text{x},\\text{y}) \\\\ \\text{Var}\\left(\\sum_{i=1}&#94;N\\text{x}_i\\right)=\\sum_{i,j=1}&#94;N\\text{Cov}(\\text{x}_i,\\text{x}_j)=\\sum_{i=1}&#94;N\\text{Var}(\\text{x}_i)+\\sum_{i\\neq j}\\text{Cov}(\\text{x}_i,\\text{x}_j)$$ 最后一式为随机向量的方差。 协\b方差 （covariance）在概率论和统计学中用于衡量两个变量的总体误差。而方差是协方差的一种特殊情况，即当两个变量是相同的情\b况。期望值分别为 \\(\\mathbb{E}(\\text{x})=\\mu\\) 和 \\(\\mathbb{E}(y)=\\nu\\) 的两个具有有限二阶矩的实数随机变量 x 与 y 之间的协方差定义为： $$\\text{Cov}(\\text{x},\\text{y})=\\mathbb{E}\\left[(\\text{x}-\\mu)(\\text{y}-\\nu)\\right]=\\mathbb{E}[\\text{x}\\cdot y]-\\mu\\nu$$ 协方差表示的是两个变量的总体的误差，这与只表示一个变量误差的方差不同。 如果两个变量的变化趋势一致，也就\b是说如果其中一个大于自身的期望值，另外一个也大于自身的期望值，那么两个变量之间的协方差就是正值。 如果两个变量的变化趋势相反，即其中一个大于自身的期望值，另外一个却小于自身的期望值，那么两个变量之间的协方差就是负值。 如果 x 与 y 是统计独立的，那么二者之间的协方\b差就是 0。 取决于协方差的 相关性 （correlation）定义为 $$\\eta=\\frac{\\text{cov}(\\text{x},\\text{y})}{\\sqrt{\\text{Var}(\\text{x})\\cdot\\text{Var}(\\text{y})}}$$ 更准确地说是线性相关性，是一个衡量线性独立的无量纲数，其取值在 \\([－1,1]\\) 之间。相关性 \\(\\eta=1\\) 时称为\"完全线性相关\"（相关性 \\(\\eta=-1\\) 时称为\"完全线性负相关\"）。 相关性为 0（因而协方差也为 0）的两个随机变量又被称为是不相关的，或者更准确地说叫作\"线性无关\"、\"线性不相关\"，这仅仅表明 x 与 y 两随机变量之间没有线性相关性，并非表示它们之间一定没有任何内在的（非线性）函数关系。 性质： $$\\text{Cov}(\\text{x},\\text{x})=\\text{Var}(\\text{x}) \\\\ \\text{Cov}(\\text{x},\\text{y})=\\text{Cov}(\\text{y},\\text{x}) \\\\ \\text{Cov}(a\\text{x},b\\text{y})=ab\\ \\text{Cov}(\\text{x},\\text{y}) \\\\ \\text{Cov}\\left(\\sum_{i=1}&#94;n\\text{x}_i\\sum_{j=1}&#94;m\\text{y}_j\\right)=\\sum_{i=1}&#94;n\\sum_{j=1}&#94;m\\text{Cov}(\\text{x}_i,\\text{y}_j)$$ 协方差矩阵 （covariance matrix）对随机向量 \\({\\bf x}\\in\\mathbb{R}&#94;n\\) ，协方差矩阵为 $$\\text{Cov}({\\bf x})_{i,j}=\\text{Cov}(\\text{x}_i,\\text{y}_j)$$ 其对角元是方差。 3.7 常用概率分布 3.7.1 伯努利分布 伯努利分布 （Bernoulli distribution），又称两点分布或 0-1 分布。 $$P(\\text{x}=1)=\\phi \\\\ P(\\text{x}=0)=1-\\phi \\\\ P(\\text{x}=x)=\\phi&#94;x(1-\\phi)&#94;{1-x} \\\\ \\text{E}_{\\text{x}}[\\text{x}]=\\phi \\\\ \\text{Var}_{\\text{x}}(\\text{x})=\\phi(1-\\phi)$$ 3.7.2 高斯分布 实数上最常用的分布就是 正态分布 （normal distribution），也称高斯分布（Gaussian distribution）。 $${\\cal N}(x;\\mu,\\sigma&#94;2)=\\sqrt{\\frac{1}{2\\pi\\sigma&#94;2}}\\exp\\left(-\\frac{1}{2\\sigma&#94;2}(x-\\mu)&#94;2\\right) \\\\ \\mathbb{E}_{\\text{x}\\sim{\\cal N}}[\\text{x}]=\\mu \\\\ \\text{Var}_{\\text{x}\\sim{\\cal N}}[\\text{x}]=\\sigma&#94;2$$ 函数拐点在 \\(x=\\mu\\pm\\sigma\\) 处。 当我们由于缺乏关于某个实数上分布的先验知识而不知道该选择怎样的形式时，正态分布是默认较好的选择，有两个原因： 我们想要建模的很多分布的真实情况是比较接近正态分布的。中心极限定理（central limit theorem）说明很多独立随机变量的和近似服从正态分布 在具有相同方差的所有可能的概率分布中，正态分布在实数上具有最大的不确定性。因此，我们可以认为正态分布是对模型加入的先验知识量最少的分布 正态分布可以推广到 \\(\\mathbb{R}&#94;n\\) 空间，这种情况下称为\b 多维正态分布 （multivariate normal distribution）。它的参数是一个正定对称矩阵 \\(\\boldsymbol \\Sigma\\) （协方差\b矩阵）： $${\\cal N}(\\boldsymbol x;\\boldsymbol\\mu,\\boldsymbol\\Sigma)=\\sqrt{\\frac{1}{(2\\pi)&#94;n\\text{det}(\\boldsymbol \\Sigma)}}\\exp\\left(-\\frac{1}{2}(\\boldsymbol x-\\boldsymbol \\mu)&#94;\\text{T}\\boldsymbol\\Sigma&#94;{-1}(\\boldsymbol x-\\boldsymbol \\mu)\\right)$$ 3.7.3 指数分布和 Laplace 分布 指数分布 （exponential distribution）在 \\(x=0\\) 处取得边界点（sharp point）的分布。 $$p(x;\\lambda)=\\lambda\\boldsymbol 1_{x\\geq0}\\exp(-\\lambda x)$$ 指示函数（indicator function） \\(\\boldsymbol 1_{x\\geq0}\\) 来使得当 \\(x\\) 取负值时的概率为零。 拉普拉斯分布 （Laplace \bdistribution）可以在任意一点 \\(\\mu\\) 处设置概率质量的峰值。 $$\\text{Laplace}(x;\\mu,\\gamma)=\\frac{1}{2\\gamma}\\exp\\left(-\\frac{|x-\\mu|}{\\gamma}\\right)$$ 3.7.4 Dirac 分布和经验分布 Dirac delta 函数可以用于定义狄拉克分布： $$p(x)=\\delta(x-\\mu)$$ Dirac 分布常作为 经验分布 （empirical distribution）的一个组成部分出现： $$\\hat{p}(\\boldsymbol x)=\\frac{1}{m}\\sum_{i=1}&#94;m\\delta(\\boldsymbol x-\\boldsymbol x&#94;{(i)})$$ 经验分布将概率密度 \\(\\frac{1}{m}\\) 赋给 \\(m\\) 个点 \\(\\boldsymbol x&#94;{(1)},\\cdots,\\boldsymbol x&#94;{(m)}\\) 中的每一个，这些点是给定的数据集或者采样的集合。 只有在定义连续型随机变量的经验分布时，狄拉克 delta 函数才是必要的。对于离散型随机变量，对于每一个可能的输入，其概率可以简单的设为训练集上那个输入值的\b 经验频率 （empirical frequency）。 当我们在训练集上训练模型时，可以认为从这个训练集上得到的经验分布指明了采样来源的分布。关于经验分布另外一个重要的观点是，它是训练数据的似然最大的那个概率密度函数。 3.7.5 分布的混合 混合分布 （mixture distribution）是由一些\b组件（component）分布构成： $$P(\\text{x})=\\sum_iP(\\text{c}=i)P(\\text{x}|\\text{c}=i)$$ 这里 \\(P(\\text{c})\\) 是各个组件被选中的概率，决定每一次试验样本从哪个组件分布生成。 3.8 常用函数的性质 3.8.1\b 逻辑函数 逻辑函数 （logistic function），也被称为 S 函数 （sigmoid function），通常用来产生伯努利分布中的参数 \\(\\phi\\) ，因为它的范围是 \\((0,1)\\) 。sigmoid 函数在变量取绝对值非常大的时候会出现饱和（saturate）现象，意味着对输入的微小变化变得不敏感。 $$\\sigma(x)=\\frac{1}{1+\\text{e}&#94;{-x}}$$ 一些性质： $$\\sigma(x)=\\frac{\\text{e}&#94;{x}}{\\text{e}&#94;{x}+1} \\\\ \\frac{d}{dx}\\sigma(x)=\\sigma(x)\\sigma(-x) \\\\ 1-\\sigma(x)=\\sigma(-x) \\\\ \\forall x\\in(0,1),\\ \\sigma&#94;{-1}(x)=\\ln\\left(\\frac{x}{1-x}\\right)$$ 3.8.2 softplus 函数 $$\\zeta(x)=\\ln(1+\\text{e}&#94;{x})$$ softplus 函数可以用来产生正态分布的 \\(\\beta\\) 和 \\(\\sigma\\) 参数，因为它的范围是 \\((0,\\infty)\\) 。softplus 函数名来源于它是另外一个函数的平滑（或\"软化\"）形式，这个函数是： $$x&#94;+=\\max(0,x)$$ 一些性质： $$\\zeta(x)=-\\ln\\sigma(-x) \\\\ \\frac{d}{dx}\\zeta(x)=\\sigma(x) \\\\ \\forall x\\geq0,\\ \\zeta&#94;{-1}(x)=\\ln\\left(\\text{e}&#94;x-1\\right) \\\\ \\zeta(x)=\\int_{-\\infty}&#94;x\\sigma(y)dy \\\\ \\zeta(x)-\\zeta(-x)=x$$ 正部函数 （positive part function）： \\(x&#94;+=\\max(0,x)\\) 负部函数 （negative part function）： \\(x&#94;-=\\max(0,-x)\\) $$x&#94;+-x&#94;-=x$$ 3.9 贝叶斯规则 贝叶斯规则 （Bayes' rule）： $$P(\\text{x}|\\text{y})=\\frac{P(\\text{x})P(\\text{y}|\\text{x})}{P(\\text{y})}=\\frac{P(\\text{x})P(\\text{y}|\\text{x})}{\\sum_xP(\\text{y}|x)P(x)}$$ 3.10 连续型变量的技术细节 假设有两个随机变量 \\(\\bf x\\) 和 \\(\\bf y\\) 满足 \\(\\boldsymbol y=g(\\boldsymbol x)\\) ，其中 \\(g\\) 是可逆、连续可微的函数。 我们需要保持下面的性质： $$|p_y(g(x))dy|=|p_x(x)dx|$$ 即 $$p_y(y)=p_x(g&#94;{-1}(y))\\left\\lvert\\frac{\\partial x}{\\partial y}\\right\\rvert$$ 即 $$p_x(x)=p_y(g(x))\\left\\lvert\\frac{\\partial g(x)}{\\partial x}\\right\\rvert$$ 在高维空间中，微分运算扩展为 Jacobian\b 矩阵 的行列式，矩阵的每个元素为 \\(J_{i,j}=\\frac{\\partial x_i}{\\partial y_j}\\) 。因此，对实值向量 \\(\\boldsymbol x\\) 和 \\(\\boldsymbol y\\) ： $$p_x(\\boldsymbol x)=p_y(g(\\boldsymbol x))\\left\\lvert\\text{det}\\left(\\frac{\\partial g(\\boldsymbol x)}{\\partial \\boldsymbol x}\\right)\\right\\rvert \\\\$$ 3.11 信息论 3.11.1 自信息 一个事件 \b \\(\\text{x}=x\\) 的 自信息 （self-information）为 $$I(x)=-\\log P(x)$$ 当底数是 e 时，自信息的单位是\b 奈特 （nats）。当底数是 2 时，自信息的单位是 比特 （bit）或 香农 （shannons）。 3.11.2 香农熵 \b 香农熵 （Shannon entropy）对整个概率分布中的不确定性总量进行量化： $$H(x)=\\mathbb{E}_{\\text{x}\\sim P}[I(x)]=-\\mathbb{E}_{\\text{x}\\sim P}[\\log P(x)]$$ 也记作 \\(H(P)\\) 。当 x 是连续的，香农熵被称为 微分熵 （differential entropy）。 3.11.3 相对熵 如果对于同一个随机变量 x 有两个单独\b的概率分布 \\(P(\\text{x})\\) 和 \\(Q(\\text{x})\\) ，可以使用 相对熵 （relative entropy）来衡量两个分布的差异： $$D_{KL}(P\\|Q)=\\mathbb{E}_{\\text{x}\\sim P}\\left[\\log\\frac{P(x)}{Q(x)}\\right]=\\mathbb{E}_{\\text{x}\\sim P}[\\log P(x)-\\log Q(x)]$$ 又称为 KL 散度 （Kullback–Leibler divergence，简称KLD）， 信息散度 （information divergence）， 信息增益 （information gain）。 KL 散度是非负的。当且仅当分布相同 KL 散度为 0。 尽管从直觉上 KL 散度是个度量或距离函数, 但是它实际上并不是一个真正的度量或距离。因为 KL 散度不具有对称性。 按照惯例，在信息论中， \\(\\lim_{x\\to0}x\\ln x=0\\) if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"读书笔记","url":"https://xutree.github.io/pages/2018/11/21/dl-3/"},{"title":"深度学习 第二章 线性代数","text":"2.1 标量、向量、矩阵和张量 标量 （scalar）：一个单独的数，用斜体小写字母表示，如 \\(n\\in\\mathbb{R}\\) 中的 \\(n\\) 向量 （vector）：一列数，用粗斜体小写字母表示 $$\\boldsymbol x=\\begin{bmatrix} x_1 \\\\ x_2 \\\\ \\vdots \\\\ x_n \\end{bmatrix}$$ \\(\\boldsymbol x_{-1}\\) 表示 \\(\\boldsymbol x\\) 中除 \\(x_1\\) 外的所有元素构成的向量。 \\(\\boldsymbol x_{-S}\\) 表示 \\(\\boldsymbol x\\) 中除 \\(S\\) 中指定的索引外的所有元素构成的向量。 矩阵 （matrix）：二位数组，用粗斜体大写字母表示 $$\\boldsymbol A=\\begin{bmatrix} A_{1,1} & A_{1,2} \\\\ A_{2,1} & A_{2,2} \\end{bmatrix}$$ 张量 （tensor）：坐标超过两维的数组，用粗体大写字母表示。张量 \\(\\bf A\\) 中坐标为 \\((i,j,k)\\) 的元素记为 \\({\\bf A}_{i,j,k}\\) 转置 （transpose）是矩阵以其主对角线（main diagonal）为轴的镜像。 $$({\\boldsymbol A}&#94;\\text{T})_{i,j}=A_{j,i}$$ 标量的转置等于它本身。 广播 （broadcasting）是矩阵和向量采取下面的规则相加 $${\\boldsymbol C}={\\boldsymbol A}+{\\boldsymbol b}\\Longleftrightarrow C_{i,j}=A_{i,j}+b_j$$ 也就是向量 \\({\\boldsymbol b}\\) 和矩阵 \\({\\boldsymbol A}\\) 的每一行相加。 2.2 矩阵和向量相乘 矩阵相乘 （matrix product）：要求第一个矩阵的列数等于第二个矩阵的行数。满足分配律、结合律，一般不满足交换律。 $${\\boldsymbol C}=\\boldsymbol {AB}\\Longleftrightarrow C_{i,j}=\\sum_kA_{i,k}B_{k,j}$$ Hadamard 乘积 ：要求两个矩阵形状一样，为对应元素乘积。满足交换律。 $${\\boldsymbol C}={\\boldsymbol A}\\odot{\\boldsymbol B}\\Longleftrightarrow C_{i,j}=A_{i,j}B_{i,j}$$ 向量点积 （vector dot product）：要求两个向量维度相同。满足交换律。 $${\\boldsymbol z}=\\boldsymbol {xy}\\Longleftrightarrow z_i=x_iy_i$$ 也可写作矩阵乘积的形式 $${\\boldsymbol z}={\\boldsymbol x}&#94;\\text{T}{\\boldsymbol y}$$ 和 Hadamard 乘积形式 $${\\boldsymbol z}={\\boldsymbol x}\\odot{\\boldsymbol y}$$ 2.3 范数 有时我们需要衡量一个向量的大小。在机器学习中，我们经常使用 范数 （norm）来衡量向量的大小。形式上， \\(L&#94;p\\) 范数定义如下： $$\\|{\\boldsymbol x}\\|_p=\\left(\\sum_i|x_i|&#94;p\\right)&#94;{\\frac{1}{p}}$$ 其中， \\(p\\in\\mathbb{R}\\) ， \\(p\\geq1\\) 。 更严格的，范数是满足下列性质的任意函数\b： \\(f({\\boldsymbol x})=0\\Rightarrow{\\boldsymbol x}={\\boldsymbol 0}\\) \\(f({\\boldsymbol x}+{\\boldsymbol y})\\leq f({\\boldsymbol x})+f({\\boldsymbol y})\\) \\(\\forall\\alpha\\in\\mathbb{R},\\ f(\\alpha{\\boldsymbol x})=|\\alpha|f({\\boldsymbol x})\\) 当 \\(p=2\\) 时， \\(L&#94;2\\) 范数称为 欧几里得范数 （Euclidean norm），经常简化表示为 \\(\\|\\boldsymbol x\\|\\) ，略去下标 2。平方 \\(L&#94;2\\) 范数也经常用来衡量向量的大小，可以简单的通过点积 \\({\\boldsymbol x}&#94;\\text{T}{\\boldsymbol x}\\) 计算。 平方 \\(L&#94;2\\) 范数在数学和计算上都比 \\(L&#94;2\\) 范数本身更方便。例如，平方 \\(L&#94;2\\) 范数对每个元素的导数只取决于对应的元素。 但在某些情况下，平方 \\(L&#94;2\\) 范数也可能不受欢迎，因为它在原点附近增长得十分缓慢。在某些机器学习应用中，区分恰好是零元素和非零\b但值很小的元素是很重要的。在这些情况下，我们转而使用\b在各个位置斜率相同，同时保持简单的数学形式的函数： \\(L&#94;1\\) 范数： $$\\|{\\boldsymbol x}\\|_1=\\sum_i|x_i|$$ 另外一个常用的范数是 最大范数 （max norm）： $$\\|{\\boldsymbol x}\\|_{\\infty}=\\max_i|x_i|$$ 有时候我们可能也希望衡量矩阵的大小。在深度学习中，最常见的做法是使用 弗洛宾尼斯范数 （Frobenius norm）： $$\\|{\\boldsymbol A}\\|_F=\\sqrt{\\sum_{i,j}A_{i,j}&#94;2}$$ 其类似于向量的 \\(L&#94;2\\) 范数。 2.4 特征分解 特征分解 （eigendecomposition）是使用最广泛的矩阵分解之一，它将矩阵分解为一组特征值和特征向量。 设\b方阵 \\({\\boldsymbol A}\\) 的特征值为 \\(\\lambda\\) ，特征向量为 \\({\\boldsymbol v}\\) ，即 $$\\boldsymbol {Av}=\\lambda{\\boldsymbol v}$$ 假设矩阵 \\(\\boldsymbol A\\) 有 \\(n\\) 个线性无关的特征向量 \\(\\left\\{\\boldsymbol v&#94;{(1)},\\cdots,\\boldsymbol v&#94;{(n)}\\right\\}\\) ，对应和特征值 \\(\\left\\{\\lambda_1,\\cdots,\\lambda_n\\right\\}\\) 。取矩阵 \\(\\boldsymbol V=\\left[\\boldsymbol v&#94;{(1)},\\cdots,\\boldsymbol v&#94;{(n)}\\right]\\) ， \\(\\boldsymbol\\lambda=[\\lambda_1,\\cdots,\\lambda_n]&#94;\\text{T}\\) ，则 \\(\\boldsymbol A\\) 的特征分解可记作 $$\\boldsymbol A=\\boldsymbol V\\ \\text{diag}(\\boldsymbol\\lambda){\\boldsymbol V}&#94;{-1}$$ 实对称矩阵都可以分解成实特征值和\b实特征向量： $$\\boldsymbol A=\\boldsymbol {Q\\Lambda}{\\boldsymbol Q}&#94;{-1}$$ 其中， \\(\\boldsymbol Q\\) 是正交矩阵。 矩阵的特征分解提供了许多有用的信息。例如，矩阵是奇异的，当且仅当含有零特征值。 \b考虑下面的二次方程 $$f(\\boldsymbol x)=\\boldsymbol x&#94;\\text{T}\\boldsymbol {Ax}$$ 其中限制 \\(\\|\\boldsymbol x\\|_2=1\\) ，则当 \\(\\boldsymbol x\\) 等于 \\(\\boldsymbol A\\) 的某个特征向量时， \\(f\\) 将返回对应的特征值。在限制条件下， \\(f\\) 的最大值是最大特征值，最小值是最小特征值。证明方法是将任意的 \\(\\boldsymbol x\\) 展开为 \\(\\boldsymbol A\\) 特征向量的线性组合。 正定矩阵 （positive definite）：所有特征值都是正数的矩阵。 半正定矩阵 （positive semidefinite）：所有特征值都是非负数的矩阵。 负定矩阵 （negative definite）：所有特征值都是负数的矩阵。 半负定矩阵 （negative semidefinite）：所有特征值都是非正数的矩阵。 对半正定矩阵 \\(\\boldsymbol A\\) ， \\(\\forall \\boldsymbol x,\\ \\boldsymbol x&#94;\\text{T}\\boldsymbol{Ax}\\geq0\\) 。 此外，正定矩阵还保证 \\(\\boldsymbol x&#94;\\text{T}\\boldsymbol{Ax}=0\\Rightarrow\\boldsymbol x=\\boldsymbol 0\\) 。 2.5 奇异值分解 奇异值分解 （singular value decomposition，SVD）是另一种矩阵分解方法。 $$\\boldsymbol A=\\boldsymbol {UD}{\\boldsymbol V}&#94;\\text{T}$$ 其中， \\(\\boldsymbol A\\) 是 \\(m\\times n\\) 的矩阵， \\(\\boldsymbol U\\) 是 \\(m\\times m\\) 的正交矩阵， \\(\\boldsymbol V\\) 是 \\(n\\times n\\) 的正交矩阵， \\(\\boldsymbol D\\) 是 \\(m\\times n\\) 的对角矩阵。 对角矩阵 \\(\\boldsymbol D\\) 对角线上的元素称为矩阵 \\(\\boldsymbol A\\) 的奇异值（singular value）。矩阵 \\(\\boldsymbol U\\) 的列向量称为左奇异向量（left singular vector），它是 \\(\\boldsymbol {AA}&#94;\\text{T}\\) 的特征向量。矩阵 \\(\\boldsymbol V\\) 的列向量称为右奇异向量（right singular vector），它是 \\(\\boldsymbol A&#94;\\text{T}\\boldsymbol A\\) 的特征向量。 \\(\\boldsymbol A\\) 的非零奇异值是 \\(\\boldsymbol {AA}&#94;\\text{T}\\) 和 \\(\\boldsymbol A&#94;\\text{T}\\boldsymbol A\\) 特征值的平方根。 每个实数矩阵都有奇异值分解。 2.6 摩尔－彭若斯\b伪逆 矩阵 \\(\\boldsymbol A\\) 的摩尔－彭若斯伪逆（Moore-Penrose pseudoinverse）定义为： $$\\boldsymbol A&#94;+=\\lim_{\\alpha\\to0&#94;+}\\left(\\boldsymbol A&#94;\\text{T}\\boldsymbol A+\\alpha \\boldsymbol I\\right)&#94;{-1}\\boldsymbol A&#94;\\text{T}$$ 一般计算使用下面的公式： $$\\boldsymbol A&#94;+=\\boldsymbol {V}{\\boldsymbol D}&#94;+\\boldsymbol U&#94;\\text{T}$$ 其中，矩阵 \\(\\boldsymbol U\\) 、 \\(\\boldsymbol D\\) 和 \\(\\boldsymbol V\\) 是矩阵 \\(\\boldsymbol A\\) 奇异值分解后得到的矩阵。对角矩阵 \\(\\boldsymbol D\\) 的伪逆 \\(\\boldsymbol D&#94;+\\) 是其非零元素取倒数之后再转置得到的。 对于线性方程： $$\\boldsymbol {Ax}=\\boldsymbol y$$ 当矩阵 \\(\\boldsymbol A\\) 的列数多于行数时，使用伪逆求解线性方程是众多可能解法中的一种， \\(\\boldsymbol x=\\boldsymbol A&#94;+\\boldsymbol y\\) 是所有可行解中欧几里得范数 \\(\\|\\boldsymbol x\\|_2\\) 最小的那一个。 当矩阵 \\(\\boldsymbol A\\) 的列数多于行数时，可能没有解，通过伪逆求得的 \\(\\boldsymbol x\\) 是使得 \\(\\|\\boldsymbol {Ax}-\\boldsymbol y\\|_2\\) 最小的那一个。 2.7 迹运算 迹运算返回的是矩阵对角元素的和： $$\\text{Tr}(\\boldsymbol A)=\\sum_iA_{i,i}$$ 利用迹运算可以重写矩阵弗洛宾尼斯范数： $$\\|{\\boldsymbol A}\\|_F=\\sqrt{\\sum_{i,j}A_{i,j}&#94;2}=\\sqrt{\\text{Tr}(\\boldsymbol {AA}&#94;\\text{T})}$$ 迹运算性质： \\(\\text{Tr}(\\boldsymbol A)=\\text{Tr}\\left(\\boldsymbol A&#94;\\text{T}\\right)\\) \\(\\text{Tr}(\\boldsymbol{ABC})=\\text{Tr}(\\boldsymbol{CAB})=\\text{Tr}(\\boldsymbol{BCA})\\) \\(\\text{Tr}(a)=a\\) 2.8 行列式 记作 \\(\\text{det}(\\boldsymbol A)\\) ，等于矩阵特征值的乘积。 行列式的绝对值可以用来衡量矩阵参与矩阵乘法后空间扩大或缩小了多少。如果行列式是 0，那么空间至少沿着某一维完全收缩了，使其失去了所有的体积；如果行列式是 1，那么这个转换保持空间体积不变。 2.9 实例：主成分分析 主成分分析 （principal components analysis，PCA）是一个简单的机器学习算法。 问题 ：假设在 \\(\\mathbb{R}&#94;n\\) 空间中有 \\(m\\) 个点 \\(\\left\\{\\boldsymbol x&#94;{(1)},\\cdots,\\boldsymbol x&#94;{(m)}\\right\\}\\) ，我们希望对这些点进行有损压缩。有损压缩表示我们使用更少的内存，但损失一些精度去存储这些点。我们希望损失的精度尽可能少。 分析 ：编码这些点的一种方式是用低维表示。对于每个点 \\(\\boldsymbol x&#94;{(i)}\\in\\mathbb{R}&#94;n\\) ，会有一个编码向量 \\(\\boldsymbol c&#94;{(i)}\\in\\mathbb{R}&#94;l\\) 。如果 \\(l<n\\) ，那么我们便达到目的。 设编码函数是 \\(f(\\boldsymbol x)=\\boldsymbol c\\) ，解码函数是 \\(g(\\boldsymbol c)\\approx \\boldsymbol x\\) 。 PCA 由我们选择的解码函数而定，为了\b简单，我们使用矩阵乘法将编码映射回 \\(\\mathbb{R}&#94;n\\) ，即 \\(g(\\boldsymbol c)=\\boldsymbol{Dc}\\) ，其中 \\(\\boldsymbol D\\in\\mathbb{R}&#94;{n\\times l}\\) 是定义解码的矩阵。 为使解码器有唯一解，我们限制 \\(\\boldsymbol D\\) 中所有列向量都有单位范数。为了简化问题，进一步限制 \\(\\boldsymbol D\\) 中列向量彼此正交。 为求解最佳编码函数，我们计算下面的 \\(L&#94;2\\) 最优化问题： $$\\begin{eqnarray} \\boldsymbol c&#94;\\ast &=& \\arg\\max_{\\boldsymbol c}\\|\\boldsymbol x-g(\\boldsymbol c)\\|_2 \\\\ &=& \\arg\\max_{\\boldsymbol c}\\|\\boldsymbol x-g(\\boldsymbol c)\\|_2&#94;2 \\\\ &=& \\arg\\max_{\\boldsymbol c} \\left(\\boldsymbol x-g(\\boldsymbol c)\\right)&#94;\\text{T}\\left(\\boldsymbol x-g(\\boldsymbol c)\\right) \\\\ &=& \\arg\\max_{\\boldsymbol c}\\boldsymbol x&#94;\\text{T}\\boldsymbol x-\\boldsymbol x&#94;\\text{T}g(\\boldsymbol c)-g(\\boldsymbol c)&#94;\\text{T}\\boldsymbol x+g(\\boldsymbol c)&#94;\\text{T}g(\\boldsymbol c) \\\\ &=& \\arg\\max_{\\boldsymbol c}\\boldsymbol x&#94;\\text{T}\\boldsymbol x-2\\boldsymbol x&#94;\\text{T}g(\\boldsymbol c)+g(\\boldsymbol c)&#94;\\text{T}g(\\boldsymbol c)\\ \\ (利用标量 \\ \\text{Tr}(a)=a) \\\\ &=& \\arg\\max_{\\boldsymbol c}-2\\boldsymbol x&#94;\\text{T}g(\\boldsymbol c)+g(\\boldsymbol c)&#94;\\text{T}g(\\boldsymbol c)\\ \\ (忽略不含\\ \\boldsymbol c\\ 的项) \\\\ &=& \\arg\\max_{\\boldsymbol c}-2\\boldsymbol x&#94;\\text{T}\\boldsymbol {Dc}+\\boldsymbol c&#94;\\text{T}\\boldsymbol D&#94;\\text{T}\\boldsymbol {Dc}\\ \\ (带入\\ g(\\boldsymbol c)\\ 的定义) \\\\ &=& \\arg\\max_{\\boldsymbol c}-2\\boldsymbol x&#94;\\text{T}\\boldsymbol {Dc}+\\boldsymbol c&#94;\\text{T}\\boldsymbol I_l\\boldsymbol c\\ \\ (正交性单位\b性约束) \\\\ &=& \\arg\\max_{\\boldsymbol c}-2\\boldsymbol x&#94;\\text{T}\\boldsymbol {Dc}+\\boldsymbol c&#94;\\text{T}\\boldsymbol c \\end{eqnarray}$$ 令偏导为 0（参考 矩阵求导 ），得 $$\\nabla_{\\boldsymbol c}(-2\\boldsymbol x&#94;\\text{T}\\boldsymbol {Dc}+\\boldsymbol c&#94;\\text{T}\\boldsymbol c)=0 \\\\ -2\\boldsymbol D&#94;\\text{T}\\boldsymbol x+2\\boldsymbol c=0 \\\\ \\boldsymbol c=\\boldsymbol D&#94;\\text{T}\\boldsymbol x$$ 这使得算法很高效，最优编玛 \\(\\boldsymbol x\\) 只需要一个矩阵-向量乘法操作，我们获得了编码函数： $$f(\\boldsymbol x)=\\boldsymbol D&#94;\\text{T}\\boldsymbol x$$ 重构操作： $$r(\\boldsymbol x)=g(f(\\boldsymbol x))=\\boldsymbol {DD}&#94;\\text{T}\\boldsymbol x$$ 接下来，确定编码矩阵 \\(\\boldsymbol D\\) 。因为用相同的矩阵 \\(\\boldsymbol D\\) \b对所有点进行解码，我们不能再孤立的看待每个点。我们必须最小化\b所有维度和所有点上的误差矩阵的 Frobenius 范数： $$D&#94;\\ast=\\arg\\min_{\\boldsymbol D}\\sqrt{\\sum_{i=1,j=1}&#94;{i=m,j=n}\\left(\\boldsymbol x_j&#94;{(i)}-r(\\boldsymbol x&#94;{(i)})_j\\right)&#94;2},\\ \\text{s.t.}\\ \\boldsymbol D&#94;\\text{T}\\boldsymbol D=\\boldsymbol I_l$$ 考虑最简单的情况， \\(l=1\\) ，此时 \\(\\boldsymbol D\\) 退化成 \\(n\\times 1\\) 的向量 \\(\\boldsymbol d\\) ： $$\\begin{eqnarray} d&#94;\\ast &=& \\arg\\min_{\\boldsymbol d}\\sum_{i=1}&#94;m\\left\\|\\boldsymbol x&#94;{(i)}-\\boldsymbol {dd}&#94;\\text{T}\\boldsymbol x&#94;{(i)}\\right\\|_2&#94;2,\\ \\text{s.t.}\\ \\|\\boldsymbol d\\|_2=1 \\\\ &=& \\arg\\min_{\\boldsymbol d}\\sum_{i=1}&#94;m\\left\\|\\boldsymbol x&#94;{(i)}-\\boldsymbol {d}&#94;\\text{T}\\boldsymbol x&#94;{(i)}\\boldsymbol d\\right\\|_2&#94;2,\\ \\text{s.t.}\\ \\|\\boldsymbol d\\|_2=1\\ \\ (标量和向量乘积可交换) \\\\ &=& \\arg\\min_{\\boldsymbol d}\\sum_{i=1}&#94;m\\left\\|\\boldsymbol x&#94;{(i)}-\\boldsymbol x&#94;{(i)\\text{T}}\\boldsymbol {dd}\\right\\|_2&#94;2,\\ \\text{s.t.}\\ \\|\\boldsymbol d\\|_2=1\\ \\ (标量\\ a&#94;\\text{T}=a) \\\\ \\end{eqnarray}$$ 令 \\(\\boldsymbol X\\in\\mathbb{R}&#94;{m\\times n}\\) ，其中 \\(\\boldsymbol X_{i,:}=\\boldsymbol x&#94;{(i)\\text{T}}\\) ，则 $$\\begin{eqnarray} d&#94;\\ast &=&\\arg\\min_{\\boldsymbol d}\\left\\|\\boldsymbol X-\\boldsymbol {Xdd}&#94;\\text{T}\\right\\|_F&#94;2,\\ \\text{s.t.}\\ \\boldsymbol d&#94;\\text{T}\\boldsymbol d=1 \\\\ &=& \\arg\\min_{\\boldsymbol d}\\text{Tr}\\left(\\left(\\boldsymbol X-\\boldsymbol {Xdd}&#94;\\text{T}\\right)&#94;\\text{T}\\left(\\boldsymbol X-\\boldsymbol {Xdd}&#94;\\text{T}\\right)\\right),\\ \\text{s.t.}\\ \\boldsymbol d&#94;\\text{T}\\boldsymbol d=1 \\\\ &=& \\arg\\min_{\\boldsymbol d}-2\\text{Tr}\\left(\\boldsymbol X&#94;\\text{T}\\boldsymbol {Xdd}&#94;\\text{T}\\right)+\\text{Tr}\\left(\\boldsymbol {dd}&#94;\\text{T}\\boldsymbol X&#94;\\text{T}\\boldsymbol {Xdd}&#94;\\text{T}\\right),\\ \\text{s.t.}\\ \\boldsymbol d&#94;\\text{T}\\boldsymbol d=1 \\\\ &=& \\arg\\min_{\\boldsymbol d}-\\text{Tr}\\left(\\boldsymbol X&#94;\\text{T}\\boldsymbol {Xdd}&#94;\\text{T}\\right),\\ \\text{s.t.}\\ \\boldsymbol d&#94;\\text{T}\\boldsymbol d=1 \\\\ &=& \\arg\\max_{\\boldsymbol d}\\text{Tr}\\left(\\boldsymbol X&#94;\\text{T}\\boldsymbol {Xdd}&#94;\\text{T}\\right),\\ \\text{s.t.}\\ \\boldsymbol d&#94;\\text{T}\\boldsymbol d=1 \\\\ &=& \\arg\\max_{\\boldsymbol d}\\text{Tr}\\left(\\boldsymbol {d}&#94;\\text{T}\\boldsymbol X&#94;\\text{T}\\boldsymbol {Xd}\\right),\\ \\text{s.t.}\\ \\boldsymbol d&#94;\\text{T}\\boldsymbol d=1 \\\\ \\end{eqnarray}$$ 注意到 \\(\\boldsymbol X&#94;\\text{T}\\boldsymbol X\\) 是实对称矩阵，一定可以正交对角化，所以最优的 \\(\\boldsymbol d\\) 是 \\(\\boldsymbol X&#94;\\text{T}\\boldsymbol X\\) 最大特征值对应的特征\b向量。 以上推导特定于 \\(l=1\\) 的情况，仅得到了第一个主成分，更一般的，矩阵 \\(\\boldsymbol D\\) 由前 \\(l\\) 个最大的特征值对应的特征向量组成。 if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"读书笔记","url":"https://xutree.github.io/pages/2018/11/21/dl-2/"},{"title":"深度学习 第一章 引言","text":"让计算机从经验获取知识，可以避免由人类来给计算机形式化的指定它所需要的所有知识。层次化的概念让计算机构建较简单的概念来学习复杂概念。如果绘制出表示这些概念如何建立在彼此之上的图，我们得到一张\"深\"（层次很多）的图。基于这个原因，我们称这种方法为 AI 深度学习 （deep learning）。 人工智能的一个关键挑战是如何将非形式化的知识传达给计算机。 一些人工智能项目力求将关于世界的知识用形式化的语言进行硬编码（hard-code）。这就是众所周知的知识库（knowledge base）方法。 依靠硬编码的知识体系面临严重的缺陷，AI 系统需要具备自己获取知识的能力，即从原始数据中提取模式的能力。这种能力称为 机器学习 （machine learning）。 许多人工智能任务都可以通过以下方式解决：先提取一个合适的特征集，然后将这些特征提供给简单的机器学习算法。然而，对许多任务来说，我们很难知道应该提取哪些特征。解决这个问题的途径之一是使用机器学习来发掘表示本身，而不仅仅是把表示映射到输出。这种方法称之为 表示学习 （representation learning）。 表示学习算法的典型例子是 自编码器 （autoencoder）。自编码器由一个 编码器 （encoder）函数和一个 解码器 （decoder）函数组合而成。 显然，从原始数据中提取高层次、抽象的特征是非常困难的。许多诸如说话口音这样的 变差因素 （factors of vatiation），只能通过对数据进行复杂的、接近人类水平的理解来辨识。这几乎与获得原问题的表示一样困难，因此，乍一看，表示学习似乎并不能帮助我们。 深度学习 （deep learning）通过其他较简单的表示来表达复杂表示，解决了表达学习中的核心问题。","tags":"读书笔记","url":"https://xutree.github.io/pages/2018/11/21/dl-1/"},{"title":"似然函数","text":"似然函数 在数理统计学中，似然函数（likelihood function）是一种关于统计模型中的 参数 的函数，表示模型参数中的似然性。似然函数在统计推断中有重大作用，如在最大似然估计和费希尔信息之中的应用等等。\"似然性\"与\"或然性\"或\"概率\"意思相近，都是指某种事件发生的可能性，但是在统计学中，\"似然性\"和\"概率\"（或然性）又有明确的区分。概率用于在已知一些参数的情况下，预测接下来的观测所得到的结果，而似然性则是用于在已知某些观测所得到的结果时，对有关事物的性质的参数进行估计。 定义 对于离散和连续概率分布，似然函数总是被定义为参数 \\(\\theta\\) 的函数。 \\(\\blacksquare\\) 离散概率分布 设 \\(X\\) 是离散随机变量，概率质量函数 \\(p\\) 依赖于参数 \\(\\theta\\) 。那么函数 $${\\cal L}(\\theta|x)=p_\\theta(x)=p_\\theta(X=x)$$ 称为关于 \\(\\theta\\) 的似然函数。 \\(\\blacksquare\\) 连续概率分布 设 \\(X\\) 是连续随机变量，概率密度函数 \\(f\\) 依赖于参数 \\(\\theta\\) 。那么函数 $${\\cal L}(\\theta|x)=f_\\theta(x)$$ 称为关于 \\(\\theta\\) 的似然函数。 if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"基础知识","url":"https://xutree.github.io/pages/2018/11/16/likelihood-function/"},{"title":"xlwings 教程","text":"xlwings 是一个 python 包用来和 Excel 进行交互，它包含四个层次：App \\(\\rightarrow\\) Book \\(\\rightarrow\\) Sheet \\(\\rightarrow\\) Range。 App：用来索引打开的 Excel 实例。因为我们可能同时打开很多 Excel 应用程序，类似于我们可以在电脑是同时登陆多个 QQ 应用一样 Book：用来索引 Excel 实例中的工作簿，因为我们的 Excel 中可能用多个工作簿 Sheet：用来索引 Excel 工作簿中的表单，因为我们的工作簿中可能有多个表单 Range：用来所以表单中的单元格 1. 新建 xlsx 文件 新建 xlsx 文件经历如下几个步骤： \b首先建立一个 App 对象 \bapp = xw.App() ，这会打开电脑上的 Excel 应用程序 然后建立一个 Book 对象 book = xw.Book() 这会在第一步打开的 Excel 中建立一个工作簿 然后即可以保存 xlsx 文件， book.save('filename.xlsx') ，如果没有提供路径，则保存在程序当前目录 关闭 App 对象， app.quit() [ In 1 ]: import xlwings as xw [ In 2 ]: app = xw . App () [ In 3 ]: book = xw . Book () [ In 4 ]: book . save ( 'filename.xlsx' ) [ In 5 ]: app . quit () 2. 打开 xlsx 文件 执行 book = xw.Book('path//to//file') 会直接打开指定文件 [ In 1 ]: import xlwing as xw [ In 2 ]: book = xw . Book ( 'path//to//file' ) 3. 操作 xlsx 文件中的表单 3.1 获得 xlsx 文件中的表单数目 \bxlsx 文件中可能有多个表单，所以首先我们需要知道到底有多少个\b表单 [ In 1 ]: import xlwing as xw [ In 2 ]: book = xw . Book ( 'path//to//file' ) [ In 3 ]: book . sheets [ Out 3 ]: Sheets ([ < Sheet [ test . xlsx ] Sheet1 > , < Sheet [ test . xlsx ] Sheet2 > ]) 利用 book.sheets 我们得到了当前工作簿中所有的\b\b表单名称，当前工作簿有两个表单，名字分别为 Sheet1 、 Sheet2 。 3.2 索引需要的表单 知道了表单的名称和\b个数以后，我们就可以索引到我们想要的表单了，有\b四种索引方法，例如我们需要索引 Sheet2 ： sht2 = book.sheets[1] ，这种索引方法是 Python 的索引，表单的编号从 0 开始，故 Sheet2 的编号为 1 sht2 = book.sheets(2) ，这种索引方法是 Excel 的索引，\b表单编号从 1 开始，故 Sheet2 的编号为 2 sht2 = book.sheets['Sheet2'] ，这种\b索引方法是直接利用表单名字索引的 sht2 = book.sheets('Sheet2') ，这种\b索引方法也是直接利用表单名字索引的 4. \b操作表单中的单元格 4.1 索引单元格 所以单元格有如下方法： 索引单个单元格 sht2.range('B3') 或 sht2.range((3,2)) 指明是第三行第二列单元格 索引区域 sht2.range('B3:F6') 或 sht2.range((3,2),(6,6)) 4.2 操作单元格 4.2.1 超链接 sht2.range('B3:F6').add_hyperlink(address, text_to_display=None, screen_tip=None) 为区域内单元格添加超链接 sht2.range('B3').hyperlink 获取单元格的超链接， 只适用于单元格 4.2.2 列宽行高 sht2.range('B3:F6').autofit() \b自动调整区域内单元格的宽度和高度 sht2.range('B3:F6').columns.autofit() \b自动调整区域内单元格的宽度 sht2.range('B3:F6').rows.autofit() \b自动调整区域内单元格的高度 sht2.range('B3:F6').column_width 将返回区域内单元格的列宽（浮点数），单位是 point，如果列宽不一致，返回 None sht2.range('B3:F6').row_height 将返回区域内单元格的行高（浮点数），单位是 point，如果列宽不一致，返回 None sht2.range('B3:F6').column_width = 23 设置区域内单元格的列宽，范围必须为 [0, 255] sht2.range('B3:F6').row_height = 23 设置区域内单元格的行高（浮点数），范围必须是 [0, 409.5] sht2.range('B3:F6').height 返回区域单元格的总高度（浮点数），单位是 point sht2.range('B3:F6').width 返回区域单元格的总宽度（浮点数），单位是 point 4.2.3 格式和内容 sht2.range('B3:F6').value 获得区域内单元格\b的内容 sht2.range('B3:F6').value = ‘x'' 设置区域内单元格\b的内容 sht2.range('B3:F6').clear() 清除区域内单元格的内容和格式 sht2.range('B3:F6').clear_contents() 清除区域内单元格的内容，保留格式 4.2.4 获得区域字符串 sht2.range('B3:F6').address 将返回字符串 $B$3:$F$6' sht2.range('B3:F6').get_address(row_absolute=True, column_absolute=True, include_sheetname=False,\b external=False) 返回\b字符串，代表区域单元的地址，根据参数的不同可以用不同返回形式，具体参考 这里 4.2.5 单元格颜色 sht2.range('B3:F6').color 将返回区域内单元格的颜色，若区域内单元格颜色不一致，返回 (0,0,0)，若无颜色，返回空 sht2.range('B3:F6').color = (255, 0, 0) 设置区域内单元格的颜色 4.2.6 单元格数量 sht2.range('B3:F6').count 返回单元格的数量，也可用 sht2.range('B3:F6').size 4.2.7 区域单元格特殊\b位置 sht2.range('B3:F6').column 将返回区域内单元格第一列的\b索引（整数），本例返回 2 sht2.range('B3:F6').row 将返回区域内单元格第一行的\b索引（整数），本例返回 3 sht2.range('B3:F6').last_cell 返回一个 Range 对象，表\b示区域内最右下单元格的位置 sht2.range('B3:F6').top 返回一个浮点数，表示从 行 1 的上边界到此区域上边界的距离，单位是 point sht2.range('B3:F6').left 返回一个浮点数，表示从 A 栏的左边界到此区域左边界的距离，单位是 point sht2.range('B3:F6').columns 将返回一个 RangeColumns 对象，代表区域里的列，本例返回 RangeColumns(<Range [test.xlsx]Sheet2!$B$3:$F$6>) sht2.range('B3:F6').rows 将返回一个 RangeRows 对象，代表区域里的行，本例返回 RangeRows(<Range [test.xlsx]Sheet2!$B$3:$F$6>) 上面这两个对象都有一个 count 数据成员，可以很方便的得到总行数和列数。 sht2.range('B3:F6').current_region 返回一个 Range 对象\b，代表去除区域\b空白边界的范围\b，本类返回 <Range [test.xlsx]Sheet2!$A$1:$C$3> sht2.range('B3:F6').end(args) 参数 args 可为 left、right、up、down，该函数返回 Range 对象，表示指定区域\b近邻的边界单元格，如近邻的单元格无内容，则继续查找下一个近邻 sht2.range('B3:F6').expand(args) args 可为 table、down、right，该函数根据参数扩展当前区域范围，并范围 Range 对象，table 为向右向下扩展，若扩展方向下一个单元格内容为空，则停止扩展；若扩展后的区域仍为空，则返回 None （例如，从空的单元格往右扩展，但是右边一个单元格也是空的情况） 4.2.8 区域大小 sht2.range('B3:F6').resize(row_size=None, column_size=None) 重设区域大小 sht2.range('B3:F6').shape 返回元组，表示区域大小 4.2.9 区域名称和数字格式 sht2.range('B3:F6').name 返回区域\b的名字 sht2.range('B3:F6').name = 'test' 设置区域\b的名字为 test sht2.range('B3:F6').number_format 获得区域内数字的格式\b sht2.range('B3:F6').number_format = '0.00%' 设置区域内数字的格式 sht2.range('B3:F6').offset(row_offset=0, column_offset=0) 返回 Range 对象，代表偏移后的范围 sht2.range('B3:F6').options(convert=None, **options) 可设置数值转换规则等，具体见 这里 4.2.10 其他 sht2.range('B3:F6').raw_value 直接加载数据，不经过 xlwings 转换，对速度要求高的应用可以考虑这个选项 sht2.range('B3:F6').sheet 返回区域属于的表单 5. 操作表单中的形状 5.1 获取形状数量 [In 1]: sht2.shapes [Out 1]: Shapes([<Shape 'Isosceles Triangle 1' in <Sheet [test.xlsx]Sheet2>>]) [In 2]: sht2.shapes.count [Out 2]: 1 5.2 索引形状 有\b四种索引方法，例如我们需要索引 Isosceles Triangle 1 ： shp = sht2.shapes[0] ，这种索引方法是 Python 的索引，形状的编号从 0 开始 shp = sht2.shapes(1) ，这种索引方法是 Excel 的索引，\b形状编号从 1 开始 shp = sht2.shapes['Isosceles Triangle 1'\b] ，这种\b索引方法是直接利用形状名字索引的 shp = sht2.shapes['Isosceles Triangle 1') ，这种\b索引方法也是直接利用形状名字索引的 5.3 操作形状 shp.activate() 激活\b形状 shp.delete() 删除形状 shp.height 返回或设置形状的高度，单位是 point shp.width 返回或设置形状的宽度，单位是 point shp.top 返回或设置形状的水平位置，单位是 point shp.left 返回或设置形状的竖直位置，单位是 point shp.name 返回或设置形状的名字 shp.parent \b 返回形状的前驱 shp.type 返回形状的类型 6. 操作表单中的表格 6.1 获取表格数量 [In 1]: sht2.charts [Out 1]: Charts([<Chart 'Chart 2' in <Sheet [test.xlsx]Sheet2>>]) [In 2]: sht2.charts.count [Out 2]: 1 6.2 添加表格 利用 add(left=0, top=0, width=355, height=211) 函数： [ In 1 ]: import xlwings as xw [ In 2 ]: sht = xw . Book () . sheets [ 0 ] [ In 3 ]: sht . range ( 'A1' ) . value = [[ 'Foo1' , 'Foo2' ], [ 1 , 2 ]] [ In 4 ]: chart = sht2 . charts . add () [ In 5 ]: chart . set_source_data ( sht . range ( 'A1' ) . expand ()) [ In 6 ]: chart . chart_type = 'line' [ In 7 ]: chart . name [ Out 7 ]: 'Chart1' 6.3 索引表格 有\b四种索引方法，例如我们需要索引 Chart 2 ： cha = sht2.charts[0] ，这种索引方法是 Python 的索引，表格的编号从 0 开始 cha = sht2.charts(1) ，这种索引方法是 Excel 的索引，\b表格编号从 1 开始 cha = sht2.charts['Chart 2'\b] ，这种\b索引方法是直接利用表格名字索引的 cha = sht2.charts['Chart 2') ，这种\b索引方法也是直接利用表格名字索引的 6.4 操作表格 cha.delete() 删除表格 cha.height 返回或设置表格的高度，单位是 point cha.width 返回或设置表格的宽度，单位是 point cha.top 返回或设置表格的水平位置，单位是 point cha.left 返回或设置表格的竖直位置，单位是 point cha.name 返回或设置表格的名字 cha.parent \b 返回表格的前驱 cha.chart_type 返回表格的类型 cha.set_source_data(args) 设置表格\b的数据来源， args 为 Range 对象 7. 操作表单中的图像 7.1 获取图像数量 [In 1]: sht2.pictures [Out 1]: Charts([<Chart 'Chart 2' in <Sheet [test.xlsx]Sheet2>>]) [In 2]: sht2.pictures.count [Out 2]: 1 7.2 添加图像 利用\b add(image, link_to_file=False, save_with_document=True, left=0, top=0, width=None, height=None, name=None, update=False) 函数，第一参数可以是计算机中图像的路径（字符串）或者是 Matplotlib 对象： [ In 1 ]: import xlwings as xw [ In 2 ]: sht = xw . Book () . sheets [ 0 ] [ In 3 ]: sht . pictures . add ( 'path//to//file' ) 或者 [ In 1 ]: import matplotlib.pyplot as plt [ In 2 ]: fig = plt . figure () [ In 3 ]: plt . plot ([ 1 , 2 , 3 , 4 , 5 ]) [ In 4 ]: sht . pictures . add ( fig , name = 'MyPlot' , update = True ) 7.3 索引图像 有\b四种索引方法，例如我们需要索引 Picture 1 ： pic = sht2.pictures[0] ，这种索引方法是 Python 的索引，图像的编号从 0 开始 pic = sht2.pictures(1) ，这种索引方法是 Excel 的索引，\b图像编号从 1 开始 pic = sht2.pictures['Picture 1'\b] ，这种\b索引方法是直接利用图像名字索引的 pic = sht2.pictures['Picture 1') ，这种\b索引方法也是直接利用图像名字索引的 7.4 操作图像 pic.delete() 删除图像 pic.height 返回或设置图像的高度，单位是 point pic.width 返回或设置图像的宽度，单位是 point pic.top 返回或设置图像的水平位置，单位是 point pic.left 返回或设置图像的竖直位置，单位是 point pic.name 返回或设置图像的名字 pic.parent \b 返回图\b像的前驱 pic.update(image) 用新的图像替换当前图像，图像属性不变 if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"教程","url":"https://xutree.github.io/pages/2018/11/12/tutorial/"},{"title":"方向导数和梯度","text":"1. 方向导数 多元函数的偏导数反映了函数值沿着坐标轴方向的变化率，方向导数（directional derivative）则表示多元函数沿着某一方向的变化率。 定义 1.1（方向导数）设 \\(f\\) 是定义于 \\(\\mathbb{R}&#94;n\\) 中某区域 \\(D\\) 上的函数，点 \\(P_0\\in D\\) ， \\(l\\) 为一给定的非零向量， \\(P\\) 为一动点，向量 \\(\\vec{P_0P}\\) 与 \\(l\\) 的方向始终一致。如果极限 $$\\lim_{\\|P_0P\\|\\to0}\\frac{f(P)-f(P_0}{\\|\\vec{P_0P}\\|}$$ 存在，则称此极限为函数 \\(f\\) 在 \\(P_0\\) 处沿 \\(l\\) 方向的方向导数，记作 \\(\\frac{\\partial f}{\\partial l}\\) 。 定义 1.2（方向余弦）设 \\(l\\) 是一个 \\(n\\) 维非零向量， \\(l_0=\\frac{l}{\\|l\\|}\\) ，即 \\(l_0\\) 是与 \\(l\\) 同向的单位向量。取 \\(0\\leq\\alpha_i\\leq\\pi\\) ，使 $$l_0=(\\cos\\alpha_1,\\cos\\alpha_2,\\cdots,\\cos\\alpha_n)$$ 称 $$\\cos\\alpha_1,\\cos\\alpha_2,\\cdots,\\cos\\alpha_n$$ 为向量 \\(l\\) 的方向余弦。 定理 1.1（方向导数计算公式）若函数 \\(f\\) 在点 \\(P_0\\) 处可微，向量 \\(l\\) 的方向余弦为 \\(\\cos\\alpha_1,\\cos\\alpha_2,\\cdots,\\cos\\alpha_n\\) ，则函数 \\(f\\) 在点 \\(P_0\\) 处沿 \\(l\\) 方向的方向导数存在，且 $$\\frac{\\partial f}{\\partial l}\\bigg\\rvert_{P_0}=\\frac{\\partial f}{\\partial x_1}\\bigg\\rvert_{P_0}\\cos\\alpha_1+\\frac{\\partial f}{\\partial x_2}\\bigg\\rvert_{P_0}\\cos\\alpha_2+\\cdots+\\frac{\\partial f}{\\partial x_n}\\bigg\\rvert_{P_0}\\cos\\alpha_n$$ 证：因为 \\(f\\) 在 \\(P_0\\) 处可微，向量 \\(\\vec{P_0P}=(\\Delta x_1,\\Delta x_2,\\cdots,\\Delta x_n)\\) 与 \\(l\\) 同向，故 $$f(P)-f(P_0)=\\frac{\\partial f}{\\partial x_1}\\bigg\\rvert_{P_0}\\Delta x_1+\\frac{\\partial f}{\\partial x_2}\\bigg\\rvert_{P_0}\\Delta x_2+\\cdots+\\frac{\\partial f}{\\partial x_n}\\bigg\\rvert_{P_0}\\Delta x_n+o(\\|\\vec{P_0P}\\|)$$ 故 $$\\lim_{\\|\\vec{P_0P}\\|\\to0}\\frac{f(P)-f(P_0)}{\\|\\vec{P_0P}\\|}=\\lim_{\\|\\vec{P_0P}\\|\\to0}\\left[\\frac{\\partial f}{\\partial x_1}\\bigg\\rvert_{P_0}\\frac{\\Delta x_1}{\\|\\vec{P_0P}\\|}+\\frac{\\partial f}{\\partial x_2}\\bigg\\rvert_{P_0}\\frac{\\Delta x_2}{\\|\\vec{P_0P}\\|}+\\cdots+\\frac{\\partial f}{\\partial x_n}\\bigg\\rvert_{P_0}\\frac{\\Delta x_n}{\\|\\vec{P_0P}\\|}+\\frac{o(\\|\\vec{P_0P}\\|)}{\\|\\vec{P_0P}\\|}\\right] \\\\ =\\frac{\\partial f}{\\partial x_1}\\bigg\\rvert_{P_0}\\cos\\alpha_1+\\frac{\\partial f}{\\partial x_2}\\bigg\\rvert_{P_0}\\cos\\alpha_2+\\cdots+\\frac{\\partial f}{\\partial x_n}\\bigg\\rvert_{P_0}\\cos\\alpha_n$$ 因为 \\(\\frac{\\partial f}{\\partial l}\\bigg\\rvert_{P_0}\\) 存在，所以 $$\\frac{\\partial f}{\\partial l}\\bigg\\rvert_{P_0}=\\frac{\\partial f}{\\partial x_1}\\bigg\\rvert_{P_0}\\cos\\alpha_1+\\frac{\\partial f}{\\partial x_2}\\bigg\\rvert_{P_0}\\cos\\alpha_2+\\cdots+\\frac{\\partial f}{\\partial x_n}\\bigg\\rvert_{P_0}\\cos\\alpha_n$$ 注意：一个函数即使在某一点处连续，可偏导，且沿所有方向的方向导 数都存在，也不一定在该点可微。所以定义中的可微条件是必须的。 2. 梯\b度 设函数 \\(f\\) 定义于 \\(\\mathbb{R}&#94;n\\) 的区域 \\(D\\) 上，或者说 \\(f\\) 是区域 \\(D\\) 上的一个数量场。我们的问题是在点 \\(P\\in D\\) 处 \\(f\\) 的方向导数沿哪个方向取得最大值，即沿哪个方向数量场的变化率最大？\b这就是梯度（gradient）问题。 如果向量 \\(l\\) 的方向余弦为 $$\\cos\\alpha_1,\\cos\\alpha_2,\\cdots,\\cos\\alpha_n$$ 那么 \\(f\\) 在点 \\(P\\) 处沿 \\(l\\) 方向的方向导数为 $$\\frac{\\partial f}{\\partial l}=\\frac{\\partial f}{\\partial x_1}\\cos\\alpha_1+\\cdots+\\frac{\\partial f}{\\partial x_n}\\cos\\alpha_n$$ 记 \\(n\\) 维\b向量 $$\\boldsymbol{g}=\\left(\\frac{\\partial f}{\\partial x_1},\\cdots,\\frac{\\partial f}{\\partial x_n}\\right)$$ 又记 \\(l\\) 方向的单位向量为 \\(\\boldsymbol{l_0}\\) ，则 $$\\boldsymbol{l_0}=\\left(\\cos\\alpha_1,\\cdots,\\cos\\alpha_n\\right)$$ 故 $$\\frac{\\partial f}{\\partial l}=(\\boldsymbol{g},\\boldsymbol{l_0})$$ 上式右端表示向量内积，由施瓦兹不等式 $$\\left|\\frac{\\partial f}{\\partial l}\\right|=|(\\boldsymbol{g},\\boldsymbol{l_0})|\\leq\\|\\boldsymbol{g}\\|\\|\\boldsymbol{l_0}\\|=\\|\\boldsymbol{g}\\|$$ 当且仅当 \\(\\boldsymbol{g}\\) 与 \\(\\boldsymbol{l_0}\\) 同向时，等号成立。而且 $$\\max\\frac{\\partial f}{\\partial l}=\\|\\boldsymbol{g}\\|=\\left[\\sum_{i=1}&#94;n\\left(\\frac{\\partial f}{\\partial x_i}\\right)&#94;2\\right]&#94;{\\frac{1}{2}}$$ 定义 2.1（梯度）设 \\(f\\) 是 \\(\\mathbb{R}&#94;n\\) 中区域 \\(D\\) 上的数量场，如果 \\(f\\) 在 \\(P_0\\in D\\) 处可微，称向量 $$\\left(\\frac{\\partial f}{\\partial x_1},\\frac{\\partial f}{\\partial x_2},\\cdots,\\frac{\\partial f}{\\partial x_n}\\right)\\bigg\\rvert_{P_0}$$ 为 \\(f\\) 在 \\(P_0\\) 处的梯度，记作 \\({\\bf grad}f(P_0)\\) 。 沿梯度方向，函数值增加最快。同样可知，方向导数的最小值在梯度的相反方向取得。 if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"基础知识","url":"https://xutree.github.io/pages/2018/11/10/directional_derivative-gradient/"},{"title":"拉格朗日对偶性","text":"1. 原始问题 假设 \\(f(x)\\) ， \\(c_i(x)\\) ， \\(h_j(x)\\) 是定义在 \\(\\mathbb{R}&#94;n\\) 上的连续可微函数。考虑约束最优化问题： $$\\min_{x\\in\\mathbb{R}&#94;n}f(x) \\\\ \\text{s.t.}\\ \\ \\ \\ \\ \\begin{eqnarray} c_i(x) &\\leq& 0,i=1,2,\\cdots,k \\\\ h_j(x) &=& 0,j=1,2,\\cdots,l \\end{eqnarray}$$ 称此优化约束问题为\b原始最优化问题或原始问题。 首先，引进广义拉格朗日函数： $$L(x,\\alpha,\\beta)=f(x)+\\sum_{i=1}&#94;k\\alpha_ic_i(x)+\\sum_{j=1}&#94;l\\beta_jh_j(x)$$ 这里， \\(x=\\left(x&#94;{(1)},x&#94;{(2)},\\cdots,x&#94;{(n)}\\right)&#94;\\text{T}\\in\\mathbb{R}&#94;n\\) ， \\(\\alpha_i\\) ， \\(\\beta_j\\) 是拉格朗日乘子， \\(\\alpha_i\\geq0\\) ，考虑 \\(x\\) 的函数： $$\\theta_P(x)=\\max_{\\alpha,\\beta:\\alpha\\geq0}L(x,\\alpha,\\beta)$$ 这里，下标 \\(P\\) 表示原始问题。 易知： $$\\theta_P(x)=\\begin{cases} f(x), & x\\ 满足原始问题约束 \\\\ +\\infty, & 其他 \\end{cases}$$ 所以如果考虑极小化问题 $$\\min_x\\theta_P(x)=\\min_x\\max_{\\alpha,\\beta:\\alpha_i\\geq0}L(x,\\alpha,\\beta)$$ 它是与原始最优化问题等价的问题。 为了方便，定义原始问题的最优值 $$p&#94;{\\star}=\\min_x\\theta_P(x)$$ 称为原始问题的值。 2. 对偶问题 定义 $$\\theta_D(\\alpha,\\beta)=\\min_xL(x,\\alpha,\\beta)$$ 再考虑极大化，即 $$\\max_{\\alpha,\\beta:\\alpha_i\\geq0}\\theta_D(\\alpha,\\beta)=\\max_{\\alpha,\\beta:\\alpha_i\\geq0}\\min_xL(x,\\alpha,\\beta)$$ 上述问题称为广义拉格朗日函数的极大极小问题。 可以将广义拉格朗日函数的极大极小问题表示为\b约束最优化问题： $$\\max_{\\alpha,\\beta}\\theta_D(\\alpha,\\beta)=\\max_{\\alpha,\\beta}\\min_xL(x,\\alpha,\\beta) \\\\ \\text{s.t.}\\ \\ \\ \\alpha_i\\geq0,i=1,2,\\cdots,k$$ 称为原始问题的对偶问题。定义对偶问题的最优值： $$d&#94;\\star=\\max_{\\alpha,\\beta:\\alpha_i\\geq0}\\theta_D(\\alpha,\\beta)$$ 称为对偶问题的值。 3. 原始问题和对偶问题的关系 定理 1 若原始问题和对偶问题都有最优值，则 $$d&#94;\\star=\\max_{\\alpha,\\beta:\\alpha_i\\geq0}\\min_xL(x,\\alpha,\\beta)\\leq\\min_x\\max_{\\alpha,\\beta:\\alpha_i\\geq0}L(x,\\alpha,\\beta)=p&#94;\\star$$ 推论 1 设 \\(x&#94;\\star\\) 是原始问题的可行解， \\(\\alpha&#94;\\star\\) ， \\(\\beta&#94;\\star\\) 是对偶问题的可行解，并且 \\(d&#94;\\star=p&#94;\\star\\) ，则它们分别是原始问题和对偶问题的最优解。 \b 定理 2 考虑原始问题和对偶问题。\b假设函数 \\(f(x)\\) 和 \\(c_i(x)\\) 是凸函数， \\(h_j(x)\\) 是仿射函数；并且假设不等式约束 \\(c_i(x)\\) 是严格可行的，即存在 \\(x\\) ，对所有 \\(i\\) ，有 \\(c_i<0\\) ，则存在 \\(x&#94;\\star\\) ， \\(\\alpha&#94;\\star\\) ， \\(\\beta&#94;\\star\\) ，使 \\(x&#94;\\star\\) 是原始问题的解， \\(\\alpha&#94;\\star\\) ， \\(\\beta&#94;\\star\\) 是对偶问题的解，并且 $$p&#94;\\star=d&#94;\\star=L(x&#94;\\star,\\alpha&#94;\\star,\\beta&#94;\\star)$$ 定理 3 对原始问题和对偶问题，假设函数 \\(f(x)\\) 和 \\(c_i(x)\\) 是凸函数， \\(h_j(x)\\) 是仿射函数，并且假设不等式约束 \\(c_i(x)\\) 是严格可行的，则 \\(x&#94;\\star\\) ， \\(\\alpha&#94;\\star\\) ， \\(\\beta&#94;\\star\\) 分别是原始问题和对偶问题的解的充要条件是 \\(x&#94;\\star\\) ， \\(\\alpha&#94;\\star\\) ， \\(\\beta&#94;\\star\\) 满足下面的 Karush-Kuhn-Tucker（KKT）条件 $$\\nabla_xL(x&#94;\\star,\\alpha&#94;\\star,\\beta&#94;\\star)=0 \\\\ \\alpha_i&#94;\\star c_i(x&#94;\\star)=0,i=1,2,\\cdots,k \\\\ c_i(x&#94;\\star)\\leq0,i=1,2,\\cdots,k \\\\ \\alpha_i&#94;\\star\\geq0,i=1,2,\\cdots,k \\\\ h_j(x&#94;\\star)=0,j=1,2,\\cdots,l$$ if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"基础知\b识","url":"https://xutree.github.io/pages/2018/11/10/lagrange_duality/"},{"title":"Python argparse 模块","text":"argparse 是 Python 标准库中推荐的命令行解析模块。 # 导入 import argparse # 添加帮助信息的整体描述 parser = argparse . ArgumentParser ( description = \"calculate X to the power of Y\" ) # 冲突选项 group = parser . add_mutually_exclusive_group () # 以下两个参数是冲突的，只能存在一个 group . add_argument ( \"-v\" , \"--verbose\" , action = \"store_true\" ) group . add_argument ( \"-q\" , \"--quiet\" , action = \"store_true\" ) # 一个 - 是简写，-- 是全写，action 表示默认参数为 true # 添加位置参数 parser . add_argument ( \"x\" , type = int , help = \"the base\" ) parser . add_argument ( \"y\" , type = int , help = \"the exponent\" ) # 获得参数 args = parser . parse_args () # 使用参数 answer = args . x ** args . y if args . quiet : print ( answer ) elif args . verbose : print ( \"{} to the power {} equals {}\" . format ( args . x , args . y , answer )) else : print ( \"{}&#94;{} == {}\" . format ( args . x , args . y , answer )) 输出 usage : prog . py [- h ] [- v | - q ] x y calculate X to the power of Y positional arguments : x the base y the exponent optional arguments : - h , -- help show this help message and exit - v , -- verbose - q , -- quiet 另外还有一个 parse_known_args() 函数，在接受多于程序需要的参数时保证不出错，返回一个 tuple 类型的命名空间和一个保存着余下的命令行字符的 list 。 import argparse parser = argparse . ArgumentParser () parser . add_argument ( '--flag_int' , type = float , default = 0.01 , help = 'flag_int.' ) FLAGS , unparsed = parser . parse_known_args () print ( FLAGS ) print ( unparsed ) 输出 [In 1]: python prog.py --flag_int 0.02 --double 0.03 a 1 [Out 1]: Namespace(flag_int=0.02) ['--double', '0.03', 'a', '1']","tags":"教程","url":"https://xutree.github.io/pages/2018/11/10/args/"},{"title":"贝叶斯定理","text":"贝叶斯定理是关于随机事件 \\(A\\) 和 \\(B\\) 的条件概率的一则定理。 $$P(A|B)=\\frac{P(A)\\times P(B|A)}{P(B)}$$ 其中 \\(P(A|B)\\) 是指在事件 \\(B\\) 发生的情况下事件 \\(A\\) 发生的概率。 在贝叶斯定理中，每个名词都有约定俗成的名称： \\(P(A|B)\\) 是已知 \\(B\\) 发生后 \\(A\\) 的条件概率，也由于得自 \\(B\\) 的取值而被称作 \\(A\\) 的后验概率 \\(P(A)\\) 是 \\(A\\) 的先验概率（或边缘概率），之所以称为\"先验\"是因为它不考虑任何 \\(B\\) 方面的因素 \\(P(B|A)\\) 是已知 \\(A\\) 发生后 \\(B\\) 的条件概率，也由于得自 \\(A\\) 的取值而被称作 \\(B\\) 的后验概率 \\(P(B)\\) 是 \\(B\\) 的先验概率或边缘概率 1. 推导 根据条件概率的定义。在事件 \\(B\\) 发生的条件下事件A发生的概率是 $$P(A|B)={\\frac {P(A\\cap B)}{P(B)}}$$ 其中 \\(A\\) 与 \\(B\\) 的联合概率表示为 \\(P(A\\cap B)\\) 或者 \\(P(A,B)\\) 或者 \\(P(AB)\\) 。 同样地，在事件 \\(A\\) 发生的条件下事件 \\(B\\) 发生的概率 $$P(B|A)={\\frac {P(A\\cap B)}{P(A)}}$$ 整理与合并这两个方程式，我们可以得到 $$P(A|B)\\,P(B)=P(A\\cap B)=P(B|A)P(A)$$ 这个引理有时称作概率乘法规则。上式两边同除以 \\(P(B)\\) ，若 \\(P(B)\\) 是非零的，我们可以得到贝叶斯定理 $$P(A|B)=\\frac{P(B|A)P(A)}{P(B)}$$ 2. 其他形式 $$P(A|B)={\\frac {P(B|A)\\,P(A)}{P(B|A)P(A)+P(B|A&#94;{C})P(A&#94;{C})}}$$ 其中 \\(A&#94;C\\) 是 \\(A\\) 的补集（即非 \\(A\\) ），因为 $$P(B)=P(A,B)+P(A&#94;{C},B)=P(B|A)P(A)+P(B|A&#94;{C})P(A&#94;{C})$$ 在更一般化的情况，假设 \\(A_i\\) 是事件集合里的部分集合，对于任意的 \\(A_i\\) ，贝叶斯定理可用下式表示 $$P(A_{i}|B)={\\frac {P(B|A_{i})\\,P(A_{i})}{\\sum_{j}P(B|A_{j})\\,P(A_{j})}}$$ if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"基础知识","url":"https://xutree.github.io/pages/2018/11/05/bayes/"},{"title":"指示器随机变量","text":"指示器随机变量为概率和期望之间的转换提供了一个便利的方法。给定一个样本空间 \\(S\\) 和一个事件 \\(A\\) ，那么事件 \\(A\\) 对应的 指示器随机变量 \\(I\\{A\\}\\) 定义为： $$\\text{I}\\{A\\}=\\cases{ 1 & 如果 A 发生 \\\\ 0 & 如果 A 不发生 }$$ 指示器随机变量有如下性质： $$\\text{E}[X_A]=\\text{Pr}\\{A\\}$$ 就是说，指示器随机变量的期望等于它所指示事件发生的概率，指示器随机变量在分析重复随机试验时很有用。 例题1 ：连续抛硬币 \\(n\\) 次，求正面出现次数的期望。 解答 ：设指示器随机变量 \\(X_i\\) 对应第 \\(i\\) 次抛硬币时正面朝上的事件。设随机变量 \\(X\\) 表示 \\(n\\) 次抛硬币中出现正面的总次数，则： $$X=\\sum_{i=1}&#94;nX_i$$ 对上式取期望： $$\\text{E}[X]=\\text{E}\\left[\\sum_{i=1}&#94;nX_i\\right]=\\sum_{i=1}&#94;n\\text{E}[X_i]=\\sum_{i=1}&#94;n1/2=n/2$$ 例题2 ：雇佣问题。计算雇佣一个新的办公助理的期望次数。 解答 ：设指示器随机变量 \\(X_i\\) 对应第 \\(i\\) 个应聘者被雇用的事件。设随机变量 \\(X\\) 表示 雇用一个新办公助理的次数，则： $$X_i=\\text{I}\\{应聘者\\ i\\ 被雇用\\}=\\cases{ 1 & 如果应聘者 i 被雇用 \\\\ 0 & 如果应聘者 i 不被雇用 }$$ 以及： $$X=\\sum_{i=1}&#94;nX_i$$ 容易得到： $$\\text{E}[X_i]=\\frac{\\text{A}_{n-1}&#94;{n-1}}{\\text{A}_n&#94;n}=\\frac{1}{n}$$ 故： $$\\text{E}[X]=\\text{E}\\left[\\sum_{i=1}&#94;nX_i\\right]=\\sum_{i=1}&#94;n\\text{E}[X_i]=\\sum_{i=1}&#94;n1/i=\\ln n+O(1)$$ 例题3 ： \\(n\\) 位顾客，他们每个人给餐厅核对帽子的服务生一顶帽子。服务生以随机顺序将帽子归还给顾客，求拿到自己帽子的客户的期望数。 解答 ：设指示器随机变量 \\(X_i\\) 对应第 \\(i\\) 个顾客拿到自己帽子的事件。设随机变量 \\(X\\) 表示拿到自己帽子的客户的期望数，则： $$X_i=\\text{I}\\{第\\ i\\ 个顾客拿到自己的帽子\\}=\\cases{ 1 & 如果第 i 个顾客拿到自己的帽子 \\\\ 0 & 如果第 i 个顾客没有拿到自己的帽子 }$$ 以及： $$X=\\sum_{i=1}&#94;nX_i$$ 容易得到： 故： $$\\text{E}[X]=\\text{E}\\left[\\sum_{i=1}&#94;nX_i\\right]=\\sum_{i=1}&#94;n\\text{E}[X_i]=\\sum_{i=1}&#94;n1/n=1$$ 例题4 ：设 \\(A[1\\dots n]\\) 是由 \\(n\\) 个不同数构成的数列。如果 \\(i<j\\) 且 \\(A[i]>A[j]\\) ，则称 \\((i,j)\\) 对为 \\(A\\) 的一个逆序对。假设 \\(A\\) 的元素构成 \\(<1,2,\\dots,n>\\) 上的一个均匀分布。求其中逆序对数目的期望。 解答 ：设指示器随机变量 \\(X_{ij}\\) 对应 \\((i,j)\\) 为逆序对的事件。则： $$X_{ij}=\\text{I}\\{A[i]>A[j], \\text{for}\\ 1\\leq i<j\\leq n\\}$$ 容易得到： $$\\text{E}[X_{ij}]=\\text{Pr}\\{X_{ij}=1\\}=1/2$$ 设随机变量 \\(X\\) 表示逆序对总数目，则： $$X=\\sum_{i=1}&#94;{n-1}\\sum_{j=i+1}&#94;nX_{ij}$$ 故： $$\\text{E}[X]=\\text{E}\\left[\\sum_{i=1}&#94;{n-1}\\sum_{j=i+1}&#94;nX_{ij}\\right]=\\sum_{i=1}&#94;{n-1}\\sum_{j=i+1}&#94;n\\text{E}[X_{ij}]=\\sum_{i=1}&#94;{n-1}\\sum_{j=i+1}&#94;n1/2\\\\=\\frac{1}{2}\\text{C}_n&#94;2=\\frac{n(n-1)}{4}$$ 例题5 ：一个骰子，6面，1个面是 1， 2个面是2， 3个面是3， 问平均掷多少次能使1,2,3都至少出现一次？ 解答 ： 设指示器随机变量 \\(X_{i}\\) ，对应\"前i次掷骰子，1，2，3没能都至少出现一次\"的事件，其值为1表示\"前n次掷骰子，1，2，3没能都至少出现一次\"的事件，其值为0表示这个事件没有发生，即\"前n次掷骰子，1，2，3各至少出现一次\"。 设随机变量 \\(X\\) 表示1，2，3刚好全部出现过需要的投掷次数。 $$X=\\sum_0&#94;{\\infty}X_i$$ 说明一下，等式两边都是随机变量，假设对于某个随机实例（例如，这里指一次具体的投掷序列），其对应事件是：\"投了 \\(K\\) 次恰好1，2，3都出现了\"，于是等式左边显然等于 \\(K\\) ；而等式右边，对于 \\(n < K\\) ，由于这些项的对应定义事件发生了（即1，2，3没能出现），所以他们的实例值是1，而对于 \\(n\\geq K\\) ，则由于对应定义事件都没发生，实例值为0，可见这个和也是 \\(K\\) 。故两侧相等。（为了达到这个相等关系，可以看出需要把 \\(X_0\\) 包含在内的必要性）。 值得注意的是，对 \\(n < 3\\) ， \\(X_n\\) 显然恒为1。而对于 \\(n\\geq 3\\) ，这些随机变量不是独立的。他们的相关性是不容易求出的，唯一容易知道的是，当序列中一个项为0时，其后的项均为0。好在对于这题我们不需要担忧这个相关性。 下面求 \\(\\text{E}[X_i]\\) ，由于 \\(X_i\\) 考虑的是 \\(i\\) 次投掷三者没有全部出现，于是就是其中两者出现或仅一者出现。假设单次投掷1，2和3出现的概率分别为： \\(p1\\) ， \\(p2\\) 和 \\(p3\\) 。于是 \\((p1+p2)&#94;i\\) 表示 \\(i\\) 次投掷只出现1或2的概率，这其中包括了出现全1和全2的情形，于是求 \\(\\text{Pr}\\{X_{i}=1\\}\\) 可由这样的项求和并剔除重复计算的单面值情形： $$\\text{Pr}\\{X_{i}=1\\}=\\cases{ (p1+p2)&#94;i+(p1+p3)&#94;i+(p2+p3)&#94;i-p1&#94;i-p2&#94;i-p3&#94;i & i>0\\\\ 0 & i=0}$$ 故： $$\\text{E}[X]=\\text{E}\\left[\\sum_{i=0}&#94;{\\infty}X_i\\right]=\\sum_{i=0}&#94;{\\infty}\\text{E}[X_i]=\\sum_{i=0}&#94;{\\infty}\\text{Pr}\\{X_{i}=1\\}\\\\ =1+\\frac{1-p3}{p3}+\\frac{1-p2}{p2}+\\frac{1-p1}{p1}-\\frac{p1}{1-p1}-\\frac{p2}{1-p2}-\\frac{p3}{1-p3}\\\\ =7.3$$ if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"其他","url":"https://xutree.github.io/pages/2018/10/28/指示器随机变量/"},{"title":"最大子数组问题","text":"寻找数组中和最大的非空连续子数组。 1. 暴力求解 先找出从第1个元素开始的最大子数组，而后再从第2个元素开始找出从第2个元素开始的最大子数组，依次类推，比较得出最大的子数组。 时间复杂度 \\(O(n&#94;2)\\) 。 #include <tuple> typedef std :: tuple < int , int , int > array_info_message ; array_info_message find_max_subarray ( int a [], int len ) { int i , j ; int sum = 0 ; int max_left , max_right ; //每次开始累加的起始位置的循环 for ( i = 0 ; i < len ; i ++ ) { max_left = i ; int temp = 0 ; //向后累加的循环 for ( j = i ; j < len ; j ++ ) { temp += a [ j ]; if ( temp > sum ) { sum = temp ; max_right = j ; } } } return std :: make_tuple ( max_left , max_right , sum ); } 2. 分治算法 时间复杂度 \\(O(nlgn)\\) 。 #include <limits> #include <tuple> typedef std :: tuple < int , int , int > array_info_message ; void find_max_cross_subarray ( int a [], int low , int mid , int high ) { int left_sum = std :: numeric_limits < int >:: min (); int right_sum = std :: numeric_limits < int >:: min (); int sum = 0 ; int max_left = mid ; int max_right = mid ; for ( int i = mid ; i >= low ; -- i ) { sum += a [ i ]; if ( left_sum < sum ) { left_sum = sum ; max_left = i ; } } sum = 0 ; for ( int i = mid + 1 ; i <= high ; ++ i ) { sum += a [ i ]; if ( right_sum < sum ) { right_sum = sum ; max_right = i ; } } return std :: make_tuple ( max_left , max_right , left_sum + right_sum ); } array_info_message find_max_subarray ( int a [], int low , int high ) { array_info_message r1 , r2 , r3 ; if ( low == high ) return std :: make_tuple ( low , high , a [ low ]); else { // 第一次这里处理成减号了，找了半天 bug int mid = static_cast < int > (( high + low ) / 2 ); r1 = find_max_subarray ( a , low , mid ); r2 = find_max_subarray ( a , mid + 1 , high ); r3 = find_max_cross_subarray ( a , low , mid , high ); if ( std :: get < 2 > ( r1 ) >= std :: get < 2 > ( r2 ) && std :: get < 2 > ( r1 ) >= std :: get < 2 > ( r3 )) return r1 ; if (( std :: get < 2 > ( r2 ) >= std :: get < 2 > ( r1 ) && std :: get < 2 > ( r2 ) >= std :: get < 2 > ( r3 ))) return r2 ; if (( std :: get < 2 > ( r3 ) >= std :: get < 2 > ( r1 ) && std :: get < 2 > ( r3 ) >= std :: get < 2 > ( r2 ))) return r3 ; } return std :: make_tuple ( 0 , 0 , 0 ); } 3. 动态规划：Kadane 算法 Kadane 算法扫描一次整个数列的所有数值，在每一个扫描点计算以该点数值为结束点的子数列的最大和（正数和）。该子数列由两部分组成：以前一个位置为结束点的最大子数列、该位置的数值。因为该算法用到了\"最佳子结构\"（以每个位置为终点的最大子数列都是基于其前一位置的最大子数列计算得出）。 Kadane 算法时间复杂度为 \\(O(n)\\) ，空间复杂度为 \\(O(1)\\) 。 array_info_message find_max_subarray ( int a [] , int n ) { void maxSubArray(int a [] , int n) { int max = std : : numeric_limits < int >:: min (); int sum = 0 ; int left = 0, right = 0, max_left = 0, max_right = 0 ; for (int i = 0 ; i < n ; i++) { if (sum + a [ i ] > a [ i ] ) { sum = sum + a [ i ] ; right = i ; } else { sum = a [ i ] ; left = i ; right = i ; } if ( sum > max ) { max = sum ; max_left = left ; max_right = right ; } } return std :: make_tuple ( max_left , max_right , max ); } 若我们只需要求最大和，则有如下简洁解法： int find_max_subarray ( int a [] , int n ) { int max = std : : numeric_limits < int >:: min (); int sum = 0 ; for (int i = 0 ; i < n ; i++) { sum = sum + a [ i ] > a [ i ] ? sum + a [ i ] : a [ i ] ; max = sum > max ? sum : max ; } return max ; } if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"读书笔记","url":"https://xutree.github.io/pages/2018/10/27/find_maximum_subarray/"},{"title":"排序算法","text":"1. 插入排序 插入排序（英语：Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用 in-place 排序（即只需用到 \\(O(1)\\) 的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。 void insertion_sort ( int arr [] , int len ) { int i, j ; for (i = 1 ; i < len ; i++) { for (j = i - 1 ; j >= 0 && a [ j ] > arr [ j + 1 ] ; j--) { std : : swap ( a [ j ] , a [ j + 1 ] ); } } } 如果目标是把 \\(n\\) 个元素的序列升序排列，那么采用插入排序存在最好情况和最坏情况。最好情况就是，序列已经是升序排列了，在这种情况下，需要进行的比较操作需 \\(n-1\\) 次即可。最坏情况就是，序列是降序排列，那么此时需要进行的比较共有 \\(\\frac {1}{2}n(n-1)\\) 次。插入排序的赋值操作是比较操作的次数减去 \\(n-1\\) 次，（因为 \\(n-1\\) 次循环中，每一次循环的比较都比赋值多一个，多在最后那一次比较并不带来赋值）。平均来说插入排序算法复杂度为 \\(O(n&#94;{2})\\) 。因而，插入排序不适合对于数据量比较大的排序应用。但是，如果需要排序的数据量很小，例如，量级小于千；或者若已知输入元素大致上按照顺序排列，那么插入排序还是一个不错的选择。 插入排序在工业级库中也有着广泛的应用，在 STL 的 sort 算法和 stdlib 的 qsort 算法中，都将插入排序作为快速排序的补充，用于少量元素的排序（通常为8个或以下）。 最坏时间复杂度： \\(O(n&#94;2)\\) 最优时间复杂度： \\(O(n)\\) 平均时间复杂度： \\(\\Theta (n&#94;2)\\) 最坏空间复杂度： \\(O(1)\\) 稳定排序 2. 归并排序 归并排序（英语：Merge sort，或 mergesort），是创建在归并操作上的一种有效的排序算法，效率为 \\(O(n\\log n)\\) 。1945年由约翰·冯·诺伊曼首次提出。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用，且各层分治递归可以同时进行。 template < typename Iterator > void merge ( Iterator begin , Iterator end , Iterator middle ) { typedef typename std : : iterator_traits < Iterator >:: value_type T ; // 迭代器指向对象的值类型 if ( std : : distance ( begin , middle ) <= 0 || std :: distance ( middle , end ) <= 0 ) return ; std : : vector < T > result ( begin , end ); //暂存结果 auto current = result.begin() ; auto left_current = begin ; //左侧序列当前比较位置 auto right_current = middle ; //右序列当前比较位置 while (left_current != middle && right_current != end) { if (*left_current < *right_current) { *current++ = *left_current++ ; //左侧较小 } else { *current++ = *right_current++ ; //左侧较小 } } if ( left_current == middle && right_current != end ) // 当左侧序列为搬空 { std : : copy ( right_current , end , current ); } if ( right_current == end && left_current != middle ) // 当右侧序列搬空 { std : : copy ( left_current , middle , current ); } std :: copy ( result . begin (), result . end (), begin ); // 复制回原序列 ， 因此是非原地的 } template < typename Iterator > void merge_sort ( Iterator begin , Iterator end ) { auto size = std : : distance ( begin , end ); if (size > 1) { Iterator middle = begin + size / 2 ; merge_sort(begin, middle) ; merge_sort(middle, end) ; merge(begin, end, middle) ; } } 比较操作的次数介于 \\(\\frac{1}{2}n\\log n\\) 和 \\(n\\log n-n+1\\) 之间。 赋值操作的次数是 \\(2n\\log n\\) 。归并算法的空间复杂度为： \\(\\Theta (n)\\) 。 最坏时间复杂度： \\(O(n\\log n)\\) 最优时间复杂度： \\(\\Omega(n \\log n)\\) 平均时间复杂度： \\(\\Theta (n\\log n)\\) 最坏空间复杂度： \\(O(n)\\) 稳定排序 3. 堆排序 堆排序（英语：Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。 3.1 堆节点的访问 通常堆是通过一维数组来实现的。在数组起始位置为0的情形中： 父节点 \\(i\\) 的左子节点在位置 \\(2i+1\\) 父节点 \\(i\\) 的右子节点在位置 \\(2i+2\\) 子节点 \\(i\\) 的父节点在位置 \\(\\text{floor}((i-1)/2)\\) 3.2 堆的操作 堆中定义以下几种操作： 最大堆调整（Max Heapify）：将堆的末端子节点作调整，使得子节点永远小于父节点 创建最大堆（Build Max Heap）：将堆中的所有数据重新排序 堆排序（HeapSort）：移除位在第一个数据的根节点，并做最大堆调整的递归运算 #include <iostream> #include <algorithm> using namespace std ; void max_heapify ( int arr [], int start , int end ) { // 建立父節點指標和子節點指標 int dad = start ; int son = dad * 2 + 1 ; while ( son <= end ) { // 若子節點指標在範圍內才做比較 if ( son + 1 <= end && arr [ son ] < arr [ son + 1 ]) // 先比較兩個子節點大小，選擇最大的 son ++ ; if ( arr [ dad ] > arr [ son ]) // 如果父節點大於子節點代表調整完畢，直接跳出函數 return ; else { // 否則交換父子內容再繼續子節點和孫節點比較 swap ( arr [ dad ], arr [ son ]); dad = son ; son = dad * 2 + 1 ; } } } void heap_sort ( int arr [], int len ) { // 初始化，i從最後一個父節點開始調整 for ( int i = len / 2 - 1 ; i >= 0 ; i -- ) max_heapify ( arr , i , len - 1 ); // 先將第一個元素和已经排好的元素前一位做交換，再從新調整(刚调整的元素之前的元素)，直到排序完畢 for ( int i = len - 1 ; i > 0 ; i -- ) { swap ( arr [ 0 ], arr [ i ]); max_heapify ( arr , 0 , i - 1 ); } } int main () { int arr [] = { 3 , 5 , 3 , 0 , 8 , 6 , 1 , 5 , 8 , 6 , 2 , 4 , 9 , 4 , 7 , 0 , 1 , 8 , 9 , 7 , 3 , 1 , 2 , 5 , 9 , 7 , 4 , 0 , 2 , 6 }; int len = ( int ) sizeof ( arr ) / sizeof ( * arr ); heap_sort ( arr , len ); for ( int i = 0 ; i < len ; i ++ ) cout << arr [ i ] << ' ' ; cout << endl ; return 0 ; } 最坏时间复杂度： \\(O(n\\log n)\\) 最优时间复杂度： \\(O(n\\log n)\\) 平均时间复杂度： \\(\\Theta (n\\log n)\\) 最坏空间复杂度： \\(O(1)\\) 不稳定排序 4. 快速排序 快速排序（英语：Quicksort），又称划分交换排序（partition-exchange sort），简称快排，一种排序算法，最早由东尼·霍尔提出。在平均状况下，排序 \\(n\\) 个项目要 \\(O(n\\log n)\\) 次比较。在最坏状况下则需要 \\(O(n&#94;{2})\\) 次比较，但这种状况并不常见。事实上，快速排序 \\(\\Theta (n\\log n)\\) 通常明显比其他算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地达成。 快速排序是二叉查找树（二叉搜索树）的一个空间最优化版本。不是循序地把数据项插入到一个明确的树中，而是由快速排序组织这些数据项到一个由递归调用所隐含的树中。这两个算法完全地产生相同的比较次数，但是顺序不同。对于排序算法的稳定性指标，原地分割版本的快速排序算法是不稳定的。其他变种是可以通过牺牲性能和空间来维护稳定性的。 void quick_sort(int a[], int start, int end) { if (start < end) { int i = start, j = end, X = a[i]; while (i < j) { while (i < j && a[j] >= X) j--; if (i < j) a[i++] = a[j]; while (i < j && a[i] < X) i++; if (i < j) a[j--] = a[i]; } a[i] = X; quick_sort(a, start, i - 1); quick_sort(a, i + 1, end); } } 随机算法 当划分产生的两个子问题分别包含 \\(n-1\\) 和0个元素时，最坏情况发生。划分操作的时间复杂度为 \\(\\Theta(n)\\) ， \\(T(0)=\\Theta(1)\\) ，这时算法运行时间的递归式为： \\(T(n) = T(n-1) + T(0) + \\Theta(n) = T(n-1) + \\Theta(n)\\) ，解为 \\(T(n) = \\Theta(n&#94;2)\\) 。 当划分产生的两个子问题分别包含 \\(\\lfloor n/2 \\rfloor\\) 和 \\(\\lceil n/2 \\rceil-1\\) 个元素时，最好情况发生。算法运行时间递归式为： \\(T(n) = 2T(n/2) + \\Theta(n)\\) ，解为 \\(T(n) = \\Theta(n\\lg n)\\) 。 可以通过在算法中引入随机性，使得算法对所有输入都能获得较好的期望性能。随机算法保证了对任何的输入而言，都可以保证 \\(\\Theta (n\\lg n)\\) 的时间复杂度。 void rand_quick_sort ( T arr [] , int begin , int end ) { if (end-begin <= 1) return ; int pindex = rand() % (end-begin) + begin ; std : : swap ( arr [ end - 1 ] , arr [ pindex ] ); quick_sort(arr, end - begin + 1) ; } 最坏时间复杂度： \\(\\Theta(n&#94;2)\\) 最优时间复杂度： \\(\\Theta(n\\log n)\\) 平均时间复杂度： \\(\\Theta (n\\log n)\\) 空间复杂度： \\(O(\\log n)\\) 不稳定排序 5. 计数排序 计数排序（Counting sort）是一种稳定的线性时间排序算法。计数排序使用一个额外的数组 \\(C\\) ，其中第 \\(i\\) 个元素是待排序数组 \\(A\\) 中值等于 \\(i\\) 的元素的个数。然后根据数组 \\(C\\) 来将 \\(A\\) 中的元素排到正确的位置。 当输入的元素是 \\(n\\) 个 \\([0,k]\\) 之间的整数时，它的运行时间是 \\(\\Theta (n+k)\\) 。计数排序不是比较排序，排序的速度快于任何比较排序算法。 由于用来计数的数组 \\(C\\) 的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。例如：计数排序是用来排序0到100之间的数字的最好的算法，但是它不适合按字母顺序排序人名。但是，计数排序可以用在基数排序算法中，能够更有效的排序数据范围很大的数组。 当原数组有重复数据时，为保证稳定排序，最后要反向填充目标数组，以及将每个数字的统计减去1。 步骤 找出待排序的数组中最大和最小的元素 统计数组中每个值为 \\(i\\) 的元素出现的次数，存入数组 \\(C\\) 的第 \\(i\\) 项 对所有的计数累加（从 \\(C\\) 中的第一个元素开始，每一项和前一项相加） 反向填充目标数组：将每个元素 \\(i\\) 放在新数组的第 \\(C[i]\\) 项，每放一个元素就将 \\(C[i]\\) 减去1 #include <iostream> #include <time.h> #include <vector> using namespace std ; void Counting_sort ( int A [], size_t n , int k ) { //申请额外空间 int * B = new int [ n ]; int * C = new int [ k + 1 ]; for ( int i = 0 ; i <= k ; ++ i ) { C [ i ] = 0 ; //将 C 指向的数组所有元素置0 } //保存数组 A 中每个元素出现的个数 for ( int j = 0 ; j < n ; ++ j ) { C [ A [ j ]] ++ ; } //将所有计数次数累加 for ( int i = 1 ; i <= k ; ++ i ) { C [ i ] = C [ i ] + C [ i - 1 ]; } //将元素重新输入 for ( int i = n - 1 ; i >= 0 ; -- i ) { //次数大小最小为1、数组开始为0 B [ C [ A [ i ]] - 1 ] = A [ i ]; C [ A [ i ]] -- ; } for ( int j = 0 ; j < n ; ++ j ) { A [ j ] = B [ j ]; } //不要忘了释放分配的空间 delete [] B ; delete [] C ; } int main ( int argc , char ** argv ) { int a [ 10 ] = { 2 , 56 , 4 , 2 , 9 , 56 , 3 , 59 , 9 , 16 }; int max = a [ 0 ]; for ( int i = 1 ; i < 10 ; ++ i ) { if ( a [ i ] > max ) { max = a [ i ]; } } Counting_sort ( a , 10 , max ); for ( int i = 0 ; i < 10 ; ++ i ) { cout << a [ i ] << \" \" ; } return 0 ; } 最坏时间复杂度 \\(O(n+k)\\) 最优时间复杂度 \\(O(n+k)\\) 平均时间复杂度 \\(O(n+k)\\) 最坏空间复杂度 \\(O(n+k)\\) 稳定排序 6. 基数排序 基数排序（英语：Radix sort）是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。 它是这样实现的：将所有待比较数值（正整数）统一为同样的数字长度，数字较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。 基数排序的时间复杂度是 \\(O(k\\cdot n)\\) ，其中 \\(n\\) 是排序元素个数， \\(k\\) 是数字位数。 最坏时间复杂度 \\(O(k\\cdot n)\\) 最坏时间复杂度 \\(O(n&#94;2)\\) 最坏空间复杂度 \\(O(k+n)\\) 稳定排序 int maxbit(int data[], int n) //辅助函数，求数据的最大位数 { int maxData = data[0]; ///< 最大数 /// 先求出最大数，再求其位数 for (int i = 1; i < n; ++i) { if (maxData < data[i]) maxData = data[i]; } int d = 1; int p = 10; while (maxData >= p) { maxData /= 10; ++d; } return d; } void radixsort(int data[], int n) //基数排序 { int d = maxbit(data, n); int *tmp = new int[n]; int *count = new int[10]; //计数器 int i, j, k; int radix = 1; for (i = 1; i <= d; i++) //进行 d 次排序 { //每一次都是计数排序 for (j = 0; j < 10; j++) count[j] = 0; //每次分配前清空计数器 for (j = 0; j < n; j++) { k = (data[j] / radix) % 10; //统计每个桶中的记录数 count[k]++; } for (j = 1; j < 10; j++) count[j] = count[j - 1] + count[j]; //将tmp中的位置依次分配给每个桶 for (j = n - 1; j >= 0; j--) //将所有桶中记录依次收集到tmp中 { k = (data[j] / radix) % 10; tmp[count[k] - 1] = data[j]; count[k]--; } for (j = 0; j < n; j++) //将临时数组的内容复制到data中 data[j] = tmp[j]; radix = radix * 10; } delete[] tmp; delete[] count; } 7. 桶排序 桶排序（Bucket sort）或所谓的箱排序，是一个排序算法，工作的原理是将数组分到有限数量的桶里。每个桶再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。桶排序是鸽巢排序的一种归纳结果。当要被排序的数组内的数值是均匀分配的时候，桶排序使用线性时间 \\(\\Theta (n)\\) 。桶排序不是比较排序。 7.1 步骤 设置一个定量的数组当作空桶子 寻访序列，并且把项目一个一个放到对应的桶子去 对每个不是空的桶子进行排序 从不是空的桶子里把项目再放回原来的序列中 7.2 实现 转自： https://blog.csdn.net/misayaaaaa/article/details/66969486 #include <cstdlib> #include <iostream> #include <vector> using namespace std ; void Bucket_sort ( double a [], size_t n ) { double ** p = new double * [ 10 ]; // p数组存放十个double指针，分为10个桶 for ( int i = 0 ; i < 10 ; ++ i ) { p [ i ] = new double [ 100 ]; //每个指针都指向一块10个double的数组，每个桶都可以包含100个元素 } int count [ 10 ] = { 0 }; //元素全为0的数组 for ( int i = 0 ; i < n ; ++ i ) { double temp = a [ i ]; int flag = ( int )( temp * 10 ); //判断每个元素属于哪个桶 p [ flag ][ count [ flag ]] = temp ; //将每个元素放入到对应的桶中，从0开始 int j = count [ flag ] ++ ; //将对应桶的计数加1 //在本桶之中与之前的元素做比较，比较替换（插入排序） for (; j > 0 && temp < p [ flag ][ j - 1 ]; -- j ) { p [ flag ][ j ] = p [ flag ][ j - 1 ]; } p [ flag ][ j ] = temp ; } //元素全部放完之后，需要进行重新链接的过程 int k = 0 ; for ( int i = 0 ; i < 10 ; ++ i ) { for ( int j = 0 ; j < count [ i ]; ++ j ) //桶中元素的个数count[i] { a [ k ++ ] = p [ i ][ j ]; } } //申请内存的释放 for ( int i = 0 ; i < 10 ; i ++ ) { delete p [ i ]; p [ i ] = NULL ; } delete [] p ; p = NULL ; } //随机初始化数组[0,1) void Initial_array ( double a [], size_t n ) { for ( size_t i = 0 ; i < n ; ++ i ) { a [ i ] = rand () / ( static_cast < double > ( RAND_MAX ) + 1 ); } } int main ( int argc , char ** argv ) { double a [ 100 ]; Initial_array ( a , 100 ); Bucket_sort ( a , 100 ); for ( int i = 0 ; i < 100 ; ++ i ) { cout << a [ i ] << \" \" ; } return 0 ; } 时间复杂度为 \\(O(n)\\) 空间复杂度为 \\(O(n+M)\\) 稳定排序 8. 希尔排序 void shellsort3(int a[], int n) { int i, j, gap; for (gap = n / 2; gap > 0; gap /= 2) for (i = gap; i < n; i++) for (j = i - gap; j >= 0 && a[j] > a[j + gap]; j -= gap) Swap(a[j], a[j + gap]); } if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"读书笔记","url":"https://xutree.github.io/pages/2018/10/26/sort/"},{"title":"矩阵微积分","text":"矩阵求导，本质是多元函数求导，仅仅是把函数的⾃变量以及求导的结果排列成了矩阵的形式，⽅便表达与计算。类似地，复合函数的求导法则本质上也是多元函数求导的链式法则，只是将结果整理成了矩阵的形式。从原理上讲，可以对矩阵的每个分量逐元素地求导，得到最终结果；但是这样做太繁琐，极其容易出错，因此推导并记住⼀些常⽤的结论在实践中是⾮常必要的。 不同的矩阵求导方法采取不同的导数排列方法，以便于所求导数可以方便后续计算。主要存在两种符号约定。 1. 概述 矩阵微积分的自变量可以是标量，向量，或者是一个矩阵，因变量也可以是上述的三者之一。每一种不同的自变量和因变量的组合都有不同的一套运算规则。 标量 向量 矩阵 标量 \\(\\frac{\\partial y}{\\partial x}\\) \\(\\frac{\\partial {\\boldsymbol y}}{\\partial x}\\) \\(\\frac{\\partial {\\bf Y}}{\\partial x}\\) 向量 \\(\\frac{\\partial y}{\\partial {\\boldsymbol x}}\\) \\(\\frac{\\partial {\\boldsymbol y}}{\\partial {\\boldsymbol x}}\\) 矩阵 \\(\\frac{\\partial y}{\\partial {\\bf X}}\\) 向量和标量可以看作矩阵的特殊形式。表中用粗体小写字母代表向量，粗体大写字母代表矩阵。 上表中空白的部分求导结果维度太高，而且没有统一的符号约定。 以下说明采用\b\"分子布局\"。 2. 分子布局下的求导 2.1 向量对标量求导 $${\\boldsymbol y}=\\begin{bmatrix} y_{1}\\\\ y_{2}\\\\ \\vdots\\\\ y_{m} \\end{bmatrix} \\Longrightarrow\\frac{\\partial {\\boldsymbol y}}{\\partial x}=\\begin{bmatrix} \\frac{\\partial y_1}{\\partial x}\\\\ \\frac{\\partial y_2}{\\partial x}\\\\ \\vdots\\\\ \\frac{\\partial y_m}{\\partial x}\\\\ \\end{bmatrix}$$ 在向量微积分中，向量 \\({\\boldsymbol y}\\) 相对于标量 \\(x\\) 的导数被称为向量 \\({\\boldsymbol y}\\) 的切向量。 2.2 标量对向量求导 $${\\boldsymbol x} = \\begin{bmatrix} x_1 \\\\ x_2 \\\\ \\vdots \\\\ x_n \\\\ \\end{bmatrix}\\Longrightarrow \\frac{\\partial y}{\\partial {\\boldsymbol x}&#94;{\\text{T}}} = \\left[ \\frac{\\partial y}{\\partial x_1} \\frac{\\partial y}{\\partial x_2} \\cdots \\frac{\\partial y}{\\partial x_n} \\right]$$ 这是标量函数 \\(f({\\boldsymbol x})\\) 梯度的转置。 2.3\b 向量对向量的求导 $${\\boldsymbol y} = \\begin{bmatrix} y_1 \\\\ y_2 \\\\ \\vdots \\\\ y_m \\\\ \\end{bmatrix},{\\boldsymbol x} = \\begin{bmatrix} x_1 \\\\ x_2 \\\\ \\vdots \\\\ x_n \\\\ \\end{bmatrix}\\Longrightarrow \\frac{\\partial {\\boldsymbol y}}{\\partial {\\boldsymbol x}} = \\begin{bmatrix} \\frac{\\partial y_1}{\\partial x_1} & \\frac{\\partial y_1}{\\partial x_2} & \\cdots & \\frac{\\partial y_1}{\\partial x_n}\\\\ \\frac{\\partial y_2}{\\partial x_1} & \\frac{\\partial y_2}{\\partial x_2} & \\cdots & \\frac{\\partial y_2}{\\partial x_n}\\\\ \\vdots & \\vdots & \\ddots & \\vdots\\\\ \\frac{\\partial y_m}{\\partial x_1} & \\frac{\\partial y_m}{\\partial x_2} & \\cdots & \\frac{\\partial y_m}{\\partial x_n}\\\\ \\end{bmatrix}$$ 此即雅可比矩阵。 2.5 矩阵对标量求导 $$\\frac{\\partial {\\bf Y}}{\\partial x} = \\begin{bmatrix} \\frac{\\partial y_{11}}{\\partial x} & \\frac{\\partial y_{12}}{\\partial x} & \\cdots & \\frac{\\partial y_{1n}}{\\partial x}\\\\ \\frac{\\partial y_{21}}{\\partial x} & \\frac{\\partial y_{22}}{\\partial x} & \\cdots & \\frac{\\partial y_{2n}}{\\partial x}\\\\ \\vdots & \\vdots & \\ddots & \\vdots\\\\ \\frac{\\partial y_{m1}}{\\partial x} & \\frac{\\partial y_{m2}}{\\partial x} & \\cdots & \\frac{\\partial y_{mn}}{\\partial x}\\\\ \\end{bmatrix}$$ 称为切矩阵。 2.6 标量对矩阵求导 $$\\frac{\\partial y}{\\partial {\\bf X}} = \\begin{bmatrix} \\frac{\\partial y}{\\partial x_{11}} & \\frac{\\partial y}{\\partial x_{21}} & \\cdots & \\frac{\\partial y}{\\partial x_{p1}}\\\\ \\frac{\\partial y}{\\partial x_{12}} & \\frac{\\partial y}{\\partial x_{22}} & \\cdots & \\frac{\\partial y}{\\partial x_{p2}}\\\\ \\vdots & \\vdots & \\ddots & \\vdots\\\\ \\frac{\\partial y}{\\partial x_{1q}} & \\frac{\\partial y}{\\partial x_{2q}} & \\cdots & \\frac{\\partial y}{\\partial x_{pq}}\\\\ \\end{bmatrix}$$ 矩阵标量 \\(f({\\bf X})\\) 在矩阵 \\({\\bf Y}\\) 方向上的方向导数为： $$\\nabla_{\\bf Y} f = \\operatorname{tr} \\left(\\frac{\\partial f}{\\partial {\\bf X}} {\\bf Y}\\right)$$ 2.7 其他矩阵求导 对于向量对矩阵求导，矩阵对向量求导，矩阵对矩阵求导。它们没有统一的符号，也没有统一的应用。 与向量相关的两种矩阵导数，可以被看作是一个只有一列的矩阵和另一个矩阵导数的特例。下面只考虑如何写出一个矩阵对另一个矩阵求导的导数结果。 3. 标量对矩阵求导计算方法 3.1 全微分公式 \b 对于实值函数对矩阵求导，我们可以写出： $$df=\\sum_{i=1}&#94;m\\sum_{j=1}&#94;n\\frac{\\partial f}{\\partial x_{ij}}dx_{ij}=\\text{tr}\\left(\\left(\\frac{\\partial f}{\\partial x}\\right)&#94;\\text{T}dx\\right)$$ 3.2 微分法则 加减： \\(d({\\bf X}\\pm{\\bf Y})=d{\\bf X}\\pm d{\\bf Y}\\) 乘\b法： \\(d({\\bf XY})=(d{\\bf X}){\\bf Y}+{\\bf X}(d{\\bf Y})\\) 转置： \\(d({\\bf X}&#94;\\text{T})=(d{\\bf X})&#94;\\text{T}\\) 迹： \\(d\\text{tr}({\\bf X})=\\text{tr}(d{\\bf X})\\) 逆： \\(d{\\bf X}&#94;{-1}=-{\\bf X}&#94;{-1}d{\\bf X}{\\bf X}&#94;{-1}\\) ，利用 \\({\\bf X}{\\bf X}&#94;{-1}=\\mathbb{I}\\) 行列式： \\(d|{\\bf X}|=\\text{tr}({\\bf X}&#94;*d{\\bf \bX})\\) ，其中 \\({\\bf X}&#94;*\\) 表示 \\({\\bf X}\\) 的伴随矩阵，在 \\({\\bf X}\\) 可逆时又可以写做： \\(d|{\\bf X}|=|{\\bf X}|\\text{tr}({\\bf X}&#94;{-1}d{\\bf X})\\) 逐元素乘： \\(d({\\bf X}\\odot{\\bf Y})=\bd{\\bf X}\\odot{\\bf Y}+{\\bf X}\\odot d{\\bf Y}\\) ， \\(\\odot\\) 表示尺寸相同的矩阵逐元素相乘 逐元素函数： \\(dw({\\bf X})=w'({\\bf X})\\odot d{\\bf X}\\) \b， \\(w({\\bf X})\\) 是逐元素标量运算， \\(w'({\\bf X})\\) 是逐元素求导 3.3 其他\b公式 \b \\(\\text{tr}(a)=a\\) ， \\(a\\) 为标量 \\(\\text{tr}({\\bf A}&#94;\\text{T})=\\text{tr}({\\bf A})\\) \\(\\text{tr}({\\bf A}+{\\bf B})=\\text{tr}({\\bf A})+\\text{tr}({\\bf B})\\) \\(\\text{tr}({\\bf AB})=\\text{tr}({\\bf BA})\\) \\(\\text{tr}\\left({\\bf A}&#94;{\\text{T}}({\\bf B}\\odot{\\bf C})\\right)=\\text{tr}\\left(({\\bf A}\\odot {\\bf B})&#94;{\\text{T}}{\\bf C}\\right)\\) 3.4 求导方法 若标量函数 \\(f\\) 是矩阵 \\({\\bf X}\\) 经加减乘法、行列式、逆、逐元素\b函数等运算构成，则使用相应的运算法则对 \\(f\\) 求微分，再使用迹变换给 \\(df\\) 套上迹\b并将其它项交换至 \\(d{\\bf X}\\) 左侧，即能得到导数。 例题1 ： \\(f={\\boldsymbol a}&#94;{\\text{T}}{\\bf X}{\\boldsymbol b}\\) ，求： \\(\\frac{\\partial f}{\\partial {\\bf X}}\\) 。其\b中 \\(\b{\\boldsymbol a}\\) 是 \\(m\\times 1\\) 列向量， \\(\b{\\bf X}\\) 是 \\(m\\times n\\) 矩阵， \\({\\boldsymbol b}\\) 是 \\(n\\times 1\\) 列向量， \\(f\\) 是标量。 解答 ： 全微分： $$df={\\boldsymbol a}&#94;{\\text{T}}d{\\bf X}{\\boldsymbol b}$$ 两边取迹： $$df=\\text{tr}({\\boldsymbol a}&#94;{\\text{T}}d{\\bf X}{\\boldsymbol b})=\\text{tr}({\\boldsymbol b}{\\boldsymbol a}&#94;{\\text{T}}d{\\bf X})$$ 对照全微\b分公式： $$(\\frac{\\partial f}{\\partial {\\bf X}})&#94;{\\text{T}}={\\boldsymbol b}{\\boldsymbol a}&#94;{\\text{T}}$$ 得到： $$\\frac{\\partial f}{\\partial {\\bf X}}=({\\boldsymbol b}{\\boldsymbol a}&#94;{\\text{T}})&#94;{\\text{T}}={\\boldsymbol a}{\\boldsymbol b}&#94;{\\text{T}}$$ 例题2 ： \\(f={\\boldsymbol a}&#94;{\\text{T}}\\text{exp}({\\bf X}{\\boldsymbol b})\\) ，求： \\(\\frac{\\partial f}{\\partial {\\bf X}}\\) 。其中 \\(\\boldsymbol{a}\\) 是 \\(m\\times 1\\) 列向量， \\({\\bf X}\\) 是 \\(m\\times n\\) 矩阵， \\(\\boldsymbol{b}\\) 是 \\(n\\times 1\\) 列向量， \\(\\text{exp}\\) 表示逐元素求指数， \\(f\\) 是标量。 解答 ： 全微分： $$df=\\boldsymbol{a}&#94;{\\text{T}}\\left(\\text{exp}({\\bf X}{\\boldsymbol b})\\odot(d{\\bf X}{\\boldsymbol b})\\right)$$ 两边取迹： $$df = \\text{tr}( \\boldsymbol{a}&#94;{\\text{T}}(\\exp({\\bf X}\\boldsymbol{b})\\odot (d{\\bf X}\\boldsymbol{b}))) \\\\ =\\text{tr}((\\boldsymbol{a}\\odot \\exp({\\bf X}\\boldsymbol{b}))&#94;{\\text{T}}dX \\boldsymbol{b}) \\\\ = \\text{tr}(\\boldsymbol{b}(\\boldsymbol{a}\\odot \\exp({\\bf X}\\boldsymbol{b}))&#94;\\text{T}d{\\bf X})$$ 对照全微\b分公式得到： $$\\frac{\\partial f}{\\partial {\\bf X}} = (\\boldsymbol{b}(\\boldsymbol{a}\\odot \\exp({\\bf X}\\boldsymbol{b}))&#94;{\\text{T}})&#94;{\\text{T}}= (\\boldsymbol{a}\\odot \\exp({\\bf X}\\boldsymbol{b}))\\boldsymbol{b}&#94;{\\text{T}}$$ 例题3 ：线性回归问题。 \\(l = \\|{\\bf X}\\boldsymbol{w}- \\boldsymbol{y}\\|&#94;2\\) 。求 \\(\\boldsymbol{w}\\) 的最小二乘估计，即求 \\(\\frac{\\partial l}{\\partial \\boldsymbol{w}}\\) 的零点。其中 \\(\\boldsymbol{y}\\) 是 \\(m\\times 1\\) 列向量， \\({\\bf X}\\) 是 \\(m\\times n\\) 矩阵， \\(\\boldsymbol{w}\\) 是 \\(n\\times 1\\) 列向量， \\(l\\) 是标量。 解答 ： 改写模平方表达式： $$l = ({\\bf X}\\boldsymbol{w}- \\boldsymbol{y})&#94;{\\text{T}}({\\bf X}\\boldsymbol{w}- \\boldsymbol{y})$$ 全微分： $$dl = ({\\bf X}d\\boldsymbol{w})&#94;\\text{T}({\\bf X}\\boldsymbol{w}-\\boldsymbol{y})+({\\bf X}\\boldsymbol{w}-\\boldsymbol{y})&#94;\\text{T}({\\bf X}d\\boldsymbol{w}) = 2({\\bf X}\\boldsymbol{w}-\\boldsymbol{y})&#94;\\text{T}{\\bf X}d\\boldsymbol{w}$$ 对照全微\b分公式得到： $$\\frac{\\partial l}{\\partial \\boldsymbol{w}}= (2({\\bf X}\\boldsymbol{w}-\\boldsymbol{y})&#94;\\text{T}{\\bf X})&#94;\\text{T} = 2{\\boldsymbol X}&#94;\\text{T}({\\bf X}\\boldsymbol{w}-\\boldsymbol{y})$$ \\(\\frac{\\partial l}{\\partial \\boldsymbol{w}}\\) 的零点即 \\(\\frac{\\partial l}{\\partial \\boldsymbol{w}}\\) 的最小二乘估计 \\(\\boldsymbol{w} = ({\\bf X&#94;\\text{T}X})&#94;{-1}{\\bf X}&#94;\\text{T}\\boldsymbol{y}\\) 例题4 ：方差的最大似然估计。样本 \\(\\boldsymbol{x}_1,\\dots, \\boldsymbol{x}_n\\sim N(\\boldsymbol{\\mu}, \\Sigma)\\) ，求方差 \\(\\Sigma\\) 的最大似然估计。写成数学式是： \\(l =\\log|\\Sigma|+\\frac{1}{n}\\sum_{i=1}&#94;n(\\boldsymbol{x}_i-\\boldsymbol{\\bar{x}})&#94;\\text{T}\\Sigma&#94;{-1}(\\boldsymbol{x}_i-\\boldsymbol{\\bar{x}})\\) ，求 \\(\\frac{\\partial l }{\\partial \\Sigma}\\) 的零点。其中 \\(\\boldsymbol{x}_i\\) 是 \\(m\\times 1\\) 列向量， \\(\\overline{\\boldsymbol{x}}=\\frac{1}{n}\\sum_{i=1}&#94;n \\boldsymbol{x}_i\\) 是样本均值， \\(\\Sigma\\) 是 \\(m\\times m\\) 对称正定矩阵， \\(l\\) 是标量。 解答 ： 第一项： $$d\\log|\\Sigma| = |\\Sigma|&#94;{-1}d|\\Sigma| = \\text{tr}(\\Sigma&#94;{-1}d\\Sigma)$$ 第二项： $$\\frac{1}{n}\\sum_{i=1}&#94;n(\\boldsymbol{x}_i-\\boldsymbol{\\bar{x}})&#94;\\text{T}d\\Sigma&#94;{-1}(\\boldsymbol{x}_i-\\boldsymbol{\\bar{x}}) = -\\frac{1}{n}\\sum_{i=1}&#94;n(\\boldsymbol{x}_i-\\boldsymbol{\\bar{x}})&#94;\\text{T}\\Sigma&#94;{-1}d\\Sigma\\Sigma&#94;{-1}(\\boldsymbol{x}_i-\\boldsymbol{\\bar{x}})$$ 第二项求迹： $$\\text{tr}\\left(\\frac{1}{n}\\sum_{i=1}&#94;n(\\boldsymbol{x}_i-\\boldsymbol{\\bar{x}})&#94;\\text{T}\\Sigma&#94;{-1}d\\Sigma\\Sigma&#94;{-1}(\\boldsymbol{x}_i-\\boldsymbol{\\bar{x}})\\right)\\\\ =\\frac{1}{n} \\sum_{i=1}&#94;n \\text{tr}((\\boldsymbol{x}_i-\\boldsymbol{\\bar{x}})&#94;\\text{T}\\Sigma&#94;{-1} d\\Sigma \\Sigma&#94;{-1}(\\boldsymbol{x}_i-\\boldsymbol{\\bar{x}}))\\\\ = \\frac{1}{n}\\sum_{i=1}&#94;n\\text{tr}\\left(\\Sigma&#94;{-1}(\\boldsymbol{x}_i-\\boldsymbol{\\bar{x}})(\\boldsymbol{x}_i-\\boldsymbol{\\bar{x}})&#94;\\text{T}\\Sigma&#94;{-1}d\\Sigma\\right)=\\text{tr}(\\Sigma&#94;{-1}S\\Sigma&#94;{-1}d\\Sigma)$$ 定义： $$S = \\frac{1}{n}\\sum_{i=1}&#94;n(\\boldsymbol{x}_i-\\boldsymbol{\\bar{x}})(\\boldsymbol{x}_i-\\boldsymbol{\\bar{x}})&#94;\\text{T}$$ 为样本方差矩阵 得到： $$dl = \\text{tr}\\left(\\left(\\Sigma&#94;{-1}-\\Sigma&#94;{-1}S\\Sigma&#94;{-1}\\right)d\\Sigma\\right)$$ 对照全微\b分公式得到： $$\\frac{\\partial l }{\\partial \\Sigma}=(\\Sigma&#94;{-1}-\\Sigma&#94;{-1}S\\Sigma&#94;{-1})&#94;\\text{T}$$ 其零点即 \\(\\Sigma\\) 的最大似然估计为 \\(\\Sigma = S\\) 例题5 ：多元 logistic 回归。 \\(l = -\\boldsymbol{y}&#94;\\text{T}\\ln\\text{softmax}({\\bf W}\\boldsymbol{x})\\) ，求 \\(\\frac{\\partial l}{\\partial W}\\) 。其中 \\(\\boldsymbol{y}\\) 是除一个元素为1外其它元素为0的 \\(m\\times 1\\) 列向量， \\({\\bf W}\\) 是 \\(m\\times n\\) 矩阵， \\(\\boldsymbol{x}\\) 是 \\(n\\times 1\\) 列向量， \\(l\\) 是标量； \\(\\text{softmax}(\\boldsymbol{a}) = \\frac{\\exp(\\boldsymbol{a})}{\\boldsymbol{1}&#94;\\text{T}\\exp(\\boldsymbol{a})}\\) ，其中 \\(\\exp(\\boldsymbol{a})\\) 表示逐元素求指数， \\(\\boldsymbol{1}\\) 代表全1向量。 解答 ： 首先将 softmax 函数代入并写成： $$l = -\\boldsymbol{y}&#94;\\text{T} \\left(\\ln (\\exp({\\bf W}\\boldsymbol{x}))-\\boldsymbol{1}\\ln(\\boldsymbol{1}&#94;\\text{T}\\exp({\\bf W}\\boldsymbol{x}))\\right) \\\\ = -\\boldsymbol{y}&#94;\\text{T}{\\bf W}\\boldsymbol{x} + \\ln(\\boldsymbol{1}&#94;\\text{T}\\exp({\\bf W}\\boldsymbol{x}))\\\\$$ 这里注意：注意逐元素 log 满足等\b式： $$\\ln(\\boldsymbol{u}/c) = \\ln(\\boldsymbol{u}) - \\boldsymbol{1}\\ln(c)$$ 以及： $$\\boldsymbol{y}&#94;\\text{T} \\boldsymbol{1} = 1$$ 求微分： $$dl =-\\boldsymbol{y}&#94;\\text{T}d{\\bf W}\\boldsymbol{x}+\\frac{\\boldsymbol{1}&#94;\\text{T}\\left(\\exp({\\bf {\\bf W}}\\boldsymbol{x})\\odot(d{\\bf W}\\boldsymbol{x})\\right)}{\\boldsymbol{1}&#94;\\text{T}\\exp({\\bf W}\\boldsymbol{x})}$$ 根据： $$\\boldsymbol{1}&#94;\\text{T} (\\boldsymbol{u}\\odot \\boldsymbol{v}) = \\boldsymbol{u}&#94;\\text{T} \\boldsymbol{v}$$ 得： $$\\boldsymbol{1}&#94;\\text{T}\\left(\\exp({\\bf W}\\boldsymbol{x})\\odot(d{\\bf W}\\boldsymbol{x})\\right) = \\exp({\\bf W}\\boldsymbol{x})&#94;\\text{T}d{\\bf W}\\boldsymbol{x}$$ 求迹化简为： $$dl = \\text{tr}\\left(-\\boldsymbol{y}&#94;\\text{T}d{\\bf W}\\boldsymbol{x}+\\frac{\\exp({\\bf W}\\boldsymbol{x})&#94;\\text{T}d{\\bf W}\\boldsymbol{x}}{\\boldsymbol{1}&#94;\\text{T}\\exp({\\bf W}\\boldsymbol{x})}\\right) =\\text{tr}(\\boldsymbol{x}(\\text{softmax}({\\bf W}\\boldsymbol{x})-\\boldsymbol{y})&#94;\\text{T}d{\\bf W})$$ 得到： $$\\frac{\\partial l}{\\partial {\\bf W}}= (\\text{softmax}({\\bf W}\\boldsymbol{x})-\\boldsymbol{y})\\boldsymbol{x}&#94;\\text{T}$$ 例题5 ：二层神经网络\b。 \\(l = -\\boldsymbol{y}&#94;\\text{T}\\log\\text{softmax}({\\bf W_2}\\sigma({\\bf W_1}\\boldsymbol{x}))\\) ，求 \\(\\frac{\\partial l}{\\partial {\\bf W_1}}\\) 和 \\(\\frac{\\partial l}{\\partial \\bf{W_2}}\\) 。其中 \\(\\boldsymbol{y}\\) 是除一个元素为1外其它元素为0的的 \\(m\\times 1\\) 列向量， \\({\\bf W_2}\\) 是 \\(m\\times p\\) 矩阵， \\({\\bf W_1}\\) 是 \\(p\\times n\\) 矩阵， \\(\\boldsymbol{x}\\) 是 \\(n\\times 1\\) 列向量， \\(l\\) 是标量； \\(\\text{softmax}(\\boldsymbol{a}) = \\frac{\\exp(\\boldsymbol{a})}{\\boldsymbol{1}&#94;\\text{T}\\exp(\\boldsymbol{a})}\\) 同例5， \\(\\sigma(\\cdot)\\) 是逐元素 sigmoid 函数 \\(\\sigma(a) = \\frac{1}{1+\\exp(-a)}\\) 。 解答 ： 定义： $$\\boldsymbol{a}_1={\\bf W_1}\\boldsymbol{x}，\\boldsymbol{h}_1 = \\sigma(\\boldsymbol{a}_1)，\\boldsymbol{a}_2 = {\\bf W_2} \\boldsymbol{h}_1$$ 则： $$l =-\\boldsymbol{y}&#94;\\text{T}\\log\\text{softmax}(\\boldsymbol{a}_2)$$ 在例5中已求出： $$\\frac{\\partial l}{\\partial \\boldsymbol{a}_2} = \\text{softmax}(\\boldsymbol{a}_2)-\\boldsymbol{y}$$ 使用复合法则，注意此处 \\(\\boldsymbol{h}_1, {\\bf W_2}\\) 都是变量： $$dl = \\text{tr}\\left(\\frac{\\partial l}{\\partial \\boldsymbol{a}_2}&#94;\\text{T}d\\boldsymbol{a}_2\\right) = \\text{tr}\\left(\\frac{\\partial l}{\\partial \\boldsymbol{a}_2}&#94;\\text{T}dW_2 \\boldsymbol{h}_1\\right) + \\text{tr}\\left(\\frac{\\partial l}{\\partial \\boldsymbol{a}_2}&#94;\\text{T}W_2 d\\boldsymbol{h}_1\\right)$$ 使用矩阵乘法交换的迹技巧从第一项得到： $$\\frac{\\partial l}{\\partial W_2}= \\frac{\\partial l}{\\partial\\boldsymbol{a}_2}\\boldsymbol{h}_1&#94;\\text{T}$$ 从第二项得到： $$\\frac{\\partial l}{\\partial \\boldsymbol{h}_1}= W_2&#94;\\text{T}\\frac{\\partial l}{\\partial\\boldsymbol{a}_2}$$ 接下来求 \\(\\frac{\\partial l}{\\partial \\boldsymbol{a}_1}\\) ，继续使用复合法则，并利用矩阵乘法和逐元素乘法交换的迹技巧： $$\\text{tr}\\left(\\frac{\\partial l}{\\partial\\boldsymbol{h}_1}&#94;\\text{T}d\\boldsymbol{h}_1\\right) = \\text{tr}\\left(\\frac{\\partial l}{\\partial\\boldsymbol{h}_1}&#94;\\text{T}(\\sigma'(\\boldsymbol{a}_1)\\odot d\\boldsymbol{a}_1)\\right) = \\text{tr}\\left(\\left(\\frac{\\partial l}{\\partial\\boldsymbol{h}_1}\\odot \\sigma'(\\boldsymbol{a}_1)\\right)&#94;\\text{T}d\\boldsymbol{a}_1\\right)$$ 得到： $$\\frac{\\partial l}{\\partial \\boldsymbol{a}_1}= \\frac{\\partial l}{\\partial\\boldsymbol{h}_1}\\odot\\sigma'(\\boldsymbol{a}_1)$$ 为求 \\(\\frac{\\partial l}{\\partial {\\bf W_1}}\\) ，再用一次复合法则 ： $$\\text{tr}\\left(\\frac{\\partial l}{\\partial\\boldsymbol{a}_1}&#94;\\text{T}d\\boldsymbol{a}_1\\right) = \\text{tr}\\left(\\frac{\\partial l}{\\partial\\boldsymbol{a}_1}&#94;\\text{T}d{\\bf W_1}\\boldsymbol{x}\\right) = \\text{tr}\\left(\\boldsymbol{x}\\frac{\\partial l}{\\partial\\boldsymbol{a}_1}&#94;\\text{T}d{\\bf W_1}\\right)$$ 得到： $$\\frac{\\partial l}{\\partial {\\bf W_1}}= \\frac{\\partial l}{\\partial\\boldsymbol{a}_1}\\boldsymbol{x}&#94;\\text{T}$$ if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"基础知识","url":"https://xutree.github.io/pages/2018/10/23/矩阵求导/"},{"title":"C++ Primer 第十七章 标准库特殊设施","text":"17.1 tuple 类型 当我们希望将一些数据组合成单一对象，但又不想麻烦地定义一个新数据结构来表示这些数据时，可以使用 tuple 类型。与 pair 类似，但 tuple 可以有任意数量的成员。它的一个常见用途就是从一个函数返回多个值。 tuple 定义在同名的头文件中。 支持的操作： 要访问一个 tuple 的成员，使用 get 标准库模板。为了使用 get ，我们必须指定一个显式模板参数，它指明我们想要访问第几个成员。这个显式模板参数必须是一个整型常量表达式，从0开始计数，返回指定成员的引用。 auto book = get<0>(item); // 返回 item 的第一个成员 get<0>(item) *= 0.8; // 修改书的单价 借助辅助类模板 tuple_size 和 tuple_element ，可以查询 tuple 成员的数量和类型。不过使用这两个类，必须知道 tuple 对象的类型，这可以通过 decltype 很简单地得到： typedef decltype(item) trans; // 返回 trans 类型对象中成员的数量 size_t sz = tuple_size<trans>::value; // 返回 3 // cnt 的类型与 item 中第二个成员相同，是一个 int tuple_element<1, trans>::type cnt = get<1>(item); 只有两个 tuple 具有相同数量的成员，且每对成员使用 == 或 < 是合法时，才能比较两个 tuple 。另外，由于 tuple 定义了 < 和 == 运算符，可以将 tuple 序列传递给算法，并且可以在无序容器中将 tuple 作为关键字类型。 17.2 bitset 类型 bitset 类，可以方便地将整型运算对象当作二进制位集合处理，并且能够处理超过最长整型类型大小的位集合。 bitset 定义在同名的头文件中。 支持的操作： 使用字符串初始化 bitset 时，下标最小的字符对应 bitset 中的高位。 bitset<32> bitvec4(\"1100\"); // 2、3两位为1，剩余位为0 17.3 正则表达式 RE 库定义在头文件 regex 中。 组件 意义 regex 表示有一个正则表达式的类 regex_match 将一个字符序列与一个正则表达式匹配，整串匹配返回 true regex_search 寻找第一个与正则表达式匹配的子序列，有子串匹配，返回 true regex_replace 使用给定格式替换一个正则表达式 regex_iterator 迭代器适配器，调用 regex_search 来遍历一个 string 中所有匹配的子串 smatch 容器类，保存 string 中搜索的结果 ssub_match string 中匹配的子表达式的结果 regex_search 和 regex_search 的参数如下，这些操作都返回 bool ，指出是否找到匹配： (seq, m, r, mft) 或 (seq, r, mft) ：在字符序列 seq 中查找 regex 对象 r 中的正则表达式。seq 可以是一个 string 、表示范围的一对迭代器以及一个指向空字符结尾的字符数组的指针。m 是一个 match 对象，用来保存匹配结果的相关细节。m 和 seq 必须具有兼容的类型。mft 是一个可选的 regex_constants::match_flag_type 值，它们会影响匹配过程。 待续...","tags":"读书笔记","url":"https://xutree.github.io/pages/2018/10/21/C++_Primer_Chapter_17/"},{"title":"C++ Primer 第十六章 模板与泛型编程","text":"面向对象编程（OOP）和泛型编程都能处理在编写程序时不知道类型的情况。不同之处是：OOP能处理类型在程序运行之前都未知的情况；而在泛型编程中，在编译时就能获知类型了。 容器、迭代器和算法都是泛型编程的例子。模板是 C++ 中泛型编程的基础。一个模板就是一个创建类或函数的蓝图或者说公式。 16.1 定义模板 16.1.1 函数模板 模板的定义以关键字 template 开始，后面跟一个模板参数列表，用 <> 括起来。 模板有类型参数（type parameter）和非类型参数（nontype parameter）之分。 16.1.1.1 类型参数 我们可以将类型参数看作类型说明符，就像内置类型或类类型说明符一样使用。 类型参数可以用来指定返回类型或函数的参数类型，以及在函数体内用于变量声明或类型转换。 参数列表中，类型参数前必须使用关键字 class 或 typename 。在模板定义中，模板参数列表不能为空。 // 错误，U 之前必须加上 class 或 typename template <typename T, U> T calc(const T&, const U&); 16.1.1.2 非类型参数 除了定义类型参数，还可以在模板中定义非类型参数，通过一个特定的类型名而非关键字 class 或 typename 来指定非类型参数。 因为编译器需要在编译时实例化模板，此时非类型参数会被一个用户提供的或编译器推断出的值所代替，所以这些值必须是常量表达式。 非类型参数可以是一个整型，对应的模板实参必须是常量表达式。而在模板定义内，可以将这个非类型参数用在任何需要常量表达式的地方，如指定数组大小。 template <unsigned N, unsigned M> int compare(const cahr (&p1)[N], const cahr (&p2)[M]) [ return strcmp(p1, p2); } compare(\"hi\", \"mom\"); // 上式调用会实例化处如下版本，注意字符串字面常量的末尾有一个空字符！ int compare(const cahr (&p1)[3], const cahr (&p2)[4]) 也可以是一个指向对象或函数类型的指针或（左值）引用。绑定到指针或引用非类型参数的实参必须具有静态的生存期。 16.1.1.3 inline 和 constexpr 的函数模板 函数模板可以声明为 inline 或 constexpr 的，如同非模板函数一样。 inline 或 constexpr 说明符放在模板参数列表之后，返回类型之前： //正确，inline 说明符跟在模板参数列表之后 template <typename T> inline T min(const T&, const T&); //错误：inline 说明符的位置不正确 inline template <typename T> T min(const T&, const T&); 16.1.1.4 编写类型无关的代码 为了提高适用性，模板程序应尽量减少对实参类型的要求。 模板中的函数参数是 const 的引用。这样做一方面保证了即使参数类型不支持拷贝，模板程序也能正确运行；另一方面引用不会引起对象的拷贝构造，提高运行性能。 模板中使用到的类型相关的函数或运算符应尽可能的少。 16.1.1.5 模板编译 当编译器遇到一个模板定义时，它并不生成代码。只有当我们实例化出模板的一个特定版本时，编译器才会生成代码。 通常，当我们调用一个函数时，编译器只需要掌握函数的声明。类似的，当我们使用一个类类型的对象时，类定义必须是可用的，但成员函数的定义不必已经出现。因此，我们将类定义和函数声明放在头文件中，而普通函数和类的成员函数的定义放在源文件中。 为了生成一个实例化版本，编译器需要掌握函数模板或类模板成员函数的定义。因此，与非模板代码不同，模板不能分离式编译，其头文件中通常既包括声明也包括定义。 16.1.1.6 大多数编译错误在实例化期间报告 模板直到实例化时才会生成代码，大多数编译错误在实例化期间报告。通常，编译器会在三个阶段报告错误。 第一个阶段是编译模板本身时。这个阶段，编译器可以检查语法错误，如忘记分号或者变量名拼错等。 第二个阶段是编译器遇到模板使用时。对于函数模板调用，会检查实参数目是否正确和参数类型是否匹配。对于类模板，则只检查模板实参数目是否正确。 第三个阶段是模板实例化时，只有这个阶段才能发现类型相关的错误。依赖于编译器如何管理实例化，这类错误可能在链接时才报告。 16.1.2 类模板 类模板（class template）是用来生成类的蓝图的。与函数模板的不同之处是，编译器不能为类模板推断模板参数类型。使用时，必须显式提供模板实参。 16.1.2.1 定义类模板 在类模板（及其成员）的定义中，我们将模板参数当做替身，代替使用模板时用户需要提供的类型或值： template < typename T > class Bolb { public : typedef T value_type ; typedef typename std :: vector < T >:: size_type size_type ; //构造函数 Bolb (); Bolb ( std :: initializer_list < T > il ); //Bolb中的元素数目 size_type size () const { return data -> size (); } bool empty () const { return data -> empty (); } //添加和删除元素 void push_back ( const T & t ) { data -> push_back ( t ); } //移动版本 void push_back ( T && t ) { data -> push_back ( std :: move ( t )); } void pop_back (); //元素访问 T & back (); T & operator []( size_type i ); private : std :: shared_ptr < std :: vector < T >> data ; //若data[i]无效，则抛出msg void check ( size_type i , const std :: string & msg ) const ; }; 16.1.2.2 实例化模板 当使用一个类模板时，我们必须提供额外信息。我们现在知道这些额外信息是显式模板实参（explicit template argument）列表，它们被绑定到模板参数。例如： Bolb<int> ia; //空 Bolb<int> Bolb<int> ia2 = {0,1,2,3,4}; //有5个元素的 Bolb<int> 一个类模板的每个实例都形成一个独立的类。Bolb 与任何其他 Bolb 类型没有关联，也不会对任何其他 Bolb 类型的成员有特殊访问权限。 16.1.2.3 类模板的成员函数 我们既可以在类模板内部，也可以在外部为其定义成员函数。定义在类模板之外的成员函数必须以关键字 template 开始，后接类模板参数列表。 默认情况下，一个类模板的成员函数只有当程序用到它时才进行实例化。这一特性使得即使某种类型不能完全符合模板操作的要求，仍然能用该类型实例化类，但相应操作无法使用！ 16.1.2.4 在类代码内简化模板类型的使用 在类模板自己的作用域中，我们可以直接使用模板名而不提供实参，其他情况下都必须提供模板实参。： template < typename T > class BolbPtr { public : ... //递增和递减 BolbPtr & operator ++ (); //前置运算符 BolbPtr & operator -- (); ... }; 上述 BolbPtr 的前置递增和递减成员返回 BolbPtr&，而不是 BolbPtr &。当我们处于一个类模板的作用域时，编译器处理模板自身引用时就好像我们已经提供了与模板参数匹配的实参一样。 template <typename T> // 返回类型，处于类的作用域之外，需要提供模板实参 BlobPtr<T> BlobPtr<T>::operator++(int) { // 函数体内，处于类的作用域之内 BlobPtr ret = *this; ... } 16.1.2.5 类模板和友元 如果一个类模板包含一个非模板友元，则友元被授权可以访问所有模板实例；如果友元自身是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例。 一对一友好关系。用相同模板实参实例化的友元是该类的友元，可以访问非 public 部分，而对于用其他实参实例化的实例则没有特殊访问权限。 // 为了在 Blob 中声明友元，需要前置声明 template < typename T > class BlobPtr ; template < typename T > class Blob ; // 声明运算符 == 中的参数所需要的 template < typename T > bool operator == ( const Blob < T > & lhs , const Blob < T > & rhs ); template < typename T > class Blob { // 每个 Blob 实例将访问权限授予用相同类型实例化的 BlobPtr 和相等运算符 friend class BlobPtr < T > ; friend bool operator ==< T > ( const MyBlobPtr & lhs , const MyBlobPtr & rhs ); // 其它成员定义 }; // BlobPtr<char> 的成员可以访问 ca（或任何其它 Blob<char>对象）的非 public 部分 Blob < char > ca ; Blob < int > ia ; 通用和特定的模板友好关系。为了让所有实例成为友元，友元声明中必须使用与类模板本身不同的模板参数。 // 前置声明，在将模板的一个特定实例声明为友元时要用到 template < typename T > class Pal ; class C { // C是一个普通的非模板类 friend class Pal < C > ; // 用类 C 实例化的 Pal 是 C 的一个友元 // Pal2 的所有实例都是 C 的友元，这种情况无须前置声明 template < typename T > friend class Pal2 ; }; template < typename T > class C2 { // C2 本身是一个模板 // C2 的每个实例将相同实例化的 Pal 声明为友元 friend class Pal < T > ; // Pal 的模板声明必须在作用域之内 // Pal2 的所有实例都是 C2 的每个实例的友元，不需要前置声明 template < typename X > friend class Pal2 ; // Pal3 是一个非模板类，它是 C2 所有实例的友元 friend class Pal3 ; // 不需要 Pal3 的前置声明 }; 令模板自己的类型参数成为友元。在 C++11 新标准中，我们可以将模板类型参数声明为友元： template < typename Type > class Bar { friend Type ; //将访问权限授予用来实例化 Bar 的类型 //... }; 因此，对于某个类型名 Foo，Foo 将成为 Bar 的友元。 16.1.2.6 模板类型别名 类模板的一个实例定义了一个类型，与任何其他类类型一样，我们可以定义一个 typedef 来引用实例化的类： typedef Blob<string> StrBlob; 由于模板不是一个类型，我们不能定义一个 typedef 引用一个模板。即，无法定义一个 typedef 引用 Blob 。 但是，C++11 新标准允许我们为类模板定义一个类型别名： template <typename T> using twin = pair<T,T>; twin<string> authors; //autohors 是一个 pair<string,string> 当我们定义一个模板类型别名时，可以固定一个或多个模板参数： template <typename T> using partNo = pair<T, unsigned>; partNo<string> books; //books 是一个 pair<string, unsigned> partNo<Vehicle> cars; //cars 是一个 pair<Vehicle, unsigned> partNo<Student> kids; //kids 是一个 pair<Student, unsigned> 16.1.2.7 类模板的 static 成员 对于类模板 Foo 中的 static 成员 ctr，对于任意给定类型 X，都有一个 Foo::ctr 成员。所有 Foo 类型的对象共享相同的 ctr 成员： template < typename T > class Foo { public : static std :: size_t count () { return ctr ; } // 其它接口成员 private : static std :: size_t ctr ; // 其它数据成员 } ; // 所有三个对象共享相同的 Foo < int > :: ctr 和 Foo < int > :: count 成员 Foo < int > fi , fi2 , fi3 ; 类模板的 static 成员，可以通过类类型对象来访问，也可以用作用域运算符直接访问该成员，不过必须提供一个特定的模板实参。另外， static 成员函数也是只在使用时才会被初始化： Foo < int > fi ; // 实例化 Foo < int > 类和 static 数据成员 ctr auto ct = Foo < int > :: count (); // 实例化 Foo < int > :: count ct = fi . count (); // 使用 Foo < int > :: count ct = Foo :: count (); // 错误 ， 无法确定使用哪个模板实例化的 count 16.1.3 模板参数 一个模板参数的名字也没有什么内在含义，我们通常将类型参数命名为 T，但实际上我们可以使用任何名字。 模板参数名的可用范围是在其声明之后，至模板声明或定义结束之前。模板参数会隐藏外层作用域中声明的相同名字，但是在模板内不能重用模板参数名。 typedef double A; template <typename A, typename B> void f(A a, B b) { A tmp = a; // tmp的类型为模板参数 A 的类型，而非 double double B; // 错误，重声明模板参数 B } 模板声明必须包含模板参数，声明中的模板参数的名字不必与定义中相同。 template <typename T> class Blob; // 声明但不定义 16.1.3.1 使用类的类型成员 假定 T 是一个模板类型参数，当编译器遇到类似 T::mem 这样的代码时，它不知道 mem 是一个类型成员还是一个 static 数据成员，直至实例化时才会知道。 但是为了处理模板，编译器必须知道名字是否表示一个类型。例如： T::size_type * p; 。编译器需要知道我们是在定义一个名为 p 的变量还是将一个名为 size_type 的 static 数据成员与名为 p 的变量相乘。 默认情况，C++ 语言假定通过作用域运算符访问的名字不是类型。因此，如果我们希望使用一个模板类型参数的类型成员，就必须显式告诉编译器该名字是一个类型。 我们通过使用关键字 typename 来实现这一点： template < typename T > typename T :: value_type top ( const T & c ) { if (!c.empty()) return c.back() ; else return typename T : : value_type (); } 16.1.3.2 默认模板实参 在新标准中，我们可以为函数和类模板提供默认实参。而更早的 C++ 标准只允许为类模板提供默认实参。 //compare有一个默认模板实参 less<T> 和一个默认函数实参 F() template <typename T, typename F = less<T>> int compare(const T &v1, const T &b2, F f = F()) { if (f(v1, v2)) return -1; if (f(v2, v1)) return 1; return 0; } 如果一个类模板为其所有模板参数都提供了模板实参，且我们希望使用这些默认实参，就必须在模板名之后跟一个空尖括号对。 16.1.4 成员模板 一个类可以包含本身是模板的成员函数。这种成员被称为成员模板（member template）。成员模板不能是虚函数（Member template functions cannot be declared virtual.Current compiler technology experts to be able to determine the size of a class's virtual function table when the class is parsed.Allowing virtual member template functions woule require knowing all calls to such member functions everywhere in the program ahead of time.This is not feasible,especially for multi-file projects.） 16.1.4.1 普通（非模板）类的成员模板 我们定义一个类，类似 unique_ptr 所使用的默认删除器类型： //函数对象类，对给定指针执行 delete class DebugDelete { public : DebugDelete ( std :: ostream & s = std :: cerr ) : os ( s ) {} //与任何函数模板相同，T 的类型由编译器推断 template < typename T > void operator ()( T * p ) const { os << \"deleting unqiue_ptr\" << std :: endl ; delete p ; } private : std :: ostream & os ; }; 我们可以用这个类代替 delete ： double *p = new double; DebugDelete d; //可像 delete 表达式一样使用的对象 d(p); //调用 DebugDelete::operator()(double*),释放 p int* ip = new int; //在一个临时 DebugDelete 对象上调用 operator()(int*) DebugDelete()(ip); 16.1.4.2 类模板的成员模板 在此情况下，类和成员各有自己的独立的模板参数。例如，我们将 Blob 类定义一个构造函数，它接受两个迭代器，表示要拷贝的元素范围，我们希望支持不同类型序列的迭代器： template < typename T > class Blob { template < typename It > Blob ( It b , It e ); //... }; 当我们在类模板外定义一个成员模板时，必须同时为类模板和成员模板提供模板参数列表。类模板的参数列表在前，后跟成员自己的模板参数列表： template <typename T> template <typename It> Blob<T>::Blob(It b, It e) : data(std::make_shared<std::vector<T>(b,e)) {} 16.1.4.3 实例化成员模板 为了实例化一个类模板的成员模板，我们必须同时提供类和函数模板的实参： int ia[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; vector<long> vi = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; list<const char*> w = {\"now\", \"is\", \"the\", \"time\"}; //实例化 Blob<int> 类及其接受两个 int* 参数的构造函数 Blob<int> a1(begin(ia), end(ia)); 16.1.5 控制实例化 模板被使用时才会进行实例化，这意味着，当两个或多个独立编译的源文件使用了相同的模板，并提供了相同的模板参数时，每个文件中就都会有该模板的一个实例。 相同的实例可能出现在多个对象文件中，在多个文件中实例化相同模板的额外开销可能非常大。在新标准中，我们可以通过显示实例化（explicit instantiation）来避免这种开销。 形式： extern template declaration; //实例化声明 template declaration; //实例化定义 declaration 是一个类或函数声明，其中所有模板参数已被替换为模板实参，例如： //实例化声明与定义 extern template class Blob<string>; //声明 template int compare(const int&, const int&); //定义 当编译器遇到 extern 模板声明时，它不会在本文件中生成实例代码。将一个实例化声明为 extern 就表示承诺在程序其他位置有该实例化的一个非 extern 声明（定义）。对于一个给定的实例化版本，可能有多个 extern 声明，但必须只有一个定义。 由于编译器在使用一个模板时自动对其实例化，因此 extern 声明必须出现在任何使用此实例化版本的代码之前： // Application.cc // 这些模板类型必须在程序其它位置进行实例化 extern template class Blob<string>; extern template int compare(const int&, const int&); Blob<string> sa1, sa2; // 实例化会出现在其他位置 // Blob<int>及其接受 initializer_list 的构造函数在本文件中实例化 Blob<int> a1 = {0, 1, 2, 3, 4}; Blob<int> a2(a1); // 拷贝构造函数在本文件中实例化 int i = compare(a1[0], a2[0]); // 实例化出现在其他位置 // templateBuild.cc // 实例化文件必须为每个在其他文件中声明为 extern 的类型和函数提供一个（非 extern）的定义 template int compare(const int&, const int&); template class Blob<string>; 与类模板的普通实例化不同，类模板的显式实例化定义会实例化该模板的所有成员。因此，用来显示实例化一个类模板的类型，必须能用于模板的所有成员。 16.1.6 效率与灵活性 对模板设计者所面对的设计选择，标准库智能指针类型给出了一个很好的展示。 shared_ptr 和 unique_ptr 之间的明显不同是它们管理所保存的指针的策略——前者给予我们共享指针所有权的能力；后置则独占指针。 这两个类的另一差异是它们允许用户重载默认删除器的方式：我们可以很容器地重载一个 shared_ptr 的删除器，只要在创建或 reset 指针时传递给他一个可调用对象即可；与之相反，删除器类型是 unique_ptr 对象类型的一部分，用户必须在定义 unique_ptr 时以显示模板实参的形式提供删除器的类型。 16.1.6.1 在运行时绑定删除器（shared_ptr） 虽然我们不知道标准库类型是如何实现的，但可以推断出， shared_ptr 必须能直接访问其删除器。即删除器必须保存为一个指针或封装了指针的类。 我们可以确定 shared_ptr 不是将删除器直接保存为一个成员，因为删除器的类型运行时才会知道。 16.1.6.2 在编译时绑定删除器（unique_ptr） 现在，让我来考察 unique_ptr 可能的工作方式： 在这个类中，删除器的类型是类类型的一部分。即 unique_ptr 有两个模板参数，一个表示它所管理的指针，另一个表示删除器的类型。 由于删除器类型是 unique_ptr 的一部分，因此删除器成员的类型在编译时是知道的，从而删除器可以直接保存在 unique_ptr 对象中。 总结：通过在编译时绑定删除器， unique_ptr 避免了间接调用删除器的运行时开销。通过在运行时绑定删除器， shared_ptr 使用户重载删除器更为方便。 16.2 模板实参推断 我们已经看到，对于函数模板，编译器利用调用中的函数实参来确定其模板实参。从函数实参来确定模板实参的过程被称为模板实参推断（template argument deduction）。 16.2.1 类型转换与模板类型参数 只有很有限的几种类型转换会自动地应用于模板实参，编译器通常不是对实参进行类型转换，而是生成一个新的模板实例： 顶层 const ，无论是在形参还是实参中，都会被忽略 const 转换，可以将一个非 const 对象的引用（或指针）传递给一个 const 的引用（或指针）形参 数组或函数指针转换：如果函数形参不是引用类型，则可以对数组或函数类型的实参应用正常的指针转换 其他类型转换，如算术转换，派生类向基类转换以及用户定义的转换都不能应用于函数模板 template <typename T> T fobj(T, T); //实参被拷贝 template <typename T> T fref(const T&, const T&); //引用捕获方式；c 显示捕获，值捕获方式 string s1(\"a value\"); const string s2(\"another value\"); fobj(s1, s2); //调用 fobj(string, string);const 被忽略 fref(s1, s2); //调用 fref(const string&, const string&),将 s1 转换为 const 是允许的 int a[10], b[42]; fobj(a, b); //调用 f(int*, int*) fref(a, b); //错误：数组类型不匹配 将实参传递给带模板类型的函数形参时，能够自动应用的类型转换只有 const 转换以及数组或函数到指针的转换。 正常类型转换应用于普通函数实参 函数模板可以有用普通类型定义的参数，即，不涉及模板类型参数的类型。这种函数实参不进行特殊处理；它们正常转换为对应形参的类型。例如： template <typename T> ostream &print(ostream &os, const T &obj) { return os << obj; } //第一个函数参数是一个已知类型 ostream&。第二个参数 obj 则是模板参数类型 //由于 os 的类型是固定的，因此当调用 print 时，传递给它的实参会进行正常的 //类型转换 print(const , 42); //实例化 print(ostream&, int) ofstream f(\"output\"); print(f, 10); //使用 print(ostream&, int);将 f 转换为 ostream& 如果函数参数类型不是模板参数，则对实参进行正常的类型转换。 16.2.2 函数模板显式实参 在某些情况下，编译器无法推断出模板实参的类型。其他一些情况下，我们希望允许用户控制模板实例化。 16.2.2.1 指定显式模板实参 //编译器无法推断 T1，它未出现在函数参数列表中 template <typename T1, typename T2, typename T3> T1 sum(T2, T3); 本例中，没有任何函数实参的类型可用来推断 T1 的类型。每次调用 sum 时调用者都必须为 T1 提供一个显式模板实参（explicit template argument）。如下： //T1 是显示指定的，T2 和 T3 是从函数实参类型推断而来的 auto val3 = sum<long long>(i, lng); //long long sum(int, long) 显示模板实参按由左至右的顺序与对应的模板参数匹配。推断不出的模板参数的类型在定义时应该放在参数列表的最左边。 16.2.2.2 正常类型转换应用于普通函数实参 对于模板类型参数已经显式指定了的函数实参，可以进行正常的类型转换。 long lng; compare(lng, 1024); // 错误，模板参数不匹配 compare<long>(lng, 1024); // 正确，1024自动转化为 long 16.2.3 尾置返回类型与类型转换 例如，我们可能希望编写一个函数，接受表示序列的一对迭代器和返回序列中一个元素的引用。但是，我们并不知道返回结果的准确类型，但知道所需类型是处理的序列的元素类型。由于尾置返回出现在参数列表之后，它可以使用函数的参数： //尾置返回允许我们在参数列表之后声明返回类型 template <typename It> auto fcn(It beg, It end) -> decltype(*beg) { //处理序列 return *beg; //返回序列中一个元素的引用 } 使用类型转换的标准库模板类 为了获取元素类型，我们可以使用标准库的类型转换（type transformation）模板。这些模板定义在头文件 type_traits 中。这个头文件的类通常用于模板元编程设计。 // 返回一个序列中的元素值 // 为了使用模板参数的类型成员，必须使用 typename template <typename It> auto fcn(It beg, It end) -> typename remove_reference<decltype(*beg)>::type; { // 处理序列 return *beg; } 16.2.4 函数指针和实参推断 使用函数模板初始化一个函数指针或为一个函数指针赋值时，编译器使用指针的类型来推断模板实参。如果不能从函数指针类型确定模板实参，则产生错误。 template <typename T> int compare(const T&, const T&); // func 的重载版本，每个版本接受一个不同的函数指针类型 void func(int(*)(const string&, const string&)); void func(int(*)(const int&, const int&)); func(compare); // 错误，不能确定使用哪一个实例 // 正确的做法是可以显式指出实例化哪个版本 func(compare<int>); 16.2.5 模板实参推断和引用 16.2.5.1 从左值引用函数参数推断类型 template <typename T> void f(T &p) ：实参必须是一个左值。如果实参是 const 的，则 T 将被推断为 const 类型。 template <typename T> void f(const T &p) ：实参可以是任意类型(包括右值在内)，即使实参是 const 的，T 的推断类型也不会是一个 const 类型。 16.2.5.2 从右值引用函数参数推断类型 传递的实参为右值。推断出的 T 的类型是该右值实参的类型。 传递的实参为左值。此时得到的模板参数和函数参数都是左值引用。 对于接受右值引用参数的模板函数，当分别传递右值和左值实参时，模板参数类型可能是普通类型，也可能是引用类型。有时这可能会造成意想不到的结果。解决这种问题的办法是，使用基于函数参数的模板重载，来将实参分别为右值或左值时的情况分离开来： template <typename T> void f3(T&&) { T t = val; // 实参为右值时，赋值语句 // 实参为左值时，绑定引用 t = fcn(t); // 实参为右值时，只改变 t // 实参为左值时，既改变 t，也改变 val } // 定义一组重载函数，解决上述问题 template <typename T> void f(T&&); // 绑定到非 const 右值 template <typename T> void f(const T&); // 绑定到左值和 const 右值 16.2.6 理解 std::move 由于 move 本质上可以接受任何类型的实参，因此我们不会惊讶于它是一个函数模板。 标准库是这样定义 move 的： //在返回类型和类型转换中也要用到 typename template <typename T> typename remove_reference<T>::type&& move(T&& t) { //特例：可以使用 static_cast 显式地将左值转换为右值 return static_cast<typename remove_reference<T>::type&&>(t); } 16.2.7 转发 某些函数需要将其一个或多个实参连同类型不变地转发给其它参数，需要保持转发实参的所有性质，包括实参类型是否是 const 的以及实参是左值还是右值。 // 该模板将两个额外参数逆序传递给指定的可调用对象 template<typename F, typename T1, typename T2> void flip1(F f, T1 t1, T2 t2) { f(t2, t1); } // flip1 一般情况下工作的很好，但是当用它调用一个接受引用参数的函数时会出现问题 void f(int v1, int &v2) { cout << v1 << \" \" << ++v2 << endl; } f(42, i); // f 改变了实参 i flip1(f, j, 42) // j 的值不会改变 如果一个函数参数是指向模板类型参数的右值引用（如 T&&），它对应的实参的 const 属性和左值/右值属性将得到保持。使用这种方案改写上面的 flip1 函数。 // 该模板将两个额外参数逆序传递给指定的可调用对象 template<typename F, typename T1, typename T2> void flip2(F f, T1 &&t1, T2 &&t2) { f(t2, t1); } // flip2 对接受左值引用函数工作的很好，但不能用于接受右值引用的函数 void g(int &&v1, int &v2) { cout << v1 << \" \" << v2 << endl; } g(42, i); // 正确 flip1(g, i, 42) // 错误，g 中接收到的 \"42\" 是左值 当我们试图通过 flip2 调用 g，则参数 t2 将被传递给 g 的右值引用参数（即使我们传递一个右值给 filp2，也会被拷贝到 t2）。函数参数是左值表达式，不能用于实例化右值。 当用于一个指向模板参数类型的右值引用函数（T&&）时， forward 会保持实参类型的所有细节。与 move 不同， forward 必须通过显式模板实参来调用。 forward 也定义在 utility 头文件中。下面使用 forward 重写翻转函数： template < typename F , typename T1 , typename T2 > void flip3 ( F f , T1 && t1 , T2 && t2 ) { f( std : : forward < T2 > ( t2 ), std :: forward < T1 > ( t1 ) ); } 16.3 重载与模板 函数模板可以被另一个模板或一个普通非函数模板重载，与往常一样，名字相同的函数，必须具有不同数量或类型的参数。如果涉及函数模板，则函数匹配规则会在以下几个方面受到影响: 对于一个调用，其候选函数包括所有模板实参推断成功的函数模板实例 候选的函数模板总是可行的，因为模板实参推断会排除任何不可行的模板 与往常一样，可行函数（模板与非模板）按类型转换（如果对此调用需要的话）来排序。当然，可以用于函数模板调用的类型转换是非常有限的（参考前文） 与往常一样，如果恰有一个函数提供比任何其他函数都更好的匹配，则选择此函数。但是如果有多个函数提供同样好的匹配，则：（1）如果同样好的函数中只有一个是非模板函数，则选择此函数；（2）如果同样好的函数中没有非模板函数，而有多个函数模板，且其中一个模板比其它模板更特例化则选择此模板；（3）否则，此调用有歧义 // 通用模板 ， 返回 T 型对象 t 的 string 表示 template < typename T > string debug_rep ( const T & t ) { std : : ostringstream ret ; ret << t ; return ret.str() ; } // 通用模板 ， 返回 T 型指针 p 的 string 表示 template < typename T > string debug_rep ( T * p ) { std : : ostringstream ret ; // 打印指针本身的值 ret << \" pointer : \" << p; // p不为空，则打印 p指向的值 if (p) ret << \" \" << debug_rep(*p); else ret << \" null pointer \"; return ret.str(); } // 对于下面的代码调用，只会使用第一个模板 string s(\" hi \"); cout << debug_rep(s) << endl; // 对于下面的代码调用，最终会调用第二个模板 cout << debug_rep(&s) << endl; // 对于下面的代码调用，最终会调用第二个模板 const string *sp = \" hi \"; cout << debug_rep(sp) << endl; // 再定义一个普通非模板函数，打印双引号包围的 string string debug_rep(const string &s) { cout << '\" ' + s + ' \"'; } // 对于下面的代码调用，会使用普通非模板函数 cout << debug_rep(s) << endl; // 对于下面的代码调用，最终会调用第二个模板 cout << debug_rep(\" hi \" ) << endl ; 对于第一个模板参数 const T &t ，当实例化 string * 参数时，模板参数是 string * ，而函数参数是 string * const &t ，表示 t 是引用，引用自 string 型指针（本身是常量）。在进行模板实参推断之后会进行普通函数的函数匹配过程。而 string * const &t 中的顶层 const 属性也会被略去，即 f(string * const &t)和 f(string *t) 存在二义性。此时后者更特例化，所以编译器实际执行的是后者。 对于第一个模板参数 const T &t ，当实例化 const string * 参数时，模板参数是 const string * ，而函数参数是 const string * const &t ，表示 t 是引用，引用自 string 型指针（指向常量，且本身是常量）。所以，同样地， f(const string * const &t)和 f(const string *t) 存在二义性。此时后者更特例化，所以编译器实际执行的是后者。 对于第一个模板，T 的类型为 char[3] ；对于第二个模板，T 的类型是 const char ；对于普通非模板函数，要求从 const char* 到 string 的类型转换。此时，3个候选函数都是可行的。普通函数由于需要进行类型转换，可以首先排除掉。而剩下两个模板函数，后者更特例化，所以编译器实际执行的是后者。 在定义任何函数之前，记得声明所有重载的函数版本。这样就不必担心编译器由于未遇到你希望调用的函数，而实例化一个并非你所需的版本: template <typename T> string debug_rep(const T &t); template <typename T> string debug_rep(T *p); // 为了使 debug_rep(char*) 的定义正确工作，下面的声明必须在作用域中 string debug_rep(const string &); string debug_rep(char *p) { // 如果接受一个 const string&的版本的声明不在作用域中， // 返回语句将调用 debug_rep(const T &t) 的 T 实例化为 string 的版本 return debug_rep(string(p)); } 16.4 可变参数模板 一个可变参数模板（variadic template）就是一个接受可变数目参数的模板函数或模板类。可变数目的参数被称为参数包（parameter packet）。存在两种参数包：模板参数包，函数参数包。 在一个模板参数列表中， class... 或 typename... 指出，接下来的参数表是零个或多个类型的列表；一个类型名后面跟一个省略号表示零个或多个给定类型的非类型参数的列表。在函数参数列表中，如果一个参数的类型是一个模板参数包，则此参数也是一个函数参数包。 // Args 是一个模板参数包； rest 是一个函数参数包 // Args 表示零个或多个模板类型参数 // rest 表示零个或多个函数参数 template <typename T, typename... Args> void foo(const T &t, const Args& ... rest); // 对于下面调用 int i = 0; foo(i, \"hi\"); // 包中有一个参数，实例化为 foo(const int &, const char[3]&); foo(\"hi\"); // 空包，实例化为 foo(const char[3]&); sizeof... 运算符可以返回一个常量表达式，表示包中的元素个数，而且不会对其实参求值： template<typename... Args> void g(Args... args) { cout << sizeof...(Args) << endl; // 类型参数的数目 cout << sizeof...(args) << endl; // 类型参数的数目 } 16.4.1 编写可变参数函数模板 initializer_list 用来表示一组类型相同的可变数目参数，而当类型也是未知时，则需要使用可变参数函数模板。可变参数函数通常是递归的，第一步调用处理包中的第一个实参，然后用剩余实参调用自身。 // 用来终止递归并打印最后一个元素的函数 // 此函数必须在可变参数版本的 print 定义之前声明 template<typename T> ostream& print(ostream &os, const T &t) { return os << t; // 包中最后一个元素之后不打印分隔符 } // 包中除了最后一个元素之外的其他元素都会调用这个版本的 print template<typename T, typename... Args> ostream& print(ostream &os, const T &t, const Args&... rest) { os << t << \", \"; // 打印第一个实参 return print(os, rest...); // 递归调用，打印其他实参 } 给定 print(cout, i, s, 42)，其调用过程如下： 对于最后一次递归调用 print(cout, 42)，两个 print 版本都是可行的。但是因为非可变参数模板比可变参数模板更特例化，因此编译器选择非可变参数版本。另外，定义可变参数版本的 print 时，非可变参数版本的声明必须在作用域中，否则，可变参数版本会无限递归。 16.4.2 包扩展 当扩展一个包时，可以提供用于每个扩展元素的模式。扩展一个包就是将它分解为构成的元素，对每个元素应用模式，获得扩展后的列表。通过在模式右边放一个省略号（...）来触发扩展操作。 template<typename T, typename... Args> ostream& print(ostream &os, const T &t, const Args&... rest) // 扩展 Args { os << t << \", \"; return print(os, rest...); // 扩展 rest } // 对 Args 的扩展中，将模式 const Arg& 应用到模板参数包 Args 中的每个元素 print(cout, i, s, 42); // 实例化的形式为 ostream& print(ostream &, const int&, const string&, const int&); print 中的函数参数包扩展仅仅将包扩展为其构成元素，还可以进行更复杂的扩展模式。比如，对其每个实参调用之前出现过的 debug_rep： template<typename... Args> ostream& errorMsg(ostream &os, const Args&... rest) { print(os, debug_rep(rest)...); // 上式等价于 print(os, debug_rep(a1), debug_rep(a2), ..., debug_rep(a3)); // 注意，不可以写成下式形式 print(os, debug_rep(rest...)); // 错误，此调用无匹配函数 return os; } 扩展中的模式会独立地应用于包中的每个元素。 16.4.3 转发参数包 可变参数函数通常将它们的参数转发给其他函数，这种函数具有与容器中的 emplace_back 函数一样的形式。work 调用中的扩展既扩展了模板参数包也扩展了函数参数包： // fun 有零个或多个参数 ， 每个参数都是一个模板参数类型的右值引用 template < typename ... Args > void fun ( Args &&... args ) // 将 Args 扩展为一个右值引用的列表 { // work的实参既扩展 Args又扩展 args work( std : : forward < Args > ( args ) ... ); } 16.5 模板特例化 在某些情况下，通用模板的定义可能编译失败、做的不正确，或者利用特定知识来编写更高效的代码，而不是从通用模板实例化。这时可以定义类或函数模板的一个特例化版本。 当我们特例化一个函数模板时，必须为元模板中的每个模板参数都提供实参。为了指出我们正在实例化一个模板，应使用关键字 template 后跟一个空尖括号对（<>）。空尖括号指出我们将为原模板的所有模板参数提供实参。 // 第一个版本，可以比较任意两个类型 template <typename T> int compare(const T&, const T&); // 第二个版本，处理字符串字面常量 template <size_t N, size_t M> int compare(const cahr (&p1)[N], const cahr (&p2)[M]); const char *p1 = \"hi\", *p2 = \"mom\"; compare(p1, p2); // 调用第一个版本 compare(\"hi\", \"mom\"); // 调用第二个版本 // compare 的特例化版本，处理字符数组的指针 template <> int compare(const char* const &p1, const char* const &p2) { return strcmp(p1, p2); } // 参数类型为指针，不能调用第二个版本，这里调用的是特例化版本 compare(p1, p2); 我们希望定义此函数的一个特例化版本，其中 T 的类型为 const char * 。我们的函数要求一个指向此类型的 const 版本的引用。所以 p1 是一个指向 const char 的 const 指针的引用。 16.5.1 函数重载与模板特例化 当定义函数模板的特例化版本时，我们本质上接管了编译器的工作，一个特例化版本本质上是一个实例，而非函数名的一个重载版本。因此，特例化不影响函数匹配。 模板及其特例化版本应该声明在同一个头文件中。所有同名模板的声明应该放在前面，然后是这些模板的特例化版本。 16.5.2 类模板特例化 作为例子，这里为 Sales_data 类定义特例化版本的 hash 模板。而定义了 hash 模板的特例化版本的类类型，可以存储在无序容器中。为了让 Sales_data 类的用户能使用 hash 的特例化版本，应该在 Sales_data 的头文件中定义该特例化版本。一个特例化 hash 类必须定义： 一个重载的调用运算符，它接受一个容器关键字类型的对象，返回一个 size_t 两个类型成员， result_type 和 argument_type ，分别表示调用运算符的返回类型和参数类型 默认构造函数和拷贝赋值运算符（可以隐式定义） template < typename T > struct std :: hash ; class Sales_data { friend struct std :: hash < Sales_data > ; // 其它数据成员 }; // 为了使 Sales_data 能存储在无序容器中，特例化 hash 模板 // 注意， Sales_data 类应支持 == 操作 namespace std { template <> struct hash < Sales_data > { typedef size_t result_type ; typedef Sales_data argument_type ; size_t operator ()( const Sales_data & s ) const ; }; inline size_t hash < Sales_data >:: operator ()( const Sales_data & s ) const { std :: cout << \"hash模板的 Sales_data特例化版本\" << std :: endl ; return hash < string > ()( s . bookNo ) &#94; hash < unsigned > ()( s . units_sold ) &#94; hash < double > ()( s . revenue ); } } 16.5.3 类模板部分特例化 可以指定一部分而非所有模板参数，或是参数的一部分而非全部特性。一个类模板的部分特例化本身是一个模板，使用它时用户还必须为那些在特例化版本中未指定的模板参数提供实参。只能部分特例化类模板，而不能部分特例化函数模板。 16.5.4 特例化成员而不是类 template <typename T> struct Foo { Foo(cosnt T &t = T()) : men(t) {} void Bar() { /* ... */ } T men; // Foo 的其他成员 }; template<> // 表示正在特例化一个模板 void Foo<int>::Bar() // 正在特例化 Foo<int> 的成员 Bar { // 进行应用于 int的特例化处理 } Foo<string> fs; // 实例化 Foo<string>::Foo() fs.Bar(); // 实例化 Foo<string>::Bar() Foo<int> fi; // 实例化 Foo<int>::Foo() fi.Bar(); // 使用特例化版本的 Foo<int>::Bar()","tags":"读书笔记","url":"https://xutree.github.io/pages/2018/10/21/C++_Primer_Chapter_16/"},{"title":"C++ Primer 第十五章 面向对象程序设计","text":"15.1 OOP：概述 面向对象程序设计（object-oriented programming）的核心思想是数据抽象、继承和动态绑定。 15.1.1 继承 通过继承（inheritance）联系在一起的类构成一种层次关系。在 C++ 语言中，基类将类型相关的函数与派生类不做改变直接继承的函数区分对待。对于某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明成虚函数（virtual function）。 class Quote { public : std :: string isbn () const ; virtual double net_price ( std :: size_t n ) const ; }; 派生类必须通过使用派生列表（class derivation list）明确指出它是从哪个(哪些)基类继承而来的： class Bulk_quote : public Quote { public : double net_price ( std :: size_t ) const override ; }; 派生类必须在其内部对所有重新定义的虚函数进行声明。派生类可以在这样的函数之前加上 virtual 关键字，但是并不是非得这么做。并且，C++11 新标准允许派生类显式地注明它将使用哪个成员函数改写基类的虚函数，具体措施是在改函数的形参列表之后增加一个 override 关键字。 15.1.2 动态绑定 函数的运行版本由实参决定，即在运行时选择函数的版本，所以动态绑定有时又称为运行时绑定（run-time binding）。 在 C++ 语言中，当我们使用基类的引用（或指针）调用一个虚函数时将发生动态绑定。 15.2 定义基类和派生类 15.2.1 定义基类 基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。 15.2.1.1 成员函数与继承 基类必须将它的两种成员函数区分开来：一种是基类希望其派生类进行覆盖的函数，基类通常将其定义为虚函数；另一种是基类希望派生类直接继承而不要改变的函数。 任何构造函数之外的非静态函数都可以是虚函数，关键字 virtual 只能出现在类内部的声明语句之前而不能用于类外部的函数定义。 如果基类把一个函数声明为虚函数，则该函数在派生类中隐式地也是虚函数。 成员函数如果没被声明为虚函数，则其解析过程发生在编译时而非运行时。 15.2.1.2 访问控制与继承 派生类可以继承定义在基类中的成员，但是派生类的成员函数不一定有权访问从基类继承而来的成员。 派生类能访问公有成员，而不能访问私有成员。 不过在某些时候，基类中还有一种成员，基类希望它的派生类有权访问该成员，同时禁止其他用户访问。我们用受保护的（protected）访问运算符说明这样的成员。 15.2.2 定义派生类 15.2.2.1 派生类中的虚函数 派生类经常（但不总是）覆盖它继承的虚函数。如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为类似于其他的普通成员，派生类会直接继承其在基类中的版本。 C++ 新标准允许派生类显式地注明它使用某个成员函数覆盖了它继承的虚函数。具体做法是在函数后面加上关键字 override 。 15.2.2.2 派生类对象及派生类向基类的类型转换 在派生类对象中含有与其基类对应的组成部分，所以我们能把派生类的对象当成基类对象来使用，而且我们也能将基类的指针或引用绑定到派生类对象中的基类部分上。 这种转换通常称为派生类到基类的(derived-to-base)类型转换。和其他类型转换一样，编译器会隐式地执行这种转换。 在派生类对象中含有与其基类对应的组成部分，这一事实是继承的关键所在。 15.2.2.3 派生类构造函数 派生类并不能直接初始化这些从基类继承来的成员，派生类必须使用基类的构造函数来初始化它的基类部分。 每个类控制它自己的成员初始化过程。 除非我们特别指出，否则派生类对象的基类部分会向数据成员一样执行默认初始化。如果想使用其他的基类构造函数，就需要以类名加圆括号内的实参列表的形式为构造函数提供初始值。 首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员。 15.2.2.4 派生类使用基类的成员 派生类可以访问基类的共有成员和受保护的成员。 15.2.2.5 继承与静态成员 如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。不论从基类中派生出来多少个派生类，对于每个静态成员来说都只存在唯一的实例。 静态成员遵循通用的访问控制规则，如果基类中的成员是 private 的，则派生类无权访问它。假设某静态成员是可访问的，则我们既能通过基类也能通过派生类使用它。 15.2.2.6 派生类的声明 派生类的声明与其他类型差别不大，声明中包含类名但不包含它的派生列表： class Bulk_quote : public Quote ; //错误 class Bulk_quote ; //正确 15.2.2.7 被用作基类的类 如果我们想要将某个类用作基类，则该类必须已经定义而非仅仅声明。这一规定的原因显而易见：派生类中包含并且可以使用它从基类继承而来的成员，为了使用这些成员，派生类当然要知道它们是什么。因此这一规定还有一层隐含的含义，即一个类不能派生它本身。 15.2.2.8 防止继承的发生（final） C++11 新标准提供了一种防止继承发生的方法，即在类名后跟一个关键字 final ： class NoDerived final { /* */ }; //NoDerived 不能作为基类 15.2.3 类型转换与继承 理解基类和派生类之间的类型转换是理解 C++ 语言面向对象编程的关键所在。 我们可以将基类的指针或引用绑定到派生类对象上。和内置指针一样，智能指针类也支持派生类向基类的类型转换，这意味着我们可以将一个派生类对象的指针存储在一个基类的智能指针内。 静态类型与动态类型 静态类型在编译时总是已知的，动态类型则是变量或表达式表示的内存中的对象的类型，动态类型直到运行时才可知。 基类的指针或引用的静态类型可能与其动态类型不一致。 如果表达式既不是引用也不是指针，则它的动态类型永远与静态类型一致。 不存在从基类向派生类的隐式类型转换。 在对象之间不存在类型转换：派生类向基类的自动类型转换只能对指针或引用类型有效，在派生类类型和基类类型之间不存在这样的转换。 当我们用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中基类部分会被拷贝、移动或赋值，它的派生类部分将被忽略掉。 15.3 虚函数 我们必须为每一个虚函数都提供定义，而不管它是否被用到，这是因为连编译器也无法确定到底会使用哪个虚函数。 15.3.1 对虚函数的调用可能在运行时才被解析 必须搞清楚的一点是，动态绑定只有当我们通过指针或者引用调用虚函数才会发生。 OOP 的核心思想是多态性（polymorphism）。我们把具有继承关系的多个类型称为多态类型。引用或指针的静态类型与动态类型不同这一事实正是 C++ 语言支持多态性的根本所在。 15.3.2 派生类中的虚函数 一旦某个函数被声明为虚函数，则在所有派生类中它都是虚函数。 一个派生类的函数如果覆盖了某个继承来的虚函数，则它的形参类型必须与被覆盖的基类函数完全一致。该规则有一个例外，当类的虚函数返回类型是类本身的指针或引用时，派生类的虚函数可以返回派生类的指针或引用，只要求从派生类到基类的类型转换是可访问的。 15.3.3 final 和 override 说明符 C++11 新标准中我们可以使用 override 关键字来说明派生类中的虚函数，这么做的好处是使得程序员的意图更加清晰的同时让编译器可以为我们发现一些错误。 我们还能把某个函数指定为 final ，如果我们已经把函数定义成 final 了，则之后任何尝试覆盖该函数的操作都将引发错误。 final 和 override 说明符出现在形参列表（包括任何 const 或引用修饰符）以及尾置返回类型之后。 15.3.4 虚函数与默认实参 如果某次函数调用使用了默认实参，则该实参值由本次调用的 静态类型 决定。如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致。 15.3.5 回避虚函数机制 某些情况下，我们希望对虚函数的调用不要进行动态绑定，而是强迫其执行虚函数的某个特定版本。使用作用域运算符可以实现： // 强制调用基类中定义的函数版本而不管 baseP 的动态类型是什么 double undiscounted = baseP- > Quote :: net_price ( 42 ); 该调用将在编译时完成解析。 15.4 抽象基类 15.4.1 纯虚函数 我们可以将函数定义成纯虚（pure virtual）函数，这样做可以清晰明了地告诉用户这个函数是没有实际意义的。 一个纯虚函数无需定义。通过在函数体的位置（声明语句的分号之前）书写 = 0 就可以将一个虚函数说明为纯虚函数。其中 = 0 只能出现在类内部的虚函数声明语句处： //用于保存折扣值和购买量的类，派生类使用这些数据可以实现不同的价格策略 class Disc_quote : public Quote { public : Disc_quote () = default ; Disc_quote ( const std :: string & book , double price , std :: size_t qty , double disc ) : Quote ( book , price ), quantity ( qty ), discount ( disc ) {} double net_price ( std :: size_t ) const = 0 ; protected : std : size_t quantity = 0 ; //折扣适用的购买量 double discount = 0.0 ; //表示折扣的小数值 }; 我们也可以为纯虚函数提供定义，不过函数体必须定义在类的外部。 15.4.2 含有纯虚函数的类是抽象基类 含有（或未经覆盖直接继承）纯虚函数的类是抽象基类（abstruct base class）。 抽象基类负责定义接口，而后续的其他类可以覆盖该接口。 我们不能创建抽象基类的对象。 派生类构造函数只初始化它的直接基类 15.4.3 重构 重构负责重新设计类的体系以便将操作和/或数据从一个类移动到另一个类中。对于面向对象的应用程序来说，重构是一种很普遍的现象。 15.5 访问控制与继承 15.5.1 受保护的成员 protected 说明符可以看做是 public 和 private 中和后的产物： 和私有成员类似，受保护的成员对于类的用户来说是不可访问的 和公有成员类似，受保护的成员对于派生类的成员和友元来说是可访问的 派生类的成员或友元只能通过派生类对象来访问基类的受保护成员。派生类对于一个基类对象中的受保护成员没有任何访问特权 为了便于理解第（3）条，请看如下示例： class Base { protected : int prot_mem ; //protected 成员 }; class Sneaky : public Base { friend void clobber ( Sneaky & ); //能访问 Sneaky::prot_mem friend void clobber ( Base & ); //不能访问 Base::prot_mem int j ; //j默认是private }; //正确：clobber 能访问 Sneaky 对象的 private 和 protected 成员 void clobber ( Sneaky & s ) { s . j = s . prot_mem = 0 ; } //错误：clobber 不能访问 Base 的 protected 成员 void clobber ( Base & b ) { b . prot_mem = 0 ; } 理解下面两点很重要： 在类内部，类成员函数可访问类的任何一个成员（ public ， pirvate ， protected ）。 但是，在类的外部（比如 main 函数中），类的 pirvate 成员不管是对该类的对象还是该类派生类的对象，都是无访问权限的 15.5.2 公有、私有和受保护继承 某个类对其继承而来的成员的访问权限受到两个因素影响：一是在基类中该成员的访问说明符，二是在派生类的派生列表中的访问说明符。三种不同的继承方式下的基类特性和派生类特性： 继承方式 public public private 公有继承 public protected 不可见 私有继承 private private 不可见 保护继承 protected protected 不可见 15.5.3 派生类向基类转换的可访问性 假定 D 继承自 B： 只有当 D 公有地继承 B 时，用户代码才能使用派生类向基类的转换；如果 D 继承 B 的方式是受保护的或者私有的，则用户代码不能使用该转换 不论 D 以什么方式继承 B，D 的成员函数和友元都是使用派生类向基类的转换：派生类向其直接基类的类型转换对于派生类的成员和友元来说永远是可访问的 如果 D 继承 B 的方式是公有或者受保护的，则 D 的派生类的成员和友元可以使用 D 向 B 的类型转换；反之，如果 D 继承 B 的方式是私有的，则不能使用 15.5.4 友元与继承 就像友元关系不能传递一样，友元关系也不能继承。每个类负责控制各自成员的访问权限。 15.5.5 改变个别成员的可访问性 有时我们需要改变派生类继承的某个名字的访问级别，通过使用 using 声明可以达到这一目的： class Base { public : std :: size_t size () const { return n ; } protected : std :: size_t n ; }; class Derived : private Base { //注意 private 继承 public : //保持对象尺寸相关的成员的访问级别 using Base :: size ; protected : using Base :: n ; } 派生类只能为那些它可以访问的名字提供 using 声明。 15.6 继承中的类作用域 每个类定义自己的作用域，在这个作用域内我们定义类的成员。当存在继承关系时，派生类的作用域在其基类的作用域之内。如果一个名字在派生类作用域内无法正确解析，则编译器将继续在外层的基类作用域中寻找该名字的定义。 在编译时进行名字查找。 15.6.1 名字冲突与继承 派生类能重用定义在其基类或间接基类中的名字，此时定义在内层作用域（即派生类）的名字将隐藏定义在外层作用域（即基类）的名字。 15.6.2 通过作用域运算符来使用隐藏的成员 我们可以通过作用域运算符来使用一个被隐藏的基类成员。 15.6.3 名字查找先于类型检查 如前所述，声明在内层作用域的函数并不会重载声明在外层作用域的函数。同理，定义在派生类中的函数也不会重载其基类中的成员。如果派生类的成员与基类的某个成员同名，则派生类将在其作用域内隐藏（非重载）该基类成员。即使它们的形参列表不一致，基类成员也会被隐藏掉。 15.6.4 虚函数与作用域 假如基类与派生类的虚函数接受的实参不同，则我们就无法通过基类的引用或指针调用派生类的虚函数了。 class Base { public : virtual int fcn (); }; class D1 : public Base { public : //隐藏基类的 fcn，这个 fcn 不是虚函数 //D1 继承了 Base::fcn() 的定义 int fcn ( int ); //形参列表与 Base 中的 fcn 不一致 virtual void f2 (); //是一个新的虚函数，在 Base 中不存在 }; class D2 : public D1 { public : int fcn ( int ); //是一个非虚函数，隐藏了 D1::fcn(int) int fcn (); //覆盖了 Base 的虚函数 fcn void f2 (); //覆盖了 D1 的虚函数 f2 }; 15.6.5 通过基类调用隐藏的虚函数 基于上述定义的类，我们看下面的代码： Base bobj; D1 d1obj; D2 d2obj; Base *bp1 = &bobj, *bp2 = d1obj, *bp3 = d2obj; bp1->fcn(); //虚调用，将在运行时调用 Base::fcn bp2->fcn(); //虚调用，将在运行时调用 Base::fcn bp3->fcn(); //虚调用，将在运行时调用 D2::fcn D1 *d1p = &d1obj; D2 *d2p = &d2obj; bp2->f2(); //错误：Base 没有名为 f2 的成员 d1p->f2(); //虚调用，将在运行时调用 D1::f2() d2p->f2(); //虚调用，将在运行时调用 D2::f2() Base *p1 = &d2obj; D1 *p2 = &d2obj; D2 *p3 = &d2obj; p1->fcn(42); //错误：Base中 没有接受一个 int 的 fcn p2->fcn(42); //静态绑定，调用 D1::fcn(int) p3->fcn(42); //静态绑定，调用 D2::fcn(int) 基类指针指向派生类对象，则调用基类中的成员函数（该类中无虚函数，实现静态绑定）。 若想让基类指针调用派生类中的成员，则需将该成员函数声明为虚函数（实现动态绑定）。 15.7 构造函数与拷贝控制 15.7.1 虚析构函数 继承关系对基类拷贝控制最直接的影响是基类通常应该定义一个虚析构函数，这样我们就能动态分配继承体系中的对象了。 如前所述，当我们 delete 一个动态分配对象的指针时将执行析构函数。如果该指针指向继承体系中的某个类型，则可能出现指针的静态类型与被删除对象的动态类型不符的情况。通过在基类中将析构函数定义成虚函数以确保执行正确的析构函数版本： class Quote { public : //如果我们删除的是一个指向派生类对象的基类指针，则需要虚析构函数 virtual ~ Quote () = default ; //动态绑定析构函数 }; 和其他虚函数一样，析构函数的虚属性也会被继承。只要基类的析构函数是虚函数，就能确保当我们 delete 基类指针时将运行正确的析构函数版本： Quote *itemP = new Quote; //静态类型与动态类型一致 delete itemP; //调用 Quote 的析构函数 itemP = new Bulk_quote; //静态类型与动态类型不一致 delete itemP; //调用 Bulk_quote 的析构函数 如果基类的析构函数不是虚函数，则 delete 一个指向派生类对象的基类指针将产生未定义的行为。 虚析构函数将阻止合成移动操作 如果一个类定义了析构函数，即使它通过 = default 的形式使用了合成的版本，编译器也不会为这个类合成移动操作。 15.7.2 合成拷贝控制与继承 15.7.2.1 派生类中删除的拷贝控制与基类的关系 如果基类中的默认构造函数、拷贝控制函数、拷贝赋值运算符或析构函数是被删除的或者不可访问，则派生类中对应的成员将是被删除的，原因是编译器不能使用基类成员来执行派生类对象基类部分的构造、赋值或销毁操作 如果在基类中有一个不可访问或删除掉的析构函数，则派生类中合成的默认和拷贝构造函数将是被删除的，因为编译器无法销毁派生类对象的基类部分 编译器将不会合成一个删除掉的析构函数。当我们使用 = default 请求一个移动操作时，如果基类中的对应操作是删除的或不可访问的，那么派生类中该函数将是删除的，原因是派生类对象的基类部分不可移动。同样，如果基类的析构函数是删除的或不可访问的，则派生类的移动构造函数也将是删除的 class B { public : B (); B ( const B & ) = delete ; //其他成员，不含移动构造函数 }; class D : public B { //没有声明任何构造函数 }; D d ; //正确：D 的合成默认构造函数使用B的默认构造函数 D d2 ( d ); //错误：D 的合成拷贝构造函数是被删除的 D d3 ( std :: move ( d )); //错误：隐式地使用 D 的被删除的拷贝构造函数 因为我们定义了拷贝构造函数，所以编译器不会为 B 合成一个移动构造函数。因此，我们既不能移动也不能拷贝 B 的对象。在实际编程过程中，如果在基类中没有默认、拷贝或移动构造函数，则一般情况下派生类也不会定义相应的操作。 15.7.2.2 移动操作与继承 如前所述，大多数基类都会定义一个虚析构函数。因此在默认情况下，基类通常不含有合成的移动操作，而且在它的派生类中也没有合成的移动操作。 因为基类缺少移动操作会阻止派生类拥有自己的合成移动操作，所以当我们确实需要执行移动操作时应该首先在基类中进行定义。 15.7.3 派生类的拷贝控制成员 当派生类定义了拷贝或移动构造函数时，该操作负责拷贝或移动包括基类部分成员在内的整个对象。 15.7.3.1 定义派生类的拷贝或移动构造函数 当为派生类定义拷贝或移动构造函数时，我们通常使用对应的基类构造函数初始化对象的基类部分。在默认情况下，基类默认构造函数初始化派生类对象的基类部分。如果我们想拷贝（或移动）基类部分，则必须在派生类的构造函数初始值列表中显示地使用基类的拷贝（或移动）构造函数。 class Base { /*...*/ }; class D : public Base { public : //默认情况下，基类的默认构造函数初始化对象的基类部分 //要想使用拷贝或移动构造函数，我们必须在构造函数初始值列表中 //显示地调用该构造函数 D ( const D & d ) : Base ( d ) //拷贝基类成员 /* D的成员的初始值*/ { /*...*/ } D ( D && d ) : Base ( std :: move ( d )) //移动基类成员 /* D的成员的初始值*/ { /*...*/ } }; 15.7.3.2 派生类赋值运算符 与拷贝和移动构造函数一样，派生类的赋值运算符也必须显示地为其基类部分赋值： // Base :: operator =( const Base &) 不会被自动调用 D & D :: operator =( const D & rhs ) { Base : : operator = ( rhs ); //为基类部分赋值 //按照过去的方式为派生类的成员赋值 //酌情处理自赋值及释放已有资源等情况 return *this ; } 15.7.3.3 派生类析构函数 对象销毁的顺序正好与其创建顺序相反：派生类析构函数首先执行，然后是基类的析构函数。 15.7.3.4 在构造函数和析构函数中调用虚函数 如果构造函数或析构函数调用了某个虚函数，则我们应该执行与构造函数或析构函数所属类型相对应的虚函数版本。 15.7.4 继承的构造函数 在 C++11 新标准中，派生类能够重用其直接基类定义的构造函数。一个类只初始化它的直接基类，出于同样的原因，一个类也只继承其直接基类的构造函数。类不能继承默认、拷贝和移动构造函数。 我们重新定义 Bulk_quote，令其继承 Disc_quote 类的构造函数： class Bulk_quote : public Disc_quote { public : using Disc_quote :: Disc_quote ; //继承 Disc_quote 的构造函数 double net_price ( std :: size_t ) const ; }; 继承的构造函数的特点 通常情况下， using 声明语句只是令某个名字在当前作用域可见。而当作用域构造函数时， using 声明语句将令编译器产生代码。对于基类的每个构造函数，编译器都生成一个与之对应的派生类构造函数。 一个构造函数的 using 声明不会改变构造函数的访问级别。 一个 using 声明语句不能指定 explicit 或 constexpr 。继承的构造函数的这两个性质与基类构造函数相同。 当一个基类构造函数含有默认实参时，这些实参不会被继承。相反，派生类将获得多个继承的构造函数，其中每个构造函数分别省略掉一个含有默认实参的形参。 大部分派生类会继承所有的基类构造函数：第一个例外，派生类可以继承一部分构造函数，而为其他构造函数定义自己的版本；第二个例外，默认、拷贝和移动构造函数不会被继承。这些构造函数按照正常规则被合成。 15.8 容器和继承 当我们使用容器存放继承体系中的对象时，通常必须采取间接存储的方式。因为不运行在容器中保存不同类型的元素，所以我们 不能把具有继承关系的多种类型的对象直接存放在容器当中。 我们可以再容器中放置（智能）指针而非对象：当我们希望在容器中存放具有继承关系的对象时，我们实际上存放的通常是基类的指针（更好的选择是智能指针）。","tags":"读书笔记","url":"https://xutree.github.io/pages/2018/10/20/C++_Primer_Chapter_15/"},{"title":"C++ Primer 第十四章 重载运算与类型转换","text":"14.1 基本概念 重载的运算符是具有特殊名字的函数：它们的名字由关键字 operator 和其后要定义的运算符号共同组成。和其他函数一样，重载的运算符也包含返回类型、参数列表以及函数体。 对一个运算符函数来说，它或者是类的成员，或者至少含有一个类类型的参数，这一约定意味着当运算符作用于内置类型的运算对象时，我们无法改变该运算符的含义： //错误：不能为 int 重定义内置的运算符 int operator+(int, int); 我们只能重载已存在的运算符，而无权发明新的运算符。重载运算符无法改变优先级和结合律。 14.1.1 直接调用一个重载的运算符函数 //一个非成员运算符函数的等价调用 data1 + data2; //普通的表达式 operator+(data1, data2); //等价的函数调用 //一个成员运算符函数的等价调用 data1 +=data2; //基于\"调用\"的表达式 data1.operator+(data2); //等成员运算符函数的等价调用 14.1.2 选择作为成员或者非成员 当定义重载的运算符时，必须首先决定是将其声明为类的成员函数还是声明为一个普通的非成员函数。在某些时候我们别无选择，因为有的运算符必须作为成员；另一个情况下，运算符作为普通函数比作为成员更好。下面的准则有助于选择： 赋值(=)、下标([ ])、调用( () )和成员访问箭头(->)运算符必须是成员 复合赋值运算符一般来说应该是成员，但并非必须，这一点与赋值运算符略有不同 改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减和解引用运算符，通常应该是成员 具有对称性的运算符可能转换任意一端的运算对象，例如算术、相等性、关系和位运算符等，因此它们通常应该是普通的非成员函数 14.2 输入和输出运算符 14.2.1 重载输出运算符 << 通常，输出运算符的第一个形参是一个非常量 ostream 对象的引用。之所以 ostream 是非常量是因为向流写入内容会改变其状态；而该形参是引用是因为我们无法直接复制一个 ostream 对象。 第二个形参一般来说是一个常量的引用，该常量是我们想要打印的类类型。第二个形参是引用的原因是我们希望避免复制实参；而之所以该形参可以是常量是因为(通常情况下)打印对象不会改变对象的内容。 为了与其他输出运算符保持一致， operator<< 一般要返回它的 ostream 形参。 Sales_data的输出运算符： ostream &operat<< (ostream &os, const Sales_data &item) { os << item.isbn() << \" \" << item.units_sold << \" \" << item.revenue << \" \" << item.avg_price(); return os; } 输出运算符尽量减少格式化操作通常，输出运算符应该主要负责打印对象的内容而非控制格式，输出运算符不应该打印换行符。 输入输出运算符必须是非成员函数：与 iostream 标准库兼容的输入输出运算符必须是普通的非成员函数，而不能是类的成员函数。否则，它们的左侧运算对象将是我们的类的一个对象： Sales_data data; data << cout; //如果 operator<< 是 Sales_data 的成员 假设输入输出运算符是某个类的成员，则它们也必须是 istream 或 ostream 的成员。然而，这两个类属于标准库，并且我们无法给标准库中的类添加任何成员。因此，我们必须将其定义成非成员函数。当然， IO 运算符通常需要读写类的非公有数据成员，所以 IO 运算符一般被声明为友元。 14.2.2 重载输入运算符 >> 通常，输入运算符的第一个形参是运算符将要读取的流的引用，第二个形参是将要读入到的(非常量)对象的引用。该运算符通常会返回某个给定流的引用。第二个形参之所以是个非常量是因为输入运算符的目的就是将数据读入到这个对象中。 Sales_data的输入运算符： istream &operator>>(istream &is, Sales_data &item) { double price; //不需要初始化，因为我们将先读入数据到 price，之后才使用它 is >> item.bookNo >> item.units_sold >> price; if (is) //检查输入是否成功 item.revenue = item.units_sold * price; else item = Sales_data(); //输入失败：对象被赋予默认的状态 return is; } 输入运算符必须处理输入可能失败的情况，而输出运算符不需要。当读取操作发生错误时，输入运算符应该负责从错误中恢复。 14.3 算术和关系运算符 通常情况下，我们将算术和关系运算符定义成非成员函数以允许对左侧或右侧的运算对象进行转换。因为这些运算符一般不需要改变运算对象的状态，所以形参都是常量的引用。 Sales_data operator+(const Sales_data &lhs, const Sales_data &rhs) { Sales_data sum = lhs; //把lhs的数据成员拷贝给sum sum += rhs; //将rhs加到sum中 return sum; } 如果类同时定义了算术运算符和相关的复合赋值运算符，则通常情况下应该使用复合赋值来实现算术运算符。 14.3.1 相等运算符 bool operator==(const Sales_data &lhs,const Sales_data &rhs) { return lhs.isbn() == rhs.isbn() && lhs.units_sold == rhs.units_sold && lhs.revenue == rhs.revenue; } bool operator!=(const Sales_data &lhs, const Sales_data &rhs) { return !(lhs == rhs); } 如果某个类在逻辑上有相等性的含义，则该类应该定义 operator== ，这样做可以使得用户更容易使用标准库算法来处理这个类。 14.3.2 关系运算符 定义了相等运算符的类也常常(但不总是)包含关系运算符。特别是，因为关联容器和一些算法要用到小于运算符，所以定义 operator< 会比较有用。 14.4 赋值运算符 我们可以重载赋值运算符。不论形参 的类型是什么，赋值运算符都必须定义为成员函数。 14.4.1 复合赋值运算符 复合赋值运算符不非得是类的成员，不过我们还是倾向于把包括复合赋值在内的所有赋值运算都定义在类的内部。 //作为成员的二元运算符：左侧运算对象绑定到隐式地 this 指针 //假定两个对象表示的是同一本书 Sales_data& Sales_data::operator+=(const Sales_data &rhs) { units_sold += rhs.units_sold; revenue += rhs.revenue; return *this; } 这两类运算符都应该返回左侧运算对象的引用。 14.5 下标运算符 表示容器的类通常可以通过元素在容器中的位置访问元素，这些类一般会定义下标运算符 operator[] 。下标运算符必须是成员函数。 为了与下标的原始定义兼容，下标运算符通常以所访问元素的引用作为返回值，这样做的好处是下标可以出现在赋值运算符的任意一端。 如果一个类包含下标运算符，则它通常会定义两个版本：一个返回普通引用，另一个是类的常量成员并且返回常量引用。 14.6 递增和递减运算符 C++ 语言并不要求递增和递减运算符必须的类的成员，但是因为它们改变的正好是所操作对象的状态，所以建议将其设定为成员函数。 定义递增和递减运算符的应该同时定义前置后后置版本。这些运算符通常应该被定义成类的成员。 14.6.1 定义前置递增/递减运算符 class StrBlobPtr { public : //递增和递减运算符 StrBlobPtr & operator ++ (); //前置运算符 StrBlobPtr & operator -- (); //其他成员和之前版本一致 }; //前置版本：返回递增/递减对象的引用 StrBlobPtr & StrBlobPtr :: operator ++ () { //如果curr已经指向了容器的尾后位置，则无法递增它 check ( curr , \"increment past end of StrBlobPtr\" ); ++ curr ; //将curr在当前状态下向前移动一个元素 return * this ; } StrBlobPtr & StrBlobPtr :: operator -- () { //如果curr是0，则继续递减它将产生一个无效下标 -- curr ; //将curr在当前状态下向后移动一个元素 check ( curr , \"decrement past begin of StrBlobPtr\" ); return * this ; } 14.6.2 区分前置和后置运算符 后置版本接受一个额外的(不使用) int 类型的形参。这个形参的唯一作用就是区分前置版本和后置版本的函数，而不是真的要在实现后置版本时参与运算。 class StrBlobPtr { public : //递增和递减运算符 StrBlobPtr operator ++ ( int ); //后置运算符 StrBlobPtr operator -- ( int ); //其他成员和之前版本一致 }; //后置版本：递增/递减对象的值但是返回原值 StrBlobPtr StrBlobPtr :: operator ++ ( int ) { //此处无须检查有效性，调用前置递增运算时才需要检查 StrBlobPtr ret = * this ; //记录当前的值 ++* this ; //向前移动一个元素，前置++需要检查递增的有效性 return ret ; //返回之前记录的状态 } StrBlobPtr StrBlobPtr :: operator -- ( int ) { //此处无须检查有效性，调用前置递减运算时才需要检查 StrBlobPtr ret = * this ; //记录当前值 --* this ; //向后移动一个元素，前置--需要检查递减的有效性 return ret ; //返回之前记录的状态 } 14.6.3 显示地调用后置运算符 如果我们想通过函数调用的方式调用后置版本，则必须为它的整型参数传递一个值： StrBlobPtr p(a1); //p 指向 a1 中的 vector p.operator++(0); //调用后置版本的 operator++ p.operator++(); //调用前置版本的 operator++ 14.7 成员访问运算符 class StrBlobPtr { public : std :: string & operator * () const { auto p = check ( curr , \"dereference past end\" ); return ( * p )[ curr ]; //(*p)是对象所指的 vector } std :: string * operator -> () const { //将实际工作委托给解引用运算符 return & this -> opreator * (); } //其他成员与之前的版本一致 }; 解引用运算符首先检测 curr 是否仍在作用范围内，如果是，则返回 curr 所指元素的一个引用。箭头运算符不执行任何自己的操作，而是调用解引用运算符并返回解引用结果元素的地址。 箭头运算符必须是类的成员，解引用运算符通常也是类的成员，尽管并非必须如此。 值得注意的是，我们将这两个运算符定义成了 const 成员，这是因为与递增和递减运算符不一样，获取一个元素并不会改变 StrBlobPtr 对象的状态。 14.8 函数调用运算符 如果类重载了函数调用运算符，则我们可以像使用函数一样使用该类的对象。 举个🌰 ，下面这个名为 absInt 的 struct 含有一个调用运算符，该运算符负责返回其参数的绝对值： struct absInt { int operator ()( int val ) const { return val > 0 ? val : - val ; } }; 我们使用调用运算符的方式是令一个 absInt 对象作用于一个实参列表，这一过程看起来非常像调用函数的过程： int i = -42; absInt absObj; //含有函数调用运算符的对象 int ui = absObj(i); //将 i 传递给 absObj.operator() 函数调用运算符必须是成员函数。一个类可以定义多个不同版本的调用运算符，相互之间应该在参数数量或类型上有所区别。 如果定义了调用运算符，则该类的对象称为函数对象（function object）。 14.8.1 含有状态的函数对象类 和其他类一样，函数对象除了 operator() 之外也可以包含其他成员。函数对象类通常含有一些数据成员，这些成员被用于定制调用运算符中的操作。 class PrintString { public : PrintString ( ostream & o = cout , char c = ' ' ) : os ( o ), sep ( c ){} void operator ()( const string & s ) const { os << s << sep ;} private : ostream & os ; //用于写入的目的流 char sep ; //用于将不同输出隔开的字符 }; 当定义 PrintString 的对象时，对于分隔符及输出流即可以使用默认值也可以提供自己的值： PrintString printer; //使用默认值，打印到 cout printer(s); //在 cout 中打印 s，后面跟一个空格 PrintString errors(cerr, '\\n'); errors(s); //在 cerr 中打印 s，后面跟一个换行符 函数对象常常作为泛型算法的实参： //例如可以使用标准库 for_each 算法和我自己的 PrintString 类来打印容器内容 for_each(vs.begin(), vs.end(), PrintString(cerr, '\\n')); 14.8.2 lambda 是函数对象 当我们编写了一个 lambda 后，编译器将该表达式翻译成一个未命名类的未命名对象。在 lambda 表达式产生的类中含有一个重载的函数调用运算符。 stable_sort ( words . begin (), words . end (), []( const string & a , const & b ) { return a . size () < b . size ();}); //其行为类似于下面这个类的一个未命名对象 class ShorterString { public : bool operator ()( const string & s1 , const string & s2 ) const { return s1 . size () < s2 . size ();} }; 产生的类只有一个函数调用运算符成员它负责接受两个 string 并比较他们的长度，它的形参列表和函数体与lambda表达式完全一样。 默认情况下 lambda 不能改变它捕获的变量。因此在默认情况下，由 lambda 产生的类当中的函数调用运算符是一个 const 成员函数。如果 lambda 被声明为可变的，则调用运算符就不是 const 的了。 表示 lambda 及相应捕获行为的类 当一个 lambda 表达式通过引用捕获变量时，将有程序负责确保 lambda 执行时引用所引的对象确实存在。因此编译器可以直接使用该引用而无须在 lambda 产生的类中将其存储为数据成员。 相反，通过值捕获的变量被拷贝到 lambda 中。因此，这种 lambda 产生的类必须为每个值捕获的变量建立对应的数据成员，同时创建构造函数，令其使用捕获的变量的值来初始化数据成员。 lambda 表达式产生的类不含默认构造函数、赋值构造函数及默认析构函数，它是否含有默认的拷贝/移动构造函数则通常要视捕获的数据成员类型而定。 14.8.3 标准库定义的函数对象 下表所列的类型定义在 functional 头文件中： 在算法中使用标准库函数对象 在默认情况下排序算法使用 operator< 将序列按照升序排列。如果要执行降序排列的话，我们可以传入一个 greater 类型的对象。例如： //svec 是一个 vector<string> //传入一个临时的函数对象用于执行两个 string 对象的 > 比较运算 sort(svec.begin(), svec.end(), greater<string>()); 则上面的语句将按照降序对 svec 进行排序。第三个实参是 greater<string> 类型的一个未命名的对象。 需要特别注意的是，标准库规定其函数对象对于指针同样适用。我们之前曾介绍过比较两个无关指针将产生未定义的行为，然而我们可能会希望通过比较指针的内存地址来 sort 指针的 vector 。直接这么做会产生未定义的行为，但是我们可以用标准库函数对象来实现： vector<string *> nameTable; sort(nameTable.begin(), nameTable.end(), [] (string *a, sting *b { return a < b; })); //错误 sort(nameTable.begin(), nameTable.end(), less<string *>()); //正确 14.8.4 可调用对象和 function C++ 语言中的几种可调用对象： 函数 函数指针 lambda 表达式 bind 创建的对象 重载了函数调用运算符的类 与其他对象一样，可调用的对象也有类型。例如，每个 lambda 有它自己唯一的（未命名）的类型；函数及函数指针的类型则由其返回值类型和实参类型决定。 调用形式：指明了调用返回的类型以及传递给调用的实参类型。 14.8.5 不同类型可能具有相同的调用形式 //普通函数 int add(int i, int j) { return i + j; } //lambda，其产生一个未命名的函数对象类 auto mod = [] (int i, int j) { return i % j; } //函数对象类 struct divide{ int operator()(int denominator, int divisor){ return denominator / divisor; } } 上面的类型共享同一个调用形式： int(int, int) 。 若我们想把它们存入同一个函数表： map<string, int(*)(int, int)> binops; binops.insert({\"+\", add}); //正确，add 是一个指向正确类型函数的指针 binops.insert({\"%\",mod}); //错误，mod 不是一个函数指针 14.8.6 标准库 function 类型 我们可以使用一个名为 function 的新标准库类型解决上述问题，它定义在 functional 头文件中，支持的操作如下： map<string, function<int(int, int)>> binops = { {\"+\", add}, //函数指针 {\"-\", std::minus<int>()}, //标准库函数对象 {\"/\", divide()}, //未命名的 lambda {\"*\", [] (int i, int j) { return i * j; }}, //命名了的 lambda {\"%\", mod}}; // 重载的函数与 function 我们不能（直接）将重载函数的名字存入 function 类型的对象中： int add(int i, int j) { return i + j; } Sales_data add(const Sales_data&, const Sales_data&); map<string, function<int(int, int)>> binops; binops.insert({\"+\", add}); //错误，哪个 add？ 解决上述二义性问题的一条途径是存储函数指针而非函数名字： int (*fp)(int, int) = add; binops.insert({\"+\",fp}); 同样，也可以使用 lambda 来消除二义性： binops.insert({\"+\", [] (int i, int j) { return add(i, j); }}); 14.9 重载、类型转换与运算符 14.9.1 类型转换运算符 类型转换运算符（conversion operator）是类的一种特殊成员函数，它负责将一个类类型的值转换成其他类型。一般形式： operator type() const; 其中type表示某种类型。 我们不允许转换成数组或函数类型，但允许转换成指针(包括数组指针及函数指针)或引用类型。 类型转换运算符既没有显示的返回类型，也没有形参，而且必须定义成类的成员函数。类型转换运算符通常不应该改变待转换对象的内容，因此，类型转换运算符一般被定义成 const 成员。 14.9.1.1 定义含有类型转换符的类 class SmallInt { public : SmallInt ( int i = 0 ) : val ( i ) { if ( i < 0 || i > 255 ) throw std :: out_of_range ( \"Bad SmallInt value\" ); } operator int () const { return val ; } private : std :: size_t val ; }; SmallInt 类既定义了向类类型的转换，也定义了从类类型向其他类型的转换。其中构造函数将算符类型的值转换成 SmallInt 对象，而类型转换运算符将 SmallInt 对象转换成 int : SmallInt si; si = 4; //首先将4隐式地转换成 SmallInt，然后调用 SmallInt::operator= si + 3; //首先将 si 隐式地转换成 int，然后执行整数的加法 尽管编译器一次只能执行一个用户定义的类型转换，但是隐式的用户定义类型转换可以置于一个标准（内置）类型转换之前或之后： //内置类型转换将 double 实参转换为 int SmallInt si = 3.14; //调用 SmallInt(int) 构造函数 //SmallInt 的类型转换运算符将 si 转换为 int si + 3.14; //内置类型转换将所得的 int 继续转换成 double 14.9.1.2 类型转换运算符可能产生意外结果 在实践中，类很少提供类型转换运算符。在大多数情况下，如果类型转换自动发生，用户可能会感到比较意外，而不是感到受到了帮助。然而这条经验法则存在一种例外情况：对于类来说，定义向 bool 的类型转换还是比较普遍的现象。 在 C++ 标准的早期版本中，如果类想定义一个向 bool 的类型转换，则它常常遇到一个问题：因为 bool 是一种算术类型，所以类类型的对象转换成 bool 后就能被用在任何需要算术类型的上下文中。这样的类型转换可能引发意想不到的结果，特别是当 istream 含有向 bool 的类型转换时，下面的代码仍能编译通过： int i = 42; cin << i; 该程序试图将输出运算符作用在输入流。因为 istream 本身没有定义 << ，所以本来这段代码应该产生错误。然而，该代码能使用 istream 的 bool 类型转换运算符将 cin 转换成 bool ，而这个 bool 值会接着被提升成 int 并用作内置的左移运算符的左侧运算对象。这样一来，提升后的 bool 值（1或0）最终会被左移42个位置。这一结果显然与我们的预期大相径庭。 14.9.1.3 显示的类型转换运算符 为了防止这样的异常情况发生，C++ 11新标准引入了显示的类型转换运算符（explicit conversion operator）： class SmallInt { public : //编译器不会自动执行这一类型转换 explicit operator int () const { return val ; } //其他成员与之前的版本一致 }; 和显示的构造函数一样，编译器(通常)也不会将一个显式的类型转换运算符用于隐式类型转换： SmallInt si = 3; //正确：SmallInt 的构造函数不是显式的 si + 3; //错误：此处需要隐式的类型转换，但类的运算符是显式的 static_cast<int>(si) + 3; //正确：显式地请求类型转换 该规定存在一个例外，即如果表达式被用作条件，则编译器会将显式地类型转换自动应用于它。换句话说，当表达式出现在下列位置时，显示的类型转换将被隐式地执行： if 、 while 及 do 语句的条件部分 for 语句头的条件表达式 逻辑非运算符( ! )、逻辑或( || )、逻辑与( && )的运算对象 条件表达式( ? : )的条件表达式 14.9.1.4转换为 bool 在标准库的早期版本中， IO 类型定义了向 void* 的转换规则，以避免上面提到的问题。但 C++ 11新标准通过显示的类型转换运算符实现同样的目的。","tags":"读书笔记","url":"https://xutree.github.io/pages/2018/10/20/C++_Primer_Chapter_14/"},{"title":"C++ Primer 第十三章 拷贝控制","text":"当定义一个类时，我们显示地或隐式地指定在此类型的对象拷贝、移动、赋值和销毁时做什么。一个类通过定义五种特殊的成员函数来控制这些操作，包括：拷贝构造函数（copy constructor）、拷贝赋值运算符（copy-assignment operator）、移动构造函数（move constructor）、移动赋值运算符（move-assignment operator）和析构函数（destructor）。 拷贝和移动构造函数定义了当用同类型的另一个对象初始化本对象时做什么。 拷贝和移动赋值运算符定义了将一个对象赋予同类型的另一个对象时做什么。 析构函数定义了当此类型对象销毁时做什么。 我们称这些操作为拷贝控制操作（copy control）。 13.1 拷贝、赋值和销毁 13.1.1 拷贝构造函数 如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数。 class Foo { public : Foo (); //默认构造函数 Foo ( const Foo & ); //拷贝构造函数 //... }; 拷贝构造函数的第一个参数必须是一个引用类型，虽然我们可以定义一个接受非 const 引用的拷贝构造函数，但此参数几乎总是一个 const 引用。拷贝构造函数在几种情况下都会被隐式地使用。因此，拷贝构造函数通常不应该是 explicit 的。 13.1.1.1 合成拷贝构造函数（synthesized copy constructor） 如果我们没有为一个类定义拷贝构造函数，编译器会为我们定义一个。与合成默认构造函数不同，即使我们定义了其他构造函数，编译器也会为我们合成一个拷贝构造函数。 每个成员的类型决定了它如何拷贝：对类类型成员，会使用其拷贝构造函数来拷贝；内置类型的成员则直接拷贝。Sales_data 类的合成拷贝构造函数等价于： class Slaes_data { public : //其他成员和构造函数的定义，如前 //与合成的拷贝构造函数等价的拷贝构造函数的声明 Sales_data ( const Sales_data & ); private : std :: string bookNo ; int units_sold = 0 ; double revenue = 0.0 ; }; //与 Sales_data 的合成的拷贝构造函数等价 Sales_data :: Sales_data ( const Sales_data & orig ) : bookNo ( orig . bookNo ), //使用string的拷贝构造函数 units_sold ( orig . units_sold ) ， //拷贝orig.units_sold revenue ( orig . revenue ) //拷贝orig.revenue { } //空函数体 13.1.1.2 拷贝初始化（copy initialization） string dots(10,'.'); //直接初始化 string s(dots); //直接初始化 string s2 = dots; //拷贝初始化 string null_book = \"9-999-99999-9\"; //拷贝初始化 string nines = string(100, '9'); //拷贝初始化 当使用直接初始化时，我们实际上是要求编译器使用普通的函数匹配来选择与我们提供的实参最匹配的构造函数。当我们使用拷贝初始化时，我们要求编译器将右侧运算对象拷贝到正在创建的对象中，如果需要的话还要进行类型转换。 拷贝初始化通常通过拷贝构造函数来完成，但是，如果一个类有一个移动构造函数，则拷贝初始化有时会使用移动构造函数而非拷贝构造函数来完成。 拷贝初始化不仅在外面用=定义变量时会发生，在下列情况下也会发生： 将一个对象作为实参传递给一个非引用类型的形参 从一个返回类型为非引用类型的函数返回一个对象 用花括号列表初始化一个数组中的元素或一个聚合类中的成员 某些类类型还会对它们所分配的对象使用拷贝初始化。例如，当我们初始化标准库容器或是调用其 insert 或 push 成员时，容器会对其元素进行拷贝初始化。与之相对，用 emplace 成员创建的元素都进行直接初始化。 13.1.1.3 参数和返回值 在函数调用过程中，具有非引用类型的参数要进行拷贝初始化。 拷贝构造函数被用来初始化非引用类类型参数，这一特性解释了为什么拷贝构造函数自己的参数必须是引用类型。如果其参数不是引用类型，则调用永远也不会成功——为了调用拷贝构造函数，我们必须拷贝它的实参，但为了拷贝实参，我们又需要调用拷贝构造函数，如此无限循环。 13.1.1.4 拷贝初始化的限制 如前所述，如果我们使用的初始化值要求通过一个 explicit 的构造函数来进行类型转换，那么使用拷贝初始化还是直接初始化就不是无关紧要的了： vector<int> v1(10); //正确，直接初始化 vector<int> v2 = 10; //错误：接受大小参数的构造函数是 explicit 的 void f(vector<int>); //f 的参数进行拷贝初始化 f(10); //错误：不能用一个 explicit 的构造函数拷贝一个实参 f(vector<int>(10)); //正确：从一个 int 直接构造一个临时的 vector 13.1.1.5 编译器可以绕过拷贝构造函数 在拷贝初始化的过程中，编译器可以（但不是必须）跳过拷贝/移动构造函数，直接创建对象。即，编译器允许将下面的代码： string null_book = \"9-999-99999-9\"; //拷贝初始化 改写为： string null_book(\"9-999-99999-9\"); //编译器略过了拷贝构造函数 但是，即使编译器略过拷贝/移动构造函数，但在这个程序点上，拷贝/移动构造函数必须是存在并且是可访问的（例如，不能是 private 的）。 13.1.2 拷贝赋值运算符 与控制其对象如何初始化一样，类也可以控制其对象如何赋值： Sales_data trans, accum; trans = accum; //使用 Sales_data 的拷贝赋值运算符 13.1.2.1 重载赋值运算符 重载运算符本质上是函数，其名字由 operator 关键字后接表示要定义的运算符的符号组成。因此，赋值运算符就是一个名为 operator= 的函数。 某些运算符，包括赋值运算符，必须定义为成员函数。如果一个运算符是一个成员函数，其左侧运算对象就绑定到隐式的 this 参数。对于一个二元运算符，例如赋值运算符，其右侧运算对象作为显式参数传递。 //拷贝赋值运算符接受一个与其所在类相同类型的参数 class Foo { public : Foo & operator = ( const Foo & ); //赋值运算符 //... }; 为了与内置类型的赋值保持一致，赋值运算符通常返回一个指向其左侧运算对象的引用。 13.1.2.2 合成拷贝赋值运算符 //等价于合成拷贝赋值运算符 Sales_data& Sales_data::operator=(const Sales_data &rhs) { bookNo = rhs.bookNo； //调用 string::operator= units_sold = rhs.units_sold; //使用内置的 int 赋值 revenue = rhs.revenue; //使用内置的 double 赋值 return *this; } 13.1.3 析构函数 析构函数执行与构造函数相反的操作：构造函数初始化对象的非 static 数据成员，还可能做一些其他工作；析构函数释放对象使用的资源，并销毁对象的非 static 数据成员。 析构函数是类的一个成员函数，名字由波浪号接类名构成，没有返回值，也不接受参数： class Foo { public : ~ Foo (); //析构函数 //... }; 由于析构函数不接受参数，因此它不能被重载。对一个给定类，只会有唯一一个析构函数。 在一个析构函数中，首先执行函数体，然后销毁成员。成员按初始化顺序的逆序销毁。 在一个析构函数中，不存在类似构造函数中初始化列表的东西来控制成员如何销毁，析构部分是隐式的。 成员销毁时发生什么完全依赖于成员的类型。 销毁类类型成员需要执行成员自己的析构函数。内置类型没有析构函数，因此销毁内置类型成员什么也不需要做。所以： 隐式销毁一个内置指针类型的成员不会 delete 它所指向的对象 当指向一个对象的引用或指针离开作用域时，析构函数不会执行 { //新作用域 //p 和 p2 指向动态分配的内存 Sales_data *p = new Sales_data; //p 是一个内置指针 auto p2 = make_shared<Sales_data>(); //p2 是一个 shared_ptr Sales_data item(*p); //拷贝构造函数将 p 拷贝到 item 中 vector<Sales_data> vec; //局部变量 vec.push_back(*p2); //拷贝 p2 指向的对象 delete p; //对 p 指向的对象进行析构函数 } //退出局部作用域；对 item、p2 和 vec 调用析构函数 //销毁 p2 会递减其引用计数；如果引用计数为0，对象被释放 //销毁 vec 会销毁它的元素 13.1.3.1 什么时候会调用析构函数 无论何时一个对象被销毁，就会自动调用其析构函数： 变量在离开作用域时被销毁 当一个对象被销毁时，其成员被销毁 容器（无论是标准库容器还是数组）被销毁时，其元素被销毁 对于动态分配的对象，当对指向它的指针应用 delete 运算符时被销毁 对于临时对象，当创建它的完整表达式结束时被销毁 13.1.3.2 合成析构函数（synthesized destructor） 当一个类未定义自己的析构函数时，编译器会为他定义一个合成析构函数。例如，下面的代码等价于 Sales_data 的合成析构函数： class Sales_data { public : //成员会被自动销毁，除此之外不需要做其他事情 ~ Sales_data() { } //其他成员的定义，如前 }; 在（空）析构函数体执行完毕后，成员会被自动销毁。特别的， string 的析构函数会被调用，它将释放 bookNo 成员所用的内存。认识到析构函数本身并不直接销毁成员是非常重要的。成员是在析构函数体之后隐含的析构阶段中被销毁的。在整个对象销毁过程中，析构函数体是作为成员销毁步骤之外的另一部分而进行的。 13.1.4 三/五法则 如前所述，有三个基本操作可以控制类的拷贝操作：拷贝构造函数、拷贝赋值运算符和析构函数。而且，在新标准下，一个类还可以定义一个移动构造函数和一个移动赋值运算符。 13.1.4.1 需要析构函数的类也需要拷贝和赋值操作 当我们决定一个类是否要定义它自己版本的拷贝控制成员时，一个基本的原则是首先确定这个类是否需要一个析构函数。如果这个类需要一个自定义析构函数，我几乎可以肯定它也需要自定义拷贝构造函数和自定义拷贝赋值运算符。 如果类在构造函数中分配动态内存。合成析构函数不会 delete 一个指针数据成员。因此，此类需要定义一个析构函数来释放构造函数分配的内存。 13.1.4.2 需要拷贝操作的类也需要赋值操作，反之亦然 虽然很多类需要定义所有(或是不需要定义任何)拷贝控制成员，但某些类所要完成的工作，只需要拷贝或赋值操作，不需要析构函数。第二个基本原则：如果一个类需要一个拷贝构造函数，几乎可以肯定它也需要一个拷贝赋值运算符。反之亦然。 13.1.5 使用 =default 我们可以通过将拷贝控制成员定义为=default来显示地要求编译器生成合成的版本： class Sales_data { public : //拷贝控制成员；使用default Sales_data () = default ; Sales_data ( const Sales_data & ) = default ; Sales_data & operator = ( const Sales_data & ); ~ Sales_data () = default ; //其他成员的定义，如前 }; Sales_data & Sales_data :: operator = ( const Sales_data & ) = default ; 当我们在类内使用 =default 修饰成员的声明时，合成的函数将隐式地声明为内联的。如果我们不希望合成的成员是内联函数，应该只对成员的类外定义使用 =default ，就像对拷贝赋值运算符所做的那样。 我们只能对具有合成版本的成员函数使用 =default (即，默认构造函数或拷贝控制成员)。 13.1.6 阻止拷贝 大多数类应该定义默认构造函数、拷贝构造函数和拷贝赋值运算符，无论是隐式地还是显示地。 但是，在某些情况下，定义类时必须采用某种机制阻止拷贝或赋值。例如， iostream 类阻止了拷贝，以避免多个对象写入或读取相同的 IO 缓冲。 为了阻止拷贝，看起来可能应该不定义拷贝控制成员。但是，这种策略是无效的：如果我们的类未定义这些操作，编译器为它生成合成的版本。 13.1.6.1 定义删除的函数 在新标准下，我们可以通过将拷贝构造函数和拷贝赋值运算符定义为删除的函数（deleted function）来阻止拷贝。删除的函数是这样一种函数：我们虽然声明了它们但不能以任何方式使用它们： struct NoCopy{ NoCopy() = default; //使用合成的默认构造函数 NoCopy(const NoCopy&) = delete; //阻止拷贝 NoCopy &operator=(const NoCopy&) = delete; //阻止赋值 ~NoCopy() = delete; //使用合成的析构函数 //其他成员 }; =delete 通知编译器（以及我们代码的读者），我们不希望定义这些成员 与 =default 不同， =delete 必须出现在函数第一次声明的时候 与 =default 的另一不同之处是，我们可以对任何函数指定 =delete （我们只能对编译器可以合成的默认构造函数或拷贝控制成员使用 =default ） 13.1.6.2 析构函数不能是删除的成员 值得注意的是，我们不能删除析构函数。如果析构函数被删除，就无法销毁此类型的的对象了。对于析构函数已删除的类型，不能定义该类型的变量或释放指向该类型动态分配对象的指针，但是可以动态分配这种类型的对象（然而动态分配后不能释放）。 13.1.6.3 合成的拷贝控制成员可能是删除的 如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数将被定义为删除的。 13.1.6.4 private 拷贝控制 在新标准发布之前，类是通过将其拷贝构造函数和拷贝赋值运算符声明为 private 的来阻止拷贝： class PrivateCopy { //无访问说明符；接下来的成员默认为 private 的 //拷贝控制成员是 private 的，因此普通用户代码无法访问 PrivateCopy ( const PrivateCopy & ); PrivateCopy & operator = ( const PrivateCopy & ); //其他成员 public ： PrivateCopy () = default ; //使用合成的默认构造函数 ~ PrivateCopy (); //用户可以定义此类型的对象，但无法拷贝它们 }; 为了阻止友元和成员函数进行拷贝，我们将这些拷贝控制成员声明为 private 的，但并不定义它们。声明但不定义一个成员函数是合法的(例外：我们必须为每一个虚函数都提供定义，而不管它是否被用到，这是因为连编译器也无法确定到底会使用哪个虚函数)。 通过声明（但不定义） private 的拷贝构造函数，我们可以预先阻止任何拷贝该类对象的企图：试图拷贝对象的用户代码将在编译阶段被标记为错误；成员函数或友元函数的拷贝操作将会导致链接时错误。 建议：希望阻止拷贝的类应该使用 =delete 来定义它们自己的拷贝构造函数和拷贝赋值运算符，而不应该将它们声明为 private 的。 13.2 拷贝控制和资源管理 为了定义这些成员，我们首先必须确定此类型对象的拷贝语义。一般来说，有两种选择：可以定义拷贝操作，使类的行为看起来像一个值或者像一个指针。 类的行为像一个值，意味着它应该也有自己的状态。当我们拷贝一个像值的对象时，副本和原对象是完全独立的。改变副本不会对原对象有任何影响，反之亦然； 行为像指针的类则共享状态。当我们拷贝一个这种类的对象时，副本和原对象使用相同的底层数据。改变副本也会改变原对象，反之亦然。 13.2.1 行为像值的类 class HasPtr { public : HasPtr ( const std :: string & s = std :: string ()) : ps ( new std :: string ( s )), i ( 0 ){ } //ps 指向的 string，每个 HasPtr 对象都有自己的拷贝 HasPtr ( const HasPtr & p ) : ps ( new std :: string ( * p . ps )), i ( p . i ) {} HasPtr & operator = ( const HasPtr & ); ~ HasPtr() { delete ps ;} private : std :: string * ps ; int i ; }; 类值拷贝赋值运算符赋值运算符通常组合了析构函数和构造函数的操作：类似析构函数，赋值操作会销毁左侧运算对象的资源；类似拷贝构造函数，赋值操作会从右侧运算对象拷贝数据。 本例中，通过先拷贝右侧运算对象，我们可以处理自赋值情况，并能保证异常发生时代码也是安全的。在完成拷贝后，我们释放左侧运算对象的资源，并更新指针指向新分配的 string ： HasPtr& HasPtr::operator=(const HasPtr&rhs) { auto newp = new string(*rhs.ps); //拷贝底层 string，注意成员选择优先级大于解引用，故等价于*(rhs.ps) delete ps; //释放旧内存 ps = newp; //从右侧运算对象拷贝数据到本对象 i = rhs.i; return *this; //返回本对象 } 当你编写赋值运算符时，有两点需要记住： 如果将一个对象赋予它自身，赋值运算符必须能正确工作 大多数赋值运算符组合了析构函数和拷贝构造函数的工作 当你编写一个赋值运算符时，一个好的模式是先将右侧运算对象拷贝到一个局部临时对象中。当拷贝完成后，销毁左侧运算对象的现有成员就是安全的了。一旦左侧运算对象的资源被销毁，就只剩下将数据从临时对象拷贝到左侧运算对象的成员中了。 为了说明防范自赋值操作的重要性，看下面一个错误的例子： //这样编写赋值运算符是错误的！ HasPtr& HasPtr::operator=(const HasPtr &rhs) { delete ps; //释放对象指向的 string //如果 rhs 和 *this 是同一个对象，我们就将从已释放的内存中拷贝数据！ ps = new string(*(rhs.ps)); i = rhs.i; return *this; } 如果 rhs 和本对象是同一个对象， delete ps 会释放 *this 和 rhs 指向的 string 。接下来，当我们在 new 表达式中试图拷贝 *(rhs.ps) 时，就会访问一个指向无效内存的指针，其行为和结果是未定义的。 13.2.2 定义行为像指针的类 对于行为类似指针的类，我们需要为其定义拷贝构造函数和拷贝赋值运算符，来拷贝指针成员本身而不是它指向的 string 。我们的类仍然需要自己的析构函数来释放接受 string 参数的构造函数分配的内存。但是，析构函数不能单方面地释放关联的 string ，只有当最后一个指向 string 的对象销毁时，才可以释放 string 。 令一个类展现类似指针的行为最好的方法是使用 shared_ptr 来管理类中的资源。如果我们希望直接管理资源，可以使用引用计数（reference count）。下面我们不使用 shared_ptr 而是使用引用计数来实现行为像指针的类。 引用计数 引用计数的工作方式如下： 除了初始化对象之外，每个构造函数(拷贝构造函数除外)都要创建一个引用计数，用来记录有多少对象共享正在创建的对象共享状态，当创建一个对象时，引用计数为1，因为此时只有一个对象共享 拷贝构造函数不分配新得引用计数器，拷贝给定对象的数据成员，包括引用计数器，拷贝构造函数递增共享的计数器，表示给定对象更的状态又被一个新用户所共享 拷贝赋值运算符递减左侧运算对象的引用计数器，递增右侧对象的引用计数器，如果左侧对象的引用计数器为0，则销毁左侧对象 析构函数判断引用计数是否为0，如果为0，则销毁左侧对象 引用计数的实现：我们假设有下面的情况： HasPtr h1; HasPtr h2(h1); HasPtr h3(h1); HasPtr 是一个行为像指针的类，新创建的 h1的引用计数为1，创建 h2，用 h1 初始化 h2，会递增 h1 的引用计数值，此时 h2 保存了 h1 中的引用计数，在创建 h3 的时候，递增了 h1 的引用计数值，而且我们必须做的是要更新 h2 中的引用计数值，此时无法更新 h2 中的引用计数值。因此，我们需要将引用计数保存在动态内存中，这样原对象和其他副本对象都会指向相同的计数器，这样就可以自动更新引用计数在每个共享对象中的状态。 class HasPtr { public : //构造函数分配新的 string 和新的计数器，将计数器置为1 HasPtr ( const std :: string & s = std :: string ()) : ps ( new std :: string ( s )), i ( 0 ), use ( new size_t ( 1 )) {} //拷贝构造函数拷贝所以三个数据成员，并递增计数器 HasPtr ( const HasPtr & p ) : ps ( p . ps ), i ( p . i ), use ( p . use ) { ++* use ; } HasPtr & operator = ( const HasPtr & ); ~ HasPtr (); private : std :: string * ps ; int i ; std :: size_t * use ; // 引用计数 }; HasPtr :: HasPtr & operator = ( const HasPtr & has ) { ++* has . use ; //递增右侧运算对象的引用计数 if ( 0 == --* use ) { //然后递减本对象的引用计数 delete ps ; delete use ; } ps = has . ps ; i = has . i ; use = has . use ; return * this ; } HasPtr ::~ HasPtr() { if ( --* use == 0 ) { delete ps ; delete use ; } } 13.3 交换操作 通常，管理资源的类除了定义拷贝控制成员之外，还会定义交换操作的函数 swap 。 如果一个类定义了自己的 swap ，那么算法将使用类自定义版本，否则，将使用标准库定义的 swap 。 理论上来说，我们的 swap 函数应该是这样的： //交换两个类值 HasPtr 对象的代码可能像下面这样： HasPtr temp = v1; //创建 v1 的值的一个临时副本 v1 = v2; //将 v2 的值赋予 v1 v2 = temp; //将保存的 v1 的值赋予 v2 这样的代码将 v1 中 string 拷贝了两次，但是这样做是没有必要的，我们希望 swap 交换指针，而不是分配 string 的副本： string *temp = v1.ps; //为 v1.ps 中的指针创建一个副本 v1.ps = v2.ps; //将 v2.ps 中的指针赋予 v1.ps1 v2.ps = temp; //将保存的 v1.ps 中原来的指针赋予 v2.ps 13.3.1 编写我们自己的 swap 函数 class HasPtr { friend void swap ( HasPtr & , HasPtr & ); //其他成员定义 }; inline void swap ( HasPtr & lhs , HasPtr & rhs ) { using std :: swap ; swap ( lhs . ps , rhs . ps ); //交换指针，而不是string数据 swap ( lhs . i , rhs . i ); //交换 int 成员 } 我们首先将 swap 定义为 friend 以便能访问 HasPtr 的（private的）数据成员。由于 swap 的存在就是为了优化代码，我们将其声明为 inline 函数。 与拷贝控制成员不同， swap 并不是必要的。但是，对于分配了资源的类，定义 swap 可能是一种很重要的优化手段。 13.3.2 swap 函数应该调用 swap，而不是 std::swap 在 swap 函数中，使用了 using std::swap ，如果这个类有自己的 swap 函数，匹配程度会高于标准库 swap ，会优先使用类自己的 swap ，如果没有，则使用标准库的 swap 。 swap 里交换类的指针和 int 成员，并不会发生递归循环，HasPtr 的数据成员是内置类型的，这时候会调用标准库版本的 swap 。 13.3.3 在赋值运算符中使用 swap 定义 swap 的类通常用 swap 来定义它们的赋值运算符。这些运算符使用了一种名为拷贝并交换（copy and swap）的技术。这种技术将左侧运算对象与右侧运算对象的一个副本进行交换： //注意 rhs 是按值传递的，意味着 HasPtr 的拷贝构造函数将 //右侧运算对象中的 string 拷贝到 rhs HasPtr& HasPtr::operator=(HasPtr rhs) { //交换左侧运算对象和局部变量 rhs 的内容 swap(*this, rhs); //rhs 现在指向本对象曾经使用的内存 return *this; //rhs 被销毁，从而 delete 了 rhs 中的指针 } 在进行 HasPtr 类的赋值运算中，先将右侧对象拷贝到拷贝赋值运算符函数里，然后交换左侧对象的指针和右侧对象的指针，交换后，右侧对象赋值给了左侧对象，左侧对象相应的 string 指针也指向了右侧对象副本的对应成员，而右侧对象的 string 指针则指向了左侧对象的相应成员。在这个函数结束后，右侧对象的副本被销毁，于是原来左侧对象的资源被释放，而左侧对象现在保存的是右侧对象的成员。 拷贝并交换的操作，和之前的拷贝赋值运算符的实现原理是相同的， 在改变左侧对象之前拷贝右侧对象。保证了这样的操作异常的安全。 13.4 对象移动 新标准的一个最主要的特性是可以移动而非拷贝对象的能力。在某些情况下对象拷贝后就立即被销毁了。在这些情况下，移动而非拷贝对象会大幅度提升性能。 使用移动而不是拷贝的另一个原因源于 IO 类或 unique_ptr 这样的类。这些类都包括不能被共享的资源。因此，这些类型的对象不能拷贝但可以移动。 类似的，在旧版本的标准库中，容器所保存的类必须是可拷贝的，但在新标准中，我们可以用容器保存不可拷贝的类型，只要它们能被移动就行。 标准库容器、 string 和 shared_ptr 类既支持移动也支持拷贝。 IO 类和 unique_ptr 类可以移动但不能拷贝。 13.4.1 右值引用 为了支持移动操作，新标准引入了一种新的引用类型——右值引用（rvalue reference）。我们通过 && 而不是 & 来获得右值引用。右值引用一个重要性质——只能绑定到一个将要销毁的对象。 一般而言，一个左值表达式表示的是一个对象的身份，而一个右值表达式表示的是对象的值。 对于常规引用(我们可以称之为左值引用)，我们不能将其绑定到要求转换的表达式、字面常量或是返回右值的表达式。右值引用有着完全相反的特性：我们可以将一个右值引用绑定到这类表达式上，但不能将一个右值引用直接绑定到一个左值上： int i = 42; int &r = i; //正确：r 引用 i int &&rr = i; //错误：不能将一个右值引用绑定到一个左值上 int &r2 = i * 42; //错误：i * 42是一个右值 const int &r3 = i * 42; //正确：我们可以将一个 const 的引用绑定到一个右值上 int &&rr2 = i * 42; //正确：将 rr2 绑定到乘法结果上 返回左值引用的函数，连同赋值、下标、解引用和前置递增/递减运算符，都是返回左值的表达式的例子，我们可以将一个左值引用绑定到这类表达式的结果上。 返回非引用类型的函数，连同算术、关系、位以及后置递增/递减运算符，都生成右值。我们不能将一个左值引用绑定到这类表达式上，但我们可以将一个 const 的左值引用或者一个右值引用绑定到这类表达式上。 13.4.1.1 左值持久；右值短暂 由于右值引用只能绑定到临时对象，我们得知： 所引用的对象将要被销毁 该对象没有其他用户 这两个特性意味着：使用右值引用的代码可以自由地接管所引用的对象的资源。右值引用指向将要被销毁的对象。因此，我们可以从绑定到右值引用的对象\"窃取\"状态。 13.4.1.2 变量是左值 变量可以看作只有一个运算对象而没有运算符的表达式。变量表达式都是左值，这意味着我们不能讲一个右值引用绑定到一个右值引用类型的变量上： int &&rr1 = 42; //正确：字面常量是右值 it &&rr2 = rr1; //错误：表达式 rr1 是左值！ 其实有了右值表示临时对象这一观察结果，变量是左值这一特性并不令人惊讶。毕竟，变量是持久的，直至离开作用域时才被销毁。 变量是左值，因此我们不能将一个右值引用直接绑定到一个变量上，即使这个变量是右值引用类型也不行。 13.4.1.3 标准库 move 函数 虽然不能将一个右值引用直接绑定到一个左值上，但我们可以显示地将一个左值转换为对应的右值引用类型。我们还可以通过调用一个名为 move 的新标准库函数来获得绑定到左值上的右值引用。 move 定义在头文件 utility 中。 # inclue < utility > int && rr3 = std :: move ( rr1 ); // ok move 调用告诉编译器：我们有一个左值，但我们希望像一个右值一样处理它。我们必须认识到，调用 move 就意味承诺：除了对 rr1 赋值或销毁它外，我们将不再使用它。 我们可以销毁一个移后源对象，也可以赋予它新值，但不能使用一个移后源对象的值。 对 move 我们不提供 using 声明。我们直接调用 std::move 而不是 move 。这样可以避免潜在的名字冲突。 13.4.2 移动构造函数和移动赋值运算符 类似 string 类（及其他标准库类），如果我们自己的类也同时支持移动和拷贝，那么也能从中受益。这两个成员类似对应的拷贝操作，但它们从给定对象\"窃取\"资源而不是拷贝资源。 类似拷贝构造函数，移动构造函数的第一个参数是该类类型的一个引用。不同于拷贝构造函数的是，这个引用参数在移动构造函数中是一个右值引用。与拷贝构造函数一样，任何额外的参数都必须有默认实参。 除了完成资源移动，移动构造函数还必须确保移后源对象处于这样一个状态——销毁它是无害的。 作为一个例子，我们为 StrVec 类定义移动构造函数，实现从一个 StrVec 到另一个 StrVec 的元素移动而非拷贝： StrVec::StrVec(StrVec &&s) noexcept //移动操作不应抛出任何异常 //c成员初始化器接管s中的资源 ：elements(s.elements), first_free(s.first_free), cap(s.cap) { //令s进入这样的状态———对其运行析构函数是安全的 s.elements = s.first_free = s.cap = nullptr; } 13.4.2.1 移动操作、标准库容器和异常 由于移动操作\"窃取\"资源，它通常不分配任何资源。因此，移动操作通常不会抛出任何异常。一种通知标准库的方法是在我们的构造函数中指明 noexcept 。 noexcept 是新标准引入的。在一个构造函数中， noexcept 出现在参数列表被初始化列表开始的冒号之间。我们必须在类头文件声明和定义中（如果定义在类外的话）都指定 noexcept 。 不抛出异常的移动构造函数和移动赋值运算符必须标记为 noexcept 。 13.4.2.2 移动赋值运算符 移动赋值运算符执行与析构函数和移动构造函数相同的工作。 StrVec &StrVec::operator=(StrVec &&rhs) noexcept { //直接检测自赋值 if (this != &rhs){ free(); //释放已有元素 elements = rhs.elements; //从 rhs 接管资源 first_free = rhs.first_free; cap = rhs.cap; //将 rhs 置于可析构状态 rhs.elements = rhs.first_free = rhs.cap = nullptr; } return *this; } 我们进行自赋值检查的原因是此右值可能是 move 调用的返回结果。 13.4.2.3 移后源对象必须可析构 在移动操作之后，移后源对象必须保持有效的、可析构的状态，但是用户不能对其值进行任何假设。 13.4.2.4 合成的移动操作 只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非 static 数据成员都可以移动时，编译器才会为它合成移动构造函数或移动赋值运算符。 与拷贝操作不同，移动操作永远不会隐式定义为删除的函数。但是，如果我们显示地要求编译器生成 =default 的移动操作，且编译器不能移动所有成员，则编译器会将移动操作定义为删除的函数。 移动操作和合成的拷贝控制成员之间还有最后一个相互作用关系：一个类是否定义了自己的移动操作对拷贝操作如何合成有影响。如果类定义了一个移动构造函数和/或一个移动赋值运算符，则该类的合成拷贝构造函数和拷贝赋值运算符会被定义为删除的。 13.4.2.5 移动右值，拷贝左值 如果一个类既有移动构造函数，也有拷贝构造函数，编译器使用普通的函数匹配规则来确定使用哪个构造函数。赋值操作的情况类似。 13.4.2.6 但如果没有移动构造函数，右值也被拷贝 使用拷贝构造函数代替移动构造函数几乎肯定是安全的。 13.4.2.7 拷贝并交换赋值运算符和移动操作 13.4.2.8 更新的三/五法则 一般来说，如果一个类定义了任何一个拷贝操作，它就应该定义所有五个操作。 13.4.2.9 移动迭代器 新标准库中定义了一种移动迭代器（move iterator）适配器。一个移动迭代器通过改变给定迭代器的解引用运算符的行为来适配此迭代器。一般来说，一个迭代器的解引用运算符返回一个指向元素的左值。与其他迭代器不同，移动迭代器的解引用运算符生成一个右值引用。 我们通过调用标准库的 make_move_iterator 函数将一个普通迭代器转换为一个移动迭代器。此函数接受一个迭代器参数，返回一个移动迭代器。 原迭代器的所有其他操作在移动迭代器中都照常工作。由于移动迭代器支持正常的迭代器操作，我们可以将一对移动迭代器传递给算法。特别地，可以将移动迭代器传递给 uninitialized_copy ： void StrVec::reallocate() { //分配大小两倍于当前规模的内存空间 auto newcapacity = size() ? 2 * size() : 1; auto first = alloc.allocate(newcapacity); //移动元素 auto last = uninitialized_copy(make_move_iterator(begin()), make_move_iterator(end()), first); free(); //释放旧空间 elements = first; //更新指针 first_free = last; cap = elements + newcapacity; } 不要随意使用移动操作，由于一个移后源对象具有不确定的状态，对其调用 std::move 是危险的。当我们调用 move 时，必须绝对确认移后源对象没有其他用户。 通过在类代码中小心地使用 move ，可以大幅度提升性能。而如果随意在普通用户代码（与类实现代码相对）中使用移动操作，很可能导致莫名其妙的、难以查找的错误，而难以提升应用程序性能。 13.4.3 右值引用和成员函数 除了构造函数和赋值运算符外，如果一个成员函数同时提供拷贝和移动操作，它也能从中受益。一个版本接受一个指向 const 的左值引用，另一个版本接受指向非 const 的右值引用。 一般来说，我们不需要为函数操作定义接受一个 const X&& 或是一个（普通的） X& 参数的版本。当我们希望从实参\"窃取\"数据时，通常传递一个右值引用。为了达到这一目的，实参不能是 const 的。类似的，从一个对象进行拷贝的操作不应该改变该对象，因此，通常不需要定义一个接受（普通的） X& 参数的版本。 区分移动和拷贝的重载函数通常有一个版本接受一个 const T& ，而另一个版本接受 T&& 。 class StrVec { public : void push_back ( const std :: string & ); //移动元素 void push_back ( std :: string && ); //拷贝元素 //其他成员的定义 }; void StrVec : push_back ( const string & s ){ chk_n_alloc (); //确保有空间容纳新元素 //在 first_free 指向的元素中构造 s 的一个副本 alloc . constructor ( first_free ++ , s ); } void StrVec :: push_back ( string && ){ chk_n_alloc (); //如果需要的话为 StrVec 重新分配内存 alloc . constructor ( first_free ++ , std :: move ( s )); } constructor 函数使用第二个和随后的实参类型来确定使用哪个构造函数。由于 move 返回一个右值引用，因此，会使用 string 的移动构造函数来构造新元素。 13.4.3.1 左值和右值引用成员函数 13.4.3.2 重载和引用函数 就像一个成员函数可以根据是否有 const 来区分其重载版本一样，引用限定符也可以区分重载版本。而且，我们可以综合引用限定符和 const 来区分一个成员函数的重载版本。 当我们定义 const 成员函数时，可以定义两个版本，唯一的差别是一个版本有 const 限定而另一个没有。引用限定的函数则不一样。如果我们定义两个或两个以上具有相同名字和相同参数列表的成员函数，就必须对所有函数都加上引用限定符，或者所有都不加。","tags":"读书笔记","url":"https://xutree.github.io/pages/2018/10/20/C++_Primer_Chapter_13/"},{"title":"C++ Primer 第十二章 动态内存","text":"一个由 C/C++ 编译的程序占用的内存分为以下几个部分： 栈区（stack）：由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈 堆区（heap）：一般由程序员分配释放，若程序员不释放，程序结束时可能由 OS 回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表 全局区（静态区）（static）：全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量、未初始化的静态变量在相邻的另一块区域。程序结束后由系统释放 文字常量区：常量字符串就是放在这里的。程序结束后由系统释放 程序代码区：存放函数体的二进制代码 12.1 动态内存与智能指针 在 C++ 中，动态内存的管理是通过一对运算符来完成的： new ，在动态内存中为对象分配空间并返回一个指向该对象的指针，我们可以选择对对象进行初始化； delete ，接受一个动态指针，销毁该对象，并释放与之关联的内存。 为了更容易地使用动态内存，新的标准提供了两种智能指针(smart pointer)类型来管理动态对象。 shared_ptr 允许多个指针指向同一个对象； unique_ptr 则\"独占\"所指向的对象。标准库还定义了一个名为 weak_ptr 的伴随类，指向 shared_ptr 所管理的对象。这三种类型都定义在 memory 头文件中。 12.1.1 shared_ptr 类 类似 vector 智能指针也是模板： shared_ptr<string> p1; //shared_ptr，可以指向 string shared_ptr<list<int>> p2; //shared_ptr,可以指向 int 的 list 当我们创建 shared_ptr 时，可以传递一个（可选的）指向删除器函数的参数。 智能指针操作： 12.1.1.1 make_shared 函数 最安全的分配和使用动态内存的方法是调用一个名为 make_shared 的标准库函数。此函数在动态内存中分配一个对象并初始化它，返回指向此对象的 shared_ptr 。与智能指针一样， make_shared 也定义在 memory 头文件中。 //指向一个值为42的 int 的 shared_ptr shared_ptr<int> p3 = make_shared<int>(42); //p4 指向一个值为\"999999999\"的 string shared_ptr<string> p4 = make_shared<string>(10,'9'); //p5 指向一个值初始化的 int，即，值为0 shared_ptr<int> p5 = make_shared<int>(); 类似顺序容器的 emplace 成员， make_shared 用其参数来构造给定类型的对象。例如，调用 make_shared<string> 时传递的参数必须与 string 的某个构造函数相匹配。 当然，我们通常用 auto 定义一个对象来保存 make_shared 的结果，这种方式简单： //p6 指向一个动态分配的空 vector<string> auto p6 = make_shared<vector<string>>(); 12.1.1.2 shared_ptr 的拷贝和赋值 当进行拷贝或赋值操作时，每个 shared_ptr 都会记录有多少个其他 shared_ptr 指向相同的对象。 我们可以认为每个 shared_ptr 都有一个关联的计数器，通常称其为引用计数(reference count)。无论何时我们拷贝一个 shared_ptr ，计数器都会递增；当我们给 shared_ptr 赋予一个新值或是 shared_ptr 被销毁时，计算器就会递减。 一旦一个 shared_ptr 的计数器变为0，它就会自动释放自己所管理的对象。 auto r = make_shared<int>(42); //r 指向的 int 只有一个引用者 r = q; //给 r 赋值，令它指向另一个地址 //递增 q 指向的对象的引用计数 //递减 r 原来指向对象的引用计数 //r 原来指向的对象已没有引用者，会自动释放 shared_ptr 自动销毁所管理的对象，还会自动释放相关联的内存。 如果你将 shared_ptr 存放于一个容器中，而后不再需要全部元素，要记得使用 erase 删除不需要的那些元素，否则 shared_ptr 在无用之后会仍然保留。 12.1.2 直接管理内存 C++ 语言定义了两个运算符来分配和释放动态内存。运算符 new 分配内存， delete 释放 new 分配的内存。相对于智能指针，使用这两个运算符管理内存非常容易出错。 12.1.2.1 使用 new 动态分配和初始化对象 在自由空间分配的内存是无名的，因此 new 无法为其分配的对象命名，而是返回一个指向该对象的指针： int *pi = new int; //pi 指向一个动态分配的、未初始化的无名对象 默认情况下，动态分配的对象是默认初始化的，这意味着内置类型或组合类型的对象的值将是未定义的，而类类型对象将用默认构造函数进行初始化： string *ps = new string; //初始化为空 string int *pi = new int; //pi 指向一个未初始化的 int //可以使用直接初始化方式来初始化一个动态分配的对象 int *pi = new int(1024); //pi 指向的对象的值为1024 string *ps = new string(10,'9'); //*ps 为\"999999999\" //vector 有10个元素，值依次从0到9 vector<int> *pv = new vector<int>{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; 也可以对动态分配的对象进行值初始化，只需在类型名之后跟一对空括号即可： string *ps1 = new string; //默认初始化为空 string string *ps = new string(); //值初始化为空 string int *pi1 = new int; //默认初始化；*pi1 的值未定义 int *pi2 = new int(); //值初始化为0；*pi2 为0 如果我们提供了一个括号包围的初始化器，就可以用 auto 从此初始化器推断我们想要分配的对象的类型。但是由于编译器要用初始化器类型来推断分配的类型，只有当括号中仅有单一初始化器时才可以使用 auto （这也意味着不能用 auto 动态分配数组）。 12.1.2.2 动态分配的 const 对象 //分配并初始化一个 const int const int *pci = new const int(1024); //分配并默认初始化一个 const 的空 string const string *pcs =new const string; 类似其他任何 const 对象，一个动态分配的 const 对象必须进行初始化。对于一个定义了默认构造函数的类类型，其 const 动态对象可以隐式初始化，而其他类型的对象就必须显式初始化。由于分配的对象是 const 的， new 返回的指针是一个指向 const 的指针。 12.1.2.3 内存耗尽 默认情况下，如果 new 不能分配所要求的内存空间，它会抛出一个类型为 bad_alloc 的异常。我们可以改变使用 new 的方式来阻止它抛出异常： //若果分配失败，new返回一个空指针 int *p1 = new int; //如果分配失败，new 抛出std::bad_alloc int *p2 = new (nothrow) int; //如果分配失败，new 返回一个空指针 我们称这种形式的 new 为定位 new ， bad_alloc 和 nothrow 都定义在 new 头文件中。 12.1.2.4 释放动态内存 为了防止内存耗尽，在动态内存使用完毕后，必须将其归还给系统。我们通过 delete 表达式(delete expression)来将动态内存归还给系统。 与 new 类似， delete 表达式也执行两个动作：销毁给定的指针指向的对象；释放对应的内存。在 delete 之后，指针就变成了人们所说的空悬指针，即指向一块曾经保存数据对象但现在已经无效的内存的指针。如果需要保留指针，可以在 delete 之后将 nullptr 赋予指针。 12.1.2.5 使用 new 和 delete 管理动态内存存在的三个常见问题 忘记 delete 内存。忘记释放动态内存会导致人们常说的\"内存泄露\"问题，因为这种内存永远不可能归还给自由空间了。查找内存泄露错误是非常困难的。 使用已经释放掉的对象。通过在释放内存后将指针置为空，有时可以检测出这种错误。 同一块内存释放两次。当两个指针指向相同的动态分配对象时，可能发生这种错误。 12.1.3 shared_ptr 和 new 结合使用 如前所述，如果我们不初始化一个智能指针，他就会被初始化为一个空指针。如下表所示，我们还可以用 new 返回的指针来初始化智能指针： shared_ptr<double> p1; //shared_ptr 可以指向一个 double shared_ptr<int> p2(new int (42)); //p2 指向一个值为42的 int 接受指针参数的智能指针构造函数是 explicit 的。因此，我们不能将一个内置指针隐式转换为一个智能指针，必须使用直接初始化形式来初始化一个智能指针： shared_ptr<int> p1 = new int(1024); //错误：必须使用直接初始化形式 shared_ptr<int> p2(new int (1024)); //正确：使用了直接初始化 出于相同的原因，一个返回 shared_ptr 的函数不能在其返回语句中隐式转换一个普通指针： shared_ptr<int> clone(int p){ return new int(p); //错误：隐式转换为 shared_ptr<int> } //我们必须将 shared_ptr 显式绑定到一个想要返回的指针上： shared_ptr<int> clone(int p){ //正确：显式地用 int* 创建 shared_ptr<int> return shared_ptr<int>(new int(p)); } 默认情况下，一个用来初始化智能指针的普通指针必须指向动态内存，因为智能指针默认使用 delete 释放它所关联的对象。 不要混合使用普通指针和智能指针： 也不要使用get初始化另一个智能指针或为智能指针赋值： 12.1.4 unique_ptr 指针 一个 unique_ptr \"拥有\"它所指向的对象。与 shared_ptr 不同，某个时刻只能有一个 unique_ptr 指向一个给定对象。 与 shared_ptr 不同，没有类似 make_shared 的标准库函数返回一个 unique_ptr 。当我们定义一个 unique_ptr 时，需要将其绑定到一个 new 返回的指针上。类似 shared_ptr ，初始化 unique_ptr 必须采用直接初始化形式： unique_ptr<double> p1; //可以指向一个 double 的 unique_ptr unique_ptr<int> p2(new int(42)); //p2 指向一个值为42的 int 由于一个 unique_ptr 拥有它指向的对象，因此 unique_ptr 不支持普通的拷贝或赋值操作： unique_ptr<string> p1(new string(\"Stegosaurus\"); unique_ptr<string> p2(p1); //错误：unique_ptr 不支持拷贝 unique_ptr<string> p3; p3 = p2; //错误：unique_ptr 不支持赋值 unique_ptr 特有的操作： 虽然我不能拷贝或赋值 unique_ptr ，但可以通过调用 release 或 reset 将指针的所有权从一个（非 const ） unique_ptr 转移给另一个 unique ： //将所有权从 p1（指向 string Stegosaurus）转移给 p2 unique_ptr<string> p2(p1.release()); //release 将 p1 置为空 unique_ptr<string> p3(new string(\"Trex\")); //将所有权从 p3 转移给 p2 p2.reset(p3.release()); //reset 释放了 p2 原来指向的内存 调用 release 会切断 unique_ptr 和它原来管理的对象间的联系。 release 返回的指针通常被用来初始化另一个智能指针或给另一个智能指针赋值。 12.1.4.1 传递 unique_ptr 参数和返回 unique_ptr 不能拷贝 unique_ptr 的规则有一个例外：我们可以拷贝或赋值一个将要被销毁的 unique_ptr 。最常见的例子是从函数返回一个 unique_ptr ： unique_ptr<int> clone(int p){ //正确：从int*创建一个unique_ptr<int> return unique_ptr<int>(new int(p)); } //还可以返回一个局部对象的拷贝 unique_ptr<int> clone(int p){ unique_ptr<int> ret(new int(p)); //... return ret; } 对于两段代码，编译器都知道要返回的对象将要销毁。在此情况下，编译器执行一种特殊的\"拷贝\"。 12.1.4.2 向 unique_ptr 传递删除器 类似 shared_ptr ， unique_ptr 默认情况下用 delete 释放它指向的对象。与 shared_ptr 一样，我们可以重载一个 unique_ptr 中默认的删除器。与重载关联容器的比较操作类似，我们必须在尖括号中 unique_ptr 指向类型之后提供删除器类型。在创建或 reset 一个这种 unique_ptr 类型对象时，必须提供一个指定类型的可调用对象（删除器）： //p指向一个类型为 objT 的对象，并使用一个类型为 delT 的对象释放 objT 对象 //它会调用一个名为 fcn 的 delT 类型对象 unique_ptr<objT, delT> p(new objT,fcn); //作为一个更具体的例子，我们将重写连接程序，用 unique_ptr 代替 shared_ptr void f(destination &d /*其他需要的参数*/) { connection c = connect(&d); //打开连接 //当 p 被销毁时，连接将会关闭 unique_ptr<connection, decltype(end_connection)*> p(&c, end_connection); //使用连接 //当 f 退出时，connection 会被正确关闭 } 12.1.5 weak_ptr weak_ptr 是一种不控制所指向对象生存期的智能指针，它指向由一个 shared_ptr 管理的对象。将一个 weak_ptr 绑定到一个 shared_ptr 不会改变 shared_ptr 的引用计数。 一旦最后一个指向对象的 shared_ptr 被销毁，对象就会被释放，即使有 weak_ptr 指向对象。 weak_ptr 操作： 当创建一个 weak_ptr 时，要用一个 shared_ptr 来初始化它： auto p = make_shared<int>(42); weak_ptr<int> wp(p); //wp 弱共享 p；p 的引用计数未改变 由于对象可能不存在，我们不能使用 weak_ptr 直接访问对象，而必须调用 lock 。此函数检查 weak_ptr 指向的对象是否存在。 12.2 动态数组 new 和 delete 运算符一次分配/释放一个对象，但某些应用需要一次为很多对象分配内存的功能。为了支持这种需求，C++ 语言和标准库提供了两种一次分配一个对象数组的方法。C++ 语言定义了一种 new 表达式，可以分配并初始化一个对象数组。 标准库中包含一个名为 allocator 的类，允许我们将分配和初始化分离。使用 allocator 通常会提供更好的性能和更灵活的内存管理能力。 大多数应用应该使用标准库容器而不是动态分配的数组。使用容器更为简单、更不容易出现内存管理错误并且可能有更好的性能。 12.2.1 new 和数组 //调用 get_size 确定分配多少个 int int *pia = new int[get_size]; //pia 指向第一个 int //方括号中的大小必须是整型，但不必是常量 typedef int arrT[42]; //arrT 表示42个 int 的数组类型 int *p = new arrT; // 12.2.1.1 分配一个数组会得到一个元素类型的指针 虽然我们通常称 new T[] 分配的内存为\"动态数组\"，但这种叫法某种程度上有些误导。当用 new 分配一个数组时，我们并未得到一个数组类型的对象，而是得到一个数组元素类型的指针。 由于分配的内存并不是一个数组类型，因此不能对动态数组调用 begin 和 end 。这些函数使用数组维度来返回指向首元素和尾元素的指针。处于相同的原因，也不能用范围 for 语句来处理（所谓的）动态数组中的元素。 要记住我们所说的动态数组并不是数组类型，这是很重要的。 12.2.1.2 初始化动态分配对象的数组 默认情况下， new 分配的对象，不管是单个分配的还是数组中的，都是默认初始化的。可以对数组中的元素进行值初始化，方法是在大小之后跟一对空括号。 int *pia = new int[10]; //10个未初始化的 int int *pia2 = new int[10](); //10个值初始化为0的 int string *psa = new string[10]; //10个空 string string *psa2 = new string[10](); //10个空 string //在新标准中，我们还提供一个元素初始化器的花括号列表： //10个 int 分别用列表中对应的初始化器初始化 int *pia3 = new int[10] {0,1,2,3,4,5,6,7,8,9}; //10个 string，前4个用给定的初始化器初始化，剩余的进行值初始化 string *psa3 = new string[10]{\"a\", \"an\", \"the\", string(3,'x')}; 如果初始化器数目大于元素数目，则 new 表达式失败，不会分配任何内存，并抛出 bad_array_new_length 的异常，类似于 bad_alloc ，此类型定义在头文件 new 中。 12.2.1.3 动态分配一个空数组是合法的 我们在使用 new 分配一个动态数组时，可以指定分配数组的大小为0，这样做是合法的： char *pc = new char(0); 此时 new 返回一个与其他 new 表达式返回类型都不同的指针类型， 该指针不能解引用，就像一个数组的尾后迭代器一样。 12.2.1.4 释放动态数组 为了释放动态数组，我们使用一种特殊形式的 delete ——在指针前加上一个空括号对： delete p; //p 必须指向一个动态分配的对象或为空 delete [] pa; //pa 必须指向一个动态分配的数组或为空 第二条语句销毁 pa 指向的数组中的元素，并释放对应的内存。数组中的元素按逆序销毁，即，最后一个元素首先被销毁，然后是倒数第二个，以此类推。 当我们释放一个动态数组时，空方括号是必须的，它指示编译器此指针指向一个对象数组的第一个元素。 delete 一个动态数组时未添加空方括号或 delete 一个普通指针时添加了空方括号，其行为都是未定义的。 前面我们讲到， 可以使用 typedef 来给动态数组起一个别名，这样在 new 一个动态数组时就不必添加方括号 [] ，即使这样，我们在释放一个动态数组时，仍然需要添加方括号 [] ，因为它本质上还是一个动态数组。 12.2.1.5 智能指针和动态数组 unique_ptr 智能指针有个可以管理 new 分配的动态数组的版本，为了使用一个 unique_ptr 来管理动态数组，需要在对象类型后加一个空方括号 [] : unique_ptr<int[]> up(new int[10]()); up.release(); // 自动调用 delete [] 销毁其指针 当一个 unique_ptr 指向一个数组时，我们不能使用点和箭头成员运算符，毕竟， unique_ptr 指向的是一个数组而不是单个对象。不过，我们可以使用下表运算符来访问数组中的元素： for (size_t i = 0; i < 10; ++i) up[i] = i; shared_ptr 不支持动态数组，如果希望使用 shared_ptr 管理一个动态数组，我们需要提供自己的删除器： shared_ptr<int> sp(new int[10], [](int* p){ delete [] p; }); sp.reset(); 我们在这个例子中使用 lambda 做为 shared_ptr 的删除器，如果我们不提供删除器，这样的行为是未定义的，因为默认情况下 shared_ptr 使用 delete 来释放内存，使用 delete 来释放一个动态数组的定位是未定义的。 shared_ptr 不支持动态数组这一特性会影响我们访问数组中的元素： for (size_t i = 0; i != 10; ++i) *(sp.get() + i) = i; shared_ptr 没有定义下标运算符，而且智能指针不支持指针算术运算。因此，为了访问数组中的元素，我们必须用 get 成员函数获取一个内置指针，然后使用该内置指针来访问数租元素。 12.2.2 allocator 类 标准库 allocator 类定义在头文件 memory 中。它帮助我们将内存分配和构造分离开来，它分配的内存是原始的、未构造的。 类似 vector ， allocator 也是一个模板类，我们在定义一个 allocator 类类型的时候需要制定它要分配内存的类型，它会根据给定的对象类型来确定恰当的内存大小和对齐位置： allocator<string> alloc; auto const p = alloc.allocate(n); // 分配 n 个未初始化的 string allocator 类及其算法： 操作 意义 allocator a 定义了一个名为 a 的 allocator 对象，可以为类型为 T 的对象分配内存 a.allocate(n) 分配一段原始的、未构造的内存，保存 n 个类型为 T 的对象 a.deallocate(p, n) 释放从 T* 指针 p 中地址开始的内存，这块内存保存了 n 个类型为 T 的对象；p 必须是一个先前由 allocate 成员函数返回的指针，且 n 必须是创建时候的大小，在调用 deallocate 之前，用户必须对每个在在这块内存中创建的对象调用 destroy 函数 a.construct(p, args) p 必须是一个类型为 T* 的指针，指向一块原始内存，args 被传递给类型为 T 的构造函数 a.destroy(p) p 为 T* 类型的指针，此算法对 p 执行析构函数 12.2.2.1 allocator 分配未构造的内存 auto q = p; //q 指向最后构造的元素之后的位置 alloc.construct(q++); //*q 为空字符串 alloc.construct(q++, 10, 'c'); //*q 为cccccccccc alloc.construct(q++, \"hi\"); //*q 为hi 为了使用 allocate 返回的内存，我们必须用 construct 构造对象。使用未构造的内存，其行为是未定义的。 当我们用完对象后，必须对每个构造的元素调用 destroy 来销毁它们。函数 destroy 接受一个指针，对指向的对象执行析构函数： while(q != p) alloc.destroy(--q); //释放我们真正构造的 string 一旦元素被销毁后，就可以重新使用这部分内存来保存其他 string ，也可以将其归还给系统。释放内存通过调用 deallocate 来完成： alloc.deallocate(p, n); //传递给 deallocate 的指针不能为空，它必须指向由 allocate 分配的内存 //传递给 deallcoate 的大小参数必须与调用 allocate 分配内存时提供的大小参数具有一样的值 我们只能对真正构造了的元素进行 destroy 操作。 12.2.2.2 拷贝和填充为初始化内存的算法 标准库为 allocator 类定义了两个伴随算法，可以在未初始化内存中创建对象： 操作 意义 uninitialized_copy(b, e, b2) 从迭代器 b 和 e 指出的输入范围中拷贝元素到迭代器 b2 指定的未构造的原始内存中，b2 指向的内存必须足够大，能容下输入序列中的元素的拷贝 uninitialized_copy_n(b, n, b2) 从迭代器 b 指向的元素开始，拷贝 n 个元素到 b2 开始的原始内存中 uninitialized_fill(b, e, t) 在迭代器 b 和 e 指定的原始内存范围中创建对象，值均为 t 的拷贝 uninitialized_fill_n(b, n, t) 从迭代器 b 指向的原始内存地址开始创建 n 个对象，b 必须指向足够大的未构造的原始内存，能容纳给定数量的对象 这些函数在给定目的位置创建元素，而不是由系统分配内存给他们。 vector<int> vec{0, 1, 2, 3, 4, 5}; auto p = alloc.allocate(vec.size() * 2); auto q = uninitialized_copy(vec.begin(), vec.end(), p); uninitialize_fill_n(q, vec.size(), 42); uninitialized_copy 在给定位置构造元素，函数返回递增后的目的位置迭代器。因此，一个 uninitialized_copy 调用会返回一个指针，指向 最后一个构造的元素之后的位置。","tags":"读书笔记","url":"https://xutree.github.io/pages/2018/10/17/C++_Primer_Chapter_12/"},{"title":"C++ Primer 第十一章 关联容器","text":"关联容器和顺序容器有着根本的不同：关联容器中的元素是按关键字来保存和访问的。与之相对，顺序容器中的元素是按它们在容器中的位置来顺序保存和访问的。 关联容器支持高效的关键字查找和访问。两个主要的关联容器（associative-container）类型是 map 和 set 。 map 中的元素是一些关键字-值（key-value）对：关键字起到索引的作用，值则表示与索引相关联的数据。 set 中每个元素只包含一个关键字， set 支持高效的关键字查询操作。 类型 map 和 multimap 定义在头文件 map 中； set 和 multiset 定义在头文件 set 中；无序容器则定义在头文件 unordered_map 和 unordered_set 中。无序容器使用哈希函数来组织元素。 关联容器类型： 按关键字有序保存元素 map：关联数组，保存关键字-值对 set：关键字即值，即只保存关键字的容器 multimap：关键字可重复的 map multiset：关键字可重复的 set 无序集合 unordered_map：用哈希函数组织的 map unordered_set：用哈希函数组织的 set unordered_multimap：哈希组织的 map，关键字可重复出现 unordered_multiset：哈希组织的 set，关键字可重复出现 11.1 关联容器概述 关联容器（有序和无序的）都支持如下的普通容器操作： 关联容器不支持顺序容器位置相关的\b操作，例如 push_front 或 push_back ，关联容器也不支持构造函数或插入操作这些接受一个元素值和一个数量值的操作。 关联容器的迭代器都是双向的。 11.1.1 定义关联容器 每个关联容器都定义一个默认构造函数，它创建一个指定类型的空容器。我们可以将关联容器初始化为另一个同类型容器的拷贝，或者从一个值范围来初始化关联容器，只要这些值可以转换为容器所需类型就行。在新标准下，我们也可以对关联容器进行值初始化，与往常一样，初始化器必须能够转换为容器中元素的类型： map<string, size_t> word_count; //空容器 //列表初始化 set<string> exclude = {\"the\", \"but\", \"and\"}; //两个元素，列表初始化 map<string, string> authors = { {\"Joyce\", \"James\"}, {\"Austen\", \"Jane\"} }; 11.1.2 关键字类型的要求 11.1.2.1 有序容器 关键字类型必须定义元素比较的方法，默认情况下，标准库使用关键字类型的 < 运算符来比较两个关键字。 11.1.2.2 无序容器 默认情况下，无序容器使用关键字类型的 == 运算符来比较元素，它们还使用一个 hash<key_type> 类型的对象来生成每个元素的哈希值。标准库为内置类型（包括指针）提供了 hash 模板。还为一些标准库类型，包括 string 和智能指针类型定义了 hash 。 因此，我们可以直接定义关键字是内置类型（包括指针类型）、 string 还有智能指针类型的无序容器。 但是，我们不能直接定义关键字类型为自定义类类型的无序容器。\b我们必须提供自己的 hash 模板版本。 11.1.2.3 使用关键字类型的比较函数 multiset<Sales_data, decltype(compareIsbn)*> bookstore(compareIsbn); 用尖括号指出要定义哪种类型的容器，自定义的操作类型必须在尖括号中紧跟着元素类型给出 比较操作的类型应该是一种函数指针类型 在尖括号中的类型仅仅是一个类型而已，当我们创建一个容器（对象）时，才会以构造函数参数的形式提供真正的比较操作（其类型必须与尖括号中指定的类型吻合） 当使用 decltype \b来获得一个函数指针类型时，必须加上一个\"*\"来指出我们需要一个函数指针类型 用于初始化 bookstore 对象的参数也可以写作 &compareIsbn ，因为函数名会自动转换为函数指针 11.1.3 pair 类型 pair 标准\b库类型定义在头文件 utility 中。一个 pair 保存两个数据成员。 pair 是一个用来生成特定类型的模板。 pair 的默认构造函数对数据成员进行值初始化。 pair 的成员是 public 的，两个成员为 first 和 second 。 标准库定义的 pair 操作： 操作 意义 pair p; p 是一个 pair，两个类型分布为 T1 和 T2 的成员都进行值初始化 pair p(v1, v2); 用 v1 和 v2 初始化 pair p = 同上 make_pair(v1, v2) 返回一个用 v1 和 v2 初始化的 pair，pair 的类型由 v1 和 v2 推断而来 p.first, p.second 成员 p1 relop p2 关系运算符按字典顺序定义。关系运算利用元素的 < 运算符实现 p1 == p2, p1 != p2 相等性判定利用元素的 == 运算符实现 创建返回 pair 对象的函数 pair<string, int> process(vector<string> &v) { //处理 v if (!v.empty()) //列表初始化 return {v.back(), v.back().size()}; else //隐式构造返回值 return pair<string, int>(); } 11.2 关联容器操作 关联容器额外定义了一些类型别名： 别名 意义 key_type 此容器类型的关键字类型 mapped_type 每个关键字关联的类型，只适用于 map value_type 对于 set ，与 key_type 相同，对于 map ，为 pair 由于我们不能改变一个元素的关键字，因此这些 pair 的关键字部分是 const 的。 set<string>::value_type v1; //v1 是一个 string set<string>::key_type v2; //v2 是一个 string map<string, int>::value_type v3; //v3 是一个 pair<const string, int> map<string, int>::key_type v4; //v4 是一个 string map<string, int>::mapped_type v5; //v5 是一个 int 11.2.1 关联容器迭代器 当解引用一个关联容器迭代器时，我们会得到一个类型为容器的 value_type 的值的引用。 对 map 而言，得到 pair 类型，其 first 成员保存 const 关键字，second 成员保存值 对 set 而言，迭代器也是 const 的 当使用一个迭代器遍历一个 map 、 multimap 、 set 、 multiset 时，迭代器按关键字升序遍历元素。 我们通常不对关联容器使用泛型算法。在实际编程中，如果我们真的要对一个关联容器使用算法，要么将它作为一个源序列，要么将它作为一个目的位置。 11.2.2 添加元素 返回值： 不包含重复关键字的容器：返回一个 pair ，first 成员是一个迭代器，指向具有给定关键字的元素，second 成员是一个 bool 值，关键字不存在，为 true ，否则为 false 包含重复关键字的容器：返回一个指向新元素的迭代器 11.2.3 删除元素 11.2.4 map 下标操作 操作 意义 c[k] 返回关键字为 k 的元素；如果 k 不在 c 中，添加一个关键字为 k 的元素，对其进行值初始化 c.at(k) 访问关键字为 k 的元素，带参数检查；若 k 不在 c 中，抛出 out_of_range 异常 由于下标运算可能插入一个新元素，我们只可以对非 const 的 map 使用下标操作。 map 下标操作与其他下标操作不同的地方：对 map 进行下标操作时，会得到一个 mapped_type 对象；但当解引用一个 map 迭代器时，得到一个 value_type 对象。 map 下标操作与其他下标操作相同的地方：返回一个左值，可读也可写。 11.2.5 访问元素 lower_bound 和 upper_bound 不适用于无序容器。 下标和 at 操作只适用于非 const 的 map 和 unordered_map 。 对 map 使用 find 代替下标操作，以防添加不存在元素。 11.3 无序容器 新标准定义了4个无序关联容器（unordered associative container）。这些容器不是使用比较运算符来组织元素，而是使用一个哈希函数和关键字类型的 == 运算符。 除了哈希管理操作之外，无序容器还提供了与有序容器相同的操作。 11.3.1 管理桶 无序容器在存储上组织为一组桶，每个桶保存零个或多个元素。 无序容器使用一个哈希函数将元素映射到桶。 为了访问一个元素，容器首先计算元素的哈希值，它指出应该搜索哪个桶。 容器将具有一个特定哈希值的所有元素都保存在相同的桶中。 如果容器允许重复关键字，所有具有相同关键字的元素也都会在同一个桶中。 无序容器的性能依赖于哈希函数的质量和桶的数量和大小。 对于相同的参数，哈希函数必须总是产生相同的结果。 理想情况下，哈希函数还能将每个特定的值映射到唯一的桶。但是将不同关键字的元素映射到相同的桶也是允许的。 当一个桶保存多个元素时，需要顺序搜索这些元素来查找我们想要的那个。计算一个元素的哈希值和在桶中搜索通常都是很快的操作。但是如果一个桶保存了很多元素，那么查找一个特定元素就需要大量比较操作。 无序容器提供了一组管理桶的函数： 11.3.2 无序容器对关键字类型的要求","tags":"读书笔记","url":"https://xutree.github.io/pages/2018/10/17/C++_Primer_Chapter_11/"},{"title":"C++ Primer 第十章 泛型算法","text":"顺序容器只定义了很少的操作：在多数情况下，我们可以添加和删除元素。访问首尾元素、确定容器是否为空以及获得指向首元素或尾元素之后位置的迭代器。 如果我们想要做：查找特定元素、替换或删除一个特定值、重排元素顺序等。标准库并未给每个容器都定义成员函数来实现这些操作，而是定义了一组泛型算法：称它们为\"算法\"，是因为它们实现了一些经典算法的公共接口，如排序和搜索；称它们是\"泛型的\"，是因为它们可用于不同类型的元素和多种容器类型（不仅包括标准库类型，如 vector 或 list ，还包括内置的数组类型）。 10.1 概述 大多数算法都定义在头文件 algorithm 中。标准库还在头文件 numeric 中定义了一组数值泛型算法。 一般情况下，这些算法并不直接操作容器，而是遍历由两个迭代器指定的一个元素范围来进行操作。通常情况下，算法遍历范围，对其中每个元素进行一些处理。 迭代器令算法不依赖于容器，但算法依赖于元素类型的操作。虽然迭代器的使用令算法不依赖于容器类型。但大多数算法都使用了一个(或多个)元素类型上的操作。例如， find 用元素的 == 运算符完成每个元素与给定值的比较。其他算法可能要求元素类型支持 < 运算符。不过，我们将会看到，大多数算法提供了一种方法，允许我们使用自定义的操作来代替默认的运算符。 泛型算法本身不会执行容器的操作，它们只会运行与迭代器之上，执行迭代器的操作。泛型算法运行于迭代器之上而不会执行容器操作的特性带来了一个令人惊讶但非常必要的编程假定：算法永远不会改变底层容器的大小。算法可能改变容器中保存的元素的值，也可能在容器内移动元素，但永远不会直接添加或删除元素。 10.2 初识泛型算法 除了少数例外，标准库算法都对一个范围内的元素进行操作。我们将此元素范围称为\"输入范围\"。接受输入范围的算法总是使用前两个参数来表示此范围，两个参数分别是指想要处理的第一个元素和尾元素之后位置的迭代器。 10.2.1 只读算法 一些算法只会读取其输入范围内的元素，而从不改变元素。 find 就是这样一种算法。 10.2.1.1 accumulate 另一个只读算法是 accumulate ，它定义在头文件 numeric 中。 accumulate 函数接受三个参数，前两个指出了需要求和的元素的范围，第三个参赛是和的初值。假定 vec 是一个整数序列，则： //对 vec 中元素的求和，和的初值是0 int sum = accumulate(vec.cbegin(), vec.cend(), 0); 这条语句将 sum 设置为 vec 中元素的和，和的初值被设置为0. accumulate 的第三个参数的类型决定了函数中使用哪个加法运算符以及返回值的类型。 accumulate 将第三个参数作为求和起点，这蕴含着一个编程假定：将元素类型加到和的类型上的操作必须是可行的。即，序列中元素的类型必须与第三个参数匹配，或者能够转换为第三个参数的类型。 下面是另一个例子，由于 string 定义了 + 运算符，所有我们可以通过调用 accumulate 来将 vector 中所有 string 元素连接起来： string sum = accumulate(v.cbegin(), v.cend(), string(\"\")); 此调用将 v 中每个元素连接到一个 string 上，该 string 初始时是空串。注意，我们通过第三个参数显式地创建了一个 string 。将空串当做一个字符串字面值传递给第三个参数是不可以的，会导致一个编译错误： //错误：const char*上没有定义+运算符 string sum = accumulate(v.cbegin(), v.cend(), \"\"); 原因在于，如果我们传递了一个字符串字面值，用于保存和的对象的类型将是 const char* 。如前所述，此类型决定了使用哪个 + 运算符。由于 const char* 并没有+运算符，此调用将产生编译错误。 操作两个序列的算法 10.2.1.2 equal 另一个只读算法是 equal ，用于确定两个序列是否保存相同的值，它将第一个序列中的每个元素与第二个序列中的对应元素进行比较。如果所有对应元素都相等，则返回 true ，否则返回 false 。此算法接受三个迭代器：前两个表示第一个序列中的元素的范围，第三个表示第二个序列的首元素： //roster2 中的元素数目应该至少与 roster1 一样多 equal(roster1.cbegin(), roster1.cend(), roster2.cbegin()); 由于 equal 利用迭代器完成操作，因此我们可以通过调用 equal 来比较两个不同类型的容器中的元素。而且，元素类型也不必一样，只要我们能用 == 来比较两个元素类型即可。例如，在此例中，roster1 可以是 vector<string> ,而 roster2 是 list<const char*> 。 但是， equal 基于一个非常重要的假设：它假定第二个序列至少与第一个序列一样长。此算法要处理第一个序列中的每个元素，它假定每个元素在第二个序列中都有一个与之对应的元素。 那些只接受一个单一迭代器来表示第二个序列的算法，都假定第二个序列至少与第一个序列一样长。确保算法不会试图访问第二个序列中不存在的元素是程序员的责任。 10.2.2 写容器元素的算法 一些算法将新值赋予序列中的元素。当我们使用这类算法时，必须注意确保序列原大小至少不小于我们要求算法写入的元素数目。记住，算法不会执行容器操作，因此它们自身不可能改变容器的大小。 一些算法会自己向输入范围写入元素，这些算法本质上并不危险，它们最多写入与给定序列一样多的元素。 例如，算法 fill 接受一对迭代器表示一个范围，还接受一个值作为第三个参数。 fill 将给定的这个值赋予输入序列中的每个元素： fill(vec.begin(), vec.end(), 0); //将每个元素重置为0 //将容器的一个子序列设置为10 fill(vec.begin(), vec.begin()+vec.size()/2, 10); 由于 fill 向给定输入序列中写入数据，因此，只要我们传递一个有效的输入序列，写入操作就是安全的。 算法不检查写操作 一些算法接受一个迭代器来指出一个单独的目的位置。这些算法将新值赋予一个序列中的元素，该序列从目的位置迭代器指向的元素开始。例如，函数 fill_n 接受一个单迭代器、一个计数值和一个值。它将给定值赋予迭代器指向的元素开始的指定个元素。我们可以用 fill_n 将一个新值赋予 vector 中的元素： vector<int> vec; //空vector //使用vec，赋予它不同值 fill_n(vec.begin(), vec.size(), 0); //将所有元素重置为0 函数 fill_n 假定写入指定个元素是安全的。即，如下形式的调用： fill_n(dest, n, val) 函数 fill_n 假定 dest 指向一个元素，而 dest 开始的序列至少包含 n 个元素。 一个初学者非常容易犯的错误是在一个空容器上调用 fill_n （或类似的写元素的算法）： vector<int> vec; //空向量 //灾难：修改vec中10个（不存在）元素 fill_n(vec.begin(), 10, 0); 这个调用是一场灾难，我们指定了要写入10个元素，但 vec 中并没有元素——它是空的，这条语句的结果是未定义的。 向目的迭代器写入数据的算法假定目的位置是足够大，能容纳要写入的元素。 10.2.3 介绍 back_inserter 一种保证算法有足够元素空间来容纳输出数据的方法是使用插入迭代器。插入迭代器是一种向容器中添加元素的迭代器。通常情况下，当我们通过一个迭代器向容器元素赋值时，值被赋予迭代器指向的元素。而当我们通过一个插入迭代器赋值时，一个赋值号右侧值相等的元素被添加到容器中。 为了展示如何用算法向容器中写入数据，我们现在将使用 back_inserter ，它是定义在头文件 iterator 中的一个函数。 back_inserter 接受一个 指向容器的引用 ，返回一个与该容器绑定的插入迭代器。当我们通过此迭代器赋值时，赋值运算符会调用 push_back 将一个具有给定值的元素 添加 到容器中： vector<int> vec; //空容器 auto it = back_inserter(vec); //通过它赋值会将元素添加到vec中 *it = 42;//vec现在有一个元素，值为42 我们常常使用 back_inserter 来创建一个迭代器，作为算法的目的位置来使用。例如： vector<int> vec; //空向量 //正确：back_inserter 创建一个插入迭代器，可以用来向 vec 添加元素 fill_n(back_inserter(vec), 10, 0); //添加10个元素到 vec 在每步迭代中， fill_n 向给定容器序列的一个元素赋值。由于我们传递的参数是 back_inserter 返回的迭代器，因此每次赋值都会在 vec 上调用 push_back 。最终，这条 fill_n 调用语句向 vec 的末尾添加了10个元素，每个元素的值都是0. 10.2.4 拷贝算法 拷贝算法是另一个向目的位置迭代器指向的输出序列中的元素写入数据的算法。此算法接受三个迭代器，前两个表示一个输入范围，第三个表示目的序列的起始位置。此算法将输入范围中的元素拷贝到目的序列中。传递给 copy 的目的序列至少要包含与输入序列一样多的元素，这一点很重要。 我们可以用 copy 实现内置数组的拷贝，如下面代码所示： int a[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; int a2[sizeof(a1) / sizeof(*a1)]; auto ret = copy(begin(a1), end(a1), a2); //把a1的内容拷贝到a2 copy 返回的是其目的位置迭代器（递增后）的值。即，ret 恰好指向拷贝到 a2 的尾元素之后的位置。 多个算法都提供所谓的\"拷贝\"版本。这些算法计算新元素的值，但不会将它们放置在输入序列的末尾，而是创建以新序列保存这些结果。 例如， replace 算法读入一个序列，并将其中所有等于给定值的元素都改为另一个值。此算法接受4个参数：前两个是迭代器，表示输入序列，后两个一个是要搜索的值，另一个是新值。它将所有等于第一个值的元素替换为第二个值： //将所有值为0的元素改为42 replace(ilist.begin(), ilist.end(), 0, 42); 此调用将序列中所有0都替换为42,。如果我们希望保留原序列不变，可以调用 replace_copy 。此算法接受额外第三个迭代器参数，指出调整后序列的保存位置： //使用back_inserter按需要增长目标序列 replace_copy(ilist.begin(), ilist.end(), back_inserter(ivec), 0, 42); 此调用后，ilis 并未改变，ivec 包含 ilist 的一份拷贝，不过原来在 ilist 中值为0的元素在 ivec 中都变为42。 10.2.5 重排容器元素的算法 10.2.5.1 sort 某些算法会重排容器中元素的顺序，一个明显的例子是 sort 。调用 sort 会重排输入序列中的元素，使之有序，它是利用元素类型的 < 运算符来实现排序的。 10.2.5.2 unique unique 算法重排输入序列，将相邻的重复项\"消除\"，并返回一个指向不重复范围末尾的迭代器。 unique 并不真正的删除任何元素，它只是覆盖相邻的重复元素，使得不重复元素出现在序列开始部分， unique 返回的迭代器指向最后一个不重复元素之后的位置。此位置之后的元素仍然存在，但我们不知道它们的值是什么。 标准库算法对迭代器而不是容器进行操作。因此，算法不能（直接）添加或删除元素。为了真正删除无用元素，我们必须使用容器操作，例如 erase 。 10.3 定制操作 很多算法都会比较输入序列中的元素。默认情况下，这类算法使用元素类型的 < 或 == 运算符完成比较。标准库还为这些算法定义了额外的版本，允许我们提供自己定义的操作来代替默认运算符。 例如， sort 算法默认使用元素类型的 < 运算符。但可能我们希望的排序顺序与 < 所定义的顺序不同，或是我们的序列可能保存的是未定义 < 运算符的元素类型。在这两种情况下，都需要重载 sort 的默认行为。 10.3.1 向算法传递函数 sort 的第二个版本是重载过的，它接受三个参数，此参数是一个 谓词 。 谓词是一个可调用的表达式，其返回结果是一个能用作条件的值。标准库算法所使用的谓词分为两类：一元谓词（unary predicate 意味着它们只接受单一参数）和二元谓词（binary predicate 意味着它们接受两个参数）。接受谓词参数的算法对输入序列中的元素调用谓词。因此，元素类型必须能转换为谓词的参数类型。 //比较函数，用来比较长度排序单词 bool isShorter(const string &s1, const string &s2) { return s1.size() < s2.size(); } //按长度由短至长排序words sort(words.begin(), words.end(), isShorter); stable_sort 算法：这种稳定排序算法维持相等元素的原有顺序。 10.3.2 lambda 表达式 根据算法接受一元谓词还是二元谓词，我们传递给算法的谓词必须严格接受一个或两个参数。但是，有时我们希望进行的操作需要更多参数，超出了算法对谓词的限制。这时候我们可以利用 lambda 表达式。 我们可以向一个算法传递任何类别的可调用对象。对于一个对象或一个表达式，如果可以对其使用调用运算符，则称它为可调用的。即，如果 e 是一个可调用的表达式，则我们可以编写代码 e(args),其中 args 是一个逗号分隔的一个或多个参数的列表。 到目前为止，我们使用过的仅有的两种可调用对象是函数和函数指针。还有其他两种可调用对象：重载了函数调用运算符的类，以及 lambda 表达式。 一个 lambda 表达式表示一个可调用的代码单元。我们可以将其理解为一个未命名的内联函数。与任何函数类似，一个 lambda 具有一个返回返回类型、一个参数列表和一个函数体。但与函数不同， lambda 可能定义在函数内部。一个 lambda 表达式具有如下形式 [ capture list ] ( parameter list ) -> return type { function body } 其中， capture list (捕获列表)是一个 lambda 所在函数中定义的局部变量列表（通常为空）； return type 、 parameter list 和 function body 与任何普通函数一样，分别表示返回类型、参数列表和函数体。但是，与普通函数不同， lambda 必须使用尾置返回来指定返回类型。 我们可以忽略参数列表和返回类型，但必须永远包含捕获列表和函数体： auto f = [] { return 42; }; 此例中，我们定义了一个可调用对象，它不接受参数，返回42. lambda 的调用方式与普通函数的调用方式相同，都是使用调用运算符： cout << f() << endl; //打印42 在 lambda 中忽略括号和参数列表等价于指定一个空参数列表。在此例中，当调用 f 时，函数参数列表是空的。如果忽略返回类型，则返回类型从返回的表达式的类型推断而来。否则，返回类型为 void 。 如果 lambda 的函数体包含任何单一 return 语句之外的语句，且未指定返回类型，则返回 void 。 10.3.2.1 向 lambda 传递参数 与普通函数调用类似，调用一个 lambda 时给定的实参类型被用来初始化 lambda 的形参。通常，实参和形参的类型必须匹配，但与普通函数不同， lambda 不能有默认参数。因此，一个 lambda 调用的实参数目永远与形参数目相等。一旦形参初始化完毕，就可以执行函数体了。 作为一个带参数的 lambda 的例子，我们可以编写一个与 isShorter 函数完成相同功能的 lambda ： [] (const string &s1, const string &s2) { return s1.size() < s2.size(); } 空捕获列表表明此 lambda 不使用它所在函数中的任何局部变量。 lambda 的参数与 isShorter 的参数类似，是 const string 的引用。 lambda 的函数体也与 isShorter 类型，比较两个参数的 size() ，并根据两者的相对大小返回一个布尔值。 如下所示，可以使用此 lambda 来调用 stable_sort ： stable_sort(words.begin(), words.end(), [] (const string &s1, const string &s2) { return s1.size()<s2.size(); }); 当 stable_sort 需要比较两个元素时，它就会调用给定的这个 lambda 表达式。 10.3.2.2 使用捕获列表 编写一个可以传递给 find_if 的可调用表达式。我们希望这个表达式能将输入序列中每个 string 的长度与 biggies 函数中的 sz 参数的值进行比较。 虽然一个 lambda 可以出现在一个函数中，使用其局部变量，但它只能使用那些明确指明的变量。一个 lambda 通过将局部变量包含在其捕获列表中指出将会使用这些变量。捕获列表指引 lambda 在其内部包含访问局部变量所需的信息。 在本例中，我们的 lambda 会捕获 sz，并只有单一的 string 参数。其函数体会将 string 的大小与捕获的 sz 的值进行比较： [sz] (const string &s) { return s.size() >= sz; }; lambda 以一对 [] 开始，我们可以在其中提供一个以逗号分隔的名字列表，这些名字都是它所在函数中定义的。 如果我们给 lambda 提供了一个空捕获列表，则代码会编译错误： //错误：sz未捕获 [] (const string &s) { return s.size() >= sz; }; 一个 lambda 只有在其捕获列表中捕获一个所在函数中的局部变量，才能在函数体中使用该变量。 一个 lambda 可以直接使用定义在当前函数之外的名字。捕获列表只用于局部非 static 变量， lambda 可以直接使用局部 static 变量和在它所在函数之外声明的名字。 10.3.2.3 lambda 捕获和返回 当定义一个 lambda 时，编译器生成一个与 lambda 对应的新的（未命名的）类类型。当向一个函数传递一个 lambda 时，同时定义了一个新类型和该类型的一个对象；传递的参数就是此编译器生成的类类型的未命名对象。类似的，当使用 auto 定义一个用 lambda 初始化的变量时，定义了一个从 lambda 生成的类型的对象。 默认情况下，从 lambda 生成的类都包含一个对应该 lambda 所捕获的变量的数据成员类似任何普通类的数据成员， lambda 的数据成员也在 lambda 对象创建时被初始化。 10.3.2.4 值捕获 类似参数传递，变量的捕获方式也可以是值或引用。到目前为止，我们的 lambda 采用值捕获的方式。与传值参数类似，采用值捕获的前提是变量可以拷贝。与参数不同，被捕获的变量的值是在 lambda 创建时拷贝，而不是调用时拷贝： void fcn1() { size_t v1 = 42; //局部变量 //将 v1 拷贝到名为 f 的可调用对象 auto f = [v1] { return v1; }; v1 = 0; auto j = f(); //j 为42；f 保存了我们创建它时 v1 的拷贝 } 由于被捕获变量的值是在 lambda 创建时拷贝，因此随后对其修改不会影响到 lambda 内对应的值。 10.3.2.5 引用捕获 我们定义 lambda 时可以采用引用方式捕获变量。例如： void fcn2() { size_t v1 = 42; //对象 f2 包含 v1 的引用 auto f2 = [&v1] { return v1; }; v1 = 0; auto j = f2(); //j 为0；f2 保存 v1 的引用，而非拷贝 } 一个以引用方式捕获的变量与其他任何类型的引用的行为类似。当我们在 lambda 函数体内使用此变量时，实际上使用的是引用所绑定的对象。引用捕获与返回引用有着相同的问题和限制。如果我们采用引用方式捕获一个变量，就必须确保被引用的对象在 lambda 执行的时候是存在的。 lambda 捕获的都是局部变量，这些变量在函数结束后就不复存在了。如果 lambda 可能在函数结束后执行，捕获的引用指向的局部变量已经消失。 我们不能拷贝 ostream 对象，因此捕获 os 的唯一方式就是捕获其引用（或指向 os 的指针）。 我们也可以从一个函数返回 lambda ，函数可以直接返回一个可调用对象，或者返回一个类对象，该类含有可调用对象的数据成员。如果函数返回一个 lambda ，则与函数不能返回一个局部变量的引用类似，此 lambda 也不能包含引用捕获。 当以引用方式捕获一个变量时，必须保证在 lambda 执行时变量是存在的。 10.3.2.6 隐式捕获 除了显式列出我们希望使用的来自所在函数的变量外，还可以让编译器根据 lambda 体中的代码来推断我们要使用哪些变量。为了指示编译器推断捕获列表，应在捕获列表中写一个 & 或 = 。 & 告诉编译器采用捕获引用方式， = 则采用值捕获。 //sz为隐式捕获，值捕获方式 wc=find_if(words.begin(),words.end(), [=] (const string &s) { return s.size()>=sz; }); 如果我们希望对一部分变量采用值捕获，对其它变量采用引用捕获，可以混合使用隐式捕获和显式捕获： void biggies(vector<string> &words, vector<string>::size_type sz, ostream &os=cout, char c=' ') { //os 隐式捕获，引用捕获方式；c 显式捕获，值捕获方式 for_each(words.begin(), words.end(), [&, c] (const string &s) { os << s <<c; }); //os 显式捕获，引用捕获方式；c 隐式捕获，值捕获方式 for_each(words.begin(), words.end(),[=, &os] (const string &s) { os << s <<c; }); } 当我们混合使用隐式捕获和显式捕获时，捕获列表中的第一个元素必须是一个 & 或 = ，此符号指定了默认捕获方式为引用或值。 当混合使用隐式捕获和显式捕获时，显式捕获的变量必须使用与隐式捕获不同的方式。即，如果隐式捕获是引用方式（使用了 & ），则显示捕获命名变量必须采用值方式，因此不能在其名字前使用 & 。类似的，如果隐式捕获采用的是值方式（使用了 = ），则显式捕获命名变量必须采用引用方式，即，在名字前使用 & 。 10.3.2.7 可变 lambda 默认情况下，对于一个值被拷贝的变量， lambda 不会改变其值。如果我们希望能改变一个捕获的变量的值，就必须在参数列表首加上关键字 mutable 。因此，可变 lambda 能省略参数列表： void fcn3() { size_t v1 = 42; //局部变量 //f 可以改变它所捕获的变量的值 auto f = [v1] () mutable { return ++v1; }; v1=0; auto j = f(); //j为43 } 一个引用捕获的变量是否（如往常一样）可以修改依赖于此引用指向的是一个 const 类型还是一个非 const 类型： void fcn4() { size_t v1 = 42; //局部变量 //v1 是一个非 const 变量的引用 //可以通过 f2 中的引用来改变它 auto f2 = [&v1] { return ++v1; }; v1=0; auto j = f2(); //j为1 } 10.3.2.8 指定 lambda 返回类型 默认情况下，如果一个 lambda 体包含 return 之外的任何语句，则编译器假定此 lambda 返回 void 。与其它返回 void 的函数类型类似，被推断返回 void 的 lambda 不能返回值。 当我们需要为一个 lambda 定义返回类型时，必须使用尾置返回类型。 10.3.3 参数绑定 对于那种只有一两个地方使用的简单操作， lambda 表达式是最有用的。如果我们需要在很多地方使用相同的操作，通常应该定义一个函数，而不是多次编写相同的 lambda 表达式。类似的，如果一个操作需要很多语句才能完成，通常使用函数更好。 但是，对于捕获局部变量的 lambda ，用函数来替换它就不是那么容易了。例如，我们用在 find_if 调用中的 lambda 比较一个 string 和一个给定大小。我们可以很容易地编写一个完成同样工作的函数： bool check_size(const string &s, string::size_type sz) { return s.size() >= sz; } 但是，我们不能用这个函数作为 find_if 的一个参数。 find_if 接受一个一元谓词，因此传递给 find_if 的可调用对象必须接受单一参数。为了用 check_size 函数来代替 lambda ，必须解决如何向 sz 形参传递一个参数的问题。 10.3.3.1 标准库 bind 函数 我们可以解决向 check_size 传递一个长度参数的问题，方法是使用一个新的名为 bind 的标准库函数，它定义在头文件 functional 中。可以将 bind 函数看作一个通用的函数适配器，它接受一个可调用对象，生成一个新的可调用对象来\"适应\"原对象的参数列表。 调用bind的一般形式： auto newCallable = bind(callable, arg_list); 其中，newCallable 本身是一个可调用对象，arg_list 是一个逗号分隔的参数列表，对应给定的 callable 的参数。即，当我们调用 newCallable 时，newCallable 会调用 callable，并传递给它 arg_list 中的参数。 arg_list 中的参数可能包含形如 _n 的名字，其中 n 是一个整数。这些参数是\"占位符\"，表示 newCallable 的参数，它们占据了传递给 newCallable 的参数的\"位置\"。数值n表示生成的可调用对象中参数的位置： _1 为newCallable的第一个参数， _2 为第二个参数，以此类推。 10.3.3.2 绑定 check_size 的 sz 参数 作为一个简单的例子，我们将使用 bind 生成一个调用 check_size 的对象，如下所示，它用一个定值作为其大小参数来调用 check_size: //check6 是一个可调用对象，接受一个 string 类型的参数 //并用此 string 和值6来调用 check_size auto check6 = bind(check_size, _1, 6); 此 bind 调用只有一个占位符，表示 check6 只接受单一参数。占位符出现在 arg_list 的第一个位置，表示 check6 的此参数对应 check_size 的第一个参数。此参数是一个 const string& 。因此，调用 check6 必须传递给它一个 string 类型的参数，check6 会将此参数传递给 check_size。 string s = \"hello\"; bool b1 = check6(s); //check6(s) 会调用 check_size(s, 6) 使用 bind ，我们可以将原来基于 lambda 的 find_if 调用： auto wc = find_if(words.begin(), words.end(), [sz] (const string &s) 替换为如下使用 check_size 的版本： auto wc = find_if(words.begin(), words.end(), bind(check_size, _1, sz)); 此 bind 调用生成一个可调用对象，将 check_size 的第二个参数绑定到 sz 的值。 10.3.3.3 placeholders 名字 _n 都定义在一个名为 placeholders 的命名空间中，而这个命名空间本身定义在 std 命名空间中。为了使用这些名字，两个命名空间都要写上。例如， _1 对应的 using 声明为： using std :: placeholders :: _1 ; 此声明说明我们要使用的名字 _1 定义在命名空间 placeholders 中，而此命名空间又定义在命名空间 std 中。 对每个占位符名字，我们都必须提供一个单独的 using 声明。编写这样的声明很烦人，也很容易出错。可以使用另外一种不同形式的 using 语句，而不是分别声明每个占位符，如下所示： using namespace namespace_name ; 这种形式说明希望所有来自 namespace_name 的名字都可以在我们的程序中直接使用。例如： using namespace std :: placeholders ; 使得由 placeholders 定义的所有名字都可用。与 bind 函数一样， placeholders 命名空间也定义在 functional 头文件中。 10.3.3.4 绑定引用参数 默认情况下， bind 的哪些不是占位符的参数被拷贝到 bind 返回的可调用对象中。但是，与 lambda 类似，有时对有些绑定的参数我们希望以引用方式传递，或是要绑定参数的类型无法拷贝。例如，为了替换一个引用方式捕获 ostream 的 lambda 。 bind 拷贝其参数，而我们不能拷贝一个 ostream ，如果我们希望传递给 bind 一个对象而又不是拷贝它，就必须使用标准库 ref 函数： for_each(words.begin(), words.end(), bind(print, ref(os), _1,' ')); 函数 ref 返回一个对象，包含给定的引用，此对象是可以拷贝的。标准库中还有一个 cref 函数，生成一个保存 const 引用的类。与 bind 一样，函数 ref 和 cref 也定义在头文件 functional 中。 10.4 再探迭代器 除了为每个容器定义的迭代器之外，标准库在头文件iterator中还定义了额外几种迭代器。这些迭代器包括以下几种。 迭代器 意义 插入迭代器 这些迭代器被绑定到一个容器上，可用来向容器插入元素 流迭代器 这些迭代器被绑定到输入或输出上，可用来遍历所有关联的 IO 流 反向迭代器 这些迭代器向后而不是向前移动。除了 forward_list 之外的标准库容器都有反向迭代器 移动迭代器 这些专用的迭代器不是拷贝其中的元素，而是移动它们 10.4.1 插入迭代器 插入器是一种迭代器适配器，它接受一个容器，生成一个迭代器，能实现向给定容器添加元素。当我们通过一个迭代器进行赋值时，该迭代器调用容器操作来向给定容器的指定位置插入一个元素。下表列出了这种迭代器支持的操作。 操作 意义 it = t 在 it 指定的当前位置插入值 t。假定 c 是 it 绑定的容器，依赖于插入迭代器的不同种类，此赋值分别调用 c.push_back(t) 、 c.push_front(t) 或 c.insert(t, p) ,其中 p 为传递给 inserter 的迭代器位置 *it, ++it, it++ 这些操作虽然存在，但不会对 it 做任何事情。每个操作都返回 it 插入迭代器有三种类型，差异在于元素插入的位置： back_inserter 创建一个使用 push_back 的迭代器 front_inserter 创建一个使用 push_front 的迭代器 inserter 创建一个使用 insert 的迭代器。此函数接受三个参数，这个参数必须是一个指向给定容器的迭代器。元素将被插入到给定迭代器所表示的元素之前。 只有在容器支持 push_front 的情况下，我们才可以使用 front_inserter 。类似的，只有在容器支持 push_back 的情况下，我们才能使用 back_inserter 。 理解插入迭代器的工作过程是很重要的：当调用 inserter(c,iter) 时，我们得到一个迭代器，接下来使用它时，会将元素插入到 iter 原来所指的位置之前的位置。即，如果 it 是由 inserter 生成的迭代器，则下面这样的赋值语句： *it = val; 其效果与下面代码一样： it = c.insert(it, val); //it 指向新加入的元素 ++it; //递增 it 使它指向原来的元素 front_inserter 生成的迭代器的行为与 inserter 生成的迭代器完全不一样。当我们使用 front_inserter 时，元素总是插入到容器第一个元素之前，即使我们传递给 inserter 的位置原来指向第一个元素，只要我们在此元素之前插入一个新元素，此元素就不再是容器的首元素了： list<int> lst = {1, 2, 3, 4}; list<int> lst2, lst3; //空 list //拷贝完成之后，lst2 包含4 3 2 1 copy(lst.begin(), lst.end(), front_inserter(lst2)); //拷贝完成之后 lst3 包含1 2 3 4 copy(lst.begin(), lst.end(), inserter(lst3,lst.begin())); 当调用 front_inserter(c) 时，我们得到一个插入迭代器，接下来会调用 push_front 。当每个元素被插入到容器 c 中时，它变为 c 的新的首元素。因此， front_inserter 生成的迭代器会将插入的元素序列的顺序颠倒过来，而 inserter 和 back_inserter 则不会。 10.4.2 流迭代器 虽然 iostream 类型不是容器，但标准库定义了用于这些 IO 类型对象的迭代器。 istream_iterator 读取输入流， ostream_iterator 向一个输出流写数据。这些迭代器将它们对应的流当作一个特定类型的元素序列来处理。通过使用流迭代器，我们可以用泛型算法从流对象读取数据以及向其写入数据。 10.4.2.1 istream_iterator 当创建一个流迭代器时，必须指定迭代器将要读写的对象类型。一个 istream_iterator 使用 >> 来读取流。因此， istream_iterator 要读取的类型必须定义了输入运算符。当创建一个 istream_iterator 时，我们可以将它绑定到一个流。当然，我们还可以默认初始化迭代器，这样就创建了一个可以当作尾后值使用的迭代器。 istream_iterator<int> int_it(cin); //从 cin 读取 int istream_iterator<int> int_eof; //尾后迭代器 ifstream in(\"afile\"); istream_iterator<string> str_in(in); //从 afile 读取字符串 下面是一个用 istream_iterator 从标准输入流读取数据，存入一个 vector 的例子： istream_iterator<int> in_iter(cin); //从 cin 读取 int istream_iterator<int> eof; //istream 尾后迭代器 while(in_iter != eof) //后置递增运算读取流，返回迭代器的旧值 //解引用迭代器，获得从流读取的前一个值 vec.push_back(*in_iter++); 此循环从 cin 读取 int 值，保存在 vec 中。在每个循环步中，循环体代码检查 in_iter 是否等于 eof。eof 被定义为空 istream_iterator ,从而可以当作尾后迭代器来使用。对于一个绑定到流的迭代器，一旦其关联的流遇到文件尾或遇到 IO 错误，迭代器的值就与尾后迭代器相等。 我们可以将程序重写为如下形式，这体现了 istream_iterator 更有用的地方： istream_iterator<int> in_iter(cin), eof; //从 cin 读取 int vector<int> vec(in_iter,eof); //从迭代器范围构造 vec 本例中我们使用了一对表示范围的迭代器来构造 vec，这两个迭代器是 istream_iterator ，这意味着元素范围是通过从关联的流中读取数据获得的。这个构造函数从 cin 读取数据，直至遇到文件尾或者遇到一个不是 int 的数据为止。从流中读取的数据被用来构造 vec。 istream_iterator 操作 意义 istream_iterator in(is); in 从输入流 is 读取类型为 T 的值 istream_iterator end; 读取类型为 T 的值的 istream_iterator 迭代器，表所尾后位置 in1 == in2, in1 != in2 in1 和 in2 必须读取相同类型。如果它们都是尾后迭代器，或绑定到相同的输入，则两个相等 *in 返回从流中读取数据 in->mem 与 (*in).mem 的含义相同 ++in, in++ 使用元素类型所定义的 >> 运算符从输入流中读取下一个值。与以往一样，前置版本返回一个指向递增后迭代器的引用，后置版本返回旧值 10.4.2.2 使用算法操作流迭代器 由于算法使用迭代器操作来处理数据，而流迭代器又至少支持某种迭代器操作，因此我们至少可以用某些算法来操作流迭代器。下面是一个例子，我们可以用一对 istream_iterator 来调用 accumulate ，此调用会计算出从标准输入读取的值的和: istream_iterator<int> in(cin), eof; cout << accumulatre(in, eof, 0) << endl; 10.4.2.3 istream_iterator 允许使用懒惰求值 当我们将一个 istream_iterator 绑定到一个流时，标准库并不保证迭代器立即从流读取数据。具体实现可以推迟从中读取数据，直到我们使用迭代器时才真正读取。标准库中的实现所保证的是，在我们第一次解引用迭代器之前，从流中读取数据的操作已经完成了。对于大多数程序来说，立即读取还是推迟读取并没有什么差别。但是，如果我们创建了一个 istream_iterator ，没有使用就销毁了，或者我们正在从两个不同的对象同步读同一个流，那么何时读取可能就很重要了。 10.4.2.4 ostream_iterator 我们可以对任何输出运算符( << 运算符)的类型定义 ostream_iterator 。当创建一个 ostream_iterator 时，我们可以提供（可选的）第二参数，它是一个字符串，在输出每个元素后都会打印此字符串。此字符串必须是一个 C 风格字符串（即，一个字符串字面值或者一个指向以空字符结尾的字符数组的指针）。必须将 ostream_iterator 绑定到一个指定的流。不允许空的或表示尾后位置的 ostream_iterator 。 ostream_iterator 操作 意义 ostream_iterator out(os); out 将类型为 T 的值写到输出流 os 中 ostream_iterator out(os,d); out 将类型为T的值写到输出流 os 中，每个值后面都输出一个 d。d 指向一个空字符串结尾的字符数组 out = val 用 << 运算符将 val 写入到 out 所绑定的 ostream 中。val 的类型必须与 out 可写的类型兼容 *out, ++out, out++ 这些运算符是存在的，但不对 out 做任何事情。每个运算符都返回 out 我们可以使用 ostream_iterator 来输出值的序列： ostream_iterator<int> out_iter(cout,\" \"); for(auto e : vec) *out_iter++ = e; //赋值语句实际上将元素写到 cout cout << endl; 此程序将 vec 中的每个元素写到 cout ，每个元素加一个空格，每次向 out_iter 赋值时，写操作就会被提交。 值得注意的是，当我们向 out_iter 赋值时，可以忽略解引用和递增运算。即，循环可以重写成下面的样子： for(auto e : vec) out_iter = e;//赋值语句将元素写到 cout cout << end; 运算符 * 和 ++ 实际上对 ostream_iterator 对象不做任何事情，因此忽略它们对我们的程序没有任何影响。但是，推荐第一种形式。在这种写法中，流迭代器的使用与其他迭代器的使用保存一致。如果想将此循环改为操作其他迭代器类型，修改起来非常容易。而且，对于读者来说，此循环的行为也更为清晰。 可以通过调用 copy 来打印 vec 中的元素，这比编写循环更为简单： copy(vec.begin(), vec.end(), out_iter); cout << endl; 10.4.3 反向迭代器 反向迭代器就是在容器中从尾元素向首元素反向移动的迭代器。对于反向迭代器，递增（以及递减）操作的含义会颠倒过来。递增一个反向迭代器（++it）会移动到前一个元素；递减一迭代器（--it）会移动到下一个元素。 除了 forward_list 之外，其他容器都支持反向迭代器。我们可以通过调用 rbegin 、 rcend 、 crbegin 和 crend 成员函数来获得反向迭代器。这些成员函数返回指向容器尾元素和首元素之前一个位置的迭代器。与普通迭代器一样，反向迭代器也有 const 和非 const 版本。 10.4.3.1 反向迭代器需要递减运算符 我们只能从既支持 ++ 也支持 -- 的迭代器来定义反向迭代器。毕竟反向迭代器的目的是在序列中反向移动。除了 forward_list 之外，标准容器上的其他迭代器都既支持递增运算又支持递减运算。但是，流迭代器不支持递减运算，因为不可能在一个流中反向移动。因此，不可能从一个 forward_list 或一个流迭代器创建反向迭代器。 10.4.3.2 反向迭代器与其他迭代器间的关系 假定有一个名为 line 的 string ，保存着一个逗号分隔的单词列表，我们希望打印 line 中的第一个单词，使用 find 可以很容易地完成这一任务： //在一个逗号分隔的列表中查找一个元素 auto comma = find(line.cbegin(), line.cend(), ','); cout << string(line.cbegin(), comma) << endl; 如果 line 中有逗号，那么 comma 将指向这个逗号；否则，它将等于 line.cend().当我们打印从 line.cbegin() 到 comma 之间的内容时，将打印到逗号为止的序列，或者打印整个 string （如果其中不含逗号的话）。 如果希望打印最后一个单词，可以改用反向迭代器： //在一个逗号分隔的列表中查找最后一个元素 auto rcomma = find(line.crbegin(), line.crend(), ','); 由于我们将 crbegin 和 crend 传递给 find ， find 将从 line 的最后一个字符开始向前搜索。当 find 完成后，如果 line 中有逗号，则 rcomma 指向最后一个逗号——即，它指向反向搜索中找到的第一个逗号。如果 line 中没有逗号，则 rcomma 指向 line.crend()。 但我们试图打印找到的单词时，看起来下面的代码是显然的方法 //错误:将逆序输出单词的字符 cout << string(line.crbegin(), rcomma) << endl; 但它会生成错误的输出结果。例如，如果我们的输入是：FIRST,MIDOLE,LAST 则这条语句会打印：TSAL 问题所在：我们使用的是反向迭代器，会反向处理 string 。因此，上述输出语句从 crbegin 开始反向打印 line 中内容。而我们希望按正常顺序打印从 rcomma 开始到 line 末尾间的字符。但是，我们不能直接使用 rcomma。因为它是一个反向迭代器，意味着它会反向朝着 string 的开始位置移动。需要做的是，将 rcomma 转换回一个普通迭代器，能在 line 中正向移动。我们通过调用 reverse_iterator 的 base 成员函数来完成这一转换，此成员函数会返回其对应的普通迭代器： //正确：得到一个正向迭代器，从逗号开始读取字符直到 line 末尾 cout << string(rcomma.base(), line.cend()) << endl; rcomma 和 rcomma.base() 指向了不同的元素，line.crbegin() 和 line.cend() 也是如此。这些不同保证了元素范围无论是正向处理还是反向出来都是相同的。从技术上讲，普通迭代器与反向迭代器的关系反映了左闭合区间的特征。关键点在于 [line.crbegin(),rcomma) 和 [rcomma.base(),line.cend()) 指向 line 中相同的元素范围。 10.5 泛型算法结构 任何算法的最基本的特性是它要求其迭代器提供哪些操作。某些算法，如 find ，只要求通过迭代器访问元素、递增迭代器以及比较两个迭代器是否相等这些能力。其他一些算法，如 sort ，还要求读、写和随机访问元素的能力。算法所要求的迭代器操作可以分为5个迭代器类别，如表所示： 迭代器类型 要求 输入迭代器 只读，不写；单遍扫描，只能递 输出迭代器 只写，不读；单遍扫描，只能递 前向迭代器 可读写；多遍扫描，只能递 双向迭代器 可读写；多遍扫描，可递增递 随机访问迭代器 可读写；多遍扫描，支持全部迭代器运 10.5.1 5类迭代器 类似容器，迭代器也定义了一组公共操作，一些操作所有迭代器都支持，另外一些只有特定类别的迭代器才支持。例如， ostream_iterator 只支持递增、解引用和赋值。 vector 、 string 和 deque 的迭代器除了这些操作外，还支持递减、关系和算术运算。 迭代器是按它们所提供的操作来分类的，而这种分类形成了一种层次。除了输出迭代器之外，一个高层类别的迭代器支持底层类别迭代器的所有操作。 10.5.1.1 输入迭代器 输入迭代器：可以读取序列中的元素。一个输入迭代器必须支持： 用于比较两个迭代器的相等和不相等运算符（==、!=） 用于推进迭代器的前置和后置递增运算（++） 用于读取元素的解引用运算符（*）；解引用只会出现在赋值运算符的右侧 箭头运算符（->），等价于（*it）.member，即，解引用迭代器，并提取对象的成员 输入迭代器只用于顺序访问。对于一个输入迭代器， *it++ 保证是有效的，但递增它可能导致所有其他指向流的迭代器失效。其结果就是，不能保证输入迭代器的状态可以保存下来并用来访问元素。因此，输入迭代器只能用于单遍扫描算法。算法 find 和 accumulate 要求输入迭代器；而 istream_iterator 是一种输入迭代器。 10.5.1.2 输出迭代器 输出迭代器：可以看做输入迭代器功能上的补集——只写而不读元素。输出迭代器必须支持： 用于推进迭代器的前置和后置递增运算（++） 解引用运算符（*），只能出现在赋值运算符的左侧（向一个已经解引用的输出迭代器赋值，就是将值写入它所指向的元素） 我们只能向一个输出迭代器赋值一次。类似输入迭代器，输出迭代器只能用于单遍扫描算法。用作目的位置的迭代器通常都是输出迭代器。例如， copy 函数的第三个参数就是输出迭代器。 ostream_iterator 类型也是输出迭代器。 10.5.1.3 前向迭代器 前向迭代器：可以读元素。这类迭代器只能在序列中沿一个方向移动。前向迭代器支持所有输入和输出迭代器的操作，而且可以多次读写同一个元素。因此，我们可以保存前向迭代器的状态，使用前向迭代器的算法可以对序列进行多遍扫描。算法 replace 要求前向迭代器， forward_list 上的迭代器就是前向迭代器。 10.5.1.4 双向迭代器 双向迭代器：可以正向/反向读写序列中的元素。除了支持所有前向迭代器的操作之外，双向迭代器还支持前置和后置递减运算符（--）。算法 reverse 要求双向迭代器，除了 forward_list 之外，其他标准库都提供符合双向迭代器要求的迭代器。 10.5.1.5 随机迭代器 随机访问迭代器：提供在常量时间内访问序列中的任意元素的能力。此类迭代器支持双向迭代器的所有功能，此外还支持如下的操作： 用于比较两个迭代器相对位置的关系运算符（<、<=、> 和 >=） 迭代器和一个整数值的加减运算（+、+=、- 和 -=），计算结果是迭代器在序列中前进（或后退）给定整数个元素后的位置 用于两个迭代器上的减法运算符（-）得到两个迭代器的距离 下标运算符 (iter[n])，与 *(iter[n]) 等价 算法 sort 要求随机访问迭代器， array 、 deque 、 string 和 vector 的迭代器都是随机访问迭代器，用于访问内置数组元素的指针也是。 10.5.2 算法形参模式 在任何其他算法分类之上，还有一组参数规范。大多数算法具有如下4种形式之一： alg(beg, end, other args); alg(beg, end, dest, other args); alg(beg, end, beg2, other args); alg(beg, end, beg2, end2, other args); 其中 alg 是算法的名字，beg 和 end 表示算法所操作的输入范围。几乎所有算法都接受一个输入范围，是否有其他参数依赖于要执行的操作。这里列出了常见的一种——dest、beg2 和 end2，都是迭代器参数。顾名思义，如果用到了这些迭代器参数，它们分别承担指定目的位置和第二个范围的角色。除了这些迭代器参数，一些算法还接受额外的、非迭代器的特定参数。 10.5.3 算法命名规范 10.5.3.1 一些算法使用重载形式传递一个谓词 接受谓词参数来代替 < 或 == 运算符的算法，以及哪些不接受额外参数的算法，通常都是重载的函数。函数的一个版本用元素类型的运算符来比较元素；另一个版本接受一个额外谓词参数，来代替 < 或 ==。 unique(beg, end); //使用 == 运算符比较元素 unique(beg, end, comp); //使用 comp 比较运元素 两个调用都重新整理给定序列，将相邻的重复元素删除。第一个调用使用元素类型的 == 运算符来检查重复元素；第二个则调用 comp 来确定两个元素是否相等。由于两个版本的函数在参数个数上不相等，因此具体应该调用那个不会产生歧义。 10.5.3.2 _if 版本的算法 接受一个元素值的算法通常有另一个不同名的版本，该版本接受一个谓词代替元素值。接受谓词参数的算法都有附加 _if 前缀： find(beg, end, val); //查找输入范围中 val 第一次出现的位置 find_if(beg, end, pred); //查找第一个令 pred 为真的元素 这两个算法提供了命名上的差异的版本，而非重载版本，因为两个版本的算法都接受相同数目的参数。因此可能产生重载歧义，虽然很罕见，但为了避免任何可能的歧义，标准库提供不同名字的版本而不是重载。 10.5.3.3 区分拷贝元素的版本和不拷贝的版本 默认情况下，重排元素的算法将重排后的元素写回固定的输入序列中。这些算法还提供另一个版本，将元素写到一个指定的输出目的位置。如我们所见，写到额外目的空间的算法都在名字后面附加一个 _copy： reverse(beg, end); //反转输入范围中元素的顺序 reverse_copy(beg, end, dest); //将元素按逆序拷贝到 dest 一些算法同时提供 _copy 和 _if 版本。这些版本接受一个目的位置迭代器和一个谓词： //从 v1 中删除奇数元素 remove_if(v1.begin(), v1.end(), [] (int i) { return i % 2; }); //将偶数元素从 v1 拷贝到 v2；v1 不变 remove_copy_if(v1.begin(), v1.end(), back_inserter(v2), [] (int i) { return i % 2; }); 两个算法都调用了 lambda 来确定元素是否为奇数。在第一个调用中，我们从输入序列中将奇数元素删除。在第二个调用中，我们将非奇数（即偶数）元素从输入范围拷贝到 v2 中。 10.6 特定容器算法 与其他容器不同，链表类型 list 与 forward_list 定义了几个成员函数形式的算法。特别是，它们定义了独有的 sort 、 merge 、 remove 、 reverse 和 unique 。通用版本的 sort 要求随机访问迭代器，因此不能用于 list 和 forward_list ，因为这两个类型分别提供双向迭代器和前向迭代器。 链表类型定义的其他算法的通用版本可以用于链表，但代价太高。这些算法需要交换输入序列中的元素。一个链表可以通过改变元素间的链接而不是真正的交换它们的值来传递\"交换\"元素。因此，这些链表版本的算法的性能比对应的通用版本好很多。 对于 list 和 forward_list 应该优先使用成员函数版本的算法而不是通用算法。 list 和 forward_list 成员函数版本的算法，这些操作都返回 void ： lst.merge(lst2)、lst.merge(lst2, comp)：将来自 lst2 的元素合并入 lst。lst 和 lst2 都必须是有序的。元素将从 lst2 中删除。在合并之后，lst2 变为空。第一个版本使用 < 运算符；第二个版本使用给定的比较操作 lst.remove(val)、lst.remove_if(pred)：调用 erase 删除掉与给定值相等（==）或令一元谓词为真的每个元素 lst.reverse()：反转 lst 中元素的顺序 lst.sort()、lst.sort(comp)：使用 < 或给定比较操作排序元素 lst.unique()、lst.unique(pred)：调用 erase 删除同一值的连续拷贝。第一个版本使用 ==；第二个版本使用给定的二元谓词 10.6.1 splice 成员 链表类型还定义了splice算法。此算法是链表数据结构所特有的，因此不需要通用版本。 list 和 forward_list 的 splice 成员函数的参数： lst.splice(args)或flst.splice_after(args) (p,lst2)：p 是一个指向 lst 中元素的迭代器，或一个指向 flst 首前位置的迭代器。函数将 lst2 的所有元素移动到 lst 中 p 之前的位置或是 flst 中 p 之后的位置。将元素从 lst2 中删除。lst2 的类型必须与 lst 或 flst 相同，且不能是同一个链表 (p,lst2,p2)：p2 是一个指向 lst2 中位置的有效的迭代器。将 p2 指向的元素移动到 lst 中，或将 p2 之后的元素移动到 flst 中。lst2 可以是与 lst 或 flst 相同的链表 (p,lst2,b,e)：b 和 e 必须表示 lst2 中的合法范围。将给定范围中的元素从 lst2 移动到 lst 或 flst。lst2 与 lst（或 flst）可以是相同的链表，但 p 不能指向给定范围中元素 10.6.2 链表特有的操作会改变容器 多数链表特有的算法都与其通用版本很相似，但不完全相同。链表特有版本与通用版本间的一个至关重要的区别是链表版本会改变底层的容器。例如， remove 的链表版本会删除指定的元素。 unique 的链表版本会删除第二个和后继的重复元素。 类似的， merge 和 splice 会销毁其参数。例如，通用版本的 remove 将合并的序列写给一个给定的目的迭代器：两个输入序列是不变的。而链表版本的 merge 函数会销毁给定的链表——元素从参数指定的链表中删除，被合并到调用 merge 的链表对象中。在 merge 之后，来自两个链表中的元素仍然存在，但它们都已在同一个链表中。","tags":"读书笔记","url":"https://xutree.github.io/pages/2018/10/17/C++_Primer_Chapter_10/"},{"title":"C++ Primer 第九章 顺序容器","text":"一个容器就是一些特定类型对象的集合。顺序容器（sequential container）为程序员提供了控制元素存储和访问顺序的能力。这种顺序不依赖于元素的值，而是与元素加入容器时的位置相对应。 9.1 顺序容器概述 类型 简介 vector 可变大小数组。支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢 deque 双端队列。支持快速随机访问。在头尾位置插入或删除速度很快 list 双向链表。只支持双向顺序访问。在任何位置进行插入或删除都很快 forward_list 单向链表。只支持单向顺序访问。在任何位置进行插入或删除都很快 array 固定大小数组。支持快速随机访问。不能添加或删除元素 string 与 vector 相似的容器，专门用于保存字符。随机访问快。在尾部插入或删除快 string 和 vector 保存在连续的内存空间中，因此由下标计算地址非常快速。 forward_list 的设计目标是达到与最好的手写的单向链表数据结构相当的性能，因此不提供 size 操作，因为保存和计算大小会增加开销。 通常， vector 是最好的选择。 每个容器都定义在同名的头文件中，容器均是模板类。 9.2 容器库概览 9.2.1 类型别名 类型别名 意义 iterator 此容器类型的迭代器类型 const_iterator 常量迭代器类型 size_type 无符号整数，足够保存此种容器的最大大小 difference_type 带符号整数，足够保存两个迭代器之间的距离 value_type 元素类型 reference 元素的左值类型，与 value_type& 含义相同 const_reference 常量左值类型 9.2.2 构造函数 构造函数 意义 C c; 默认构造函数，构造空容器。如果 c 是一个 array ，则元素按默认方式初始化 C c1(c2); 构造 c2 的拷贝 c1，必须为相同类型，且保存元素也相同 C c1 = c2; 同上 C c(b, e); 构造 c，将迭代器指定的范围内的元素拷贝到 c，类型要相容（ array 不支持） C c 列表初始化，类型要相容，遗漏元素值初始化 C c = 同上 C seq(n); 包含 n 个元素并进行值初始化，是 explicit 构造函数（ string 不要求explicit） C seq(n, t); 包含 n 个初始值为 t 的元素 只有顺序容器（不包括 array 的构造函数才能接受大小参数）。如果元素类型没有默认构造函数，除了大小参数外，还需要显式指定元素初始值。 array 支持拷贝和赋值（内置数组不行）。 9.2.3 赋值与 swap 赋值与 swap 意义 c1 = c2; 将 c1 中的元素替换成 c2 中的元素，类型要相同 c1 = 将 c1 中的元素替换成列表中的元素（ array 不支持） a.swap(b); 交换 a 和 b 的元素，类型要相同，此操作通常比拷贝元素快得多 swap(a, b); 与上面等价 seq.assign(b, e) 将 seq 中的元素替换为迭代器范围中的元素，迭代器不能指向 seq 的元素 seq.assign(il) 用初始化列表替换 seq.assign(n, t) 用 n 个 t 替换 由于右边运算对象的大小可能与左边不同，因此 array 不支持 assign ，也不运行用花括号包围的值列表赋值。 assign 不适用于关联容器。 assign 仅要求类型相容。 赋值相关操作会导致指向左边容器内部的迭代器、引用和指针失效，而 swap 操作不会导致失效（ array 和 string 除外），它们仍指向交换之前的那些元素。 除 array 外， swap 不对任何元素进行拷贝、删除和插入操作，因此可以保证在常数时间完成，它只是交换了两个容器的内部数据结构。 swap 两个 array 会真正交换它们的元素。在操作之后，指针、引用和迭代器所绑定的元素保持不变，但元素值已经和另一个 array 中对应元素的值进行了交换。 统一使用非成员版本的 swap 是一个好习惯。 9.2.4 容器大小操作 大小 意义 c.size(); c 中元素的数目， forward_list 不支持 c.max_size(); c 可保存的最大元素数目 c.empty(); 判空 关系运算符 意义 ==、!= 所有容器都支持 <、<=、>、>= 无序关联容器不支持，类型相同，保存元素也要相同 9.2.5 添加元素 添加元素 意义 c.push_back(t) 在尾部创建值为 t 的元素，返回 void c.emplace_back(args) 在尾部用参数构造元素，返回 void c.push_front(t) 在头部创建值为 t 的元素，返回 void c.emplace_front(t) 在头部用参数构造元素，返回 void c.insert(p, t) 在迭代器 p 指向的元素之前创建值为 t 的元素，返回指向新添加元素迭代器 c.emplace(p, args) 在迭代器 p 指向的元素之前构造值为 t 的元素，返回指向新添加元素迭代器 c.insert(p, b, e) 在迭代器 p 指向的元素之前插入迭代器范围指定的元素，返回指向新添加的第一个元素的迭代器，若范围为空，返回 p c.insert(p, n, t) n 个 t c.insert(p, il) 列表 这些操作会改变容器大小， array 不支持。 forward_list 有自己版本的 insert 和 emplace。 forward_list 不支持 push_back 和 emplace_back。 vector 和 string 不支持push_front 和 emplace_front。 emplace 函数会在容器管理的内存空间中直接创建对象，而 push 函数会创建一个局部临时变量，并将其压入容器中。传递给 emplace 的参数必须与元素类型的构造函数相匹配。 9.2.6 访问元素 访问元素 意义 c.back() 返回尾元素引用。若 c 为空，行为未定义 c.front() 返回首元素引用。若 c 为空，行为未定义 c[n] 返回下标为 n 元素的引用，n 是一个无符号整数。若 n >= c.size()，行为未定义 c.at(n) 返回下标为 n 元素的引用，若 n 越界，抛出 out_of_range 异常 at 和下标操作只适用于 string 、 vector 、 deque 和 array 。 back 不适用于 forward_list 。 9.2.7 删除元素 删除元素 意义 c.pop_back() 删除尾元素。若 c 为空，行为未定义。返回 void c.pop_front() 删除首元素。若 c 为空，行为未定义。返回 void c.erase(p); 删除迭代器所指元素\b，返回被删除元素之后元素的迭代器，若 p 为尾后迭代器，行为未定义 c.erase(b, e); 删除迭代器所指元素\b，返回最后一个被删除元素之后元素的迭代器，若 e 为尾后迭代器，函数返回尾后迭代器 c.clear(); 清空，返回 void 这些操作会改变容器大小， array 不支持。 forward_list 有自己版本的 erase。 forward_list 不支持 pop_back。 vector 和 string 不支持pop_front。 删除元素的成员函数并不检查其参数。在删除元素前，程序员必须确保它们是存在的。 9.2.8 迭代器 迭代器 意义 c.begin(), c.end() 首尾迭代器 c.cbegin(), c.cend() 首尾常量迭代器 反向容器额外成员 意义 reverse_iterator 按逆序寻址元素的迭代器 const_reverse_iterator 按逆序寻址元素的常量迭代器 c.rbegin(), c.rend() 尾首迭代器 c.crbegin(), c.crend() 尾首常量迭代器 注： forward_list 不支持 9.2.9 特殊的 forward_list 操作 为了理解 forward_list 为什么有特殊版本的添加和删除操作，考虑当我们从一个单向链表中删除一个元素时会发生什么。当添加或删除一个元素时，删除或添加的元素之前的那个元素的后继会发生变化。为了添加或删除一个元素，我们需要访问其前驱，以便改变前驱改变前驱的链接。但是， forward_list 是单向链表。在一个单向链表中，没有简单的方法来获取一个元素的前驱，出于这个原因，在一个 forward_list 中添加或删除元素的操作是通过改变给定元素之后的元素来完成的。这样，我们总是可以访问到被添加或删除元素所影响的元素。 由于这些操作与其他容器上的操作有实现方式不同， forward_list 并未定义 insert 、 emplace 和 erase ，而是定义了名为 insert_after 、 emplace_after 和 erase_after 的操作。为了支持这些操作， forward_list 也定义了 before_begin ,它返回一个首前迭代器。这个迭代器允许我们在链表首元素之前并不存在的元素\"之后\"添加或删除元素（亦即在链表首元素之前添加删除元素）。 操作 意义 lst.before_begin() 返回指向链表首元素之前并不存在的元素的迭代器，此迭代器不能解引用 lst.cbefore_begin() cbefore_begin() 返回一个 const_iterator lst.insert_after(p, t) 在迭代器 p 之后的位置插入元素 t，若 p 为尾后迭代器，则函数的行为未定义。若范围为空，返回 p lst.insert_after(p, n, t) 在迭代器 p 之后的位置插入 n 个 t lst.insert_after(p, b, e) 在迭代器 p 之后的位置插入迭代器范围表示的元素 lst.insert_after(p,il) 在迭代器 p 之后的位置插入花括号列表 emplace_after(p,args) 使用 args 在 p 指定的位置之后构造一个元素，返回一个指向这个新元素的迭代器。若 p 为尾后迭代器，则函数的行为未定义 lst.erase_after(p) 删除 p 指向的位置之后的元素，返回一个指向被删除元素之后元素的迭代器，若不存在这样的元素，则返回尾后迭代器，如果 p 指向 lst 的尾元素或者是一个尾后迭代器，则函数的行为未定义 lst.erase_after(b, e) 删除从 b 之后直到（但不包含）e 之间的元素 9.2.10 改变容器大小 操作 含义 c.resize(n) 调整 c 的大小为 n 个元素。若 n < c.size()，多出的元素被丢弃。若必须添加新元素，则新元素采取值初始化 c.resize(n, t) 调整 c 的大小为 n 个元素。，多出的元素被丢弃。若必须添加新元素，则新元素初始化为 t c.shrink_to_fit() 请求将 capacity() 减小为与 size() 相同，具体的实现可能忽略此请求 c.capacity() 不重新分配内存的话，c 可以保存多少元素 c.reserve(n) 分配至少能容纳 n 个元素的内存空间 shrink_to_fit() 只适用于 vector 、 string 和 deque 。 capacity() 和 reserve(n) 只适用于 vector 和 string 。 9.3 迭代器失效 9.3.1 添加元素 vector 或 string ： 存储空间重新分配：迭代器、指针、引用均失效 未重新分配：插入位置之前的有效，之后的失效 deque ： 插入首尾之外：均失效 插入首尾：迭代器失效，指针、引用不失效 list 或 forward_list ：都有效（包括尾后和首前） 9.3.2 删除元素 list 或 forward_list ：都有效（包括尾后和首前） deque ： 删除首尾之外：均失效 删除首：\b首前失效，其他有效 删除尾：尾后失效，其他有效 vector 或 string ：被删除元素之前的都有效 当我们删除元素时，尾后迭代器总是会失效（除了删除 deque 首元素外），所以不要保存 end 返回的迭代器。 9.4 额外的 string 操作 9.4.1 构造 string 的其他方法 方法 解释 string s(cp, n) s 是 cp 指向的数组中前 n 个字符的拷贝。此数组至少应该包含 n 个字符 string s(s2, pos2) s 是 string s2 从下标 pos2 开始的字符的拷贝。若 pos2 > s2.size()，行为未定义 string s(s2, pos2, len2) 这些构造函数接受一个 string 或 const char* 参数。从 const char* 拷贝时，指针指向的数组必须以空字符结尾，如果还传递了一个计数值，数组就不必以空字符结尾。 9.4.2 substr 操作 s.substr(pos, n) 返回一个 string ，包含 s 中从 pos 开始的 n 个字符的拷贝。pos 的默认值是0，n 的默认值是 s.size()-pos，即拷贝从 pos 开始的所有字符。如果开始位置超出 string 的大小，抛出 out_of_range 异常，不管\b n 值为多少，最多拷贝到 string 的末尾。 9.4.3 其他修改 string 的操作 9.4.4 string 搜索操作 string 类提供了6个不同的搜索函数，每个函数有4个重载版本。每个搜索操作都返回 string::size_type 值，表示匹配发生的下标。如果搜索失败，则返回 string::npos 的 static 成员。标准库将 string::npos 定义成一个 const string::size_type ，并初始化为-1。由于 npos 是一个无符号数，此初始值意味着 npos 等于任何 string 最大的可能大小。 9.4.5 compare 函数 9.4.6 数值转换 string s2 = \"pi = 3.14\"; d = stod(s2.substr(s2.find_first_of(\"+-.0123456789\"))); 9.5 容器适配器 适配器（adaptors）是标准库中的一个通用概念，容器、迭代器和函数都有适配器。本质上，一个适配器是一种机制，能使某种事物的行为看起来像另外一种事物一样。一个容器适配器（Container adaptors）接受一种已有的容器类型，使其行为看起来像一种不同的类型。标准库定义了三个序列容器适配器： stack 、 queue 和 priority_queue 。 9.5.1 所以适配器都支持的的操作和类型 名称 意义 size_type 一种类型，足以保存当前类型的最大对象的大小 value_type 元素类型 container_type 实现适配器的底层容器\b类型 A a; 创建一个名为 a 的空\b适配器 A a(c); 创建一个名为 a 的适配器，带有容器 c 的一个拷贝 关系运算符 每个适配器都支持所有\b关系运算符。这些关系运算符返回底层容器的比较结果 a.empty() 判空 a.size() 元素数目 swap(a, b) 交换，类型要相同，包括底层容器类型也必须相同 a.swap(b) 同上 9.5.2 定义适配器 stack 默认基于 deque 实现，要求 push_back 、 pop_back 和 back 操作，可使用除 array 和 forward_list 之外的任何容器构造 queue 默认基于 deque 实现，\b要求 back 、 push_back 、 front 、 push_front 操作，可使用 list 和 deque 构造 priority_queue 默认基于 vector 实现，要求 front 、 push_back 和 pop_back 操作，还需要随机访问能力，可使用 vector 和 deque 构造 两种构造方法：默认构造函数创建一个空对象；接受一个容器的构造函数拷贝该容器来初始化适配器。 //假设 deq 是一个 deque<int> stack<int> stk(deq); //从 deq 拷贝元素到 stk 我们可以在创建一个适配器时将一个命名的顺序容器作为第二个类型参数，来重载默认容器类型： //在 vector 上实现的空栈 stack<string, vector<string>> str_stk; //在 vector 上实现的空栈，初始化时保存 svec 的拷贝 stack<string, vector<string>> str_stk2（svec); 9.5.3 栈适配器 stack 类型定义在同名头文件中。下面展示了如何使用： stack<int> intStack; //空栈 //填满栈 for (size_t ix = 0; ix != 10; ++ix) intStack.push(ix); //栈保存0-9十个数 while (!intStack.empty()) { //栈中有值就继续循环 int value = intStack.top(); //使用栈顶值的代码 intStack.pop(); //弹出栈顶元素，继续循环 } 操作 意义 s.pop() 删除栈顶元素，但不返回该元素值 s.push(item) 创建一个新元素压入栈顶，该元素通过拷贝或移动 item 而来 s.emplace(args) 构造一个新元素压入栈顶，该元素通过 args 构造 s.top() 返回栈顶元素，但不将元素弹出栈 每个容器适配器都基于底层容器类型的操作定义了自己的特殊操作，我们只能\b使用适配器操作，而不能使用底层容器类型的操作。 9.5.4 队列适配器 queue 和 priority_queue 定义在头文件 queue 中。操作方法如下： 操作 意义 q.pop() 删除 queue 的首元素或 priority_queue 的最高优先级的元素，但不返回该元素 q.front() 返回首元素，但不删除此元素，只适用于 queue q.back() 返回尾元素，但不删除此元素，只适用于 queue q.top() 返回优先级\b最高的元素，但不删除该元素，只适用于 priority_queue q.push(item) 在 queue \b末尾或 priority_queue 中恰当的位置创建一个元素，其值为 item q.emplace(args) 在 queue \b末尾或 priority_queue 中恰当的位置由 args 参数构造一个元素","tags":"读书笔记","url":"https://xutree.github.io/pages/2018/10/16/C++_Primer_Chapter_9/"},{"title":"Atom 快捷键","text":"参考： https://www.jianshu.com/p/e33f864981bb 、 https://github.com/nwinkler/atom-keyboard-shortcuts 1. 基本快捷键 快捷键 快捷键的功能 cmd-, 打开设置面板 shift-cmd-p 打开和关闭命令面板 ctrl-alt-cmd-l 重启 alt-cmd-i 打开开发者工具 2. 文件切换 快捷键 快捷键的功能 cmd-shift-o 打开目录 ctrl-0 焦点移到目录树,注意这里是数字0，非常实用也可以用cmd+\\来变相达到效果 a, m, d, delete 目录树下，增加，修改，另存为和删除 cmd-t 或 cmd-p 查找文件（模糊查找） cmd-b 在打开的文件之间切换 cmd-shift-b 只搜索从上次 git commit 后修改或者新增的文件 alt-cmd-left 在打开的标签页往左切换 alt-cmd-right 在打开的标签页往右切换 3. 导航 快捷键 快捷键的功能 ctrl-p 前一行 ctrl-n 后一行 ctrl-f 后一个字符 ctrl-b 前一个字符 alt-b, alt-left 移动到单词开始 alt-f, alt-right 移动到单词末尾 cmd-right, ctrl-e 移动到一行结束 cmd-left, ctrl-a 移动到一行开始 cmd-up 移动到文件开始 cmd-down 移动到文件结束 cmd-r 在方法之间跳转 4. 窗口管理 快捷键 快捷键的功能 cmd-n 新建文件 shift-cmd-n 新建窗口 cmd-o 打开文件 cmd-shift-o 打开文件夹 cmd-s 保存 shift-cmd-s 另存为 alt-cmd-s 保存所有 cmd-w 关闭标签 shift-cmd-w 关闭窗口 cmd-k up/down/left/right 分隔窗口 cmd-k cmd-up/down/left/right 聚焦窗口 ctrl-cmd-f 全屏 5. 目录树操作 快捷键 快捷键的功能 cmd-\\ 显示(隐藏)目录树 ctrl-0 焦点切换到目录树(再按一次或者 Esc 退出目录树) alt-right 和 alt-left 展开(隐藏)所有目录 ctrl-alt-] 和 ctrl-alt-[ 同上 ctrl-[ 和 ctrl-] 展开(隐藏)当前目录 ctrl-shift-c 复制当前文件绝对路径 cmd-k h 或 cmd-k left 在左半视图中打开文件 cmd-k j 或 cmd-k down 在下半视图中打开文件 cmd-k k 或 cmd-k up 在上半视图中打开文件 cmd-k l 或 cmd-k right 在右半视图中打开文件 cmd-k h 为先按下 cmd-k ，松开后按 h 。 6. 书签 快捷键 快捷键的功能 cmd-F2 在本行增加书签 F2 跳到当前文件的下一条书签 shift-F2 跳到当前文件的上一条书签 7. 选取 快捷键 快捷键的功能 ctrl-shift-p 选取至上一行 ctrl-shift-n 选取至下一行 ctrl-shift-b 选取至前一个字符 ctrl-shift-f 选取至后一个字符 alt-shift-b, alt-shift-left 选取至字符开始 alt-shift-f, alt-shift-right 选取至字符结束 ctrl-shift-e, cmd-shift-right 选取至本行结束 ctrl-shift-a, cmd-shift-left 选取至本行开始 cmd-shift-up 选取至文件开始 cmd-shift-down 选取至文件结尾 cmd-a 全选 cmd-l 选取一行，继续按会继续选取下一行 ctrl-shift-w 选取当前单词 8. 编辑和删除文本 快捷键 快捷键的功能 ctrl-t 使光标前后字符交换 cmd-j 将下一行与当前行合并 ctrl-cmd-up, ctrl-cmd-down 使当前行向上或者向下移动 cmd-shift-d 复制当前行到下一行 cmd-/ 将选择的文件加入注释 9. Atom 大小写转换 快捷键 快捷键的功能 cmd-k, cmd-u 使当前字符大写 cmd-k, cmd-l 使当前字符小写 cmd-k, cmd-u 为先按 cmd-k 再按 cmd-u 。 10. 删除和剪切 快捷键 快捷键的功能 ctrl-shift-k 删除当前行 ctrl-k 剪切到当前行结束 alt-h 或 alt-delete 删除到当前单词开始 alt-d 删除到当前单词结束 11. 多光标和多处选取 快捷键 快捷键的功能 cmd-click 增加新光标 cmd-shift-l 将多行选取改为多行光标 ctrl-shift-up, ctrl-shift-down 增加上（下）一行光标 cmd-d 选取文档中和当前单词相同的下一处 cmd-u 取消选择 ctrl-cmd-g 选取文档中所有和当前光标单词相同的位置 12. 跳转 快捷键 快捷键的功能 ctrl-m 相应括号之间，html tag之间等跳转 ctrl-g 移动到指定行 row:column 处 ctrl-cmd-m 括号(tag)之间文本选取 alt-cmd-.|关闭当前XML/HTML tag ctrl-shift-o 打开链接 13. 编码方式，文件类型，Markdown 预览 快捷键 快捷键的功能 ctrl-shift-u 调出切换编码选项 ctrl-shift-l 选择文本类型 ctrl-shift-m Markdown 预览 14. 查找和替换 快捷键 快捷键的功能 cmd-f 在buffer中查找 cmd-g 查找下一个 shift-cmd-g 查找上一个 cmd-shift-f 在整个工程中查找 15. 折叠 快捷键 快捷键的功能 alt-cmd-[ 折叠 alt-cmd-] 展开 alt-cmd-shift-{ 折叠全部 alt-cmd-shift-} 展开全部 cmd-k cmd-n 指定折叠层级，n为层级数 16. git 操作 快捷键 快捷键的功能 cmd-alt-z checkout HEAD 版本 cmd-shift-b 弹出 untracked 和 modified 文件列表 alt-g down alt-g up 在修改处跳转 alt-g d 弹出diff列表 alt-g o 在 github 上打开文件 alt-g g 在 github 上打开项目地址 alt-g b 在 github 上打开文件 blame alt-g h 在 github 上打开文件 history alt-g i 在 github 上打开 issues alt-g r 在 github 打开分支比较 alt-g c 拷贝当前文件在 gihub 上的网址","tags":"教程","url":"https://xutree.github.io/pages/2018/10/16/atom快捷键/"},{"title":"Perl 入门","text":"Perl 是 Practical Extraction and Report Language 的缩写，可翻译为 \"实用报表提取语言\"。 Perl 是高级、通用、直译式、动态的程序语言。 Perl 最初的设计者为拉里·沃尔（Larry Wall），于1987年12月18日发表。 Perl 借用了 C、sed、awk、shell 脚本以及很多其他编程语言的特性。 Perl 最重要的特性是 Perl 内部集成了正则表达式的功能，以及巨大的第三方代码库CPAN。 以下代码为使用 Perl 输出 \"Hello World！\"： 1 2 #!/usr/bin/perl print \"Hello, World!\\n\" ; Perl 语言的应用范围很广，除 CGI 以外，Perl 被用于图形编程、系统管理、网络编程、金融、生物以及其他领域。由于其灵活性，Perl 被称为脚本语言中的瑞士军刀。 Perl 与脚本语言一样，Perl 不需要编译器和链接器来运行代码，你要做的只是写出程序并告诉 Perl 来运行而已。这意味着 Perl 对于小的编程问题的快速解决方案和为大型事件创建原型来测试潜在的解决方案是十分理想的。 1. 运行 Perl 1.1 交互式 $perl -e <perl code> # Unix/Linux C:>perl -e <perl code> # Windows/DOS 选项 描述 -d[:debugger] 在调试模式下运行程序 -Idirectory 指定 @INC/#include 目录 -T 允许污染检测 -t 允许污染警告 -U 允许不安全操作 -w 许很多有用的警告 -W 允许所有警告 -X 禁用使用警告 -e program 执行 perl 代码 file 执行 perl 脚本文件 1.2 脚本执行 $perl script.pl # Unix/Linux C:>perl script.pl # Windows/DOS 2. Perl 基础语法 2.1 语句 Perl 程序有声明与语句组成，程序自上而下执行，包含了循环，条件控制，每个语句以分号 ( ; ) 结束。Perl 语言没有严格的格式规范，你可以根据自己喜欢的风格来缩进。 2.2 注释 perl 注释的方法为在语句的开头用字符 #。 perl 也支持多行注释，最常用的方法是使用 POD(Plain Old Documentations) 来进行多行注释。方法如下: 1 2 3 4 5 6 7 8 9 10 11 #!/usr/bin/perl # 这是一个单行注释 print \"Hello, world\\n\" ; =pod 注释 这是一个多行注释 这是一个多行注释 这是一个多行注释 这是一个多行注释 =cut =pod、 =cut只能在行首 以=开头，以=cut结尾 =后面要紧接一个字符，=cut后面可以不用 2.3 空白 Perl 解释器不会关心有多少个空白。但是如果空格和分行出现在字符串内，他会原样输出。 2.4 引号 Perl 双引号和单引号的区别: 双引号可以正常解析一些转义字符与变量，而单引号无法解析会原样输出。 2.5 Here 文档 必须后接分号，否则编译通不过 END 可以用任意其它字符代替，只需保证结束标识与开始标识一致 结束标识必须顶格独自占一行(即必须从行首开始，前后不能衔接任何空白和字符) 开始标识可以不带引号号或带单双引号，不带引号与带双引号效果一致，解释内嵌的变量和转义符号，带单引号则不解释内嵌的变量和转义符号 当内容需要内嵌引号（单引号或双引号）时，不需要加转义符，本身对单双引号转义 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #!/usr/bin/perl $a = 10 ; $var = <<\" EOF \"; 这是一个 Here 文档实例，使用双引号。 可以在这输如字符串和变量。 例如：a = $a EOF print \"$var\\n\" ; $var = <<' EOF '; 这是一个 Here 文档实例，使用单引号。 例如：a = $a EOF print \"$var\\n\" ; 执行以上程序输出结果为： 这是一个 Here 文档实例，使用双引号。 可以在这输如字符串和变量。 例如：a = 10 这是一个 Here 文档实例，使用单引号。 例如：a = $a 3. Perl 数据类型 Perl 是一种弱类型语言，所以变量不需要指定类型，Perl 解释器会根据上下文自动选择匹配类型。 Perl 有三个基本的数据类型：标量、数组、哈希。 3.1 标量 标量是 Perl 语言中最简单的一种数据类型。这种数据类型的变量可以是数字，字符串，浮点数，不作严格的区分。在使用时在变量的名字前面加上一个\"$\",表示是标量。 3.2 数组 数组变量以字符\"@\"开头，索引从0开始。 3.3 哈希 哈希是一个无序的 key/value 对集合。可以使用键作为下标获取值。哈希变量以字符\"%\"开头。 4. 数字字面量 4.1 整型 Perl 实际上把整数存在你的计算机中的浮点寄存器中，所以实际上被当作浮点数看待。 在多数计算机中，浮点寄存器可以存贮约16位数字，长于此的被丢弃。整数实为浮点数的特例。 8进制和16进制数：8进制以0开始，16进制以0x开始。 4.2 浮点数 浮点数数据如：11.4 、 -0.3 、.3 、 3. 、 54.1e+02 、 5.41e03 浮点寄存器通常不能精确地存贮浮点数，从而产生误差，在运算和比较中要特别注意。指数的范围通常为-309到+308。 4.3 字符串 Perl 中的字符串使用一个标量来表示，定义方式和 c 很像，但是在 Perl 里面字符串不是用0来表示结束的。 Perl 双引号和单引号的区别: 双引号可以正常解析一些转义字符与变量，而单引号无法解析会原样输出。但是用单引号定义可以使用多行文本。 4. 转义字符 转义字符 含义 \\\\ 反斜线 \\' 单引号 \\\" 双引号 \\a 系统响铃 \\b 退格 \\f 换页符 \\n 换行 \\r 回车 \\t 水平制表符 \\v 垂直制表符 \\0nn 创建八进制格式的数字 \\xnn 创建十六进制格式的数字 \\cx 控制字符，x可以是任何字符 \\u 强制下一个字符为大写 \\l 强制下一个字符为小写 \\U 强制将所有字符转换为大写 \\L 强制将所有的字符转换为小写 \\Q 将到\\E为止的非单词（non-word）字符加上反斜线 \\E 结束\\L、\\U、\\Q 5. Perl 变量 标量 \\( 开始， 如\\) a $b 是两个标量。 数组 @ 开始 ， 如 \\@a \\@b 是两个数组。 哈希 % 开始 ， %a %b 是两个哈希。 Perl 为每个变量类型设置了独立的命令空间，所以不同类型的变量可以使用相同的名称，你不用担心会发生冲突。例如 $foo 和 \\@foo 是两个不同的变量。 变量不需要显式声明类型，在变量赋值后，解释器会自动分配匹配的类型空间。 5.1 Perl 标量 标量是一个简单的数据单元。 标量可以是一个整数，浮点数，字符，字符串，段落或者一个完整的网页。 5.1.1 特殊字符 以下我们将演示 Perl 中特殊字符的应用，如 __FILE__, __LINE__, 和 __PACKAGE__ 分别表示当前执行脚本的文件名，行号，包名。 注意： 是两条下划线，__FILE 前后各两条下划线。 这些特殊字符是单独的标记，不能写在字符串中，例如： 1 2 3 4 5 6 7 8 #!/usr/bin/perl print \"文件名 \" . __FILE__ . \"\\n\" ; print \"行号 \" . __LINE__ . \"\\n\" ; print \"包名 \" . __PACKAGE__ . \"\\n\" ; # 无法解析 print \"__FILE__ __LINE__ __PACKAGE__\\n\" ; 文件名 test.pl 行号 4 包名 main __FILE__ __LINE__ __PACKAGE__ 5.1.2 v 字符串 用于十六进制： 1 2 3 4 5 6 7 8 9 #!/usr/bin/perl $smile = v9786 ; $foo = v102 .111.111 ; $martin = v77 .97.114.116.105.110 ; print \"smile = $smile\\n\" ; print \"foo = $foo\\n\" ; print \"martin = $martin\\n\" ; Wide character in print at test.pl line 7. smile = &#x263a; foo = foo martin = Martin 5.2 数组 Perl 数组一个是存储标量值的列表变量，变量可以是不同类型。 数组变量以 \\@ 开头。访问数组元素使用 $ + 变量名称 + [索引值] 格式来读取。 if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"教程","url":"https://xutree.github.io/pages/2018/10/15/perl入门/"},{"title":"原码, 反码, 补码","text":"1. 原码 原码就是符号位加上真值的绝对值，即用第一位表示符号，其余位表示值。 2. 反码 反码的表示方法是: 正数的反码是其本身 负数的反码是在其原码的基础上，符号位不变，其余各个位取反 3. 补码 补码的表示方法是: 正数的补码就是其本身 负数的补码是在其原码的基础上，符号位不变，其余各位取反，最后 +1，(即在反码的基础上 +1)","tags":"基础知识","url":"https://xutree.github.io/pages/2018/10/14/bianma/"},{"title":"eps 图像截切四周的空白","text":"$ epstopdf origin.eps temp.pdf $ pdfcrop temp.pdf temp-crop.pdf $ pdf2ps temp-crop.pdf final.eps $ rm temp*","tags":"其他","url":"https://xutree.github.io/pages/2018/10/13/eps/"},{"title":"PyTroch 之 torch 包","text":"1. 张量 torch.is_tensor(obj) torch.is_storage(obj) torch.set_default_dtype(d) // default: torch.float32 torch.get_default_dtype() → torch.dtype torch.set_default_tensor_type(t) // default: torch.FloatTensor torch.numel(input) → int torch.set_printoptions(precision=None, threshold=None, edgeitems=None, linewidth=None, profile=None) torch.set_flush_denormal(mode) → bool 1.1 创建 torch.tensor(data, dtype=None, device=None, requires_grad=False) → Tensor torch.sparse_coo_tensor(indices, values, size=None, dtype=None, device=None, requires_grad=False) → Tensor torch.as_tensor(data, dtype=None, device=None) → Tensor torch.from_numpy(ndarray) → Tensor torch.zeros(*sizes, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) → Tensor torch.zeros_like(input, dtype=None, layout=None, device=None, requires_grad=False) → Tensor torch.ones(*sizes, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) → Tensor torch.ones_like(input, dtype=None, layout=None, device=None, requires_grad=False) → Tensor torch.arange(start=0, end, step=1, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) → Tensor torch.range(start=0, end, step=1, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) → Tensor torch.linspace(start, end, steps=100, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) → Tensor torch.logspace(start, end, steps=100, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) → Tensor torch.eye(n, m=None, out=None, dtype=None, layout=torch.strided, deviceNone, requires_grad=False) → Tensor torch.empty(*sizes, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) → Tensor torch.empty_like(input, dtype=None, layout=None, device=None, requires_grad=False) → Tensor torch.full(size, fill_value, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) → Tensor torch.full_like(input, fill_value, out=None, dtype=None, layout=torch.strided, device=None, requires_grad=False) → Tensor 1.2 切片、索引、连接和转换操作 torch.cat(tensors, dim=0, out=None) → Tensor torch.chunk(tensor, chunks, dim=0) → List of Tensors torch.gather(input, dim, index, out=None) → Tensor torch.index_select(input, dim, index, out=None) → Tensor torch.masked_select(input, mask, out=None) → Tensor torch.narrow(input, dimension, start, length) → Tensor torch.nonzero(input, out=None) → LongTensor torch.reshape(input, shape) → Tensor torch.split(tensor, split_size_or_sections, dim=0) torch.squeeze(input, dim=None, out=None) → Tensor torch.stack(seq, dim=0, out=None) → Tensor torch.t(input) → Tensor torch.take(input, indices) → Tensor torch.transpose(input, dim0, dim1) → Tensor torch.unbind(tensor, dim=0) → seq torch.unsqueeze(input, dim, out=None) → Tensor torch.where(condition, x, y) → Tensor 1.3 随机采样 torch.manual_seed(seed) → torch._C.Generator torch.initial_seed() torch.get_rng_state()","tags":"教程","url":"https://xutree.github.io/pages/2018/10/12/torch/"},{"title":"数据结构——向量","text":"数据结构大致可分为：线性结构、半线性结构和非线性结构。线性结构中最基本的称为序列（sequence），根据其中数据项的逻辑次序与其物理存储地址的对应关系不同，又可分为向量（vector）和列表（list）。 1. 从数组到向量 数组：集合 S 由 n 个元素组成，且各元素之间具有一个线性次序，则可以将它们存放于起始地址 A，物理位置连续的一段存储空间。记为： A[0,n) = { A[0], A[1], ..., A[n-1] } 将它们存放于起始地址 A，若每个元素占用 s 个单位的空间，则元素 A[i] 的物理地址为： A + i * s ，所以被称作线性数组。 向量： V[0,n) = { v[0], v[1], ..., v[n-1] } 是线性数组的一种抽象和泛化，由具有线性次序的一组元素构成的集合，其中的元素由秩区分。各元素秩互异，且均为 [0, n) 内的整数。采用\"寻秩访问\"。经过抽象，不限定同一向量中元素都属于同一数据类型，故而不保证它们之间可以相互比较大小。 2. 接口 作为一种抽象数据类型，向量对象应支持如下操作接口： 操作接口 功能 适用对象 size() 元素总数 向量 get(r) 获取秩为 r 的元素 向量 put(r, e) 用 e 代替秩为 r 的元素 向量 insert(r, e) e 作为秩为 r 的元素插入，原后继元素依次后移 向量 remove(r) 删除秩为 r 的元素，返回该元素中原存放的对象 向量 disordered() 判断所有元素是否已按非降序排列 向量 sort() 非降序排序 向量 find(e) 查找等于 e 且秩最大的元素 向量 search(e) 查找目标元素 e，返回不大于 e 且秩最大的元素 有序向量 deduplicate() 剔除重复元素 向量 uniquify() 剔除重复元素 有序向量 traverse() 遍历向量并统一处理所有元素，处理方法由函数对象指定 向量 3. Vector 模板类 typedef int Rank; //秩 #define DEFAULT_CAPACITY 3 //默认的初始容量（实际应用中可设置为更大） template <typename T> class Vector { //向量模板类 protected: Rank _size; int _capacity; T* _elem; //规模、容量、数据区 void copyFrom(T const* A, Rank lo, Rank hi); //复制数组区间A[lo,hi) void expand(); //空间不足时扩容 void shrink(); //装填因子过小时压缩 bool bubble(Rank lo, Rank hi); //扫描交换 void bubbleSort()Rank lo, Rank hi); //气泡排序算法 Rank max(Rank lo, Rank hi); //选取最大元素 void selectionSort(Rank lo, Rank hi); //选择排序算法 void merge(Rank lo, Rank mi, Rank hi); //归并算法 void mergeSort(Rank lo, Rank hi); //归并排序算法 Rank partition(Rank lo, Rank hi); //轴点构造算法 void quickSort(Rank lo, Rank hi); //快速排序算法 void heapSort(Rank lo, Rank hi); //堆排序 public: //构造函数 //容量为 c，规模为 s，所有元素初始化为 v，s<=c Vector(int c = DEFAULT_CAPACITY, int s = 0, T v = 0) { _elem = new T[_capacity = c]; for(_size = 0; _size < s; _elem[_size++] = v); } Vector(T const* A, Rank n) { copyFrom(A, 0, n); } //数组整体复制 Vector(T const* A, Rank lo, Rank hi) { copyFrom(A, lo, hi); } //区间 Vector(Vector<T> const& V) { copyFrom(V._elem, 0, V._size); } //向量整体复制 Vector(Vector<T> const& V, Rank lo, Rank hi) { copyFrom(V._elem, lo, hi); } //区间 //析构函数 ~Vector() { delete [] _elem; } //释放内部空间 //只读访问接口 Rank size() const { return _size; } //规模 bool empty() const { return !_size; } //判空 int disordered() const; //判断向量是否已排序 Rank find(T const& e) const { return find(e, 0, _size); } //无序向量整体查找 Rank find(T const& e, Rank lo, Rank hi) const; //无序向量区间查找 Rank search(T const& e) const //有序向量整体查找 { return (0 >= _size) ? -1 : search(e, 0, _size); } Rank search(T const& e, Rank lo, Rank hi) const //有序向量区间查找 //可写访问接口 T& operator[](Rank r) const; //重载下标运算符，可以类似于数组形式引用各元素 Vector<T> & operator=(Vector<T> const&); //重载赋值运算符，以便直接克隆向量 T remove(Rank r); //删除秩为 r 的元素 int remove(Rank lo, Rank hi); //删除秩在区间 [lo,hi) 之内的元素 Rank insert(Rank r, T const& e); //插入元素 Rank insert(T const& e) { return insert(_size, e); } //默认作为尾元素插入 void sort(Rank lo, Rank hi); //对 [lo,hi) 排序 void sort() { sort(0, _size); } //整体排序 void unsort(Rank lo, Rank hi); //对 [lo,hi) 置乱 void unsort() { unsort(0, _size); } //整体置乱 int deduplicate(); //无序去重 int uniquify(); //有序去重 //遍历 void traverse(void (*)(T&)); //遍历（使用函数指针，只读或局部性修改） template <typename VST> void traverse(VST&); //遍历（使用函数对象，可全局性修改） };//Vector 4. 构造与析构 约定：向量中秩为 r 的元素，对应于内部数组中的 _elem[r]，其物理地址为：_elem + r 4.1 默认构造函数 整个默认构造过程顺序进行，没有任何迭代，故忽略用于分配数组空间的时间，需要常数时间。 4.2 基于复制的构造函数 在模板的实现中，我们将基于数组或者向量的复制操作（局部或整体的）都转交给如下的 copyFrom 函数处理： template <typename T> void Vector<T>::copyFrom(T const* A, Rank lo, Rank hi) { _elem = new T[_capacity = 2 * (hi -lo) ]; _size = 0; //分配空间，规模清零 while( lo <hi) //A[lo,hi) 元素逐一复制 _elem[_size++] = A[lo++]; // } 需要 O (_size) 时间。 需要强调的是，由于向量内部含有动态分配的空间，默认的\"=\"运算符不足以支持向量之间的直接赋值。故要重建\"=\"： template <typename T> Vector<T>& Vector<T>::operator=(Vector<T> const& V) { if( _elem ) delet [] _elem; copyFrom(V._elem, 0, V.size()); return *this; } 4.3 析构 若不计系统用于空间回收的时间，整个析构过程只需常数时间。 5. 动态空间管理 5.1 扩容 template <typename T> void Vector<T>::expand() { if(_size < _capacity) return; //尚未满员，不必扩容 if(_capacity < DEFAULT_CAPACITY) _capacity = DEFAULT_CAPACITY; //不低于最小容量 T *oldElem = _elem; _elem = new T[_capacity << 1]; //容量加倍 for( int i = 0; i < _size; i++) _elem[i] = oldElem[i]; //复制原向量内容（T为基本类型，或以重载赋值运算符 delete [] oldElem; //释放原空间 } 分摊运行时间为 O (1) 5.2 缩容 template <typename T> void Vector<T>::shrink() { if(_capacity < DEFAULT_CAPACITY << 1) return; //不至收缩到DEFAULT_CAPACITY if(_size << 2 > _capacity) return; //以25%为界 T *oldElem = _elem; _elem = new T[_capacity >> 1]; //容量减半 for( int i = 0; i < _size; i++) _elem[i] = oldElem[i]; //复制原向量内容（T为基本类型，或以重载赋值运算符 delete [] oldElem; //释放原空间 } 就单次扩容或缩容操作而言，所需时间的确会高达 O (n)，因此在对单次操作的执行速度及其敏感的应用场合以上策略并不适用，其中缩容操作甚至可以完全不予考虑。 6. 常规向量 6.1 直接引用元素 与数组直接通过下标访问元素的形式相比，向量 ADT（abstract data type）所设置的 get() 和 put() 接口都显得不甚自然。 template <typename T> T& Vector<T>::operator[](Rank r) const { return _elem[r]; } //assert: 0 <= r < _size 6.2 置乱器 重载后 [] 返回的是对数组元素的引用，这就意味着它既可以取代 get() 操作（通常作为赋值表达式的右值），也可以取代 set() 操作（通常作为左值）。采用这种形式，可以很清晰地实现如下的向量置乱器： template <typename T> void permute(Vector<T>& V) { for(int i = V.size(); i > 0; i--) swap(V[i-1], V[rand() % i]); //V[i-1] 与 V[0,i) 中某一随机元素交换 } 从理论上讲，上述算法可以枚举出同一向量所有可能的排列，而且能够保证生成各种排列的概率均等。 为便于对各种向量算法的测试与比较，不妨将上述算法封装到向量 ADT 中，并对外提供向量的置乱接口操作： template <typename T> void Vector<T>::unsort(Rank lo, Rank hi) { T* V = _elem + lo; for(Rank i =hi -lo; i > 0; i--) swap(V[i-1], V[rand() % i]); } 上述两段代码的细微差异：上面的代码通过重载\"[]\"，利用秩间接访问 向量 元素，下面的代码通过下标直接访问内部 数组 的元素。 6.3 判等器和比较器 template <typename T> static bool lt(T* a, T* b) { return lt(*a, *b); } //less than template <typename T> static bool lt(T& a, T& b) { return a < b; } //less than template <typename T> static bool eq(T* a, T* b) { return eq(*a, *b); } //equal template <typename T> static bool eq(T& a, T& b) { return a == b; } //equal 在一些复杂的数据结构中，内部元素本身的类型可能就是指向其他对象的指针，从而外部更多关注的，往往是其所指向对象的大小如直接比较指针，则结果毫无意义，故上面的代码分别出了了指针和引用的情况。 6.4 无序查找 6.4.1 判等器 Vector 模板中的 find 接口的语义为\"查找与数据对象 e 相等的元素\"。这暗示向量元素可以通过相互\"比对\"判断是否相等。这类仅支持比对，但未必支持比较的向量，称为无序向量（unsorted vector）。 6.4.2 顺序查找 由于 find 函数查找相等的最大秩元素，故从后往前比对： template <typename T> Rank Vector<T>::find(T const& e, Rank lo, Rank hi) const { while( (lo < hi--) && (e != _elem[hi]) ); //assert: 0 <= lo < hi <= _size return hi; } 最坏情况： O (n)；最好情况： O (1)。为输入敏感（input sensitive）算法。 6.5 插入 //assert: 0 <= r <= size template <typename T> Rank Vector<T>::insert(Rank r, T const& e) { expan(); //如有必要，扩容 for(int i = _size; i > r; i--) _elem[i] = _elem[i-1]; _elem[r] = e; _size++; //插入并更新容量 return r; } 注意从后往前搬移数据，以防覆盖。复杂度：若插入位置等概论分布，则平均运行时间为 O (_size)= O (n)。 6.6 删除 应将单元素删除视为区间删除的特例，并基于后者来实现前者。 6.6.1 区间删除 //删除区间[lo, hi) template <typename T> int Vector<T>::remove(Rank lo, Rank hi) { if(lo === hi) return 0; while(hi < _size) _elem[lo++] = _elem[hi++]; _size = lo; shrink(); return hi - lo; //返回被删除元素个数 } 6.6.2 单元素删除 template <typename T> T Vector<T>::remove(Rank r) { T e = _elem[r]; remove(r, r + 1); return e; } 被删除元素在向量中的位置越靠后（前）所需时间越短（长），最好为 O (1)，最坏为 O (n)。 6.7 唯一化 template <typename T> int Vector<T>::deduplicate() { int oldSize = _size; Rank i = 1; while(i < _size) (find(_elem[i], 0, i) < 0) ? i++ : remove(i); return oldSize - _size; }","tags":"读书笔记","url":"https://xutree.github.io/pages/2018/10/10/数据结构向量/"},{"title":"数据结构——树","text":"1. 预备知识 一棵树是 \b \\(N\\) 个节点和 \\(N-1\\) 条边的集合，因为除了根（root）节点外，其余节点都有唯一一条边指向其父（parent）节点 没有儿子的节点称为叶（leaf）节点；具有相同父节点的节点称为兄弟（sibling）节点 对任意节点 \\(n_i\\) ， \\(n_i\\) 的深度（depth）为从根节点到 \\(n_i\\) 的唯一路径的长度；故根的深度为 0 对任意节点 \\(n_i\\) ， \\(n_i\\) 的高（height）是从 \\(n_i\\) 到一片树叶的最长路径的长度；故叶的高度为0；一棵树的高等于它的根的高 1.1 树的实现 typedef struct TreeNode* PtrToNode; struct TreeNode { ElementType Element; PtrToNode FristChild; PtrToNode NextSibling; } 此种方法存的是指向兄弟节点和子节点的链表而非指针，节省了空间（因每个节点的子节点数目并不一致）。 1.2 树的遍历及应用 流行的用法之一就是包括 UNIX，\bVAX/VMS 和 DOS 在内的许多常用操作系统中的目录结构。（严格来讲，UNIX 文件系统还存在指向该目录本身和指向该目录父目录的项，故为类树 treelike）。 前序遍历：根结点 \\(\\longrightarrow\\) 左子树 \\(\\longrightarrow\\) 右子树 中序遍历：左子树 \\(\\longrightarrow\\) 根结点 \\(\\longrightarrow\\) 右子树 后序遍历：左子树 \\(\\longrightarrow\\) 右子树 \\(\\longrightarrow\\) 根结点 层次遍历：只需按层次遍历即可 前序遍历：1 2 4 5 7 8 3 6 中序遍历：4 2 7 5 8 1 3 6 后序遍历：4 7 8 5 2 6 3 1 层次遍历：1 2 3 4 5 6 7 8 2. 二叉树（binary tree） 二叉树的一个性质是平均二叉树的深度要比 \\(N\\) 小得多。分析表明，这个平均深度为 \\(O(\\sqrt N)\\) ；而对于特殊类型的二叉树，即二叉查找树（binary search tree），其深度的平均值为 \\(O(\\log N)\\) ；不幸的是，二叉树的最大深度可以达到 \\(N-1\\) 。 2.1 实现 typedef struct TreeNode* PtrToNode; typedef struct PtrToNode Tree; struct TreeNode { ElementType Element; Tree Left; Tree Right; } 类似双链表的声明。 2.2 表达式树（expression tree） 树叶为操作数，其他节点为操作符。 2.3 二叉树的遍历 2.3.1 前序遍历 前序遍历：根结点 \\(\\longrightarrow\\) 左子树 \\(\\longrightarrow\\) 右子树。 递归实现 void PreOrder(TreeNode *root) { if (root == NULL) return; cout << root->val; PreOrder(root->left); PreOrder(root->right); } 非递归实现 对于任一结点 \\(P\\) ： 1) 访问结点 \\(P\\) ，并将结点 \\(P\\) 入栈 2) 判断结点 \\(P\\) 的左孩子是否为空，若为空，则取栈顶结点并进行出栈操作，并将栈顶结点的右孩子置为当前的结点 \\(P\\) ，循环至 1)；若不为空，则将 \\(P\\) 的左孩子置为当前的结点 \\(P\\) 3) 直到 \\(P\\) 为 NULL 并且栈为空，则遍历结束 void PreOrderDev(TreeNode *root) { if (root == NULL) return; // 保存节点 stack<TreeNode *> nstack; // 备份根节点 TreeNode *node = root; // 开始遍历整个二叉树 while (node != NULL || nstack.empty() != true) { // 输出当前子树的根节点，然后递归直至最左 while (node != NULL) { cout << node->val; nstack.push(node); node = node->left; } // 此时循环结束时，当前栈顶节点已经是最左节点 // 此时递归开始返回，开始出栈，并输出节点的右节点 if (nstack.empty() != true) { node = nstack.top(); nstack.pop(); node = node->right; } } } 2.3.2 中序遍历 中序遍历：左子树 \\(\\longrightarrow\\) 根结点 \\(\\longrightarrow\\) 右子树 递归实现 void InOrder(TreeNode *root) { if (root == NULL) return; InOrder(root->left); cout <<root->val; InOrder(root->right); } 非递归实现 对于任一结点 \\(P\\) ： 1) 若其左孩子不为空，则将 \\(P\\) 入栈并将 \\(P\\) 的左孩子置为当前的 \\(P\\) ，然后对当前结点 \\(P\\) 再进行相同的处理 2) 若其左孩子为空，则取栈顶元素并进行出栈操作，访问该栈顶结点，然后将当前的 \\(P\\) 置为栈顶结点的右孩子 3) 直到 \\(P\\) 为 NULL 并且栈为空则遍历结束 void InOrderDev(TreeNode *root) { if (root == NULL) return; // 保存节点 stack<TreeNode *> nstack; // 备份根节点 TreeNode *node = root; // 开始遍历整个二叉树 while (node != NULL || nstack.empty() != true) { // 不输出当前根节点，但是递归直至当前根节点 node 的最左端 while (node != NULL) { nstack.push(node); node = node->left; } // 此时栈顶的元素是当前最左元素 // 它应该被输出 if (nstack.empty() != true) { node = nstack.top(); cout << node->val; nstack.pop(); node = node->right; } } } 2.3.3 后序遍历 后序遍历：左子树 \\(\\longrightarrow\\) 右子树 \\(\\longrightarrow\\) 根结点 递归实现 void PostOrder(TreeNode *root) { if (root == NULL) return; PostOrder(root->left); PostOrder(root->right); cout << root->val; } 非递归实现 后序遍历的非递归实现是三种遍历方式中最难的一种。因为在后序遍历中，要保证左孩子和右孩子都已被访问并且左孩子在右孩子前访问才能访问根结点，这就为流程的控制带来了难题。 要保证根结点在左孩子和右孩子访问之后才能访问，因此对于任一结点 \\(P\\) ，先将其入栈。如果 \\(P\\) 不存在左孩子和右孩子，则可以直接访问它；或者 \\(P\\) 存在左孩子或者右孩子，但是其左孩子和右孩子都已被访问过了，则同样可以直接访问该结点。若非上述两种情况，则将 \\(P\\) 的右孩子和左孩子依次入栈，这样就保证了每次取栈顶元素的时候，左孩子在右孩子前面被访问，左孩子和右孩子都在根结点前面被访问。 void PostOrderDev(TreeNode *root) { if (root == NULL) return; stack<TreeNode *> nstack; TreeNode *cur; //当前结点 TreeNode *pre = NULL; //前一次访问的结点 nstack.push(root); while (nstack.empty() != true) { cur = nstack.top(); if ((cur->left == NULL && cur->right == NULL) // 左右还是均为 NULL, 可以被输出 || (pre != NULL && ((pre == cur->left || pre == cur->right))) // 左右还是被输出了, 递归返回 // 其实当前节点要是想被输出, 要么 // 1--其左右孩子均为 NULL // 2--其左孩子刚被输出，而其右孩子为 NULL // 3--其右孩子刚被输出 // // 但是这里有一个优化，入栈时候，先是根入栈，然后是右孩子，然后是左孩子，因此当跟元素位于栈顶的时候，其左右孩子必然已经弹出，即被输出，也就是说, 即后序遍历中当前栈顶元素要是想被输出 // 1--其左右孩子均为 NULL // 2--其孩子（不论左右）刚被输出即可 { cout << cur->val; //如果当前结点没有孩子结点或者孩子节点都已被访问过 nstack.pop(); pre = cur; } else { // 由于栈是先进后出，因此先入右孩子, 再左孩子可以保证递归返回时先遍历左孩子 if (cur->right != NULL) { nstack.push(cur->right); } if (cur->left != NULL) { nstack.push(cur->left); } } } } 2.3.4 层次遍历 双指针法 void TreeNode::LevelOrderUsePoint(TreeNode *root) { vector<TreeNode*> vec; vec.push_back(root); int cur = 0; int end = 1; while (cur < vec.size()) { end = vec.size(); /// 新的一行访问开始，重新定位last于当前行最后一个节点的下一个位置 while (cur < end) { cout << vec[cur]->val; /// 访问节点 if (vec[cur]->left != NULL) /// 压入左节点 { vec.push_back(vec[cur]->left); } if (vec[cur]->right != NULL) /// 压入右节点 { vec.push_back(vec[cur]->right); } cur++; } cout << endl; } } 3. 查找树 ADT——二叉查找树 使二叉树成为二叉查找树的关键性质是：对于树中每个节点 \\(X\\) ，它的左子树中 所有 关键字值小于 \\(X\\) 的关键字值，而它的右子树中 所有 关键字值大于 \\(X\\) 的关键字值。 if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"读书笔记","url":"https://xutree.github.io/pages/2018/10/10/树/"},{"title":"C++ Primer 第八章 IO 库","text":"8.1 IO 类 iostream 头文件： istream , wistream , ostream , wostream , iostream , wiostream 类型。 fstream 头文件： ifstream , wifstream , ofstream , wofstream , fstream , wfstream 类型。 sstream 头文件： istringstream , wistringstream , ostringstream , wostringstream , stringstream , wstringstream 类型。 宽字符版本的类型和函数的名字以一个\"w\"开始。 IO 对象无拷贝和赋值。进行 IO 操作的函数通常以引用方式传递和返回值。读写一个 IO 对象会改变其状态，因此传递和返回的引用不能是 const 的。 8.1.1 条件状态 下表中 strm 是一种 IO 类型： 状态 含义 strm ::iostate iostate 是一种机器相关的类型，提供了表达条件状态的完整功能 strm ::badbit 流已崩溃 strm ::failbit IO 操作失败了 strm ::eofbit 流到达了文件结束 strm ::goodbit 流未处于错误状态，此值保证为0 s.eof() 若流 s 的 eofbit 置位，返回 true s.fail() 若流 s 的 failbit 或 badbit 置位，返回 true s.bad() 若流 s 的 badbit 置位，返回 true s.good() 若流 s 处于有效状态，返回 true s.clear() 将流 s 所以状态位复位，将流的状态设为有效，返回 void s.clear(flags) 根据 flags 复位，flags 类型为 strm ::iostate，返回 void s.setstate(flags) 根据 flags 置位，flags 类型为 strm ::iostate，返回 void s.rdstate() 返回流 s 的当前条件状态，返回值类型为 strm ::iostate badbit 表示系统级错误，如不可恢复的读写错误，一旦被置位，流就无法再使用了。 failbit 表示可恢复的错误，例如期望读取数值却读到一个字符等错误。这种问题通常是可以修正的，流还可以继续使用。 如果到达文件结尾， eofbit 和 failbit 都会被置位。 goodbit 值为0，表示流未发生错误。 如果 badbit 、 failbit 和 eofbit 任一个被置位，则检测流状态的条件会失败。 good() 函数在所有错误位均未置位的情况下返回 true 。 我们将流当做条件使用的代码等价于 !fail() 。 8.1.2 管理条件状态 // 记住 cin 的当前状态 auto old_state = cin.rdstate(); // 记住 cin 的当前状态 cin.clean(); // 使 cin 有效 process_input(cin); // 使用 cin cin.setstate(old_state); // 将 cin 置为原有状态 // 复位 failbit 和 badbit，保持其他标志位布标 cin.clear(cin.rdstate() & ~cin.failbit & ~cin.badbit); 8.1.3 管理输出缓冲 每个输出流都管理一个缓冲区，用来保存程序读写的数据。 导致缓冲刷新（即，数据真正写到输出设备或文件）的原因有很多： 程序正常结束，作为 main 函数的 return 操作的一部分，缓冲刷新被执行 缓冲区满 使用操纵符 endl （插入换行）、 ends （插入空字符）、 flush （什么都不插入）显式刷新 在每个输出操作之后，可以用操纵符 unitbuf 设置流的内部状态，来情况缓冲区。默认情况下，对 cerr 是设置 unitbuf 的，因此 cerr 的内容都是立即刷新的 一个输出流可以关联到另一个流。当读写被关联的流时，关联到的流的缓冲区会被刷新。默认情况下， cin 和 cerr 都关联到 cout 。因此读 cin 或者写 cerr 都会导致 cout 的缓冲区被刷新 8.1.4 unitbuf 操纵符 如果想在每次输出操作后都刷新缓冲区，可以使用 unitbuf 操纵符。它告诉流在接下来的每次写操作之后都执行一次 flush 刷新。 nounitbuf 操纵符则重置流，使其恢复使用正常的系统管理的缓冲区刷新机制： cout << unitbuf; // 所有输出操作后都会立即刷新缓冲区 // 任何输出都会立即刷新，无缓冲 cout << nounitbuf; // 回到正常的缓冲方式 8.1.5 关联输入和输出流 tie() 有两个重载的版本： 不带参数的版本返回指向输出流的指针。如果本对象当前关联到一个输出流，则返回的就是指向这个流的指针，如果对象未关联到流，则返回空指针 第二个版本接受一个指向 ostream 的指针，将自己关联到此 ostream 每个流同时最多关联到一个流，但多个流可以同时关联到同一个 ostream 8.2 文件输入输出 8.2.1 fstream 特有的操作 下表中的 fstream 是头文件 fstream 中定义的一个类型： 操作 含义 fstream fstrm; 创建一个未绑定的文件流 fstream fstrm(s); 创建一个 fstream ，并打开名为 s 的文件。s 可以是 string 类型或者指向 C 风格字符串的指针。这些构造函数都是 explicit 的。默认的文件模式 mode 依赖于 fstream 的类型 fstream fstrm(s, mode); 按 mode 打开文件 fstrm.open(s) 打开名为 s 的文件并与 fstrm 绑定。s 可以是 string 类型或者指向 C 风格字符串的指针。默认的文件模式 mode 依赖于 fstream 的类型。返回 void fstrm.close() 关闭与 fstrm 绑定的文件。返回 void fstrm.is_open() 返回一个布尔值，指出与 fstrm 关联的文件是否打开成功且尚未关闭 如果调用 open() 失败， failbit 会被置位，条件会为假： if(open(file)) 可用于判定。 对一个已经打开的文件流调用 open() 会失败，并且 failbit 会被置位。为了将文件流关联到另一个文件，必须先关闭已经关联的文件。 当一个 fstream 对象被销毁时， close 会自动被调用。 8.2.2 文件模式 文件模式 意义 in 只读 out 只写（会清空已有数据） app 每次写操作前均定位到文件末尾 ate 打开文件后立即定位到文件末尾 trunc 截断文件 binary 以二进制方式进行 IO ifstream 默认 in 模式； ofstream 默认 out 模式； fstream 默认 in 和 out 模式打开。 8.3 string 流 fstream 特有的操作 下表中的 sstream 是头文件 sstream 中定义的一个类型： 操作 含义 sstream strm; 创建一个未绑定的 stringstream 对象 sstream strm(s); strm 是一个 sstream 对象，保存 string s 的一个拷贝。此构造函数时 explicit 的 strm.str() 返回 strm 所保存的 string 的拷贝 strm.str(s) 将 string s 拷贝到 strm 中，返回 void","tags":"读书笔记","url":"https://xutree.github.io/pages/2018/10/09/C++_Primer_Chapter_8/"},{"title":"C++ Primer 第七章 类","text":"类的基本思想是数据抽象和封装。 数据抽象是一种依赖于接口和实现分离的编程（以及设计）技术。类的接口包括用户可以执行的操作，类的实现包括类的数据成员，负责接口实现的函数体以及定义类所需的各种私有函数。 封装实现了类的接口和实现的分离。封装后的类隐藏了它的实现细节，类的用户只能使用接口而无法访问实现部分。 7.1 类的定义 定义在类内部的函数时隐式 inline 的。 this 是一个常量指针。 7.1.1 const 成员函数 通过在紧随参数列表之后添加 const ，可以定义 const 成员函数。 const 的作用是修改隐式 this 指针的类型。 默认情况下， this 指针的类型是指向类类型非常量版本的常量指针（顶层常量）。这意味着我们不能把 this 绑定到一个常量对象上。 常量对象，以及常量对象的引用或者指针都只能调用常量成员函数。 7.1.2 类作用域和成员函数 编译器分两步处理类：首先编译成员的声明，然后才轮到成员函数体（如果有的话）。因此，成员函数体可以随意使用类中的其他成员而无须在意这些成员出现的顺序。 编译器处理完类中的全部声明后才会处理成员函数的定义。 这种两阶段的处理方式只适用于成员函数中使用的名字。声明中使用的名字，包括返回类型或者参数列表中使用的名字，都必须在使用前确保可见。如果某个成员的声明使用了类中尚未出现的名字，则编译器将会在定义该类的作用域中继续查找。 typedef double Money ; string bal ; class Account { public : Money balance() { return bal ; } private : Money bal ; // ... }; 当编译器看到 balance 函数的声明语句时，它将在 Account 类的范围内寻找对 Money 的声明。编译器只考虑 Account 中在使用 Money 前出现的声明，因为没找到匹配的成员，所以编译器会接着到 Account 的外层作用域中查找。在上面的例子中，编译器会找到 Money 的 typedef 语句，该类型被用作 balance 函数的返回类型及数据成员 bal 的类型。另一方面，balance 函数体在整个类可见后才被处理。因此，该函数的 return 语句返回名为 bal 的成员，而非外层作用域的 string 对象。 7.1.3 构造函数 构造函数不能被声明成 const 的。 当我们创建类的一个 const 对象时，直到构造函数完成初始化过程，对象才能真正取得其\"常量\"属性。因此，构造函数在 const 对象的构造过程中可以向其写值。 如果我们的类没有显式定义构造函数，编译器会生成合成的默认构造函数。对于大多数类来说，合成的默认构造函数按照如下规则初始化类的数据成员： 如果存在类内的初始值，用它来初始化成员 否则，执行默认初始化 在 C++ 11中，如果我们需要默认的行为，那么可以通过在参数列表后面写上 = default 来要求编译器生成构造函数。如果 = default 出现在类的内部，则默认构造函数是内联的；如果它出现在外部，则该成员默认情况下不是内联的。 7.1.3.1 构造函数初始值列表 构造函数初始值列表： Sales_data(const std::string &s) : bookNo(s) { } 如果成员是 const 或者引用的话，必须将其初始化。类似的，当成员属于某种类类型且该类类型没有定义默认构造函数时，也必须将这个成员初始化。 随着构造函数体一开始执行，初始化就完成了。我们初始化 const 或者引用类型的唯一机会就是通过构造函数初始化。 构造函数初始值列表只说明用于初始化成员的值。成员的初始化顺序与它们在类定义中出现顺序一致。 7.1.3.2 委托构造函数 一个委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程，或者说它把它自己的一些（或者全部）职责委托给了其他构造函数。 class Sales_data { public : // 非委托构造函数 Sales_data ( std :: string s , unsigned cnt , double price ) : bookNo ( s ), units_sold ( cnt ), revenue ( cnt * price ) { } // 其余构造函数都委托给另外一个构造函数 Sales_data () : Sales_data ( \"\" , 0 , 0 ) { } Sales_data ( std :: string s ) : Sales_data ( s , 0 , 0 ) { } Sales_data ( std :: istream & is ) : Sales_data() { read ( is , * this ); } //其他成员 } 受委托的构造函数先执行。 7.2 访问控制与封装 定义在 public 说明符之后的成员在整个程序内可被访问， public 成员定义类的接口。 定义在 private 说明符之后的成员可以被类的成员函数访问，但是不能被使用该类的代码访问。 class 和 struct 定义类唯一的区别就是默认的访问权限。 友元 通过友元，类可以允许其他类或者函数访问它的 非公有成员 。 如果类想把一个函数作为它的友元，只需要增加一条以 friend 关键字开始的函数声明即可。友元声明只能出现在类定义的内部，但是在类内出现的具体位置不限。友元不是类的成员也不受它所在区域访问控制级别的约束。 友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明。如果我们希望类的用户能够调用某个友元函数，那么我们必须在友元声明之外再专门对函数进行一次声明。 友元关系不存在传递性。 如果一个类指定了友元类，则友元类的成员函数可以访问此类 包括非公有成员在内的所有成员 。 7.3 类的其他特性 7.3.1 定义类型成员 类可以自定义某种类型在类中的别名。要注意，用来定义类型的成员必须先定义后使用。 7.3.2 可变数据成员 有时我们希望能够修改类的某个数据成员，即使是在一个 const 成员函数内。通过关键字 mutable 可以达到这种效果。一个可变数据成员永远不会是 const ，即使它是 const 对象的成员。 7.3.3 返回 *this 的成员函数 一个 const 成员函数如果以引用的方式返回*this，那么它的返回类型将是常量引用。 基于 const 的重载： class Screen { public : // 根据对象是否是 const 重载 display 函数 Screen & display ( std :: ostream & os ) { do_display ( os ); return * this ; } const Screen & display ( std :: ostream & os ) const { do_display ( os ); return * this ; } private : // 该函数负责显示 Screen 的内容 void do_display ( std :: ostream & os ) const { os << contents ; } }; 7.3.4 类类型 声明方法： Sales_data item1; 或 class Sales_data item1; 后一种从 C 语言继承而来。 类的声明：前向声明，在类声明之后定义之前，类是一个不完全类型。 不完全类型只能在非常有限的情景下使用：定义指向这种类型的引用或指针，也可以声明（但是不能定义）以不完全类型作为参数或者返回类型的函数。 直到类被定义之后数据成员才可以被声明成这种类类型。然而，当一个类的名字出现后，它被认为是声明过了（但尚未定义），因此允许包含指向它自身类型的引用或者指针（有没有想到链表结构）。 7.3.4.1 隐式的类类型转换 如果构造函数只接受一个实参，则它实际上定义了转换为此类类型的隐式转换机制，有时我们把这种构造函数称为转换构造函数。 只允许一步类类型转换。类类型转换不是总有效。 7.3.4.2 抑制构造函数定义的隐式转换 可以通过将构造函数声明为 explicit 加以阻止。 关键字 explicit 只对一个实参的构造函数有效。需要多个实参的构造函数不能用于执行隐式转换，所以无须将这些构造函数指定为 explicit 。 只能在类内声明构造函数时使用 explicit 关键字，在类外部定义时不应重复。 explicit 构造函数只能用于直接初始化。 尽管编译器不会将 explicit 的构造函数用于隐式转换过程，但是我们可以使用这样的构造函数显式地强制类型转换： item.combine(static_cast<Sales_data>(cin)); 7.3.5 聚合类 当一个类满足如下条件时，我们说它是聚合的： 所有成员都是 public 的 没有定义任何构造函数 没有类内初始值 没有基类，也没有虚函数 例子： struct Data { int ival; string s; } 可以使用初始化列表初始化，初始值的顺序必须与声明的顺序一致。如果初始值列表中的元素个数少于类的成员数量，则靠后的成员被值初始化。 7.3.6 字面值常量类 字面值类型的类可能含有 constexpr 函数成员，它们是隐式 const 成员函数。 数据成员都是字面值类型的聚合类是字面值常量类。 如果一个类不是聚合类，符合以下要求也是一个字面值常量类： 数据成员都必须是字面值类型 类必须至少有一个 constexpr 构造函数 如果一个数据成员含有类内初始值，则内置类型成员的初始值必须是一条常量表达式；如果成员属于某种类类型，则初始值必须使用成员自己的 constexpr 构造函数 类必须使用析构函数的默认定义，该成员负责销毁类的定义 尽管构造函数不能是 const 的，但是字面值常量类的构造函数可以使 constexpr 函数。事实上，一个字面值常量类都必须至少提供一个 constexpr 构造函数。通过前置关键字 constexpr 就可以声明一个 constexpr 构造函数。 constexpr 构造函数可以声明成 =default 或者删除函数的形式，否则， constexpr 构造函数就必须既符合构造函数的要求（意味着不能包含返回语句），又符合 constexpr 函数的要求（意味着它唯一可执行语句就是返回语句），综合这两点， constexpr 构造函数体一般来说应该是空的。 constexpr 构造函数必须初始化所有数据成员，初始值或者使用 constexpr 构造函数，或者是一条常量表达式。 7.4 类的静态成员 类的静态成员存在于任何对象之外，对象中不包含任何与静态数据成员有关的数据。类似的，静态成员函数也不与任何对象绑定在一起，它们不包含 this 指针。作为结果，静态成员函数不能声明成 const 的，而且我们也不能在静态函数体内使用 this 指针。 成员函数不用通过作用域运算符就能直接使用静态成员。 当在类的外部定义静态成员时，不能重复 static 关键字，该关键字只出现在类内部的声明语句。 必须在类的外部定义和初始化每个静态成员（一个例外，如果静态成员是字面值类型的 constexpr 可以在类内给它提供一个整数类型的常量表达式初始值），一个静态成员只能被初始化一次。 类似于全局变量，静态数据成员定义在任何函数之外，一直存在于程序的整个生命周期中。 静态数据成员可以是不完全类型，非静态数据成员只能声明成它所属类的指针或引用。 静态数据成员可以作为默认实参，非静态数据成员不行，因为它的值本身属于对象的一部分，这么做的结果是无法真正提供一个对象以便从中获得成员的值（类似于循环定义），将引发错误。","tags":"读书笔记","url":"https://xutree.github.io/pages/2018/10/09/C++_Primer_Chapter_7/"},{"title":"C++ Primer 第六章 函数","text":"函数是一个命名了的代码块。 6.1 函数基础 为了与 C 语言兼容，可以使用关键字 void 表示函数没有形参。 函数的返回值不能是数组或者函数类型，但可以返回指向数组和函数的指针。 自动对象：只存在于块执行期间的对象。当块的执行结束后，块中创建的自动对象的值就变成未定义的了。 局部静态对象：在程序执行路径第一次经过对象定义语句时初始化，并且直到程序终止才销毁。如果没有显示初始化，则执行值初始化，内置类型的局部静态变量初始化为0。 6.2 参数传递 值传递和引用传递。 当某种类型不支持拷贝操作时，函数只能通过引用形参访问该类型的对象。如 IO 类型。 6.2.1 const 形参和实参 如果函数无须改变引用形参的值，最好将其声明为常量引用。 此外，使用引用而非常量引用也会极大地限制函数所能接受的实参类型。例如，我们不能把 const 对象、字面值或者需要类型转换的对象传递给普通的引用形参，这种绝不像看起来那么简单，它可能造成出人意料的后果。考虑如下函数： string :: size_type find_char ( string & s , char c , string :: size_type & occurs ); 则只能将 find_char 函数用于 string 对象。类似下面的调用将在编译时发生错误： find_char(\"Hello World\", 'o', ctr); 还有一个更难察觉的问题。假如其它函数（正确的）将它们的形参定义成常量引用，那么上述的 find_char 函数无法在此类函数中正常使用。例如 bool is_sentence ( const string & s ) { string : : size_type ctr = 0 ; return find_char(s, '.', ctr) == s.size() - 1 && ctr == 1 ; } 正确的修改思路是改正 find_char 函数的形参。如果实在不能修改 find_char，就在 is_sentence 内部定义一个 string 类型的变量，令其为 s 的副本，然后把这个对象传递给 find_char。 用实参初始化形参时，会忽略顶层 const 。也就是说，当形参是顶层 const 时，传给它常量对象或者非常量对象都是可以的。 可以使用一个非常量初始化一个底层 const 对象，但反过来不行。 6.2.2 数组形参 数组的两个性质：不允许拷贝数组；使用数组时会将其转换成指针。 当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针。 尽管不能以值传递的方式传递数组，但是我们可以把形参写成类似数组的形式： void print(const int*); void print(const int[]); void print(const int[10]); 尽管表现形式不同，但是上面的三个函数是等价的：每个函数的唯一形参都是 const int* 类型的。如果我们传给 print 函数的是一个数组，则实参自动的转换成指向数组首元素的指针，数组的大小对函数的调用没有影响。 因为数组是以指针的形式传递给函数的，所以一开始函数并不知道数组的确切尺寸，调用者应该为此提供一些额外的信息： 使用标记指定数组长度：让数组本身包含一个结束标记，例如 C 风格字符串 使用标准库规范， begin() 和 end() 函数 显示传递一个表示数组大小的形参 当函数不需要对数组元素执行写操作的时候，数组形参应该是指向 const 的指针，注意下面的函数只能作用于大小为10的数组 void print(int (&arr)[10]) { for (auto elem : arr) cout << elem << endl; } 6.2.3 main：处理命令行选项 int main(int argc, char *argv[]) { ... } 第二个形参 argv 是一个数组，它的元素是指向 C 风格字符串的指针；第一个形参 argc 表示数组中字符串的数量。因为第二个形参是数组，所以 main 函数也可以定义成： int main(int argc, char **argv) { ... } 当实参传给 main 函数之后，argv 的第一个元素指向程序的名字或者一个空字符串，接下来的元素依次传递命令行提供的实参，最后一个指针之后的元素值保证为0。 6.2.4 含有可变形参的函数 为了编写能够处理不同数量实参的函数，C++11 新标准提供了两种主要的方法： 如果所有实参类型相同，可以传递一个名为 initializer_list 的标准库类型 如果实参的类型不同，可以编写可变参数模板 C++ 还有一种特殊的形参类型（即省略号），可以用它传递可变数量的实参，不过需要注意的是，这种功能一般只用于与 C 函数交互的接口程序 6.2.4.1 initializer_list 形参 initializer_list 类型定义在同名的头文件中。 initializer_list 是一种类型模板，提供的操作如下： initializer_list <T> lst; 默认初始化；T 类型元素的空列表。 initializer_list <T> lst{a,b,c...}; lst 的元素数量和初始值一样多；lst 的元素是对应初始值的副本；列表中的元素是 const。 lst2(lst); 拷贝或赋值一个 initializer_list 对象不会拷贝列表中的元素；拷贝后，原始列表和副本共享元素。 lst2 = lst; 等价于 lst2(lst) 。 lst.size(); 列表中的元素数量。 lst.begin(); 返回指向 lst 中首元素的指针。 lst.end(); 返回指向 lst 中尾元素下一位置的指针。 initializer_list 和 vector 一样，也是类型模板，定义 initializer_list 对象时，必须说明列表中所含对象的类型。和 vector 不一样的是， initializer_list 对象中的元素永远是常量值。 如果想向 initializer_list 形参中传递一个值的序列，则必须把序列放在一对花括号内： //expected和actual是string对象 if (expected != actual) error_msg({\"functionX\", expected, actual}); else error_msg({\"functionX\", \"okay\"}); 6.2.4.2 省略符形参 省略符形参是为了便于 C++ 程序访问某些特殊的 C 代码而设置的，这些代码使用了名为 varargs 的 C 标准库功能。通常，省略符形参不应用于其他目的。你的 C 编译器文档会描述如何使用 varargs。 省略符形参只能出现在形参列表的最后一个位置，无外乎两种形式，在第一种形式中，形参声明后面的逗号是可选的： void foo(parm_list,...); void foo(...); 6.3 返回类型和 return 语句 返回 void 的函数不要求非得有 return 语句，以为这类函数的最后一句会隐式的执行 return 。 返回的值用于初始化调用点的一个临时量，该临时量就是函数调用的结果。 不要返回局部对象的引用或指针。 调用一个返回引用的函数得到左值，其他返回类型得到右值。 C++ 11新标准规定，函数可以返回花括号包围的值的列表，类似于其他返回结果，此处的列表也用来对表示函数返回的临时量进行初始化。如果列表为空，临时量执行值初始化。如果函数返回的是内置类型，则花括号包围的列表最多包含一个值，且该值所占空间不应该大于目标类型的空间。如果返回的是类类型，由类本身定义初始值如何使用。 如果控制语句到达了 main 函数的结尾处而且没有 return 语句，编译器会隐式的插入一条返回0的 return 语句。 cstdlib 头文件定义了两个预处理变量表示成功与失败： EXIT_SUCCESS ， EXIT_FAILURE 。 int (*func(int i))[10]; func 是一个函数指针，指向：接受一个 int 参数，返回值是包含10个 int 数组的地址的函数。也可以利用尾置返回类型（C++ 11）写为： auto func(int i) -> int(*)[10]; 还有一种情况，如果我们知道函数返回的指针将指向哪个数组，就可以使用 decltype 关键字声明返回类型。例如，下面的函数返回一个指针，该指针根据参数i的不同指向两个已知数组中的某一个： int odd[] = {1, 3, 5, 7, 9}; int even[] = {0, 2, 4, 6, 8}; //返回一个指针，该指针指向含有5个整数的数组 decltype(odd) *arrPtr(int i) { return (i % 2) ? &odd : &even; } arrPtr 使用关键字 decltype 表示它的返回类型是个指针，并且该指针所指的对象与 odd 的类型一致。因为 odd 是数组，所以 arrPtr 返回一个指向含有5个整数的数组的指针。有一个地方需要注意， decltype 并不负责把数组类型转换成对应的指针，所以 decltype 的结果是个数组，要想表示 arrPtr 返回指针还必须在函数声明时加一个 * 符号。 6.4 函数重载 6.4.1 顶层 const 顶层 const 不影响传入函数的对象。一个用于顶层 const 的形参无法和一个没有顶层 const 的形参区分开，无法重载： Record lookup(Phone); Record lookup(const Phone); // Record lookup(Phone*); Record lookup(Phone* const); 6.4.2 底层 const 底层 const 可以实现重载。当我们传递一个非常量对象或者指向非常量对象的指针时，编译器会优先选用非常量的版本： Record lookup(Account&); Record lookup(const Account&); // Record lookup(Account*); Record lookup(const Account*); 6.4.3 const_cast和重载 //函数1 const string &shorterString(const string &s1, const strinf &s2) { return s1.size() <= s2.size() ? s1 : s2; } //函数2 string &shorterString(string &s1, string &s2) { auto &r = shorterString(const_cast<const string &>(s1), const_cast<const string&>(s2)); return const_cast<string&>(r); } 函数1的参数和返回类型都是 const string 的引用。我们当然可以对两个非常量的 string 实参调用这个函数，但返回的结果仍然是 const string 的引用。 6.4.4 作用域与重载 编译器首先在当前作用域寻找函数，一旦找到，就会忽略掉外层作用域中的同名实体，剩下的工作就是检查函数调用是否有效了。 在C++语言中，名字查找发生在类型检查之前。 6.5 特殊用于语言特性 6.5.1 默认实参 一旦一个形参被赋予了默认值，它后面的所有形参都必须有默认值。 在给定的作用域中，一个形参只能被赋予一次默认实参。 局部变量不能作为默认实参。 用作函数实参的名字在函数声明所在的作用域内解析，而这些名字的求值过程发生在函数调用时： sz wd = 80; char def = ''; sz ht(); string screen(sz = ht(), sz = wd, char = def); void f() { def = '*'; //改变默认实参的值 sz wd = 100; //隐藏了外层定义的wd，但是没有改变默认值 window = screen(); //调用 screen(ht(), 80, '*') } 6.5.2 内联函数 以空间换时间。在函数返回类型前面加上关键字 inline 。内联说明只是向编译器发出一个请求，编译器可以选择忽略这个请求。 6.5.3 constexpr 函数 能用于常量表达式的函数。函数的返回类型及所有的形参类型都得是字面值类型。函数体中必须有且只有一条 return 语句。 constexpr int new_sz() { return 42; } constexpr int foo = new_sz(); 编译器在程序编译时验证 new_sz 函数的返回类型。执行初始化任务时，编译器把对 constexpr 函数的调用替换成其结果值。为了能在编译过程中随时展开， constexpr 函数被隐式指定为内联函数。 constexpr 函数体内也可以包含其他语句，只要这些语句在运行时不执行任何操作就行，例如，空语句、类型别名及 using 声明。 constexpr 函数不一定返回常量表达式，当把这类函数用在需要常量表达式的上下文中时，会出错。 把内联函数和 constexpr 函数放在头文件内。 和其它函数不一样，内联函数和 constexpr 函数可以在程序中多次定义，但是多个定义必须完全一致。 6.5.4 调试帮助 6.5.4.1 assert 预处理宏 所谓预处理宏其实是一个预处理变量，它的行为有点类似于内联函数。 assert 宏使用一个表达式作为它的条件： assert(expr); 首先对 expr 求值，如果表达式为假， assert 输出信息并终止程序的执行。如果表达式为真， assert 什么也不做。 assert 定义在cassert头文件中， assert 宏常用于检查\"不能发生\"的条件。 6.5.4.2 NDEBUG 预处理变量 assert 的行为依赖于 NDEBUG 预处理变量的状态。如果定义了 NDEBUG ， assert 什么都不做，默认情况下没有定义 NDEBUG ， assert 将执行运行时检查。我们可以使用一个 #define 语句定义 NDEBUG ，从而关闭调试状态。同时，很多编译器都提供了一个命令行选项使我们可以定义预处理变量： $ CC -D NDEBUG main.C #use /D with the Mocrosoft compiler. 除了使用 assert 外，也可以使用 NDEBUG 编写自己的条件调试代码。如果 NDEBUG 未定义，将执行 #ifndef 和 #endif 之间的代码；如果定义了 NDEBUG ，这些代码将被忽略掉。 编译器为每个函数都定义了 __func__ ，它是一个 const char 局部静态数组，用于存放函数的名字，除了 C++ 编译器定义的 __func__ 之外，预处理器还定义了另外4个对于程序调试很有用的名字： __FILE__ 存放文件名的字符串字面值 __LINE__ 存放当前行号的整型字面值 __TIME__ 存放文件编译时间的字符串字面值 __DATE__ 存放文件编译日期的字符串字面值 6.6 函数匹配 候选函数：函数匹配的第一步是选定本次调用对应的重载函数集。 可行函数：形参数量与本次提供的实参数量相等（默认形参可以少于）；每个实参的类型与对应的形参相同，或者可以转换成形参的类型。 寻找最佳匹配（如果有的话）：该函数每个实参的匹配都不劣于其他可行函数需要的匹配；至少有一个实参的匹配优于其他可行函数提供的匹配。 如果没找到可行函数：编译器报告无匹配函数的错误；如果最佳匹配不唯一，编译器报告二义性错误。 6.7 函数指针 要声明一个函数指针，只需要用指针替换函数名： bool (*pf)(const string &, const string &); //未初始化，pf 两端括号必不可少 当把函数名作为一个值使用时，该函数自动转换为指针，也就是说取地址符是可选的。同样，我们可以直接用函数指针调用函数，解引用符也是可选的。 不同类型的函数指针之前不存在转换规则。 函数指针没有指向任何一个函数：将函数指针赋为0或者 nullptr 。 和数组类似，虽然不能定义函数类型的形参，但是可以定义指向函数的指针。此时，形参看起来是函数，实际上被当成指针使用： //形参是函数类型，会自动转化为指向函数的指针 void test(bool pf(const string &, const string &)); //等价的定义 void test(bool (*pf)(const string &, const string &)); 如果函数返回指向函数的指针，那么必须显示的将返回类型指定为指针。","tags":"读书笔记","url":"https://xutree.github.io/pages/2018/10/09/C++_Primer_Chapter_6/"},{"title":"回车与换行的区别","text":"转载自： 这里 关于换行和回车其实平时我们不太在意，所以关于两者的区别也不太清楚，在平时开发时可能会遇到一些文件处理的问题，放到不同的操作系统上出现各种坑。那么回车和换行到底有哪些区别呢？今天咱们就来总结一下。 1. 由来 在计算机还没有出现之前，有一种叫做电传打字机（Teletype Model 33）的机械打字机，每秒钟可以打10个字符。但是它有一个问题，就是打完一行换行的时候，要用去0.2秒，正好可以打两个字符。要是在这0.2秒里面，又有新的字符传过来，那么这个字符将丢失。 于是，研制人员想了个办法解决这个问题，就是在每行后面加两个表示结束的字符。一个叫做\"回车\"，告诉打字机把打印头定位在左边界，不卷动滚筒；另一个叫做\"换行\"，告诉打字机把滚筒卷一格，不改变水平位置。 这就是\"换行\"和\"回车\"的由来。 2. 使用 后来，计算机发明了，这两个概念也就被般到了计算机上。那时，存储器很贵，一些科学家认为在每行结尾加两个字符太浪费了，加一个就可以。于是，就出现了分歧。 回车 \\r 本义是光标重新回到本行开头，r 的英文 return，控制字符可以写成 CR ，即 Carriage Return。 换行 \\n 本义是光标往下一行（不一定到下一行行首），n 的英文 newline，控制字符可以写成 LF ，即 Line Feed。 符号 ASCII 码 意义 \\n 10 换行 LF \\r 13 回车 CR 在不同的操作系统这几个字符表现不同，比如在 WIN 系统下，这两个字符就是表现的本义，在 UNIX 类系统，换行 \\n 就表现为光标下一行并回到行首，在 MAC 上， \\r 就表现为回到本行开头并往下一行，至于 ENTER 键的定义是与操作系统有关的。通常用的 Enter 是两个加起来。 不同操作系统下的含义： \\n ：UNIX 系统行末结束符 \\n\\r ：window 系统行末结束符 \\r ：MAC OS 系统行末结束符 我们经常遇到的一个问题就是，Unix/Mac 系统下的文件在 Windows 里打开的话，所有文字会变成一行；而 Windows 里的文件在 Unix/Mac 下打开的话，在每行的结尾可能会多出一个 &#94;M 符号。 3. 软回车和硬回车 硬回车就是普通我们按回车产生的，它在换行的同时也起着段落分隔的作用。 软回车是用 Shift + Enter 产生的，它换行，但是并不换段，即前后两段文字在 Word 中属于同一\"段\"。在应用格式时你会体会到这一点。 软回车能使前后两行的行间距大幅度缩小，因为它不是段落标记，要和法定的段落标记——硬回车区别出来。硬回车的 html 代码是 <p>..</p> ，段落的内容就夹在里面，而软回车的代码很精悍： <br> 。网页的文字如果复制到 word 中，则硬回车变为弯曲的箭头，软回车变为向下的箭头。","tags":"趣闻","url":"https://xutree.github.io/pages/2018/10/09/回车与换行的区别/"},{"title":"C++ Primer 第五章 语句","text":"5.1 空语句 使用空语句时应该加上注释，从而令读这段代码的知道该语句是有意省略的。 5.2 悬垂 else C++ 规定 else 与离它最近的尚未匹配的 if 匹配。 5.3 switch 语句 switch 语句中的 case 标签必须是 整型常量表达式 或者 可以转换成整型常量表达式的类型 。 如果某个 case 标签匹配成功，将从该标签处开始往后顺序执行所有 case 分支，除非程序显示的中断了这一过程，否则直到 switch 结尾处才停下来。在大多说情况下，在下一个 case 标签之前应该有一条 break 语句用于中断。 标签不应该孤零零的出现，它后面必须跟上一条语句或者另一个 case 标签。如果 switch 结构以一个空的 default 标签作为结束，则该 default 标签后面必须跟上一条空语句或一个空块。 不允许跨过变量的初始化语句直接跳转到该变量作用域内的另一个位置。 5.4 范围 for 在范围 for 语句中，预存了 end() 的值，一旦程序中添加（删除）元素， end 函数的值就可能变得无效，所以不能通过范围 for 语句增加或删除容器的元素。 5.5 do while 语句 应该在括号包围起来的条件后面用一个分号表示语句结束。 5.6 跳转语句 5.6.1 break 语句 break 语句负责终止离它最近的 while 、 do while 、 for 或 switch 语句，并从这些语句之后的第一条语句开始继续执行。 break 语句只能出现在迭代语句或者 switch 语句内部（包括嵌套在此类循环里的语句或块的内部）。 break 语句的作用范围仅限于最近的循环或者 switch 。 5.6.2 continue 语句 continu e语句终止最近的循环中的当前迭代并立即开始下一次迭代。 continue 语句只能出现在 for 、 while 和 do while 的循环的内部，或者嵌套在此类循环里的语句或块的内部。 和 break 语句类似的是，出现在嵌套循环中的 continue 语句也仅作用于离它最近的循环。 和 break 语句不同的是，只有当 switch 语句嵌套在迭代语句内部时，才能在 switch 里使用 continue 。 5.6.3 goto 语句 goto 语句的作用是从 goto 语句无条件跳转到同一函数内的另一条语句。 goto 语句和控制权转向的那条带标签的语句必须位于同一函数之内。 5.7 异常处理 5.7.1 throw 表达式 异常检测部分使用 throw 表达式来表示它遇到了无法处理的问题。我们说 throw 引发了异常，例如： throw runtime_error(\"Data must refer to same ISBN\"); 5.7.2 try 语句块 异常处理部分使用 try 语句处理异常。 try 语句块以关键字 try 开始，并以一个或多个 catch 字句结束。 try 语句块中代码抛出的异常通常会被某个catch字句处理，这些字句称为异常处理代码。 try{ program-statements } catch (exception-declaration) { handler-statements } catch (exception-declaration) { handler-statements } 跟在 try 块之后的是一个或多个 catch 子句。 catch 子句包括三个部分： 关键字 catch 括号内一个（可能未命名的）对象的声明（称作异常声明） 一个块 try 语句块中 program-statements 组成程序的正常逻辑，像其他任何块一样，可以有包含声明在内的任意 C++ 语句。 try 语句块内声明的变量在块外部无法访问，特别是在 catch子 句内也无法访问。 函数在寻找代码处理的过程中退出，如果最终没能找到任何匹配的 catch 子句，程序转到名为 terminate 的标准库函数。该函数的行为与系统有关，一般情况下，执行该函数将导致程序非正常退出。 5.7.3 标准异常 C++ 标准库定义了一组类，用于报告标准库函数遇到的问题，这些异常类也可以在用户别写的程序中使用，它们分别定义在4个头文件中： 5.7.4 exception 头文件 定义了最通用的异常类 exception 。它只报告异常的发生，不提供任何异常信息 5.7.5 stdexcept 头文件定义了几种常见的异常类 异常类 解释 exception 最常见的问题 runtime_error 只有在运行时才能检测出的问题 range_error 运行时错误：生成的结果超出了有意义的值域范围 overflow_error 运行时错误：计算上溢 underflow_error 运行时错误：计算下溢 logic_error 程序逻辑错误 domain_error 逻辑错误：参数对应的结果值不存在 invalid_argument 逻辑错误：无效参数 length_error 逻辑错误：试图创建一个超出该类型最大长度的对象 out_of_range 逻辑错误：使用一个超出有效范围的值 5.7.6 new 头文件 定义了 bad_alloc 异常类型 5.7.7 type_info 头文件 定义了 bad_cast 异常类型 标准异常库只定义了几种运算，包括创建和拷贝异常类型的对象，以及为异常类型的对象赋值。我们只能以默认初始化的方式初始化 exception 、 bad_alloc 和 bad_cas t对象，不允许为这些对象提供初始值。 其他异常类型的行为则刚好相反。应该使用 string 对象或者 C 风格字符串初始化这些类型的对象，但是不允许使用默认初始化的方式。当创建此类对象时，必须提供初始值，该初始值含有错误相关的信息。 异常类型只定义了一个名为 what 的成员函数，该函数没有任何参数，返回值是一个指向 C 风格字符串的 const char * 。该字符串的目的是提供关于异常的一些文本信息。 what 函数返回的 C 风格字符串的内容与异常对象的类型有关。如果异常类型只有一个字符串初始值，则 what 返回该字符串。对于其他无初始值的异常类型来说， what 返回的内容由编译器决定。","tags":"读书笔记","url":"https://xutree.github.io/pages/2018/10/09/C++_Primer_Chapter_5/"},{"title":"几个奇葩的 Linux 命令","text":"Linux 中有一些很奇葩的命令，可能你的发行版默认没有安装，你可以自己安装： [me@linuxbox ~]$ apt-get install 命令 (Debian) [me@linuxbox ~]$ yum install 命令 (Red Hat） [me@linuxbox ~]$ brew install 命令 （Mac） 1. rev rev 命令反转输入的内容（来自文件或者标准输入或者管道）： [me@linuxbox ~]$ echo Hello, World! | rev !dlroW ,olleH 2. tac cat 命令的反写，执行效果也和 cat 相反，即，将文件列表中的每一个文件输出到标准输出，行号大的优先。 3. sl 你可能知道命令 ls ,并经常使用它来查看文件夹的内容。但是由于错误输入有时会导致 sl ，如何在终端获得一点乐趣而不是\"command not found\"？ sl 命令！ 当你把 ls 错误打成 sl 时，一辆蒸汽机车（ s team l ocomotive）会在屏幕上驶过... 4. yes yes命令将进入一个循环，一遍又一遍地重复相同的字符串。默认重复\"y\"，你可以指定其他字符串。 [me@linuxbox ~]$ yes \"这是一个测试\" 这是一个测试 这是一个测试 这是一个测试 这是一个测试 这是一个测试 这是一个测试 这是一个测试 利用 Ctrl C 终止。 5. cowsay 屏幕上会出现一只 ASCII 码拼成的奶牛。。。你可以指定奶牛要说的话。这个命令还有其他版本，如 xcowsay ， cowthink 。 6. figlet 这个算不上奇葩，他它利用 ASCII 码拼成你输出\b字符串的横幅，而且有许多参数可以定制。还有个 toilet 命令和 figlet 很类似。比如， figlet good ： 7. fortune 会显示你的未来（ 😆 )。可以试试： [me@linuxbox ~]$ fortune | cowsay 8. cmatrix 会像《黑客帝国》里那样显示\b。 9. Fork 炸弹 [me@linuxbox ~]$ :(){ :|:& }: 不要尝试不要尝试不要尝试... 10. asciiquarium 水族馆 11. lolcat lolcat 可以在终端产生彩虹。 lolcat 是一个 RubyGem 因此它必须有你的系统上安装了 Ruby 的最新版本。利用文章开头部分的方法安装好 lolcat 后，在终端执行 gem install lolcat 安装。 [me@linuxbox ~]$ git log -1 | cowsay -f dragon-and-cow | lolcat lolcat 接受管道输入，所以你可以试试： [me@linuxbox ~]$ sl | lolcat","tags":"趣闻","url":"https://xutree.github.io/pages/2018/10/08/几个奇葩的Linux命令/"},{"title":"剑指 offer (2)","text":"1. 整数中 1 出现的次数 求出 1~13 的整数中 1 出现的次数，并算出 100~1300 的整数中 1 出现的次数？为此他特别数了一下 1~13 中包含 1 的数字有 1、10、11、12、13 因此共出现 6 次，但是对于后面问题他就没辙了。ACMer 希望你们帮帮他，并把问题更加普遍化，可以很快的求出任意非负整数区间中 1 出现的次数（从 1 到 \\(n\\) 中 1 出现的次数）。 class Solution { public : int NumberOf1Between1AndN_Solution ( int n ) { long count = 0 , i = 1 ; long before = 0 , current = 0 , after = 0 ; while ( n / i != 0 ) { before = n / ( i * 10 ); current = ( n / i ) % 10 ; after = n - ( n / i ) * i ; if ( current > 1 ) count += before * i + i ; else if ( current == 0 ) count += before * i ; else if ( current == 1 ) count += before * i + after + 1 ; i *= 10 ; } return count ; } }; 2. 把数组排成最小的数 输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组 {3，32，321}，则打印出这三个数字能排成的最小数字为 321323。 // #include <sstream> template < class T > string ToString ( const T & t ) { ostringstream oss ; // 创建一个流 oss << t ; // 把值传递如流中 return oss . str (); // 获取转换后的字符转并将其写入 result } class Solution { public : /// 比较函数 // 我们比较的不是两个字符串本身的大小，而是他们拼接后的两个数字的大小 static bool Compare ( const string & left , const string & right ) { string leftright = left + right ; string rightleft = right + left ; return leftright < rightleft ; } string PrintMinNumber ( vector < int > numbers ) { string res = \"\" ; string str ; vector < string > strNum ; /// 将整数转换成字符串 for ( unsigned int i = 0 ; i < numbers . size (); i ++ ) { str = ToString ( numbers [ i ]); strNum . push_back ( str ); } /// 对字符串按照拼接后的大小进行排序 // #include <algorithm> sort ( strNum . begin (), strNum . end (), Compare ); /// 拼接结果 for ( unsigned int i = 0 ; i < strNum . size (); i ++ ) res += strNum [ i ]; return res ; } }; 3. 丑数 把只包含质因子 2、3 和 5的数称作丑数（Ugly Number）。例如 6、8 都是丑数，但 14 不是，因为它包含质因子 7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第 \\(N\\) 个丑数。 class Solution { // 自己添加 protected : int ugly [ 10000 ]; int min ( int a , int b , int c ) { int temp = ( a < b ? a : b ); return ( temp < c ? temp : c ); } public : int GetUglyNumber_Solution ( int index ) { ugly [ 0 ] = 1 ; int index2 = 0 ; int index3 = 0 ; int index5 = 0 ; int n = 1 ; while ( n < index ) { //竞争产生下一个丑数 int val = min ( ugly [ index2 ] * 2 , ugly [ index3 ] * 3 , ugly [ index5 ] * 5 ); if ( val == ugly [ index2 ] * 2 ) //将产生这个丑数的index*向后挪一位； ++ index2 ; if ( val == ugly [ index3 ] * 3 ) //这里不能用elseif，因为可能有两个最小值，这时都要挪动； ++ index3 ; if ( val == ugly [ index5 ] * 5 ) ++ index5 ; ugly [ n ++ ] = val ; } int result = ugly [ index - 1 ]; return result ; } }; 4. 第一个只出现一次的字符 在一个字符串（0<= 字符串长度 <= 10000，全部由字母组成）中\b找到第一个只出现一次的字符，并返回它的位置，如果没有则返回 -1（需要区分大小写）。 class Solution { public : int FirstNotRepeatingChar ( string str ) { int x [ 26 ] = { 0 }, y [ 26 ] = { 0 }; for ( unsigned int i = 0 ; i < str . size (); i ++ ) { // 小写字母 if ( 'a' <= str [ i ] && str [ i ] <= 'z' ) { if ( x [ str [ i ] - 'a' ] == 0 ) { // 首次出现保存出现位置 x [ str [ i ] - 'a' ] = i + 1 ; } else { // 出现多次, 就置标识-1 x [ str [ i ] - 'a' ] = - 1 ; } } else if ( 'A' <= str [ i ] && str [ i ] <= 'Z' ) { if ( y [ str [ i ] - 'A' ] == 0 ) { // 首次出现保存出现位置 y [ str [ i ] - 'A' ] = i + 1 ; } else { // 出现多次, 就置标识-1 y [ str [ i ] - 'A' ] = - 1 ; } } } // 由于标识数组中 // 只出现一次的字符会存储出\b现的位置 // 出现多次的字符就存储标识-1 // 因此查找数组中非-1的最小值即可 int res = INT_MAX ; for ( int i = 0 ; i < 26 ; ++ i ) { if ( x [ i ] != 0 && x [ i ] != - 1 ) { res = min ( res , x [ i ]); } if ( y [ i ] != 0 && y [ i ] != - 1 ) { res = min ( res , y [ i ]); } } return res > str . size () ? - 1 : res - 1 ; } }; 5. 数组中的逆序对 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数 \\(P\\) 。并将 \\(P\\) 对 1000000007 取模的结果输出。 即输出 P % 1000000007 。 class Solution { public : int InversePairs ( vector < int > data ) { if ( data . size () == 0 ) return 0 ; vector < int > temp ( data . size ()); long long sum = CountMergePairs ( data , 0 , data . size () - 1 , temp ); return sum % 1000000007 ; } long long CountMergePairs ( vector < int > & data , int start , int end , vector < int > & temp ) { long long PairsNum = 0 ; if ( start < end ) { int mid = ( start + end ) / 2 ; PairsNum += CountMergePairs ( data , start , mid , temp ); //统计左边子数组的逆序对 PairsNum += CountMergePairs ( data , mid + 1 , end , temp ); //统计右边子数组的逆序对 PairsNum += MergePairsBetweenArray ( data , start , mid , end , temp ); //统计左右子数组间的逆序对 } return PairsNum ; } long long MergePairsBetweenArray ( vector < int > & data , int start , int mid , int end , vector < int > & temp ) { int i = start ; int j = mid + 1 ; int k = 0 ; //辅助数组的最后一位 long long count = 0 ; //设置两个指针i,j分别从右往左依次比较， //将较大的依次放入辅助数组的右边 while ( i <= mid && j <= end ) { if ( data [ i ] > data [ j ]) { count += mid - i + 1 ; temp [ k ++ ] = data [ j ++ ]; } else temp [ k ++ ] = data [ i ++ ]; } //将其中一个数组中还剩下的元素拷贝到辅助数组中， //两个循环只会执行其中的一个 while ( i <= mid ) temp [ k ++ ] = data [ i ++ ]; while ( j <= end ) temp [ k ++ ] = data [ j ++ ]; //从辅助数组中将元素拷贝到原数组中，使其有序排列 for ( i = 0 ; i < k ; i ++ ) data [ start + i ] = temp [ i ]; return count ; } }; 6. 两个链表的第一个公共结点 输入两个链表，找出它们的第一个公共结点。 /* struct ListNode { int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) { } };*/ class Solution { public : ListNode * FindFirstCommonNode ( ListNode * pHead1 , ListNode * pHead2 ) { unordered_map < ListNode * , bool > umap ; ListNode * left = pHead1 ; while ( left != NULL ) { umap . insert ( make_pair ( left , 1 )); left = left -> next ; } ListNode * right = pHead2 ; while ( right ) { if ( umap . count ( right ) > 0 ) { return right ; } right = right -> next ; } return NULL ; } }; 7. 数字在排序数组中出现的次数 统计一个数字在排序数组中出现的次数。 class Solution { public : int GetNumberOfK ( vector < int > data , int k ) { if ( data . size () == 0 ) return 0 ; int index = BinarySearch ( data , 0 , data . size () - 1 , k ); int i , res = 0 ; if ( index != - 1 ) { for ( i = index ; i < data . size (); i ++ ) { if ( data [ i ] == k ) res ++ ; else break ; } for ( i = index - 1 ; i >= 0 ; i -- ) { if ( data [ i ] == k ) res ++ ; else break ; } } return res ; } int BinarySearch ( vector < int > & data , int low , int high , int k ) { int mid ; while ( low <= high ) { mid = ( low + high ) / 2 ; if ( data [ mid ] > k ) high = mid - 1 ; else if ( data [ mid ] < k ) low = mid + 1 ; else return mid ; } return - 1 ; } }; 8. 二叉树的深度 输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { } };*/ class Solution { public : int TreeDepth ( TreeNode * pRoot ) { return TreeDepthRecursion ( pRoot ); } int TreeDepthRecursion ( TreeNode * root ) { if ( root == NULL ) { return 0 ; } else { int leftDepth = TreeDepthRecursion ( root -> left ); int rightDepth = TreeDepthRecursion ( root -> right ); return max ( leftDepth , rightDepth ) + 1 ; } } }; 9. 平衡二叉树 输入一棵二叉树，判断该二叉树是否是平衡二叉树。 class Solution { public : bool IsBalanced_Solution ( TreeNode * pRoot ) { if ( pRoot == NULL ) return true ; //int leftDepth = TreeDepth(pRoot->left); //int rightDepth = TreeDepth(pRoot->right); //if(fabs(leftDepth - rightDepth) <= 1) // return IsBalanced_Solution(pRoot->left) && IsBalanced_Solution(pRoot->right); //else // return false; int depth = 0 ; return IsVALWithDepth ( pRoot , & depth ); } int TreeDepth ( TreeNode * root ) { if ( root == NULL ) return 0 ; int leftDepth = TreeDepth ( root -> left ); int rightDepth = TreeDepth ( root -> right ); // 返回左右子树中深度最深的 return max ( leftDepth , rightDepth ) + 1 ; } bool IsVALWithDepth ( TreeNode * root , int * depth ) { if ( root == NULL ) { * depth = 0 ; return true ; } int leftDepth , rightDepth ; bool left = IsVALWithDepth ( root -> left , & leftDepth ); bool right = IsVALWithDepth ( root -> right , & rightDepth ); if ( left == true && right == true ) { if ( fabs ( leftDepth - rightDepth ) <= 1 ) { * depth = max ( leftDepth , rightDepth ) + 1 ; return true ; } } return false ; } }; 思路 ：1. 首先得到二叉树的深度\b，然后递归的判断每个节点的左右子树是否满足平衡条件；2. 这个递归法有很大缺陷，在求该结点的的左右子树深度时遍历一遍树，再次判断子树的平衡性时又遍历一遍树结构，造成遍历多次。我们在递归的过程中用 depth 来保存层数，然后递归的过程中同步遍历。 10. 只出现一次的数字 一个整型数组里除了两个数字之外，其他的数字都出现了偶数次。请写程序找出这两个只出现一次的数字。 class Solution { public : void FindNumsAppearOnce ( vector < int > data , int * num1 , int * num2 ) { // 注意星号！！！ * num1 = * num2 = 0 ; if ( data . size () < 2 ) return ; int i , len = data . size (); int XOR = data [ 0 ]; for ( i = 1 ; i < len ; i ++ ) XOR &#94;= data [ i ]; int flag = XOR & ( - XOR ); for ( i = 0 ; i < len ; i ++ ) { // 注意加括号，先算术运算，后移位运算，最后位运算。 if (( data [ i ] & flag ) == flag ) * num1 &#94;= data [ i ]; else * num2 &#94;= data [ i ]; } return ; } }; 11. 和为 \\(S\\) 的连续正数序列 小明很喜欢数学,有一天他在做数学作业时,要求计算出 9~16 的和,他马上就写出了正确答案是 100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为 100（至少包括两个数）。没多久,他就得\b到另一组连续正数和为 100 的序列：18，19，20，21，22。现在把问题交给你,你能不能也很快的找出所有和为 \\(S\\) 的连续正数序列? Good Luck! class Solution { public : vector < vector < int > > FindContinuousSequence ( int sum ) { int l , r , s ; vector < vector < int >> res ; for ( l = 1 , r = 2 ; l < ( sum + 1 ) / 2 && r < sum ; ) { s = ( r - l + 1 ) / 2.0 * ( l + r ); if ( s < sum ) r ++ ; else if ( s > sum ) l ++ ; else { vector < int > temp ; for ( int i = l ; i <= r ; i ++ ) { temp . push_back ( i ); } res . push_back ( temp ); l ++ ; } } return res ; } }; 思路 ：滑动窗口法。 12. 和为 \\(S\\) 的两个数字 输入一个递增排序的数组和一个数字 \\(S\\) ，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于 \\(S\\) ，输出两个数的乘积最小的。 class Solution { public : vector < int > FindNumbersWithSum ( vector < int > array , int sum ) { vector < int > res ; if ( array . size () < 2 ) return res ; int l = 0 , r = array . size () - 1 ; for (; l < ( sum + 1 ) / 2 && l < r ; ) { if ( array [ l ] + array [ r ] == sum ) { res . push_back ( array [ l ]); res . push_back ( array [ r ]); return res ; } else if ( array [ l ] + array [ r ] > sum ) { r -- ; } else { l ++ ; } } return res ; } }; 思路 ：从两端开始查找，距离越远积越小。 13. 左旋转字符串 汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列 \\(S\\) ，请你把其循环左移 \\(K\\) 位后的序列输出。例如，字符序列 \\(S=abcXYZdef\\) ，要求输出循环左移 3 位后的结果，即 \\(XYZdefabc\\) 。是不是很简单？OK，搞定它。 class Solution { public : string LeftRotateString ( string str , int n ) { if ( str . size () == 0 ) return \"\" ; // 不修改原字符串 string res ( str ); if ( n > str . size ()) n %= str . size (); for ( int i = 0 ; i < str . size (); i ++ ) res [ i ] = str [( i + n ) % str . size ()]; return res ; } }; 14. 翻转单词顺序列 牛客最近来了一个新员工 Fish，每天早晨总是会拿着一本英文\b杂志，写些句子在本子上。同事 Cat 对 Fish 写的内容颇感兴趣，有一天他向 Fish 借来翻看，但却读不懂它的意思。例如，\"student. a am I\"。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是 \"I am a student.\"。Cat 对一一的翻转这些单词顺序可不在行，你能帮助他么？ class Solution { public : string ReverseSentence ( string str ) { if ( str . size () == 0 ) return str ; string res = \"\" , tmp = \"\" ; for ( unsigned int i = 0 ; i < str . size (); i ++ ) { if ( str [ i ] == ' ' ) // 发现一个单词 { res = \" \" + tmp + res ; // 顺序的拼接, 前面需要一个空格 tmp = \"\" ; } else { tmp += str [ i ]; } } if ( tmp . size () != 0 ) // 拼接最后一个单子, 前面无需空格 { res = tmp + res ; } return res ; } }; 思路 ：从后向前重新组装字符串。 15. 扑克牌顺子 LL 今天心情特别好，因为他去买了一副扑克牌，发现里面居然有 2 个大王，2 个小王（一副牌原本是 54 张）...他随机从中抽出了 5 张牌，想测测自己的手气，看看能不能抽到顺子，如果抽到的话，他决定去买体育彩票,嘿嘿！！他想了想，决定大小王可以看成任何数字，并且 A 看作 1，J 为 11，Q 为 12 K 为 13。现在，要求你使用这幅牌模拟上面的过程，然后告诉我们 LL 的运气如何，如果牌能组成顺子就输出 true，否则就输出 false。为了方便起见，你可以认为大小王是0。 # define BIT_GET ( number , pos ) (( number ) >> ( pos ) & 1 ) /// 用宏得到某数的某位 # define BIT_SET ( number , pos ) (( number ) |= 1 << ( pos )) /// 把某位置1 # define BIT_CLR ( number , pos ) (( number ) &= ~ ( 1 << ( pos ))) /// 把某位清0 # define BIT_CPL ( number , pos ) (( number ) &#94;= 1 << ( pos )) /// 把number的POS位取反 class Solution { public : bool IsContinuous ( vector < int > numbers ) { if ( numbers . size () != 5 ) return false ; int min = INT_MAX ; int max = INT_MIN ; int flag = 0 ; for ( int i = 0 ; i < numbers . size (); i ++ ) { int num = numbers [ i ]; if ( num < 0 || num > 13 ) // 牌只能在0~13之间 return false ; else if ( num == 0 ) // 0用来答题任何牌，因此不能参与最大最小牌的比对 continue ; // 非0元素不能重复 if ( BIT_GET ( flag , num ) == 1 ) // 如果flag的第num位为1, 说明num重复 return false ; else BIT_SET ( flag , num ); // 将标识flag的第num位置为1 // 寻找最大最小的牌 if ( num > max ) max = num ; if ( num < min ) min = num ; // 如果最大值和最小值的差值大于4, 那么必应不能补齐 if ( max - min > 4 ) return false ; } return true ; } }; 思路 ：条件： 5张牌，顺子，除 0 之外不能重复。 结论： 非 0 元素的极差（最大值最小值的差）不超过 4， 非 0 元素不重复。 也可以排序后看 0 能不能填补空缺。 // 左移、右移 > 位运算 > 逻辑运算 #define BIT_GET(number, pos) ((number) >> (pos) & 1) /// 用宏得到某数的某位 #define BIT_SET(number, pos) ((number) |= 1 << (pos)) /// 把某位置1 #define BIT_CLR(number, pos) ((number) &= ~(1 << (pos))) /// 把某位清0 #define BIT_CPL(number, pos) ((number) &#94;= 1 << (pos)) /// 把number的POS位取反 16. 孩子们的游戏（圆圈中最后剩下的数） 每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友，今年亦是如此。HF 作为牛客的资深元老，自然也准备了一些小游戏。其中，有个游戏是这样的：首先，让小朋友们围成一个大圈。然后，他随机指定一个数 \\(m\\) ，让编号为 0 的小朋友开始报数。每次喊到 \\(m-1\\) 的那个小朋友要出列唱首歌，然后可以在礼品箱中任意的挑选礼物，并且不再回到圈中，从他的下一个小朋友开始,继续 0... \\(m-1\\) 报数....这样下去....直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的\"名侦探柯南\"典藏版(名额有限哦!)。请你试着想下，哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从 0 到 \\(n-1\\) )。 class Solution { public : int LastRemaining_Solution ( int n , int m ) { if ( n < 1 || m < 1 ) return - 1 ; int last = 0 ; for ( int step = 2 ; step <= n ; step ++ ) last = ( last + m ) % step ; return last ; } }; https://blog.csdn.net/fuxuemingzhu/article/details/79702974 17. 求 \\(1+2+3+...+n\\) 要求不能使用乘除法、for、while、if、else、switch、case 等关键字及条件判断语句（A?B:C）。 class Solution { public : int Sum_Solution ( int n ) { int ans = n ; n && ( ans += Sum_Solution ( n - 1 )); return ans ; } }; 18. 不用加减乘除做加法 写一个函数，求两个整数之和，要求在函数体内不得使用 +、-、*、/ 四则运算符号。 class Solution { public : int Add ( int num1 , int num2 ) { int temp ; while ( num2 != 0 ) { temp = num1 &#94; num2 ; // 计算不带进位的情况 num2 = ( num1 & num2 ) << 1 ; // 计算带进位的情况 num1 = temp ; // now num1 = 不带进位的情况, num2 = 带进位的情况 } return num1 ; } }; 19. 将一个字符串转换成一个整数 将一个字符串转换成一个整数（实现 Integer.valueOf(string) 的功能，但是 string 不符合数字要求时返回 0），要求不能使用字符串转换整数的库函数。 数值为 0 或者字符串不是一个合法的数值则返回 0。 class Solution { public : int StrToInt ( string str ) { string :: iterator pstr = str . begin (); // 排除前导的空格 while ( * pstr == ' ' ) // 排除前导的空格 pstr ++ ; bool minus = false ; // 判断符号位+ - if ( * pstr == '+' ) pstr ++ ; else if ( * pstr == '-' ) { pstr ++ ; minus = true ; } long long int value = 0 ; for ( ; pstr != str . end (); pstr ++ ) { if ( '0' <= * pstr && * pstr <= '9' ) { value *= 10 ; value += * pstr - '0' ; } else break ; // 解决OVER_FLOW的问题 // INT_MAX 2147483647 // INT_MIN -2147483648 minus = true // 负数绝对值最大为INT_MAX + 1 // 正数最大值为INT_MAX if (( minus == true && value > ( unsigned long )( INT_MAX ) + 1 ) || ( minus == false && value > INT_MAX )) break ; } if ( pstr != str . end ()) return 0 ; else { if ( minus == true ) value = - value ; if ( value >= INT_MAX ) value = INT_MAX ; else if ( value <= INT_MIN ) value = INT_MIN ; return ( int ) value ; } } }; 20. 数组中重复的数字 在一个长度为 \\(n\\) 的数组里的所有数字都在 0 到 \\(n-1\\) 的范围内。数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为 7 的数组 {2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字 2。 # define SET_SYMBOL_BIT ( num ) (( num ) |= ( 1 << 31 )) /* 设置符号位为1 */ # define GET_ORIGIN_NUM ( num ) (( num ) & ( ~ ( 1 << 31 ))) /* 获取到源数据 */ # define GET_SYMBOL_BIT ( num ) ((( num ) >> 31 ) & 1 ) /* 获取符号位(标识)*/ class Solution { public : // Parameters: // numbers: an array of integers // length: the length of array numbers // duplication: (Output) the duplicated number in the array number // Return value: true if the input is valid, and there are some duplications in the array number // otherwise false bool duplicate ( int numbers [], int length , int * duplication ) { * duplication = - 1 ; if ( CheckValidity ( numbers , length ) == false ) return false ; for ( int i = 0 ; i < length ; i ++ ) { // 当前数字numbers[i]的标识即是numbers[numbers[i]]的符号位 // 检查numbers[i] if ( GET_SYMBOL_BIT ( numbers [ GET_ORIGIN_NUM ( numbers [ i ])]) == 1 ) { * duplication = GET_ORIGIN_NUM ( numbers [ i ]); return true ; } else { SET_SYMBOL_BIT ( numbers [ GET_ORIGIN_NUM ( numbers [ i ])]); } } return false ; } bool CheckValidity ( int * numbers , int length ) { // 输入数据不合法 if ( numbers == NULL || length <= 0 ) return false ; // 元素必须\b在[0, n-1]的范围 for ( int i = 0 ; i < length ; i ++ ) if ( numbers [ i ] < 0 || numbers [ i ] > length - 1 ) return false ; return true ; } }; 思路 ：1. 排序后判断重复；2. 符号位标识法；3. 固定偏移法；4. 将元素放在自己该在的位置。 21. 构建乘积数组 给定一个数组 A[0,1,...,n-1]，请构建一个数组 B[0,1,...,n-1]，其中 B 中的元素 B[i]=A[0]*A[1]*...*A[i-1]*A[i+1]*...*A[n-1]。不能使用除法。 class Solution { public : vector < int > multiply ( const vector < int >& A ) { vector < int > B ( A . size ()); if ( A . size () == 0 ) return B ; for ( int i = 0 , temp = 1 ; i < A . size (); i ++ ){ B [ i ] = temp ; temp *= A [ i ]; } for ( int i = A . size () - 1 , temp = 1 ; i >= 0 ; i -- ) { B [ i ] *= temp ; temp *= A [ i ]; } return B ; } }; 22. 正则表达式匹配 请实现一个函数用来匹配包括'.'和'*'的正则表达式。模式中的字符'.'表示任意一个字符，而'*'表示它前面的字符可以出现任意次（包含 0 次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串 \"aaa\" 与模式 \"a.a\" 和 \"ab ac a\" 匹配，但是与 \"aa.a\" 和 \"ab*a\" 均不匹配。 class Solution { public : bool match ( char * str , char * pattern ) { /** * f[i][j]: if s[0..i-1] matches p[0..j-1] * if p[j - 1] != '*' * f[i][j] = f[i - 1][j - 1] && s[i - 1] == p[j - 1] * if p[j - 1] == '*', denote p[j - 2] with x * f[i][j] is true iff any of the following is true * 1) \"x*\" repeats 0 time and matches empty: f[i][j - 2] * 2) \"x*\" repeats >= 1 times and matches \"x*x\": s[i - 1] == x && f[i - 1][j] * '.' matches any single character */ int m = strlen ( str ), n = strlen ( pattern ); vector < vector < bool >> f ( m + 1 , vector < bool > ( n + 1 , false )); f [ 0 ][ 0 ] = true ; for ( int i = 1 ; i <= m ; i ++ ) f [ i ][ 0 ] = false ; // p[0.., j - 3, j - 2, j - 1] matches empty iff p[j - 1] // is '*' and p[0..j - 3] matches empty for ( int j = 1 ; j <= n ; j ++ ) f [ 0 ][ j ] = j > 1 && '*' == pattern [ j - 1 ] && f [ 0 ][ j - 2 ]; for ( int i = 1 ; i <= m ; i ++ ) for ( int j = 1 ; j <= n ; j ++ ) if ( pattern [ j - 1 ] != '*' ) f [ i ][ j ] = f [ i - 1 ][ j - 1 ] && ( str [ i - 1 ] == pattern [ j - 1 ] || '.' == pattern [ j - 1 ]); else // p[0] cannot be '*' so no need to check \"j > 1\" here f [ i ][ j ] = f [ i ][ j - 2 ] || ( str [ i - 1 ] == pattern [ j - 2 ] || '.' == pattern [ j - 2 ]) && f [ i - 1 ][ j ]; return f [ m ][ n ]; } }; 23. 表示数值的字符串 请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串 \"+100\"，\"5e2\"，\"-123\"，\"3.1416\" 和 \"-1E-16\" 都表示数值。 但是 \"12e\"，\"1a3.14\"，\"1.2.3\"，\"+-5\" 和 \"12e+4.3\" 都不是。 class Solution { public : bool isNumeric ( char * string ) { if ( string == NULL ) return false ; if ( * string == '+' || * string == '-' ) ++ string ; if ( * string == '\\0' ) return false ; bool res = true ; ScanDigits ( & string ); if ( * string != '\\0' ) { if ( * string == '.' ) { ++ string ; ScanDigits ( & string ); if ( * string == 'e' || * string == 'E' ) { res = IsExponential ( & string ); } } else if ( * string == 'e' || * string == 'E' ) { res = IsExponential ( & string ); } else { res = false ; } } return res && * string == '\\0' ; } void ScanDigits ( char ** string ) { while ( ** string != '\\0' && ( ** string >= '0' && ** string <= '9' )) { ++ ( * string ); } } bool IsExponential ( char ** string ) { ++ ( * string ); if ( ** string == '+' || ** string == '-' ) ++ ( * string ); if ( ** string == '\\0' ) return false ; ScanDigits ( string ); return ( ** string == '\\0' ) ? true : false ; } }; 思路 ： 1) 首先看第一个字符是不是正负号。 2) 如果是，在字符串上移动一个字符，继续扫描剩余的字符串中0到9的数位。 3) 如果是一个小数，则将遇到小数点。 4) 另外，如果是用科学计数法表示的数值，在整数或者小数的后面还有可能遇到\"e\"或者\"E\"。 24. 字符流中第一个只出现一次的字符 请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符\"go\"时，第一个只出现一次的字符是\"g\"。当从该字符流中读出前六个字符\"google\"时，第一个只出现一次的字符是\"l\"。 class Solution { public : Solution (){ str = \"\" ; // #include <cstring> memset ( count , 0 , sizeof ( count )); } //Insert one char from stringstream void Insert ( char ch ) { str += ch ; count [( int ) ch ] ++ ; } //return the first appearence once char in current stringstream char FirstAppearingOnce() { int len = str . size (); for ( int i = 0 ; i < len ; i ++ ) if ( count [( int ) str [ i ]] == 1 ) return str [ i ]; return '#' ; } private : string str ; int count [ 256 ]; }; 25. 链表中环入口 给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出 null。 /* struct ListNode { int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) { } }; */ class Solution { public : ListNode * EntryNodeOfLoop ( ListNode * pHead ) { if ( pHead == NULL ) return NULL ; ListNode * p1 = pHead , * p2 = pHead ; while ( p1 != NULL && p2 != NULL ) { p1 = p1 -> next ; p2 = p2 -> next ; if ( p2 == NULL ) return NULL ; p2 = p2 -> next ; if ( p1 == p2 ) break ; } p1 = pHead ; while ( p1 != p2 ) { p1 = p1 -> next ; p2 = p2 -> next ; } return p1 ; } }; 思路 ：双指针，第二个指针比第一个指针多走环节点整数倍。 26. 删除链表中重复的结点 在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表 1->2->3->3->4->4->5 处理后为 1->2->5 /* struct ListNode { int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) { } }; */ class Solution { public : ListNode * deleteDuplication ( ListNode * pHead ) { if ( pHead == NULL ) return NULL ; ListNode * phony = new ListNode ( - 1 ); phony -> next = pHead ; ListNode * p = pHead , * last = phony ; while ( p != NULL && p -> next != NULL ) { if ( p -> val == p -> next -> val ) { int val = p -> val ; while ( p != NULL && p -> val == val ) p = p -> next ; last -> next = p ; } else { last = p ; p = p -> next ; } } return phony -> next ; } }; 思路 ： 1) 我们每次都判断当前结点的值与下一个节点的值是否重复 2) 如果重复就循环寻找下一个不重复的节点，将他们链接新新链表的尾部（其实就是删除重复的节点） 27. 二叉树的下一个结点 给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 /* struct TreeLinkNode { int val; struct TreeLinkNode *left; struct TreeLinkNode *right; struct TreeLinkNode *next; TreeLinkNode(int x) :val(x), left(NULL), right(NULL), next(NULL) { } }; */ class Solution { public : TreeLinkNode * GetNext ( TreeLinkNode * pNode ) { if ( pNode == NULL ) return NULL ; // 不要在局部函数内定义需要返回的变量，局部函数执行完就销毁了。 TreeLinkNode * Next = NULL ; if ( pNode -> right != NULL ) { TreeLinkNode * temp = pNode -> right ; while ( temp -> left != NULL ) { temp = temp -> left ; } Next = temp ; } else { TreeLinkNode * parent = pNode -> next ; TreeLinkNode * current = pNode ; while ( parent != NULL && current == parent -> right ) { current = parent ; parent = parent -> next ; } Next = parent ; } return Next ; } }; 思路 ： 1) 如果当前结点有右子树, 那么其中序遍历的下一个结点就是其右子树的最左结点 2) 如果当前结点没有右子树, 而它是其父结点的左子结点那么其中序遍历的下一个结点就是他的父亲结点 3) 如果当前结点没有右子树，而它还是其父结点的右子结点，这种情况下其下一个结点应该是当前结点所在的左子树的根, 因此我们可以顺着其父节点一直向上遍历, 直到找到一个是它父结点的左子结点的结点 28. 对称的二叉树 请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { } }; */ class Solution { public : bool isSymmetrical ( TreeNode * pRoot ) { if ( pRoot == NULL ) return true ; return isSymmetricalRecursion ( pRoot -> left , pRoot -> right ); } bool isSymmetricalRecursion ( TreeNode * pLeft , TreeNode * pRight ) { if ( pLeft == NULL && pRight == NULL ) return true ; if ( pLeft == NULL || pRight == NULL ) return false ; if ( pLeft -> val != pRight -> val ) return false ; // 左子树的左与右子树的右对称 // 左子树的右与右子树的左对称 return isSymmetricalRecursion ( pLeft -> left , pRight -> right ) && isSymmetricalRecursion ( pLeft -> right , pRight -> left ); } }; class Solution { public : bool isSymmetrical ( TreeNode * root ) { if ( root == NULL ) { return true ; } if ( root -> left == NULL && root -> right == NULL ) { return true ; } if (( root -> left == NULL && root -> right != NULL ) || ( root -> left != NULL && root -> right == NULL )) { return false ; } deque < TreeNode * > dq ; dq . push_front ( root -> left ); dq . push_back ( root -> right ); while ( dq . empty ( ) != true ) { TreeNode * lroot = dq . front (); TreeNode * rroot = dq . back (); dq . pop_front (); dq . pop_back (); if ( lroot -> val != rroot -> val ) { return false ; } if (( lroot -> right == NULL && rroot -> left != NULL ) || ( lroot -> right != NULL && rroot -> left == NULL )) { return false ; } if ( lroot -> right != NULL ) { dq . push_front ( lroot -> right ); dq . push_back ( rroot -> left ); } if (( lroot -> left == NULL && rroot -> right != NULL ) || ( lroot -> left != NULL && rroot -> right == NULL )) { return false ; } if ( lroot -> left != NULL ) { dq . push_front ( lroot -> left ); dq . push_back ( rroot -> right ); } } return true ; } }; 29. 按照之字形打印二叉树 请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { } }; */ class Solution { public : vector < vector < int > > Print ( TreeNode * pRoot ) { vector < vector < int >> ret ; if ( pRoot == NULL ) return ret ; vector < int > curr ; deque < TreeNode *> deq ; deq . push_back ( NULL ); //层分隔符 deq . push_back ( pRoot ); bool leftToRight = true ; while ( deq . size () != 1 ){ TreeNode * node = deq . front (); deq . pop_front (); if ( node == NULL ) // 到达每层分隔符 { if ( leftToRight == true ) // 从前完后遍历 { deque < TreeNode *>:: iterator iter ; for ( iter = deq . begin (); iter != deq . end (); iter ++ ) curr . push_back (( * iter ) -> val ); } else // 从后往前遍历 { deque < TreeNode *>:: reverse_iterator riter ; for ( riter = deq . rbegin (); riter < deq . rend (); riter ++ ) curr . push_back (( * riter ) -> val ); } leftToRight = ! leftToRight ; ret . push_back ( curr ); curr . clear (); deq . push_back ( NULL ); //添加层分隔符 continue ; //一定要continue } if ( node -> left != NULL ) deq . push_back ( node -> left ); if ( node -> right != NULL ) deq . push_back ( node -> right ); } return ret ; } }; 30. 把二叉树打印出多行 从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { } }; */ class Solution { public : vector < vector < int > > Print ( TreeNode * pRoot ) { vector < vector < int >> res ; if ( pRoot == NULL ) return res ; vector < int > temp ; TreeNode * curr ; queue < TreeNode *> node ; node . push ( pRoot ); node . push ( NULL ); while ( node . empty () != true ) { curr = node . front (); node . pop (); if ( curr != NULL ) { temp . push_back ( curr -> val ); if ( curr -> left != NULL ) node . push ( curr -> left ); if ( curr -> right != NULL ) node . push ( curr -> right ); } else if ( node . empty () != true ) { res . push_back ( temp ); temp . clear (); node . push ( NULL ); } } if ( temp . size () != 0 ) res . push_back ( temp ); return res ; } }; 31. 序列化二叉树 请实现两个函数，分别用来序列化和反序列化二叉树。 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { } }; */ class Solution { public : /* 序列化二叉树 */ char * Serialize ( TreeNode * root ){ if ( root == NULL ){ char * serial = new char [ 3 ]; strcpy ( serial , \"#,\" ); return serial ; } string str ; Serialize ( root , str ); const char * c_str = str . c_str (); char * serial = new char [ str . length () + 1 ]; strcpy ( serial , c_str ); return serial ; } TreeNode * Deserialize ( char * str ) { if ( str == NULL || * str == '\\0' ) return NULL ; int index = 0 ; return Deserialize ( str , index ); } private : void Serialize ( TreeNode * root , string & str ) { if ( root == NULL ) { str += \"#,\" ; return ; } /* 先序遍历的方式, 序列化二叉树 */ str += ( toString ( root -> val ) + \",\" ); Serialize ( root -> left , str ); Serialize ( root -> right , str ); } /* 反序列化二叉树 * 将一个序列化的字符串转换成二叉树 */ TreeNode * Deserialize ( char * str , int & index ) { if ( str [ index ] == '#' ) { index += 2 ; return NULL ; } /* 获取到节点的数字权值 */ int num = 0 ; while ( str [ index ] != ',' && str [ index ] != '\\0' ){ num = num * 10 + ( str [ index ] - '0' ); index ++ ; } index ++ ; TreeNode * root = new TreeNode ( num ); root -> left = Deserialize ( str , index ); root -> right = Deserialize ( str , index ); return root ; } string toString ( int num ) { stringstream ss ; ss << num ; return ss . str (); } }; 32. 二叉搜索树的第 \\(k\\) 个结点 给定一棵二叉搜索树，请找出其中的第 \\(k\\) 小的结点。例如，（5，3，7，2，4，6，8） 中，按结点数值大小顺序第三小结点的值为 4。 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { } }; */ class Solution { private : unsigned int count = 0 ; public : TreeNode * KthNode ( TreeNode * pRoot , int k ) { if ( pRoot == NULL ) return NULL ; TreeNode * ret = NULL ; if (( ret = KthNode ( pRoot -> left , k )) != NULL ) return ret ; ++ count ; if ( count == k ) return pRoot ; if (( ret = KthNode ( pRoot -> right , k )) != NULL ) return ret ; return NULL ; } }; 33. 数据流中的中位数 如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用 Insert() 方法读取数据流，使用 GetMedian() 方法获取当前读取数据的中位数。 class Solution { private : vector < int > m_min ; // 后半部分数据 vector < int > m_max ; // 前半部分数据 protected : void MakeHeapify ( vector < int > & a , int start , int end , int flag ) { int dad = start ; int son = 2 * dad + 1 ; // 最大堆 if ( flag == 1 ) { while ( son <= end ) { if ( son + 1 <= end && a [ son + 1 ] > a [ son ]) son ++ ; if ( a [ dad ] >= a [ son ]) return ; else { swap ( a [ dad ], a [ son ]); dad = son ; son = dad * 2 + 1 ; } } } // 最小堆 if ( flag == 0 ) { while ( son <= end ) { if ( son + 1 <= end && a [ son + 1 ] < a [ son ]) son ++ ; if ( a [ dad ] < a [ son ]) return ; else { swap ( a [ dad ], a [ son ]); dad = son ; son = dad * 2 + 1 ; } } } } void swap ( int & a , int & b ) { if ( a != b ) { a &#94;= b ; b &#94;= a ; a &#94;= b ; } } public : void Insert ( int num ) { int temp = num ; // 偶数时，假设最大堆比最小堆少1 关系 > 逐位运算 if ((( m_min . size () + m_max . size ()) & 1 ) == 0 ) { if ( m_max . size () > 0 && num < m_max [ 0 ]) { swap ( m_max [ 0 ], temp ); MakeHeapify ( m_max , 0 , m_max . size () - 1 , 1 ); } m_min . push_back ( temp ); MakeHeapify ( m_min , 0 , m_min . size () - 1 , 0 ); } else { if ( m_min . size () > 0 && num > m_min [ 0 ]) { swap ( m_min [ 0 ], temp ); MakeHeapify ( m_min , 0 , m_min . size () - 1 , 0 ); } m_max . push_back ( temp ); MakeHeapify ( m_max , 0 , m_max . size () - 1 , 1 ); } } double GetMedian() { int size = m_min . size () + m_max . size (); if ( size == 0 ) return - 1 ; double median = 0 ; if (( size & 1 ) != 0 ) median = ( double ) m_min [ 0 ]; else median = ( double ) ( m_max [ 0 ] + m_min [ 0 ]) / 2 ; return median ; } }; 34. 滑动窗口的最大值 给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。 class Solution { public : vector < int > maxInWindows ( const vector < int >& num , unsigned int size ) { vector < int > res ; deque < int > index ; for ( unsigned int i = 0 ; i < num . size (); i ++ ) { /* 从后面依次弹出队列中比当前num值小的元素， * 同时也能保证队列首元素为当前窗口最大值下标 */ while ( index . size () != 0 && num [ index . back ()] <= num [ i ]) index . pop_back (); /* 当前窗口移出队首元素所在的位置 即队首元素坐标对应的num不在窗口中，需要弹出 */ while ( index . size () && i - index . front () + 1 > size ) index . pop_front ( ); /* 把每次滑动的num下标加入队列 */ index . push_back ( i ); /* 当滑动窗口首地址i大于等于size时才开始写入窗口最大值 */ if ( size != 0 && i + 1 >= size ) res . push_back ( num [ index . front ()]); } return res ; } }; 35. 矩阵中的路径 请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。 例如 a b c e s f c s a d e e 这样的3 X 4 矩阵中包含一条字符串\"bcced\"的路径，但是矩阵中不包含\"abcb\"路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。 class Solution { public : bool hasPath ( char * matrix , int rows , int cols , char * str ) { if ( matrix == NULL || rows < 1 || cols < 1 || str == NULL ) return false ; //定义一个辅助矩阵，用来标记路径是否已经进入了每个格子 bool * visited = new bool [ rows * cols ]; memset ( visited , 0 , rows * cols ); int pathLength = 0 ; //该循环是为了实现从任何一个位置出发，寻找路径 for ( int row = 0 ; row < rows ; ++ row ) { for ( int col = 0 ; col < cols ; ++ col ) { if ( hasPathCore ( matrix , rows , cols , row , col , str , pathLength , visited )) return true ; } } delete [] visited ; return false ; } /*此函数用来判断在当前路径满足条件下，相邻格子中是否存在一个格子满足条件*/ bool hasPathCore ( char * matrix , int rows , int cols , int row , int col , char * str , int & pathLength , bool * visited ) { if ( str [ pathLength ] == '\\0' ) return true ; bool hasPath = false ; if ( row >= 0 && row < rows && col >= 0 && col < cols && matrix [ row * cols + col ] == str [ pathLength ] && ! visited [ row * cols + col ]) { ++ pathLength ; visited [ row * cols + col ] = true ; /*如果矩阵格子(row,col)与路径字符串中下标为pathLength的字符一样时， 从它的4个相邻格子中寻找与路径字符串下标为pathLength+1的字符相等的格子*/ hasPath = hasPathCore ( matrix , rows , cols , row , col - 1 , str , pathLength , visited ) || hasPathCore ( matrix , rows , cols , row - 1 , col , str , pathLength , visited ) || hasPathCore ( matrix , rows , cols , row , col + 1 , str , pathLength , visited ) || hasPathCore ( matrix , rows , cols , row + 1 , col , str , pathLength , visited ); if ( ! hasPath ) { //如果没找到，则说明当前第pathLength个字符定位不正确，返回上一个位置重新定位 -- pathLength ; visited [ row * cols + col ] = false ; } } return hasPath ; } }; 37. 机器人的运动范围 地上有一个 \\(m\\) 行和 \\(n\\) 列的方格。一个机器人从坐标 (0,0) 的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于 \\(k\\) 的格子。 例如，当 \\(k\\) 为 18 时，机器人能够进入方格（35,37），因为 3+5+3+7 = 18。但是，它不能进入方格（35,38），因为 3+5+3+8 = 19。请问该机器人能够达到多少个格子？ class Solution { public : int movingCount ( int threshold , int rows , int cols ) { bool * visited = new bool [ rows * cols ]; memset ( visited , 0 , rows * cols ); int count = movingCountCore ( threshold , rows , cols , 0 , 0 , visited ); delete [] visited ; return count ; } int movingCountCore ( int threshold , int rows , int cols , int row , int col , bool * visited ) { int count = 0 ; if ( check ( threshold , rows , cols , row , col , visited )) { visited [ row * cols + col ] = true ; count = 1 + movingCountCore ( threshold , rows , cols , row , col - 1 , visited ) + movingCountCore ( threshold , rows , cols , row - 1 , col , visited ) + movingCountCore ( threshold , rows , cols , row , col + 1 , visited ) + movingCountCore ( threshold , rows , cols , row + 1 , col , visited ); } return count ; } /*该函数检查坐标为(row,col)的方格能够进入*/ bool check ( int threshold , int rows , int cols , int row , int col , bool * visited ) { if ( row >= 0 && row < rows && col >= 0 && col < cols && getDigitSum ( row ) + getDigitSum ( col ) <= threshold && ! visited [ row * cols + col ]) return true ; return false ; } /*计算一个数的所有位数之和*/ int getDigitSum ( int number ) { int sum = 0 ; while ( number > 0 ) { sum += number % 10 ; number = number / 10 ; } return sum ; } }; if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"读书笔记","url":"https://xutree.github.io/pages/2018/10/08/jzoffer2/"},{"title":"Linux 中的扩展和引用","text":"1. 扩展 当我们每次在命令行按下 Enter 键时，bash 会在执行命令之前对文本进行多重处理。产生这个结果的处理过程称为扩展（expansion）。 一个 🌰 : echo * 会将当前目录下所有的非隐藏文件名打印出来。 1.1 单词分隔 单词分隔会先查找是否存在空格、制表符以及换行，然后把它们作为单词的界定符（delimiter）。所以下面的命令后面跟着4个不同的参数： [me@linuxbox ~]$ echo this is a test this is a test 1.2 路径名扩展 通过使用通配符来实现扩展的\b机制称为路径名扩展（pathname expansion）。 1.3 波浪线扩展（~） 如果把它用在一个单词的开头，那么它将被扩展为指定用户的主目录名；如果没有指定用户名，则扩展为当前用户的主目录： [me@linuxbox ~]$ ech ~ /home/me [me@linuxbox ~]$ ech ~foo /home/foo 1.4 算术扩展 shell 支持通过扩展来运行算术表达式。这允许我们把 shell 提示符当做计算器来使用： [me@linuxbox ~]$ echo $((2+2)) 4 算术扩展使用形式： $((expression)) ，其中 expression 是包含数\b值和算术操作符的算术表达式。算术扩展 只支持整数 。 1.4.1 运算符 运算符 描述 + 加 - 减 * 乘 / 除（结果为整数） % 取余 ** 取幂 空格在算术表达式中无意义，表达式可以嵌套： [me@linuxbox ~]$ echo $(($((5**2)) * 3)) 75 还可以使用\b一对括号来组合多个子表达式： [me@linuxbox ~]$ echo $(((5**2) * 3)) 75 1.4.2 数字进制 符号 描述 number 默认情况下，number 没有任何符号，将作为十进制数字 0number 在数字表达式中，以0开始的数字被视为八进制数字 0xnumber 十六进制数 base#number base 进制的 number 🌰 ： [me@linuxbox ~]$ echo $((0xff)) 255 [me@linuxbox ~]$ echo $((3#11)) 4 1.5 花括号扩展 花括号扩展可以用于创建多种文本字符串，例如 [me@linuxbox ~]$ echo Front-{A,B,C}-Back Front-A-Back Front-B-Back Front-C-Back 用于花括号扩展的模式信息可以包含一个称为 前导字符 的开头部分和一个称为 附言 的结尾部分。花括号表达式本身可以包含一些列逗号分隔的字符串，也可以包含一系列整数或者单个字符。 模式信息不能包含内嵌的\b空白。 花括号扩展最普遍的应用是创建一系列的文件或者目录： [me@linuxbox ~]$ mkdir {2009..2011}-0{1..9} {2009..2010}-{10..12} 1.6 参数扩展 shell 提供了多种参数扩展的形式。 1.6.1 基本参数 参数扩展的最简单形式体现在平时对变量的使用中。举例来说， $a 扩展后成为变量 a 所包含的内容，无论 a 包含什么。 简单参数可以被括号包围，如 ${a} ，当变量相邻与其他文本时，必须使用括号，否则可能让 shell 混淆。 [me@linuxbox ~]$ a=\"foo\" [me@linuxbox ~]$ echo \" $a_file \" [me@linuxbox ~]$ echo \" ${ a } _file\" foo_file 因为不存在 a_file 变量，所以 shell 输出空。 同样，对于大于9的位置参数可以通过给相应数字加上括号来访问，例如访问第11个位置参数： ${11} 1.6.2 空变量扩展的管理 有的参数扩展用于处理不存在的变量和空变量。这些参数扩展在处理缺失的位置参数和给参数赋默认值时很有用。 ${parameter:-word} ：如果 parameter 未被设定或者是空参数，则其扩展为 word 的值。如果\b parameter 非空，则扩展为 parameter 的值。 [ me@linuxbox ~ ] $ foo = [ me@linuxbox ~ ] $ echo $ { foo : - \"substitute value if unset\" } substitute value if unset [ me@linuxbox ~ ] $ echo $ foo [ me@linuxbox ~ ] $ foo = bar [ me@linuxbox ~ ] $ echo $ { foo : - \"substitute value if unset\" } bar [ me@linuxbox ~ ] $ echo $ foo bar ${parameter:=word} ：如果 parameter 未被设定或者是空参数，则其扩展为 word 的值；此外，word 的值也将赋给 parameter。如果\b parameter 非空，则扩展为 parameter 的值。注意：位置参数和其他特殊参数不能以这种方式赋值。 [ me@linuxbox ~ ] $ foo = [ me@linuxbox ~ ] $ echo $ { foo : = \"deafult value if unset\" } deafult value if unset [ me@linuxbox ~ ] $ echo $ foo deafult value if unset [ me@linuxbox ~ ] $ foo = bar [ me@linuxbox ~ ] $ echo $ { foo : - \"deafult value if unset\" } bar [ me@linuxbox ~ ] $ echo $ foo bar ${parameter:？word} ：如果 parameter 未被设定或者是空参数，这样扩展会致使脚本\b出错而退出，并且 word 的内容输出到标准错误。如果 parameter 非空，则扩展为 parameter 的值。 [me@linuxbox ~]$ foo= [me@linuxbox ~]$ echo ${ foo : ? \"parameter is empty\" } bash: foo: parameter is empty [me@linuxbox ~]$ echo $? 1 [me@linuxbox ~]$ foo=bar [me@linuxbox ~]$ echo ${ foo : ? \"parameter is empty\" } bar [me@linuxbox ~]$ echo $? 0 ${parameter:+word} ：如果 parameter 未被设定或者是空参数，则不产生任何扩展。若 parameter 非空，word 的值将取代 parameter 的值产生扩展；然而，parameter 的值并不发生变化。 [me@linuxbox ~]$ foo= [me@linuxbox ~]$ echo ${ foo : + \"substitute value if unset\" } [me@linuxbox ~]$ foo=bar [me@linuxbox ~]$ echo ${ foo : + \"substitute value if unset\" } substitute value if unset [me@linuxbox ~]$ echo $foo bar 1.6.3 返回变量名的扩展 shell 具有返回变量名的扩展。这种功能在相当特殊的情况下才会使用。 ${ ! prefix * } ${ ! prefix @ } 该扩展返回当前以 prefix 开通的变量名。根据 bash 文档，这两种形式的扩展形式执行的效果一模一样。 1.6.4 字符串操作 ${#parameter} ：扩展为 parameter 内包含的字符串的长度。如果 parameter 是 \"@\" 或 \"*\"，那么扩展的结果就是位置参数的个数。 [me@linuxbox ~]$ foo=\"This string is long.\" [me@linuxbox ~]$ echo \"' $foo ' is ${ #foo } characters long.\" 'This string is long.' is 20 characters long. {parameter:offset} 和 {parameter:offset:length} ：这个扩展提取一部分字符串。扩展以 offset 字符开始，直到字符串末尾，除非 length 特别指定它。 [me@linuxbox ~]$ foo=\"This string is long.\" [me@linuxbox ~]$ echo ${ foo : 5 } string is long. [me@linuxbox ~]$ echo ${ foo : 5 : 6 } string 如果 offset 为负，默认表示从字符串末尾开始。 注意，负值前必须有一个空格 ，以防和 ${parameter:-word} 扩展混淆。length 不能小于0。 [me@linuxbox ~]$ foo=\"This string is long.\" [me@linuxbox ~]$ echo ${ foo : - 5 } long. [me@linuxbox ~]$ echo ${ foo : - 5 : 2 } lo 如果参数是 \"@\"，扩展的结果则是从 offset 开始，length 为位置参数。 ${parameter#pattern} 和 ${parameter##pattern} ：pattern 是一个通配符模式，\"#\" 去除最短匹配，\"##\" 去除最长匹配。 [me@linuxbox ~]$ foo=file.txt.zip [me@linuxbox ~]$ echo ${ foo #*. } txt.zip [me@linuxbox ~]$ echo ${ foo ##*. } zip ${parameter%pattern} 和 ${parameter%%pattern} ：从尾部去除。pattern 是一个通配符模式，\"%\" 去除最短匹配，\"%%\" 去除最长匹配。 [me@linuxbox ~]$ foo=file.txt.zip [me@linuxbox ~]$ echo ${ foo %*. } file.txt [me@linuxbox ~]$ echo ${ foo %%*. } file ${parameter/pattern/string} ：查找替换，只替换第一个出现的 ${parameter//pattern/string} ：替换所有的 ${parameter/#pattern/string} ：要求匹配出现在字符串开头 ${parameter/%pattern/string} ：要求匹配出现在字符串末尾 /string 可以省略，此时匹配到的字符被删除 [me@linuxbox ~]$ foo=JPG.JPG [me@linuxbox ~]$ echo ${ foo / JPG / jpg } jpg.JPG [me@linuxbox ~]$ echo ${ foo // JPG / jpg } jpg.jpg [me@linuxbox ~]$ echo ${ foo / #JPG/jpg } jpg.JPG [me@linuxbox ~]$ echo ${ foo /% JPG / jpg } JPG.jpg 1.7 命令替换 命令替换可以把一个命令的输出作为一个扩展模式使用： [me@linuxbox ~]$ ls -l $(which cp) -rwxr-xr-x 1 root wheel 29008 10 26 2017 /bin/cp 在早期的 shell 程序中，存在命令替换的另一种语法，bash 也支持这种格式。它用反引号代替美元符号和括号： [me@linuxbox ~]$ ls -l `which cp` -rwxr-xr-x 1 root wheel 29008 10 26 2017 /bin/cp 2. 引用 引用主要用于控制扩展。 2.1 双引号 如果把文本放在双引号中，那么 shell 使用的所有特殊字符都被看成普通字符，除了 \"$（美元符号）\"，\"\\（反斜杠）\"，\"`（反引号）\" 除外。 单词分隔、路径名扩展、波浪线扩展、花括号扩展都失效。 参数扩展、算术扩展、命令替换仍然有效。 使用双引号可以阻止单词分隔，这可以用来处理包含空白的文件名。 单引号 抑制所有扩展。 转义字符 转义字符通常用在双引号中用来有选择性的阻止扩展。 关于反斜杠转义字符（backslash escape sequence） 反斜杠除了作为转义字符外，也是一种表示法的一部分。ASCII 码表的前32个字符用来向电传打字类设备传送命令。 转义字符 含义 \\a 响铃（警告声——计算机发出哔哔声） \\b 退格 \\n 新的一行（在类 UNIX 系统中，产生的是换行效果 \\r 回车 \\t 制表 在 echo 命令中带上 -e 选项，就能够解释转义字符序列，也可以将其放在 \"$''\"中。下面的例子，实现一个简单的倒计时计时器： [me@linuxbox ~]$ sleep 10; echo -e \"Time's up\\a\" 也可以这样做： [me@linuxbox ~]$ sleep 10; echo -e \"Time's up\" $'\\a'","tags":"教程","url":"https://xutree.github.io/pages/2018/10/08/linux中的扩展和引用/"},{"title":"剑指 offer (1)","text":"1. 二维数组中的查找 在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 class Solution { public : bool Find ( int target , vector < vector < int > > array ) { // 注意 size 是成员函数，要加括号 if ( array . size () == 0 ) return false ; // 为空，返回 int row = array . size (); int col = array [ 0 ]. size (); // 从右上角开始查找 for ( int i = 0 , j = n - 1 ; i < m && j >= 0 ;) { if ( array [ i ][ j ] == target ) { return true ; } else if ( array [ i ][ j ] > target ) { j -- ; } else { i ++ ; } } return false ; } }; 思路 ：如我们从右上角的数据开始出发，比他小的数必定在它的左侧，就往左找；比他大的数必定在它的下侧，就往下找。 2. 替换空格 请实现一个函数，将一个字符串中的每个空格替换成\"%20\"。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 class Solution { public : void replaceSpace ( char * str , int length ) { // 先统计总共有多少空格 int count_space = 0 ; for ( int i = 0 ; i < length ; i ++ ) { if ( str [ i ] == ' ' ) count_space ++ ; } int new_length = length + 2 * count_space ; // 从后开始移位 for ( int i = length - 1 , j = new_length - 1 ; i >= 0 && j >= 0 ; ) { if ( str [ i ] == ' ' ) { str [ j -- ] = '0' ; str [ j -- ] = '2' ; str [ j -- ] = '%' ; i -- ; } else { str [ j -- ] = str [ i -- ]; } } // 字符串结束标志 str [ new_length ] = '\\0' ; } }; 思路 ：从后往前移位可避免重复移位。 3. 从尾到头打印链表 输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。 /** * struct ListNode { * int val; * struct ListNode *next; * ListNode(int x) : * val(x), next(NULL) { * } * }; */ class Solution { public : vector < int > printListFromTailToHead ( ListNode * head ) { ListNode * node = head ; stack < int > st ; int count = 0 ; while ( node != NULL ) { // 用 -> st . push ( node -> val ); count ++ ; node = node -> next ; } // 为了效率我们静态 vector 开辟空间 vector < int > res ( count ); for ( int i = 0 ; i < count && st . empty () != true ; i ++ ) { // 如果静态开辟 vector 不能使用push_back // 否则会在原来数据的基础上增加 // res.push_back(st.top()); // 注意栈的三个主要函数 res [ i ] = st . top (); st . pop (); } return res ; } }; 思路 ：首先我们想到的就是反转链表了,如果把链表反转了，然后再返回头，这样再次遍历的时候就相当于从尾到头打印了。但是在面试时候，如果我们打算修改输入的数据，最好先问问面试官是不是允许修改。通常打印只是一个只读操作，我们肯定不希望输入时候修改链表的内容。 利用栈的后进先出特性 ：单链表的遍历只能从前往后，但是需要从尾往头输出，这不是典型的\"先进后出\"么，那么我们可以用栈模拟输出。每经过一个结点的时候，把该结点放到一个栈中。当遍历完整个链表后，再从栈顶开始逐个输出结点的值，此时输出的结点的顺序已经反转过来了。注意包含 stack 头文件。 递归实现 /** * struct ListNode { * int val; * struct ListNode *next; * ListNode(int x) : * val(x), next(NULL) { * } * }; */ class Solution { public : vector < int > res ; // 保存结果 vector < int > printListFromTailToHead ( ListNode * head ) { if ( head != NULL ) { printListFromTailToHead ( head -> next ); res . push_back ( head -> val ); } return res ; } }; 4. 重建二叉树 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 /** * Definition for binary tree * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public : TreeNode * reConstructBinaryTree ( vector < int > pre , vector < int > vin ) { // 遍历长度应该相同 if ( pre . size () != vin . size ()) return NULL ; // 非空 if ( pre . size () == 0 ) return NULL ; int length = pre . size (); // 前序遍历的第一个节点是根节点 int value = pre [ 0 ]; TreeNode * root = new TreeNode ( value ); // 在中序遍历中查找根的位置 int rootIndex = 0 ; for ( rootIndex = 0 ; rootIndex < length ; rootIndex ++ ) { if ( vin [ rootIndex ] == value ) break ; } if ( rootIndex >= length ) return NULL ; // 区分左子树和右子树 // 中序遍历中，根左边的就是左子数，右边的就是右子树 // 前序遍历中，根后面是先遍历左子树，然后是右子树 // 首先确定左右子树的长度，从中序遍历 vin 中确定 int leftLength = rootIndex ; int rightLength = length - 1 - rootIndex ; vector < int > preLeft ( leftLength ), vinLeft ( leftLength ); vector < int > preRight ( rightLength ), vinRight ( rightLength ); for ( int i = 0 ; i < length ; i ++ ) { if ( i < rootIndex ) { preLeft [ i ] = pre [ i + 1 ]; vinLeft [ i ] = vin [ i ]; } else if ( i > rootIndex ) { preRight [ i - rootIndex - 1 ] = pre [ i ]; vinRight [ i - rootIndex - 1 ] = vin [ i ]; } } root -> left = reConstructBinaryTree ( preLeft , vinLeft ); root -> right = reConstructBinaryTree ( preRight , vinRight ); return root ; } }; 5. 用两个栈实现队列 用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。 队列中的元素为 int 类型。 class Solution { public : void push ( int node ) { stack1 . push ( node ); } int pop() { if ( stack2 . empty ()) { // 空队列，返回 -1 if ( stack1 . empty ()) return - 1 ; while ( ! stack1 . empty ()) { int temp = stack1 . top (); stack2 . push ( temp ); stack1 . pop (); } } int res = stack2 . top (); stack2 . pop (); return res ; } private : stack < int > stack1 ; stack < int > stack2 ; }; 思路 ：始终维护 s1 作为输入栈，以 s2 作为输出栈： 入队时，将元素压入 s1 出队时，判断 s2 是\b否为空，如不为空，则直接弹出顶元素；如为空，则将 s1 的元素逐个\"倒入\" s2，把最后\b一个元素弹出并出队。这个思路，避免了反复\"倒\"栈，仅在需要时才\"倒\"一次。 6. 旋转数组的最小数字 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组 {3,4,5,1,2} 为 {1,2,3,4,5} 的一个旋转，该数组的最小值为 1。 NOTE：给出的所有元素都大于 0，若数组大小为\b 0，请返回 0。 class Solution { public : int minNumberInRotateArray ( vector < int > rotateArray ) { if ( rotateArray . size () == 0 ) return 0 ; // 如果把排序数组前面 0 个元素搬到后面，也就是说其实没有旋转， // 那么第 0 个元素就是最小的元素 // 因此我们将 mid 初始化为 0 int mid = 0 ; int low = 0 , high = rotateArray . size () - 1 ; while ( rotateArray [ low ] >= rotateArray [ high ]) { // 如果前一个元素与后一个元素差一位 // 说明找到了最大最小的元素 if ( high - low == 1 ) { mid = high ; break ; } mid = ( low + high ) / 2 ; // rotateArray[low] rotateArray[mid] rotateArray[high]三者相等 // 无法确定中间元素是属于前面还是后面的递增子数组 // 只能顺序查找 if ( rotateArray [ low ] == rotateArray [ mid ] && rotateArray [ mid ] == rotateArray [ high ]) { return MinOrder ( rotateArray , low , high ); } // 如果该中间元素位于前面的递增子数组，那么它应该大于或者等于第一个指针指向的元素 if ( rotateArray [ mid ] >= rotateArray [ low ]) { low = mid ; // 此时最小的元素位于中间元素的后面 } // 如果中间元素位于后面的递增子数组，那么它应该小于或者等于第二个指针指 向的元素 else if ( rotateArray [ mid ] <= rotateArray [ high ]) { high = mid ; // 此时最小的元素位于中间元素的前面 } } return rotateArray [ mid ]; } private : // 顺序寻找最小值 int MinOrder ( vector < int > & num , int low , int high ) { int result = num [ low ]; for ( int i = low + 1 ; i < high ; i ++ ) { if ( num [ i ] < result ) result = num [ i ]; } return result ; } }; 思路 ：和二分查找法一样，用两个指针分别指向数组的第一个元素和最后一个元素。我们注意到旋转之后的数组实际上可以划分为两个排序的子数组，而且前面的子数组的元素都大于或者等于后面子数组的元素。我们还可以注意到最小的元素刚好是这两个子数组的分界线。 我们试着用二元查找法的思路在寻找这个最小的元素。 首先我们用两个指针，分别指向数组的第一个元素和最后一个元素。按照题目旋转的规则，第一个元素应该是大于或者等于最后一个元素的（这其实不完全对，还有特例。后面再讨论特例）。 接着我们得到处在数组中间的元素。 如果该中间元素位于前面的递增子数组，那么它应该大于或者等于第一个指针指向的元素。 此时数组中最小的元素应该位于该中间 元素的后面。我们可以把第一指针指向该中间元素，这样可以缩小寻找的范围。 同样，如果中间元素位于后面的递增子数组，那么它应该小于或者等于第二个指针指 向的元素。此时该数组中最小的元素应该位于该中间元素的前面。我们可以把第二个指针指向该中间元素，这样同样可以缩小寻找的范围。我们接着再用更新之后的 两个指针，去得到和比较新的中间元素，循环下去。 按照上述的思路，我们的第一个指针总是指向前面递增数组的元素，而第二个指针总是指向后面递增数组的元素。最后第一个指针将指向前面子数组的最后一个元素， 而第二个指针会指向后面子数组的第一个元素。也就是它们最终会指向两个相邻的元素，而第二个指针指向的刚好是最小的元素。这就是循环结束的条件。 我们考虑下特殊情况，我们的循环判断是以 rotateArray[low] >= rotateArray[high] 为条件的，不满足这个的特殊情况有那些呢？ 由于是把递增排序数组前面的若干个数据搬到后面去，因此第一个数字总是大于或者等于最后一个数字，但按照定义还有一个 特例：开始时就 rotateArray[low] < rotateArray[high] ，那么循环不会执行.如果数组旋转后仍然有序，即 rotateArray[low] < rotateArray[high] 如果把排序数组前面 0 个元素搬到后面，也就是说其实没有旋转。那么第 0 个元素就是最小的元素，因此我们将 mid 初始化为 0。 如果 rotateArray[low] = rotateArray[high] 测试用例: [2, 3, 4, 2, 2, 2, 2]，此时 rotateArray[low] rotateArray[mid] rotateArray[high] 三者相等，无法确定中间元素是属于前面还是后面的递增子数组，只能顺序查找。 7. \b斐波那契数列 大家都知道斐波那契数列，现在要求输入一个整数 \\(n\\) ，请你输出斐波那契数列的第 \\(n\\) 项（从 0 开始，第 0 项为 0），\b \\(n \\leq 39\\) 。 class Solution { public : int Fibonacci ( int n ) { if ( n < 2 ) { return n ; } int f1 = 0 , f2 = 1 , res = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { res = f1 + f2 ; f1 = f2 ; f2 = res ; } return res ; } }; 思路 ：不可递归，会超时，需展开。 8. 跳台阶 一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级。求该青蛙跳上一个 \\(n\\) 级的台阶总共有多少种跳法（先后次序不同算不同的结果）。 class Solution { public : int jumpFloor ( int number ) { if ( number <= 2 ) return number ; int f1 = 1 , f2 = 2 , res ; for ( int i = 3 ; i <= number ; i ++ ) { res = f1 + f2 ; f1 = f2 ; f2 = res ; } return res ; } }; 思\b路 ： \\(f(n)=f(n-1)+f(n-2)\\) 9. 变态跳台阶 一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级...它也可以跳上 \\(n\\) 级。求该青蛙跳上一个 \\(n\\) 级的台阶总共有多少种跳法。 class Solution { public : int jumpFloorII ( int number ) { return pow ( 2 , number - 1 ); } }; 思\b路 ： \\(f(n)=f(n-1)+f(n-2)+\\cdots+f(1)=2f(n-1)\\) $$f(n)=\\begin{cases} 1, & n=0 \\\\ 1, & n=1 \\\\ 2f(n-1), & n\\geq 2 \\end{cases}$$ 10. 矩形覆盖 我们可以用 \\(2\\times1\\) 的小矩形横着或者竖着去覆盖更大的矩形。请问用 \\(n\\) 个 \\(2\\times1\\) 的小矩形无重叠地覆盖一个 \\(2\\times n\\) 的大矩形，总共有多少种方法？ class Solution { public : int rectCover ( int number ) { if ( number <= 2 ) return number ; int f1 = 1 , f2 = 2 , res ; for ( int i = 3 ; i <= number ; i ++ ) { res = f1 + f2 ; f1 = f2 ; f2 = res ; } return res ; } }; 思\b路 ： \\(f(n)=f(n-1)+f(n-2)\\) 11. 二进制中 1 的个数 输入一个整数，输出该数二进制表示中 1 的个数。其中负数用补码表示。 class Solution { public : int NumberOf1 ( int n ) { int count = 0 ; while ( n ) { count ++ ; n = n & ( n - 1 ); } return count ; } }; 逻辑右移与算术右移 ：比如一个有符号位的 8 位二进制数 11001101，逻辑右移就不管符号位，如果移一位就变成 01100110。算术右移要管符号位，右移一位变成 10100110。 逻辑左移=算数左移，右边统一添 0 逻辑右移，左边统一添 0 算数右移，左边添加的数和符号有关 因此如果输入负数，那么我们的算法简单的判断是不是 0 来终结，岂不是要死循环。 避免负数移位的死循环 ：为了负数时候避免死循环，我们可以不右移数字 \\(n\\) ，转而去移动测试位。 那么思考我们的循环结束条件，flag 一直左移（乘以 2），当超出表示标识范围的时候，我们就可以终止了，但是这样子的话，最高位的符号位没有测试，因此要单独测试，同时由于会溢出，我们的 flag 需要用 long 来标识。 整数中有几个 1 就循环几次 --- lowbit 优化 ：把一个整数 \\(n\\) 减去 1，再和原来的整数做与运算，会把该整数最右边一个 1 变成 0，那么该整数有多少个 1，就会进行多少次与运算。 12. 数值的正数次方 给定一个 double 类型的\b浮点数 base 和 int 类型的整数 exponent 。求 base 的 exponent 次方。 class Solution { public : double Power ( double base , int exponent ) { // 注意不可声明为int double res = 1 , curr = base ; // 只有正数支持位运算 int n ; if ( exponent > 0 ) { n = exponent ; } else if ( exponent < 0 ) { // 由于精度原因，double 类型的变量不能用等号判断两个数是否相等 if ( base > - 0.000001 && base < 0.000001 ) { // 抛出异常 throw new runtime_error ( \"分母不能为0\" ); } n = - exponent ; } else { return 1 ; } while ( n != 0 ) { // 不确定的地方加括号 if (( n & 1 ) == 1 ) res *= curr ; curr *= curr ; n >>= 1 ; } return exponent >= 0 ? res : ( 1 / res ); } }; 13. 调整数组顺序使奇数位于偶数前面 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 class Solution { public : void reOrderArray ( vector < int > & array ) { if ( array . size () <= 1 ) return ; vector < int > temp ; auto ib1 = array . begin (); // 删除元素，尾后迭代器失效 for (; ib1 != array . end (); ) { if ( * ib1 % 2 == 0 ) { temp . push_back ( * ib1 ); array . erase ( ib1 ); } else { ib1 ++ ; } } /* Summary: 1. For observing the elements, use the following syntax: for (const auto& elem : container) // capture by const reference 2. If the objects are cheap to copy (like ints, doubles, etc.), it's possible to use a slightly simplified form: for (auto elem : container) // capture by value 3. For modifying the elements in place, use: for (auto& elem : container) // capture by (non-const) reference 4. If the container uses \"proxy iterators\" (like std::vector<bool>), use: for (auto&& elem : container) // capture by && 5. Of course, if there is a need to make a local copy of the element inside the loop body, capturing by value (for (auto elem : container)) is a good choice. */ for ( auto elem : temp ) { array . push_back ( elem ); } } }; 14. 链表中倒数第 \\(k\\) 个结点 输入一个链表，输出该链表中倒数第 \\(k\\) 个结点。 /* struct ListNode { int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) { } };*/ class Solution { public : ListNode * FindKthToTail ( ListNode * pListHead , unsigned int k ) { if ( pListHead == NULL ) return NULL ; ListNode * left = pListHead , * right = left ; unsigned int i = 0 ; while ( i < k && right != NULL ) { right = right -> next ; i ++ ; } // 注意条件 if ( i < k && right == NULL ) return NULL ; // 注意条件 while ( right != NULL ) { right = right -> next ; left = left -> next ; } return left ; } }; \b 思路 ：双指针法 15. 反转链表 输入一个链表，反转链表后，输出新链表的表头。 /* struct ListNode { int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) { } };*/ class Solution { public : ListNode * ReverseList ( ListNode * pHead ) { if ( pHead == NULL ) return NULL ; ListNode * pPrev = NULL , * pNext = NULL , * pNode = pHead ; while ( pNode ) { pNext = pNode -> next ; pNode -> next = pPrev ; pPrev = pNode ; pNode = pNext ; } return pPrev ; } }; 16. 合并两个排序的链表 输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。 /* struct ListNode { int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) { } };*/ class Solution { public : ListNode * Merge ( ListNode * pHead1 , ListNode * pHead2 ) { if ( pHead1 == NULL ) { return pHead2 ; } else if ( pHead2 == NULL ) { return pHead1 ; } ListNode * phead1 = pHead1 ; ListNode * phead2 = pHead2 ; // 先生成头结点 ListNode * head = NULL ; if ( phead1 -> val < phead2 -> val ) { head = phead1 ; phead1 = phead1 -> next ; } else { head = phead2 ; phead2 = phead2 -> next ; } // 遍历两个链表，另用一个指针以保存头指针 ListNode * curr = head ; while ( phead1 && phead2 ) { if ( phead1 -> val > phead2 -> val ) { curr -> next = phead2 ; curr = curr -> next ; phead2 = phead2 -> next ; } else { curr -> next = phead1 ; curr = curr -> next ; phead1 = phead1 -> next ; } } // 直接附加上去 if ( phead1 == NULL ) { curr -> next = phead2 ; } else { curr -> next = phead1 ; } return head ; } }; 17. 树的子结构 输入两棵二叉树 \\(A\\) ， \\(B\\) ，判断 \\(B\\) 是不是 \\(A\\) 的子结构。（ps：我们约定空树不是任意一个树的子结构）。 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { } };*/ class Solution { public : bool HasSubtree ( TreeNode * pRoot1 , TreeNode * pRoot2 ) { bool res = false ; // 判断非空 if ( pRoot1 != NULL && pRoot2 != NULL ) { if ( pRoot1 -> val == pRoot2 -> val ) { res = DoesTree1HaveTree2 ( pRoot1 , pRoot2 ); } if ( ! res ) { res = HasSubtree ( pRoot1 -> left , pRoot2 ); } if ( ! res ) { res = HasSubtree ( pRoot1 -> right , pRoot2 ); } } return res ; } bool DoesTree1HaveTree2 ( TreeNode * pRoot1 , TreeNode * pRoot2 ) { if ( pRoot2 == NULL ) return true ; if ( pRoot1 == NULL ) return false ; if ( pRoot1 -> val != pRoot2 -> val ) return false ; return DoesTree1HaveTree2 ( pRoot1 -> left , pRoot2 -> left ) && DoesTree1HaveTree2 ( pRoot1 -> right , pRoot2 -> right ); } }; 18. 二叉树的镜像 操作给定的二叉树，将其变换为源二叉树的镜像。 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { } };*/ class Solution { public : void Mirror ( TreeNode * pRoot ) { if ( pRoot == NULL ) { return ; } swap ( pRoot -> left , pRoot -> right ); Mirror ( pRoot -> left ); Mirror ( pRoot -> right ); } }; 19. 顺序打印矩阵 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10。 class Solution { private : int row , col ; vector < vector < bool >> flag ; bool judge ( int i , int j ) { return 0 <= i && i < row && 0 <= j && j < col && flag [ i ][ j ] == true ; } public : vector < int > printMatrix ( vector < vector < int > > matrix ) { vector < int > res ; if ( matrix . size () == 0 ) return res ; row = matrix . size (); col = matrix [ 0 ]. size (); flag = vector < vector < bool >> ( row , vector < bool > ( col , true )); const int D [ 4 ][ 2 ] = {{ 0 , 1 }, { 1 , 0 }, { 0 , - 1 }, { - 1 , 0 }}; int i = 0 , j = 0 , d = 0 , count = row * col ; while ( count -- ) { res . push_back ( matrix [ i ][ j ]); flag [ i ][ j ] = false ; if ( judge ( i + D [ d ][ 0 ], j + D [ d ][ 1 ]) == false ) { ( ++ d ) %= 4 ; } i += D [ d ][ 0 ]; j += D [ d ][ 1 ]; } return res ; } }; 20. 包含 min 函数的栈 定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的 min 函数（时间复杂度应为 \\(O(1)\\) ）。 class Solution { public : void push ( int value ) { m_data . push ( value ); if ( m_min . empty ()) { m_min . push ( value ); } else { int temp = value < m_min . top () ? value : m_min.top (); m_min . push ( temp ); } } void pop() { m_data . pop (); m_min . pop (); } int top() { return m_data . top (); } int min() { // 注意空 if ( m_min . empty ()) return 0 ; return m_min . top (); } // 自己添加成员变量 protected : stack < int > m_data ; stack < int > m_min ; }; 思路 ：我们维持两个栈 数据栈 m_data，存储栈的数据用于常规的栈操作 最小栈 m_min，保存每次 push 和 pop 时候的最小值， 在 push-data 栈的时候，将当前最小数据压入，在 pop-data 栈的时候，将 min 栈栈顶的最小数据弹出，这样保证 min 栈中存储着当前现场的最小值，并随着数据栈的更新而更新。 21. 栈的压入、弹出序列 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）。 class Solution { public : bool IsPopOrder ( vector < int > pushV , vector < int > popV ) { if ( pushV . empty ()) return false ; vector < int > stack ; for ( int i = 0 , j = 0 ; i < pushV . size (); ) { stack . push_back ( pushV [ i ++ ]); // 注意为 while while ( j < popV . size () && stack . back () == popV [ j ]) { stack . pop_back (); j ++ ; } } return stack . empty (); } }; 22. 从上往下打印二叉树 从上往下打印出二叉树的每个节点，同层节点从左至右打印。 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { } };*/ class Solution { public : vector < int > PrintFromTopToBottom ( TreeNode * root ) { vector < int > res ; if ( root == NULL ) return res ; vector < TreeNode *> vec ; vec . push_back ( root ); int cur = 0 ; int end = 1 ; while ( cur < vec . size ()) { // 新的一行访问开始，重新定位 end 于当前行最后一个节点的下一个位置 end = vec . size (); while ( cur < end ) { res . push_back ( vec [ cur ] -> val ); if ( vec [ cur ] -> left != NULL ) /// 压入左节点 { vec . push_back ( vec [ cur ] -> left ); } if ( vec [ cur ] -> right != NULL ) /// 压入右节点 { vec . push_back ( vec [ cur ] -> right ); } cur ++ ; } } return res ; } }; /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { } };*/ class Solution { public : vector < int > PrintFromTopToBottom ( TreeNode * root ) { vector < int > res ; if ( root == NULL ) return res ; queue < TreeNode *> node ; node . push ( root ); node . push ( NULL ); TreeNode * curr = root ; while ( node . size () != 0 ) { // front 函数记住 curr = node . front (); node . pop (); if ( curr ) { res . push_back ( curr -> val ); if ( curr -> left ) node . push ( curr -> left ); if ( curr -> right ) node . push ( curr -> right ); } else if ( node . size () != 0 ) { node . push ( NULL ); } } return res ; } }; 23. 二叉搜索树的后序遍历序列 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。 class Solution { public : bool VerifySquenceOfBST ( vector < int > sequence ) { if ( sequence . empty ()) return false ; return judge ( sequence , 0 , sequence . size () - 1 ); } bool judge ( vector < int > & sequence , int left , int right ) { if ( left >= right ) return true ; /// 后一半的元素都比根元素大 int mid = right - 1 ; // mid >= left while ( mid >= left && sequence [ mid ] > sequence [ right ]) mid -- ; /// 那么前面的元素都应该比根小 int i = left ; while ( i < mid && sequence [ i ] < sequence [ right ]) i ++ ; if ( i < mid ) return false ; return judge ( sequence , left , mid ) && judge ( sequence , mid + 1 , right - 1 ); } }; 思路 ：如果按照后序遍历，先左后右最后自己的顺序来遍历树，数组的最后一个元素肯定是自己（父节点），然后剩余的部分分成两个部分，第一部分都比自己小（左子树部分），第二部分都比自己大（右子树部分），因此套用这个关系就可以循环检验出是否是二叉搜索树的后序遍历了。 24. 二叉树中和为某一值的路径 输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的 list 中，数组长度大的数组靠前)。 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { } };*/ class Solution { // 自己添加 private : vector < vector < int > > allRes ; vector < int > tmp ; void dfsFind ( TreeNode * node , int expectNumber ){ tmp . push_back ( node -> val ); if ( expectNumber == node -> val && node -> left == NULL && node -> right == NULL ) allRes . push_back ( tmp ); else { if ( node -> left ) dfsFind ( node -> left , expectNumber - node -> val ); if ( node -> right ) dfsFind ( node -> right , expectNumber - node -> val ); } tmp . pop_back (); } public : vector < vector < int > > FindPath ( TreeNode * root , int expectNumber ) { if ( root ) dfsFind ( root , expectNumber ); return allRes ; } }; 25. 复杂链表的复制 输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空） /* struct RandomListNode { int label; struct RandomListNode *next, *random; RandomListNode(int x) : label(x), next(NULL), random(NULL) { } }; */ class Solution { public : RandomListNode * Clone ( RandomListNode * pHead ) { if ( pHead == NULL ) return NULL ; RandomListNode * currNode = pHead ; RandomListNode * newHead = NULL , * newNode = NULL ; // 复制常规节点 while ( currNode != NULL ) { if (( newNode = new RandomListNode ( currNode -> label )) == NULL ) { // cstdio 用来将上一个函数发生错误的原因输出到标准设备(stderr) perror ( \"new error: \" ); // cstdlib 退出当前运行的程序，并将参数返回给主调进程 exit ( - 1 ); } newNode -> next = currNode -> next ; currNode -> next = newNode ; currNode = newNode -> next ; } // 随机指针 currNode = pHead ; newNode = pHead -> next ; while ( currNode != NULL ) { RandomListNode * randNode = currNode -> random ; RandomListNode * newNode = currNode -> next ; if ( randNode != NULL ) { newNode -> random = randNode -> next ; } else { newNode -> random = NULL ; } currNode = newNode -> next ; } // 断开 currNode = pHead ; newNode = newHead = pHead -> next ; while ( currNode != NULL ) { currNode -> next = newNode -> next ; if ( newNode -> next != NULL ) { newNode -> next = newNode -> next -> next ; } else { newNode -> next = NULL ; } currNode = currNode -> next ; newNode = newNode -> next ; } return newHead ; } }; 思路 ：用 next 指针域关联新旧结点。将新节点直接插入到原结点的后面。 26. 二叉搜索树与双向链表 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 /* struct TreeNode { int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) { } };*/ class Solution { public : TreeNode * Convert ( TreeNode * pRootOfTree ) { if ( pRootOfTree == NULL ) return NULL ; TreeNode * pLastNode = NULL ; ConvertRecursion ( pRootOfTree , & pLastNode ); // 当递归结束后,*pLastNode 指向了双向链表的尾结点 TreeNode * node = pLastNode ; while ( node != NULL && node -> left != NULL ) { node = node -> left ; } return node ; } void ConvertRecursion ( TreeNode * root , TreeNode ** pLastNode ) { if ( root == NULL ) return ; TreeNode * currNode = root ; if ( currNode -> left != NULL ) { ConvertRecursion ( currNode -> left , pLastNode ); } currNode -> left = * pLastNode ; // 注意两层指针解引用 if ( * pLastNode != NULL ) ( * pLastNode ) -> right = currNode ; * pLastNode = currNode ; if ( currNode -> right != NULL ) { ConvertRecursion ( currNode -> right , pLastNode ); } } }; 27. 字符串的排列 输入一个字符串，按字典序打印出该字符串中字符的所有排列。例如输入字符串 abc，则打印出由字符 a、b、c 所能排列出来的所有字符串 abc、acb、bac、bca、cab 和 cba。 class Solution { // 自己添加 protected : vector < string > m_res ; public : vector < string > Permutation ( string str ) { m_res . clear (); if ( str . empty () == true ) { return m_res ; } PermutationRecursion ( str , 0 ); sort ( m_res . begin (), m_res . end ()); return m_res ; } void PermutationRecursion ( string str , int begin ) { if ( str [ begin ] == '\\0' ) { m_res . push_back ( str ); } else { for ( int i = begin ; str [ i ] != '\\0' ; i ++ ) { if ( ! HasDuplicate ( str , begin , i )) { swap ( str [ i ], str [ begin ]); PermutationRecursion ( str , begin + 1 ); swap ( str [ i ], str [ begin ]); } } } } private : //find duplicate of str[i] in str[k,i) bool HasDuplicate ( string & str , int k , int i ) const { for ( int p = k ; p < i ; p ++ ) \b\b if ( str [ p ] == str [ i ]) return true ; return false ; } }; 思路 ：全排列中去掉重复的规则： 去重的全排列就是从第一个数字起，每个数分别与它后面非重复出现的数字交换。 28. 数组中出现次数超过一半的数字 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为 9 的数组 {1，2，3，2，2，2，5，4，2}。由于数字 2 在数组中出现了 5 次，超过数组长度的一半，因此输出 2。如果不存在则输出 0。 class Solution { public : int MoreThanHalfNum_Solution ( vector < int > numbers ) { int len = numbers . size (); if ( len == 0 ) return 0 ; if ( len == 1 ) return numbers [ 0 ]; int k_val = FindKth ( numbers , 0 , len - 1 , len / 2 ); int count = 0 ; for ( auto & ele : numbers ) { if ( ele == k_val ) count ++ ; } return count > len / 2 ? k_val : 0 ; } int Partition ( vector < int > & numbers , int low , int high ) { if ( low < high ) { int i = low , j = high , x = numbers [ i ]; while ( i < j ) { while ( i < j && numbers [ j ] >= x ) j -- ; numbers [ i ++ ] = numbers [ j ]; while ( i < j && numbers [ i ] < x ) i ++ ; numbers [ j -- ] = numbers [ i ]; } numbers [ i ] = x ; return i ; } return low ; } int FindKth ( vector < int > & numbers , int low , int high , int k ) { if ( low == high ) return numbers [ low ]; int index ; index = Partition ( numbers , low , high ); // 递归 FindKth if ( index < k ) return FindKth ( numbers , index + 1 , high , k ); else if ( index > k ) return FindKth ( numbers , low , index - 1 , k ); else return numbers [ index ]; } }; 29. 最小的 \\(K\\) 个数 输入 \\(n\\) 个整数，找出其中最小的 \\(K\\) 个数。例如输入 4，5，6，2，7，3，8 这 8 个数字，则最小的 4 个数字是 1，2，3，4。 class Solution { public : vector < int > GetLeastNumbers_Solution ( vector < int > input , int k ) { vector < int > res ; if ( input . size () == 0 || input . size () < k ) return res ; // 快排 // quick_sort(input, 0, input.size() - 1); // 最大堆 // make_maxheap(input, k); //for (int i = k; i < input.size(); i++) { // if (input[0] > input[i]) { // swap(input[0], input[i]); // make_maxheap(input, k); // } //} for ( int i = 0 ; i < k ; i ++ ) res . push_back ( input [ i ]); return res ; } // 快排 void quick_sort ( vector < int > & input , int low , int high ) { if ( low < high ) { int i = low , j = high , x = input [ i ]; while ( i < j ) { while ( i < j && input [ j ] >= x ) j -- ; if ( i < j ) input [ i ++ ] = input [ j ]; while ( i < j && input [ i ] < x ) i ++ ; if ( i < j ) input [ j -- ] = input [ i ]; } input [ i ] = x ; quick_sort ( input , low , i - 1 ); quick_sort ( input , i + 1 , high ); } } // 最大堆 void make_maxheap ( vector < int > & input , int k ) { int dad = 0 , son = 2 * dad + 1 ; while ( son < k ) { if ( son + 1 < k && input [ son + 1 ] > input [ son ]) son ++ ; if ( input [ son ] <= input [ dad ]) return ; else { swap ( input [ son ], input [ dad ]); dad = son ; son = 2 * dad + 1 ; } } } void swap ( int & a , int & b ) { if ( a != b ) { a &#94;= b ; b &#94;= a ; a &#94;= b ; } } }; 30. 最大连续子序列的和 HZ 偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后，他又发话了：在古老的一维模式识别中，常常需要计算连续子向量的最大和，当向量全为正数的时候，问题很好解决。但是，如果向量中包含负数，是否应该包含某个负数，并期望旁边的正数会弥补它呢？例如：{6，-3，-2，7，-15，1，2，2}，连续子向量的最大和为 8（从第 0 个开始，到第 3 个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是 1)。 class Solution { public : int FindGreatestSumOfSubArray ( vector < int > array ) { if ( array . size () == 0 ) return 0 ; // #include <climits> int sum = 0 , max_sum = INT_MIN ; for ( int i = 0 ; i < array . size (); i ++ ) { if ( sum <= 0 ) { sum = array [ i ]; } else { sum += array [ i ]; } if ( sum > max_sum ) { max_sum = sum ; } } return max_sum ; } }; if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"读书笔记","url":"https://xutree.github.io/pages/2018/10/07/jzoffer1/"},{"title":"CSS 入门","text":"1. 什么是 CSS CSS（ C ascading S tyle S heets），即层叠样式表。 层叠是指 CSS 将一种样式应用于另一种样式的方式。样式表控制 Web 文档的外观。 2. CSS CSS 允许你将特定样式应用于特定 HTML 元素 CSS 的主要好处是它允许您将样式与内容分开 仅使用 HTML，所有样式和格式都在同一个地方，随着页面的增长，这变得相当难以维护 3. CSS 三种形式 3.1 内联 CSS：inline CSS 使用内联样式是插入样式表的方法之一。 使用内联样式，将独特的样式应用于单个元素。 要使用内联样式，请将style属性添加到相关标记。 <p style= \"color:white; background-color:gray;\" > This is an example of inline styling. </p> 3.2 嵌入式/内部 CSS：Embedded/Internal CSS 内部样式在 HTML 页面的 head 部分内的 <style> 元素中定义。 <html> <head> <style> p { color:white; background-color:gray; } </style> </head> <body> <p> This is my first paragraph. </p> <p> This is my second paragraph. </p> </body> </html> 3.3 外部 CSS：External CSS 使用此方法，所有样式规则都包含在单个文本文件中，该文件以 .css 扩展名保存。 然后使用 <link> 标记在 HTML 中引用此 CSS 文件。 <link> 元素位于 head 部分内部。 <head> <link rel= \"stylesheet\" href= \"example.css\" > </head> <body> <p> This is my first paragraph. </p> <p> This is my second paragraph. </p> <p> This is my third paragraph. </p> </body> 4. CSS 语法 CSS 由浏览器解释的样式规则组成，然后应用于文档中的相应元素。样式规则有三个部分： selector ， property 和 value 。 例如，标题颜色可以定义为： h1 { color: orange; } 选择器指向要设置样式的HTML元素。声明块包含一个或多个声明，以分号分隔。每个声明都包含一个属性名称和一个以冒号分隔的值。CSS 声明始终以分号结尾，声明组由大括号括起。 4.1 类型选择器 最常见且易于理解的选择器是类型选择器。 此选择器针对页面上的元素类型。 例如，要定位页面上的所有段落： p { color : red ; font-size : 130 % ; } 4.2 id 和 clss 选择器 id 选择器允许您设置具有 id 属性的 HTML 元素的样式，而不管它们在文档树中的位置如何。 以下是 id 选择器的示例： HTML 文件： <div id= \"intro\" > <p> This paragraph is in the intro section. </p> </div> <p> This paragraph is not in the intro section. </p> CSS 文件: # intro { color : white ; background-color : gray ; } 要选择具有特定 id 的元素，请使用井号 # 字符，然后使用元素的 id 跟随它。 类选择器以类似的方式工作。 主要区别在于 id 每页只能应用一次，而类可以根据需要在页面上多次使用。 在下面的示例中，具有\"first\"类的两个段落都将受到 CSS 的影响： HTML 文件： <div> <p class= \"first\" > This is a paragraph </p> <p> This is the second paragraph. </p> </div> <p class= \"first\" > This is not in the intro section </p> <p> The second paragraph is not in the intro section. </p> CSS 文件： .first { font-size : 200 % ;} 要选择具有特定类的元素，请使用句点 . 字符，后跟类的名称。不要用数字开始一个类或 id 名称。 4.3 后代选择器 这些选择器用于选择作为另一个元素的后代的元素。 选择级别时，您可以根据需要选择多个级别。 例如，要仅定位\"intro\"部分第一段中的 <em> 元素： HTML 文件： <div id= \"intro\" > <p class= \"first\" > This is a <em> paragraph. </em></p> <p> This is the second paragraph. </p> </div> <p class= \"first\" > This is not in the intro section. </p> <p> The second paragraph is not in the intro section. </p> CSS 文件： # intro . first em { color : pink ; background-color : gray ; } 后代选择器匹配作为指定元素后代的所有元素。 5. 注释 注释用于解释你的代码，浏览器会忽略。 /* Comment goes here */ 6. 层叠 网页的最终外观是不同样式规则的结果。形成层叠的三种主要风格来源是： 页面作者创建的样式表 浏览器的默认样式 用户指定的样式 继承是指属性在页面中流动的方式。 除非另有定义，否则子元素通常会采用父元素的特征。","tags":"教程","url":"https://xutree.github.io/pages/2018/10/07/css_overview/"},{"title":"C++ Primer 第四章 表达式","text":"重载运算符时，其包括运算对象的类型和返回值的类型，都是由该运算符定义的；但是运算对象的个数、运算符的优先级和结合律都是无法改变的。 4.1 左值和右值 当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。 一个重要的原则：在需要右值的地方可以用左值来代替，但是不能把右值当成左值（也就是位置）使用。当一个左值被当成右值使用时，实际使用的是它的内容（值）。 要用到左值的运算符： 赋值运算符需要一个左值作为其左侧运算对象，得到的结果也仍然是一个左值 取地址符作用于一个左值运算对象，返回一个指向该运算对象的指针，这个指针是一个右值 内置解引用运算符、下标运算符、迭代器解引用运算符、 string 和 vector 的下标运算符的求值结果都是左值 内置类型和迭代器的递增递减运算符作用于左值运算对象 4.2 求值顺序 优先级规定了运算对象的组合方式，但是没有说明运算对象按照什么顺序求值。对于那些没有指定执行顺序的运算符来说，如果表达式指向并修改了同一个对象，将会引发错误并产生未定义的行为。 例如，下面的输出表达式是未定义的，我们无法推测编译器是先求 ++i 还是先输出： int i = 0; cout << i << \" \" << ++i << endl; //未定义的 有4种运算符明确规定了运算对象的求值顺序。&&、||、?:、和逗号（，）运算符。 对于f()+g()*h()+j()的表达式： 优先级规定，g() 的返回值和 h() 的返回值相乘 结合律规定，f() 的返回值先与 g() 和 h() 的乘积相加，所得结果再与 j() 的返回值相加 对于这些函数的调用顺序没有明确规定 如果 f、g、h 和 j 是无关函数，它们既不会改变同一对象的状态也不执行 IO 任务，那么函数的调用顺序不受限制。反之，如果其中某几个函数影响同一对象，则它是一条错误的表达式，将产生未定义的行为 4.3 算术运算符 +(正号)、-(负号)、*(乘)、/(除),%(求余)，+(加)、-(减) 算术运算符的运算对象和求值结果都是右值。 一元正号负号运算符对运算对象作用后，返回一个（提升后的）副本： int i = 1024; int k = -i; bool b = true; bool b2 = -b; //b2 是 true 对大多数运算符来说，布尔类型的运算对象将被提升为 int 类型。如上，b 参与运算时被提升成整数值1，对它求负-1，转换为布尔值将其作为 b2 的初始值。 在除法运算中，如果两个运算对象的符号相同则商为正，否则商为负。C++ 语言的早期版本允许结果为负值的商向上或向下取整，C++11 新标准则规定商一律向0取整（即直接切除小数部分）。 4.4 逻辑和关系运算符 运算对象和求值结果都是右值；短路求值；进行比较运算符时，除非比较的对象是布尔类型，否则不要使用布尔字面值 true 和 false 作为运算对象 4.5 赋值运算符 赋值运算符的左侧运算对象必须是一个可修改的左值 赋值运算的结果是它的左侧运算对象，并且是一个左值，结果的类型就是左侧运算对象的类型 如果赋值运算符的左右两个运算对象类型不同，则右侧运算对象将转换成左侧运算对象的类型 赋值运算满足右结合律：ival = jval = 0； 4.6 ++ 和 -- 运算符 前置版本将对象本身作为左值返回，后置版本则将对象原始值的副本作为右值返回 建议：除非必须，否则不用递增递减算符的后置版本 后置递增运算符的优先级高于解引用运算符，因此 *pbeg++ 等价于 *(pbeg++)，pbeg++ 把 pbeg 的值加1，然后返回 pbeg 的初始值的副本作为其求值结果 4.7 成员访问运算符 由于解引用运算符的优先级低于逗号运算符，因此要对解引用运算符加括号 箭头运算符作用于一个指针类型的运算对象，结果是一个左值 点运算符分成两种情况：如果成员所属的对象是左值，那么结果就是左值；反之，如果成员所属的对象是右值，那么结果是右值 4.8 条件运算符 当条件运算符的两个表达式都是左值或者能转换成同一种左值类型时，运算的结果是左值；否则运算的结果是右值 条件运算符满足右结合律 4.9 位运算符 位运算符作用于整数类型的运算对象 关于符号位如何处理没有明确的规定，所以强烈建议仅将位运算符作用于处理无符号类型 移位运算符 首先令左侧运算对象的内容按照右侧运算对象的要求移动指定位数，然后将经过移动的（可能还进行了提升）左侧运算对象的拷贝作为求值结果。其中，右侧的运算对象一定不能为负，而且值必须严格小于结果的位数，否则就会产生未定义的行为。移出边界之外的位就被舍弃掉了 移位运算符满足左结合律 移位运算符的优先级比算术运算符低，比关系运算符、赋值运算符和条件运算符高 4.10 sizeof运算符 sizeof 运算符返回一条表达式或一个类型名字所占的字节数。 sizeof 运算符满足右结合律，其所得的值是一个 size_t 类型的常量表达式 两种形式 sizeof (type) sizeof expr sizeof 并不直接计算其运算对象的值。 对于 sizeof *p ： 因为 sizeof 满足右结合律并且与 * 的运算符的优先级一样，所以表达式按照从右到左的顺序结合，等价于： sizeof (*p) 其次，因为 sizeof 不实际求运算对象的值，所以即使 p 是一个无效（即未初始化）的指针也不会有什么影响 在 sizeof 的运算对象中解引用一个无效的指针仍然是一种安全的行为，因为指针实际上并没有被真正使用 sizeof 运算符的结果部分地依赖于其作用的类型： 对 char 或者类型为 char 的表达式执行 sizeof 运算，结果得1 对引用类型执行 sizeof 运算得到被引用对象所占空间的大小 对指针执行 sizeof 运算得到指针本身所占空间的大小 对解引用指针执行 sizeof 运算得到指针指向的对象所占空间的大小，指针不需有效 对数值执行 sizeof 运算符得到整个数组所占空间的大小。 sizeof 运算不会把数组转换成指针来处理 对 string 对象或者 vector 对象执行 sizeof 运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。即只取决于里面存放的数据类型，与元素的个数无关，是个编译器相关的值 4.11 逗号运算符 首先对左侧的表达式求值，然后将求值结果丢弃掉。逗号表达式真正的结果是右侧表达式的值。如果右侧运算对象是左值，那么最终的求值结果也是左值。 4.12 类型转换 4.12.1 何时发生隐式类型转换 在大多数表达式中，比 int 类型小的整数值首先提升为较大的整数类型 在条件中，非布尔值转换成布尔类型 初始化过程中，初始值转换成变量的类型；在赋值语句中，右侧运算对象装换成左侧运算对象的类型 如果算术运算或关系运算的运算对象有多种类型，需要转换成同一种类型 函数调用时也会发生类型转换 数组转换成指针（当数组被用作 decltype 关键字的参数，或者作为取地址符、 sizeof 即 typeid 等运算符的运算对象时，上述转换不会发生，如果用一个引用来初始化数组，上述转换也不会发生） 4.12.2 指针的转换 常量整数值0或者字面值 nullptr 能转换成任意指针类型 指向任意非常量的指针能转换成 void * 指向任意对象的指针能转换成 const void * 转换成常量：允许将指向非常量类型的指针转换成指向相应的常量类型的指针，对于引用也是这样。相反的转换并不存在，因为它试图删掉底层 const 4.12.3 类类型定义的转换 类类型能定义由编译器自动执行的转换，不过编译器每次只能执行一种类类型的转换，如果同时提出多个转换请求，这些请求将被拒绝 之前遇到过的类类型转换 string s, t = \"a value\"; //字符串字面值转换成 string 类型 wile( cin >> s) //while 的条件部分把 cin 转换成布尔值 4.12.4 显示转换 虽然有时不得不使用强制类型转换，但这种方法本质上是非常危险的。 4.12.5 命名的强制类型转换 一个命名的强制类型转换具有如下格式： cast-name<type>(expression); type 是转换的目标类型。如果 type 是引用类型，则结果是左值；expression 是要转换的值；cast-name 是 static_cast 、 dynamic_cast 、 const_cast 和 reinterpret_cast 中的一种。 dynamic_cast 支持运行时类型识别。 4.12.6 static_cast 任何具有明确定义的类型转换，只要不包含底层 const ，都可以使用 static_cast 。当需要把一个较大的算术类型赋给较小的类型时， static_cast 非常有用。此时，强制类型转换告诉程序的读者和编译器：我们知道并且不在乎潜在的精度损失。 static_cast 对于编译器无法自动执行的类型转换也非常有用。例如，我们可以使用它找回 void * 指针中的值: void *p = &d; double *dp = static_cast<double *>(p); 4.12.7 const_cast const_cast 只能改变运算对象的底层 const : const char *pc; char *p = const_cast<char*>(pc);//正确，但通过p写值是未定义的行为 只有 const_cast 能改变表达式的常量属性。 4.12.8 reinterpret_cast einterpret_cast 通常为运算对象的位模式提供较低层次上的重新解释。 假如有以下转换： int *ip; char *pc = reinterpret_cast<char*>(ip); 我们必须牢记 pc 所指的真实对象是一个 int 而非字符，如果把 pc 当成普通的字符指针使用就可能在运行时发生错误。 string str(pc); //可能导致异常的运行时行为 reinterpret_cast 本质上依赖于机器。要想安全地使用 reinterpret_cast 必须对涉及的类型和编译器实现转换的过程都非常了解。 强制类型转换干扰了正常的类型检查，因此强烈建议避免使用强制类型转换。 4.12.9 旧式的强制类型转换 在早期版本的 C++ 语言中，显示地进行强制类型转换包含两种形式： type (expr); //函数形式的强制类型转换 (type) expr; //C 语言风格的强制类型转换 根据所设计的类型不同，旧式的强制类型转换分别具有与 const_cast ， static_cast 或 reinterpret_cast 相似的行为。当我们在某处执行旧式的强制类型转换时，如果换成 const_cast 和 static_cast 也合法，则其行为与相应的命名转换一致。如果替换后不合法，则旧式强制类型转换执行与 reinterpret_cast 类似的功能。 char *pc = (char*) ip; //ip是指向整数的指针 上述代码的效果与 reinterpret_cast 一样。","tags":"读书笔记","url":"https://xutree.github.io/pages/2018/10/07/C++_Primer_Chapter_4/"},{"title":"C++ Primer 第三章 字符串、向量和数组","text":"string 表示可变长的字符数组。 vector 存放的是某种给定类型对象的可变长序列。 数组和其他内置类型一样，实现与硬件密切相关，在灵活性上稍显不足。 命名空间 using 声明： using namespace::name; 例如： using std::cin; 。 头文件不应包含 using 声明，防止名字冲突。 3.1 标准库类型 string 3.1.1 头文件和声明 #include <string> using std :: string ; 3.1.2 定义和初始化 string s1; //默认初始化，空字符串 string s2 = s1; //s2是s1的副本，等价于 s2(s1) string s3 = \"hiya\"; //s3是字符串字面值的副本，等价于s3(\"hiya\") string s4(10, 'c'); //s4的内容是cccccccccc 3.1.3 string 对象上的操作 操作 意义 os << s 将 s 写到输出流 os 中，返回 os is >> s 从 is 中读取字符串赋给 s，字符串以空白分隔，返回 is getline(is, s) 从 is 中读取一行赋给 s，返回 is s.empty() s 为空返回 true，否则返回 false s.size() 返回 s 中字符的个数 s[n] 返回 s 中第 n 个字符的引用，位置 n 从0记起 s1 + s2 返回连接后的结果 s1 = s2 用 s2 的副本代替 s1 s1 == s2 如果 s1 和 s2 中所含的字符完全一样，则他们相等 s1 != s2 string 对象的相等性判断对大小写敏感 <, <=, >, >= 利用字符在字典里的顺序进行比较，大小写敏感 3.1.4 读取未知数量的 string 对象 int main() { string word; while (cin >> word) cout << word << endl; return 0; } 直到遇到结束标记或者非法输入才会停止 3.1.5 使用 getline 读取一整行 int main() { string line; while (getline(cin,line)) cout << line << endl; return 0; } getline 函数的参数是一个输入流和一个 string 对象， getline 从给定的输入流中读入内容，直到遇到换行符为止（注意换行符也被读进来了），然后把所读的内容存入 string 对象中（注意不存换行符）。如果输入一开始就是换行符，那么所得的结果是个空 string 。 3.1.6 string::size_type 类型 是一个无符号类型的值。如果一个表达式中已经有 size 函数就不要再使用 int 了，这样可以避免混用 int 和 unsigned 可能带来的问题。 string 对象可以和字符字符串字面值相加，只要保证 + 号两侧的运算对象至少有一个 string 对象即可。 由于某些历史原因，也为了和 C 兼容，所以 C++ 中的字符串字面值并不是标准库 string 类型。 3.1.7 处理 string 对象里的字符 包含在 cctype 头文件中： 函数 意义 isalunm(c) 当 c 是字母或数字时为真 isalpha(c) 当 c 是字母时为真 iscntrl(c) 当 c 是控制字符时为真 isdigit(c) 当 c 是数字时为真 isgraph(c) 当 c 不是空格但可打印时为真 islower(c) 当 c 是小写字母时为真 isprint(c) 当 c 是可打印字符时为真（即 c 是空格或 c 具有可视形式） ispunct(c) 当 c 是标点符号时为真（即 c 不是控制字符、数字、字母、可打印空白中的一种） isspace(c) 当 c 是空白时为真（即 c 是空格、横向制表符、纵向制表符、回车符、换行符、进纸符中的一种） isupper(c) 当 c 是大写字母时为真 isxdigit(c) 当 c 是十六进制数字时为真 tolower(c) 输出 c 的小写 toupper(c) 输出 c 的大写 C++ 标准库除了定义 C++ 语言特有的功能外，也兼容了 C 语言的标准库。C 语言的头文件形如 name.h，C++ 则将这些文件命名为 cname。因此 cctype 头文件和 ctype.h 头文件的内容是一样的，只不过从命名规范上来讲更符合 C++ 语言的要求。特别地，在名为 cname 的头文件中定义的名字从属于命名空间 std 。 3.1.8 范围 for for (declaration: expression) statement expression 是一个对象，用于表示一个序列；declaration 负责定义一个变量，该变量将被用于访问序列中的基础元素，每次迭代，declaration 部分的变量会被初始化为 expression 部分的下一个元素值。 使用范围for输出 string str(\"some string\"); for (auto c : str) cout << c << endl; 使用范围for修改 string s(\"Hello World!\"); for (auto &c : s) c = toupper(c); cout << s << endl; 3.1.9 下标运算符 [ ] [ ]接收的输入参数是 string:size_type 类型的值，这个参数表示要访问的字符的位置，返回值是该位置上字符的引用。 string 对象的下标必须大于等于0而小于 s.size() 。 3.2 标准库类型 vector vector 表示对象的集合，其中所有对象的类型都相同，也常被称作容器，是一种类模板 #include <vector> using std :: vector ; 编译器根据模板创建类或函数的过程称为实例化，对于类模板，我们通过提供一些额外信息来指定模板到底实例化成什么样的类：在模板名字后面跟一对尖括号，在括号内放上信息 vector<int> ivec; vector<Sales_item> Sales_vec; vector<vector<string>> file; 在早期版本的 C++ 标准中如果 vector 的元素还是 vector （或者其他模板类型），则其定义的形式与现在的 C++11 新标准略有不同。过去，必须在外层 vector 对象的右尖括号和其元素类型之间添加一个空格，如应写成 vector<vector<int> > 3.2.1 初始化 默认初始化。 列表初始化。 值初始化：通常情况下，可以只提供vector对象容纳的元素数量而略去初始值。此时库会创建一个值初始化的元素初值，并把它赋给容器中的所有元素。这个初值由vector对象中元素的类型决定。内置类型：0；类类型：由类默认初始化。 3.2.2 添加元素 push_back ：负责把一个值当成 vector 对象的尾元素压到 vector 对象的尾端 vector<int> v2; for (int i = 0; i != 100; ++i) v2.push_back(i); 如果循环内部包含有向 vector 对象添加元素的语句，则不能使用范围 for 循环。 3.2.3 其他vector操作 函数 含义 v.empty() 如果 v 不含有任何元素，返回真；否则返回假 v.size() 返回 v 中元素的个数 v.push_back(t) 向 v 的尾端添加一个值为 t 的元素 v[n] 返回 v 中第 n 个位置上元素的引用 v1 = v2 用 v2 中的元素拷贝替换 v1 中的元素 v1 = 用列表中元素的拷贝替换 v1 中的元素 v1 == v2 v1 和 v2 相等当且仅当它们的元素数量相同且对应位置的元素值都相同 v1 != v2 <,<=,>,>= 以字典顺序进行比较 3.2.4 vector 的 size_type vector<int>::size_type //正确 vector::size_type //错误 和 string 一样， vector 对象的下标也是从0开始计算， vector 对象（以及 string 对象）的下标运算符可用于访问已存在的元素，而不能用于添加元素。 3.3 迭代器 所有标准库容器都可以使用迭代器，但只有少数的几种才同时支持下标运算符。 严格来讲， string 不属于容器类型，但是 string 支持很多与容器类型相似的操作。 vector 支持下标运算符，这点和 string 一样。 和指针不一样，获取迭代器不是使用取地址符，有迭代器的类型同时拥有返回迭代器的成员。 begin 和 end ： auto b = v.begin(), e = v.end(); 。 end 成员负责返回指向容器\"尾元素的下一位置\"的迭代器。常被称作尾后迭代器或尾迭代器。 如果容器为空，则 begin 和 end 返回的是同一个迭代器，都是尾后迭代器。 3.3.1 标准容器迭代器的运算符 符号 含义 *iter 返回迭代器 iter 所指元素的引用 iter->mem 解引用 iter 并获取该元素的名为 mem 的成员，等价于(*iter).mem ++iter 令 iter 指向容器中的下一个元素 --iter 令 iter 指向容器中的上一个元素 iter1 == iter2 判断两个迭代器是否相等 iter1 != iter2 如果指向同一元素或者他们是同一容器的尾后迭代器 因为 end 返回的迭代器并不实际指向某个元素，所以不能对其进行递增或解引用操作。C++ 程序员习惯性地使用 != ，其原因和他们更愿意使用迭代器而非下标的原因一样：这种编程风格在标准库提供的所有容器上都有效，因为所有标准库容器都定义了 == 和 != 。 3.3.2 迭代器类型 拥有迭代器的标准库类型使用 iterator 和 const_iterator 来表示迭代器的类型 vector < int > :: iterator it ; // it 能读写 vector < int > 的元素 string :: iterator it2 ; // it2 能读写 string 对象中的元素 vector < int > const_iterator it3 ; // it3 只能读元素 ， 不能写元素 string :: const_iterator it4 ; // it4 只能读字符 ， 不能写字符 begin 和 end 返回的具体类型由对象是否是常量决定，如果对象是常量， begin 和 end 返回 const_iterator ；如果对象不是常量，返回 iterator 。如果对象只需读操作而无需写操作的话最好使用常量类型迭代器。为了专门得到 const_iterator ，C++11 标准引入两个新函数： cbegin 和 cend 。任何一种可能改变容器容量的操作，都会是迭代器失效。 3.3.3 迭代器运算 string 和 vector 的迭代器提供了更多额外的运算符： iter + n ：迭代器加上一个整数值仍得到一个迭代器，迭代器指示的新位置与原来相比向前移动了若干个元素。结果迭代器或者指示容器内的一个元素，或者指示容器尾元素的下一位置。 iter - n ：迭代器减去一个整数值仍得一个迭代器，迭代器指示的新位置与原来相比向后移动了若干位置。结果迭代器或者指示容器内的一个元素，或者指示容器尾元素的下一位置。 iter1 - iter2 ：两个迭代器相减的结果是它们之间的距离，也就是说，将运算符右侧的迭代器向前移动差值个元素后将得到左侧的迭代器。参与运算的两个迭代器必须指向的是同一容器中的元素或者尾元素的下一位置。 >, >=, <, <= ：迭代器的关系运算符，如果迭代器指向的容器位置在另一个迭代器所指位置之前，则说前者小于后者。 3.4 数组 因为数组的大小固定，因此在对某些特殊的应用来说程序的运行时性能较好，但是相应的也损失了一些灵活性。 数组的维度必须是一个常量表达式。 默认情况下数组的元素被默认初始化。 和内置类型的变量一样，如果在函数内部定义了某种内置类型的数组，那么默认初始化会令数组含有未定义的值。 定义数组的时候必须指定数组的类型，不允许用auto关键字由初始值的列表推断类型。 字符数组可以利用字符串字面值初始化，此时注意字符串字面值末尾的空字符，也会被拷贝到字符数组中。 不允许拷贝和赋值。一些编译器支持数组的赋值，这就是所谓的编译器扩展，但一般来说，最好避免使用非标准特性，因为可能在其他编译器上无法正常工作。 理解复杂的数组声明：由内向外阅读 int *ptrs[10]; //ptrs 是含有10个整型指针的数组 int (*Parray)[10] = &arr; //Parray 是指针，指向一个含有10个整数的数组 int (&arrRef)[10] = arr; //arrRef 是引用，引用一个含有10个整数的数组 int *(&arry)[10] = ptrs; //arry 是引用，引用一个含有10个整型指针的数组 3.4.1 访问数组元素 数组的索引从0开始。 在使用数组下标的时候，通常将其定义为 size_t 类型。 size_t 是一种机器相关的无符号类型，它被设计的足够大以便能表示内存中任意对象的大小。 在 cstddef 头文件中定义了 size_t 类型，这个文件是 C 标准库 stddef.h 头文件的 C++ 版本。 使用数组的时候编译器一般会把它转换成指针。 通常情况下，使用取地址符来获取指向某个对象的指针，取地址符可以用于任何对象。数组的元素也是对象，对数组使用下标运算符得到该数组指定位置的元素，对数组元素应用取地址符就能得到指向该元素的指针。 数组还有一个特性：在很多时候用到数组名字的地方，编译器都会自动地将其替换为一个指向数组首元素的指针 string *p2 = nums; //等价于 p2 = &nums[0] 所以如果使用数组作为一个auto变量的初始值时，推断的类型是指针而非数组 int ia[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9,}; auto ia2(ia); // ia2 是一个整型指针，指向 ia 的第一个元素 ia2 = 42; //错误，ia2 是一个指针，不能用 int 赋值 当使用 decltype 关键字时上述转换不会发生， decltype(ia) 返回的类型是由10个整数构成的数组 decltype(ia) ia3 = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; ia3 = p; //错误，不能用整型指针给数组赋值 ia3[4] = i; //正确：把 i 的值赋给 ia3 的一个元素 为了让指针的使用更简单、更安全，C++11 新标准引入两个名为 begin 和 end 的函数，不过数组毕竟不是类类型，因此这两个函数不是成员函数。正确的使用形式是将数组作为它们的参数 int ia[] = {1, 2, 3, 4, 5, 6, 7, 8, 9}; int *beg = begin(ia); int *last = end(ia); begin 函数返回指向 ia 首元素的指针， end 函数返回指向 ia 尾元素下一位置的指针，这两个函数定义在 iterator 头文件中 两个指针相减结果的类型是一种名为 ptrdiff_t 的类型，和 size_t 一样，它也是定义在 cstddef 头文件中的机器相关的类型。因为差值可能是负值，所以它是一种带符号类型。 内置的下标运算符所用的索引值不是无符号类型，这一点和 vector 和 string 不一样 int *p = &ia[2]; int k = p[-2]; //k 是 ia[0] 那个元素 3.4.2 C 风格字符串 按此习惯书写的字符串存放在字符数组中并以空字符结束。 C 语言标准库提供了一组函数用于操作 C 风格字符串，它们定义在 cstring 头文件中，cstring 是 C 语言头文件 string.h 的 C++ 版本。 3.4.3 与旧代码的接口 任何出现字符串字面值的地方都可以用空字符结尾的字符数组来代替。不能用string对象直接初始化指向字符的指针，为了完成该功能，string专门提供了一个名为c_str的成员函数 char *str = s; //错误，不能用 string 对象初始化 char* const char *str = s.c_str(); //正确 我们无法保证 c_str 函数返回的数组一直有效，事实上，如果后续的操作改变了 s 的值就可能让之前返回的数组失去效用 使用数组初始化 vector 对象 int int_arr[] = {0, 1, 2, 3, 4, 5}; vector<int> ivec(begin(int_arr),end(int_arr)); 现代的 C++ 程序员应当尽量使用 vector 和迭代器，避免使用内置的数组和指针，应该尽量使用 string ，避免使用 C 风格的基于数组的字符串。 多维数组：要使用范围 for 语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型。 缓冲区溢出：主要原因是试图通过一个越界的索引访问容器内容。 difference_type ：由 string 和 vector 定义的一种带符号整数类型，表示两个迭代器之间的距离。","tags":"读书笔记","url":"https://xutree.github.io/pages/2018/10/06/C++_Primer_Chapter_3/"},{"title":"C++ Primer 第二章 变量和基本类型","text":"2.1 类型 下表列出了 C++ 标准规定的数据类型尺寸的最小值，同时允许编译器赋予这些类型更大的尺寸 类型 含义 最小尺寸 bool 布尔类型 未定义 char 字符 8位 wchar_t 宽字符 16位 char16_t Unicode 字符 16位 char32_t Unicode 字符 32位 short 短整型 16位 int 整型 16位 long 长整型 32位 long long 长整型 64位 float 单精度浮点数 6位有效数字 double 双精度浮点数 10位有效数字 long double 扩展精度浮点数 10位有效数字 一个 char 的空间应确保可以存放机器基本字符集中任意字符对应的数字值。也就是说，一个 char 的大小和一个机器字节一样。 wchar_t 类型用于确保可以存放机器最大扩展字符集中的任意一个字符。 C++ 语言规定，一个 int 至少和一个 short 一样大，一个 long 至少和一个 int 一样大，一个 long long 至少和一个 long 一样大。 可寻址的最小内存块成称为\"字节（byte）\"，存储的基本单元称为\"字（word）\"，它通常有几个字节组成。 在 C++ 语言中，一个字节至少能容纳机器基本字符串中的字符。大多数机器的字节由8比特构成，字则由32或64比特构成，也就是4字节或8字节。 C++ 标准指定了一个浮点数有效位数的最小值，然而大多数编译器都实现了更高的精度。通常， float 以1个字（32比特）来表示， double 以2个字（64位）来表示， long double 以3或4个字（96或128比特）来表示。一般来说， float 和 double 分别有7和16个有效位；类型 long double 则常常被用于有特殊浮点要求的硬件，它的具体实现不同，精度也各不相同。 类型 int 、 short 、 long 和 long long 都是带符号的，通过在这些类型名前添加 unsigned 就可以得到无符号类型。 char 、 signed char 和 unsigned char ， char 是否等于 signed char 由编译器决定。 C++ 标准并没有规定带符号类型应如何表示，但是约定了在表示范围内正值和负值的量应该平衡。因此，8比特的 signed char 理论上可以表示-127至127区间内的值，大多数现代计算机将实际的表示范围定为-128至127。 2.2 如何选择类型 明知数值不可能为负数，选用无符号类型。 如果数值超过了 int 的表示范围，选用 long long ，因为 long 一般和 int 有一样的尺寸。 算术表达式中不要使用 bool 或 char 。 执行浮点数运算选用 double 。因为 float 通常精度不够而且计算代价相差无几。 long double 提供的精度一般情况下是没有必要的而且计算代价大。 2.3 类型转换 非布尔 -> 布尔：0 -> false ，其他 -> ture 。 布尔 -> 非布尔： false -> 0， ture -> 1。 浮点 -> 整型：仅保留小数点前。 整型 -> 浮点：小数部分记为0，如果该整数所占的空间超过浮点类型的容量，精度可能损失。 当我们赋给无符号类型一个超过它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。 当我们赋给带符号类型一个超出它表示范围的值时，结果是未定义的。此时，程序可能继续工作、可能崩溃，也可能生成垃圾数据。 当一个算术表达式中既有无符号数又有 int 值时，那个 int 会转换成无符号数。把 int 转换成无符号数的过程和把 int 赋值给无符号变量一样。 当从一个无符号数中减去一个值时，我们必须确保结果不是负值，否则实际结果会是取模后的值。 2.4 字面值常量 整型和浮点型字面值。 字符和字符串字面值： ‘a' 和\"a\"，字符串字面值最后补'\\0' 如果两个字符串字面值位置紧邻且仅由空格、缩进和换行分隔，则它们是一个整体 布尔字面值： true 、 false 。 指针字面值： nullptr 。 2.5 指定字面值的类型 字符和字符串字面值 前缀 类型 u char16_t U char32_t L wchar_t u8 char 整型字面值 后缀 最小匹配类型 u 或 U unsigned l 或 L long ll 或 LL long long 浮点型字面值 后缀 类型 f 或 F float l 或 L long double 2.6 列表初始化 int units_sold{0} 列表初始化的重要特点：如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将报错。 2.7 默认初始化 内置类型变量 定义于任何函数之外，初始化为0 定义于函数体内的局部静态变量，初始化为0 定义于函数体内的非局部静态变量，不被初始化，试图拷贝或以其他方式访问此类值将引发错误 每个类各自决定其初始化对象的方式。 2.8 分离式编译 将程序分割为若干个文件，每个文件可被独立编译 2.9 声明 extern int i; extern 语句如果包含初始值就不再是声明，而变成定义了： extern int i = 0; 在函数体内部，试图初始化一个由 extern 关键字标记的变量将引发错误。 静态类型语言：在编译阶段执行类型检查 2.10 C++ 标识符 字母、数字、下划线，必须以字母或下划线开头，长度无限制，大小写敏感。 C++ 为标准库保留了一些名字 自定义标识符中不能连续出现两个下划线 不能以下划线紧接大写字母开头 定义在函数体外的函数不能以下划线开头 2.11 作用域操作符 :: 若左侧为空，则指代全局作用域 2.12 复合类型 2.12.1 引用 int &b = a; b指向a。 引用必须初始化。 引用本身不是一个对象，不能定义引用的引用。 引用必须绑定到对象上，不能绑定到字面值或者某个表达式的计算结果上。 除了两种例外，所有引用的类型都要和它所绑定的对象严格匹配： 初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可 允许将基类的引用绑定到派生类上 2.12.2 指针 int *b = &a; 。 指针是一个对象。 在块作用域内定义的指针如果未初始化，将拥有一个不确定的值。 除了两种例外，所有指针的类型都要和它所指向的对象严格匹配： 允许一个指向常量的指针指向一个非常量对象 允许将基类的指针绑定到派生类上 试图拷贝或以其他方式访问无效指针的值将引起错误，编译器不负责检查此类错误。 任何非零的指针对应的条件值都是true。 合法指针可以比较大小：== 或 !=。 void * 是一个特殊的指针类型，可用于存放任意对象的地址，只支持有限的操作： 拿它和别的指针比较 作为函数的输入或输出 赋给另外一个 void * 指针 2.13 理解复合类型的声明 变量的定义包括一个基本数据类型和一组声明符。 一条定义语句可能定义出不同类型的变量： int i = 1024, *p = &i, &r =i; 。 面对一条比较复杂的指针或者引用的声明语句时，从右往左阅读有助于弄清楚它的真实含义，例如： int \\*&r; 首先 r 是一个引用，其次 r 是一个指针的引用，再次 r 是一个指向整型指针的引用。 2.14 const 限定符 因为 const 对象一旦创建就无法改变其值，所以必须初始化。 当用一个对象去初始化另外一个对象，它们是不是 const 都无关紧要，常量的特性仅仅在执行改变其值的操作时才会发挥作用。 默认情况下， const 对象仅在文件内有效。 如果想在多个文件之间共享 const 对象，必须在变量的定义之前添加 extern 关键字。 const 的引用，常量引用的初始化：初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。尤其，允许为一个常量引用绑定非常量的对象、字面值甚至是一个表达式。实际上是通过绑定到一个临时量对象上实现的。 对 const 的引用可能引用一个并非 const 的对象，常量引用仅对引用可参与的操作做了限制，对于引用的对象本身是不是常量未做限制。 2.15 指针和 const 2.15.1 指向常量的指针 允许一个指向常量的指针指向一个非常量对象。 仅对指向常量的指针可参与的操作做了限制，对于指向的对象本身是不是常量未做限制。 2.15.2 const 指针 指针是对象，可以把指针本身定为常量。 常量指针必须初始化，一经初始化就不能再改变。 把*放在 const 关键字之前说明指针是一个常量。 2.15.3 顶层和底层 const 顶层 const ：指针本身是个常量。 底层 const ：指针所值的对象是一个常量。 更一般的，顶层 const 可以表示任意的对象是常量，这一点对任意数据类型都适用。底层 const 则与指针和引用等复合类型的基本类型部分有关。 执行对象的拷贝操作时，顶层 const 不受影响；拷入和拷出的对象必须具有相同的底层 const 资格，或者两个对象的数据类型必须能够转换。一般来说，非常量可以转换成常量，反之不行。 2.15.4 constexpr 和常量表达式 常量表达式：值不会改变并且在编译过程就能得到计算结果的表达式。 constexpr 变量：由编译器来验证变量的值是否是一个常量表达式，声明为 constexpr 的变量一定是一个常量，并且必须用常量表达式初始化。 字面值类型：算术类型、引用、指针、字面值常量类、枚举。 声明 constexpr 用到的类型为字面值类型。 一个 constexpr 指针的初始值必须是 nullptr 或者0，或者是存储于某个固定地址中的对象： 函数体内定义的变量一般并非存放在固定地址中， constexpr 指针不能指向这样的变量（局部静态对象除外） 定义于所有函数体之外的对象地址固定不变，能用来初始化 constexpr 指针 在 constexpr 声明中如果定义了一个指针，限定符 constexpr 仅对指针有效，与指针所指的对象无关。 constexpr 把它所定义的对象置为顶层 const 。 2.16 处理类型 2.16.1 类型别名 typedef double wages; using SI = Sales_item; 2.16.2 auto 类型说明符 让编译器自己去分析表达式所属的类型。 auto 也能在一条语句中声明多个变量。因为一条声明语句只能有一个基本数据类型，所以该语句中所有变量的基本数据类型都必须一样。 当引用被用作初始化 auto 变量时，编译器以引用所引用对象的类型作为 auto 的类型。 auto 一般会忽略顶层 const ，同时底层 const 会保留下来。 如果希望推断出的 auto 类型是一个顶层 const ，需要明确指出。 auto 引用 auto &b = a; 初始值 a 的顶层 const 会保留。 2.16.3 decltype 类型指示符 选择并返回操作数的数据类型，编译器分析表达式得到它的类型，却不实际计算表达式的值，编译器并不实际调用f。 如果 decltype 使用的表达式是一个变量，则 decltype 返回该变量的类型（包括顶层 const 和引用在内），需要指出的是，引用从来都作为其所指对象的同义词出现，只有在 decltype 处是一个例外。 如果 decltype 使用的表达式不是一个变量，则 decltype 返回该表达式的结果对应的类型： 因为 r 是一个引用， decltype(r) 的结果是引用类型，如果想让结果类型是 r 所指的类型，可以把 r 作为表达式的一部分，显然这个表达式的结果是一个具体的值而非一个引用 如果表达式的内容是解引用操作，则 decltype 将得到引用类型 如果 decltype 使用的表达式是一个变量： 不加括号，得到该变量的类型 加括号，得到引用类型 2.17 自定义数据结构：结构体和类 记得定义末尾的分号。可以类内初始化。 2.18 头文件保护符 头文件保护符依赖于预处理变量。 预处理变量由两个状态：已定义和未定义。 #define 指令把一个名字设定为预处理变量。 #ifdef 当且仅当变量已定义时为真。 #ifndef 当且仅当变量未定义时为真。 一旦检查结果为真，则执行后续操作直到遇到 #endif 指令为止","tags":"读书笔记","url":"https://xutree.github.io/pages/2018/10/06/C++_Primer_Chapter_2/"},{"title":"利用 Mac stat 添加文件创建时间、最后修改时间","text":"Pelican 根据 .md 文件生成网页的时候需要 metadata，所以写个命令行自动添加文件创建时间、最后修改时间，这样写博客的时候只需要把 title、category 和 tags 标签填上就行了，其中用了 stat 命令。 1. 自动添加文件创建时间、最后修改时间 stat 命令的 a, m, c, B 参数分别代表上次访问或修改时间文件，上次更改 inode 的时间或 inode 的生成时间（ UNIX 时间戳），所以我们可以通过提取这些信息实现想要的功能。唯一需要注意的是，结果是UNIX时间戳，我们需要将其转换为普通时间。 UNIX 时间，或称 POSIX 时间是 UNIX 或类 UNIX 系统使用的时间表示方式：从协调世界时1970年1月1日0时0分0秒起至现在的总秒数，不考虑闰秒。在多数 UNIX 系统上 UNIX 时间可以通过 date +%s 指令来检查。 在 Mac 系统是由 UNIX 时间戳转化为普通时间的指令为： 所以我们\b先根据 stat 获得文件的创建时间： 然后转化为普通时间： \b以下为脚本： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #! /bin/bash # 输入：需要修改的文件 static = $1 # 提取创建时间 create_time = $( date -r $( stat -f \"%B\" $static ) \"+%Y-%m-%d %H:%M:%S\" ) # 提取修改时间 modify_time = $( date -r $( stat -f \"%m\" $static ) \"+%Y-%m-%d %H:%M:%S\" ) # 查找Date标签的行号 num1 = $( head -5 $static | grep -n 'Date' | cut -d \":\" -f 1 ) # 查找Modified标签的行号 num2 = $( head -5 $static | grep -n 'Modified' | cut -d \":\" -f 1 ) # 如果Date标签行号为空，说明不存在Date标签，则插入Date if [ -z \" $num1 \" ] ; then sed -i '' -e \"2s/&#94;//p; 2s/&#94;.*/Date: $create_time /\" $static fi # 如果Modified标签行号为空，插入Modified if [ -z \" $num2 \" ] ; then sed -i '' -e \"3s/&#94;//p; 3s/&#94;.*/Modified: $modify_time /\" $static else # 否则，替换Modified标签到最新时间 sed -i '' ${ num2 } d $static sed -i '' -e \"3s/&#94;//p; 3s/&#94;.*/Modified: $modify_time /\" $static fi 2. 附：stat 命令详情 stat 显示有关文件的信息。 不需要读取，写入或执行指定文件的权限，但必须可搜索通向该文件的路径名中列出的所有目录。 如果没有给出参数， stat 将显示有关标准输入的文件描述符（stdin）的信息。 当作为 readlink 调用时，仅打印符号链接的目标。 如果给定的参数不是符号链接，则 readlink 将不打印任何内容并退出并显示错误。 显示的信息是通过使用给定参数调用 lstat 系统调用并解释返回的结构来获得的。 2.1 参数 -F 与 ls 命令\b的 -F 参数一样，在作为目录的每个路径名之后显示斜杠（'/'），在每个可执行的路径名后面显示星号（'*'），在每个符号链接后显示at符号（'@'）， 在每个without文件后面显示百分号（'％'），每个套接字后显示等号（'='），以及在每个FIFO文件后面显示一个垂直条（'|'）。 -F 的使用意味着 -l -f format 使用指定的格式显示信息 -L 使用 stat 而不是 lstat 。 如果文件是符号链接，则stat给出的信息是链接文件目标文件的信息，而不是链接\b文件本身 -l 将输出以 ls -lT 格式显示，即显示文件的完整时间信息，包括月，日，小时，分钟，秒和年 -n 输出不强制换行 -q 如果对 stat 或 lstat 的调用失败，则不\b显示失败消息。以 readlink 方式运行时，会自动禁止错误消息 -r 显示原始信息。即，对于stat结构（UNIX/Linux系统中定义的结构体）中的所有字段，显示原始数值（例如，自纪元以来的秒数等） -s 在\"shell输出\"中显示信息，适用于初始化变量 -t timefmt 使用指定的格式显示时间戳。 此格式直接传递给 strftime 命令 -x 从某些Linux发行版中以更详细的方式显示信息 2.2 格式 格式字符串类似于 printf 格式，因为它们以 ％ 开头，然后是一系列格式化字符，最后是一个字符，用于选择要格式化的 struct stat 字段。 如果 ％ 后面紧跟 n，t，％ 或 @ 之一，则会打印换行符，制表符，百分号或当前文件号，否则将检查字符串是否包含以下内容： 以下是任何可选标志： # 为八进制和十六进制输出选择备用输出形式。 非零八进制输出将具有前导零，并且非零十六进制输出将具有前缀\"0x\" + 断言应始终打印指示数字是正数还是负数的符号。 非负数通常不打印带符号 - 将字符串输出对齐到字段的左侧，而不是右侧 0 将左边距的填充字\b符设置为\"0\"字符，而不是空格 space 在非负有符号输出字段的前面保留一个空格。 如果同时使用 ‘+' ，则 ‘+' 将覆盖空格 以下是任何可选字段： size 可选的十进制数字字符串，指定最小字段宽度 prec 由小数点'.'和十进制数字字符串组成的可选精度，指示最大字符串长度，浮点输出中小数点后出现的位数，或数字输出中显示的最小位数 fmt 可选的输出格式说明符，它是D，O，U，X，F 或 S 之一。它们分别表示带符号的十进制输出，八进制输出，无符号十进制输出，十六进制输出，浮点输出和字符串输出。 某些输出格式不适用于所有字段。 浮点输出仅适用于 timespec 字段（a，m 和 c 字段）。 特殊输出说明符S可用于指示输出（如果适用）应为字符串格式。 可与以下标志结合使用： amc 以 strftime 格式显示日期 dr 显示实际设备名称 gu 显示组或用户名 p 以 ls -lTd 显示文件模式 N 显示文件名 T 显示文件类型 Y 在输出中插入\" -> \"。 请注意， Y 的默认输出格式是字符串，但如果明确指定，则会预先添加这四个字符 sub 可选的子字段说明符（高，中，低）。仅适用于 p，d，r 和 T 输出格式。 它可以是以下之一： H \"高\"，指定来自 r 或 d 的设备的主要编号，来自 p 的字符串形式的权限的\"用户\"位，来自 p 的数字形式的文件\"type\"位，以及 T 的长输出形式 L \"低\"，指定来自 r 或 d 的设备的次要编号，来自 p 的字符串形式的权限的\"其他\"位，来自 p 的数字形式的\"用户\"，\"组\"和\"其他\"位， 当与 T 一起使用时，文件类型的 ls -F 样式输出字符（对此使用 L 是可选的） M \"中\"，指定 p 的字符串输出形式的权限的\"组\"位，或 p 的数字形式的 \"suid\"，\"sgid\" 和 \"sticky\" 位 datum 必填字段说明符，是以下之一： d 文件所在的设备 i 文件的inode编号 p 文件类型和权限 l 文件的硬链接数 u, g 文件所有者的用户ID和组ID r 字符和块设备专用文件的设备编号 a, m, c, B 上次访问或修改时间文件，上次更改 inode 的时间或 inode 的生成时间（UNIX时间戳） z 文件大小（以字节为单位） b 分配给文件的块数 k 最佳文件系统I / O操作块大小 f 用户定义的文件标志 v Inode 生成号 以下四个字段说明符不是直接从struct stat中的数据中提取的，而是： N 文件的名称 T 文件类型，类似 ls -F ，如果给出子字段说明符H，则采用更具描述性的形式。 Y 符号链接的目标 Z 从字符或块特殊设备的rdev字段扩展为\"major，minor\"，并为所有其他设备提供大小输出 只有 ％ 和字段说明符是必需的。大多数字段说明符默认为 U 作为输出形式；p 默认输出形式是 O；a、m、c 默认输出形式是 D，Y、T、N 默认输出形式是 S。","tags":"教程","url":"https://xutree.github.io/pages/2018/10/06/mac-stat/"},{"title":"C++ Primer 第一章 开始","text":"g++ -std=c++14 -Wall -o test test.cpp iostream cin cout cerr clog << 运算符返回其左侧的运算对象 写入 endl 的效果是结束当前行，并将与设备关联的缓冲区中的内容刷到设备中。缓冲刷新操作可以保证到目前为止程序所产生的所有输出都真正写入到输出流中，而不是仅停留在内存中等待写入流 小心程序崩溃，输出可能还留在缓冲区的情况，利用 endl 标准库定义的所有名字都在命名空间 std 中 当我们使用一个 istream 对象作为条件时，其效果是检测流的状态。流有效，即流未遇到错误，那么检测成功。当遇到文件结束符（end of file），或遇到一个无效输入时， istream 对象的状态会变为无效。无效的 istream 对象会使条件为假 文件结束符：Windows 先Ctrl + Z，后Enter 或 Return；UNIX：Ctrl +D 标准库文件通常不带后缀。编译器一般不关心头文件名的形式，但有的IDE对此有特定要求 头文件包含：标准库头文件 <> 非标准库头文件 \"\" 文件重定向：从文件读入\\<infile，输出到文件>outfile cerr (无缓冲标准错误) 没有缓冲，发送给它的内容立即被输出 clog (缓冲标准错误) 有缓冲，缓冲区满时输出 cout 标准输出 cout 是在终端显示器输出， cout 流在内存中对应开辟了一个缓冲区，用来存放流中的数据，当向 cout 流插入一个 endl ，不论缓冲区是否满了，都立即输出流中所有数据，然后插入一个换行符 cerr 流对象是标准错误流，指定为和显示器关联，和 cout 作用差不多，有点不同就是 cout 通常是传到显示器输出，但可以被重定向输出到文件，而 cerr 流中的信息只能在显示器输出 clog 流也是标准错误流，作用和 cerr 一样，区别在于 cerr 不经过缓冲区，直接向显示器输出信息，而 clog 中的信息存放在缓冲区，缓冲区满或者遇到 endl 时才输出 对于为什么有 cerr 和 clog ？比如，你的程序遇到调用栈用完了的威胁（无限，没有出口的递归。你说，你到什么地方借内存，存放你的错误信息？所以有了 cerr 。其目的，就是在你最需要它的紧急情况下，还能得到输出功能的支持 缓冲区的目的，就是减少刷屏的次数——比如，你的程序输出圣经中的一篇文章。不带缓冲的话，就会每写一个字母，就输出一个字母，然后刷屏。有了缓冲，你将看到若干句子\"同时\"就出现在了屏幕上（由内存翻新到显存，然后刷新屏幕）","tags":"读书笔记","url":"https://xutree.github.io/pages/2018/10/05/C++_Primer_Chapter_1/"},{"title":"Python 教程","text":"1. 开始之前 Python 提供了很多数据结构，也支持大型程序，远超 shell 脚本或批处理文件的功能。Python 还提供比 C 语言更多的错误检查，而且作为一种\"超高级语言\"，它有高级的内置数据类型，比如灵活的数组和字典。 Python 允许你划分程序模块，在其他的 Python 程序中重用。它内置了很多的标准模块，你可以在此基础上开发程序。 Python 是一种解释型语言，在程序开发阶段可以为你节省大量时间，因为不需要编译和链接。 2. Python 解释器 2.1 调用解释器 在 Python 可用的机器上，Python 解释器通常放在 /usr/local/bin/python3.7 ；把 /usr/local/bin 放到你 Unix shell 的搜索路径当中 , 这样键入命令： python3.7 就能运行了。 另一种启动解释器的方式是 python -c command [arg] ... ，其中 command 要换成想执行的指令，就像命令行的 -c 选项。由于 Python 代码中经常会包含对终端来说比较特殊的字符，通常情况下都建议用 英文单引号 把 command 括起来。 有些 Python 模块也可以作为脚本使用。可以这样输入： python -m module [arg] ... ，这会执行 module 的源文件，就跟你在命令行把路径写全了一样。 在运行脚本的时候，有时可能也会需要在运行后进入交互模式。这种时候在文件参数前，加上选项 -i 就可以了。 2.2 传入参数 如果可能的话，解释器会读取命令行参数，转化为字符串列表存入 sys 模块中的 argv 变量中。执行命令 import sys 你可以导入这个模块并访问这个列表。这个列表最少也会有一个元素。 如果没有给定输入参数， sys.argv[0] 就是个空字符串。 如果脚本名是标准输入， sys.argv[0] 就是 '-'。 使用 -c command 时， sys.argv[0] 就会是 '-c'。 如果使用选项 -m module ， sys.argv[0] 就是包含目录的模块全名。 在 -c command 或 -m module 之后的选项不会被解释器处理，而会直接留在 sys.argv 中给命令或模块来处理。 2.3 解释器的运行环境 默认情况下，Python 源码文件以 UTF-8 编码方式处理。如果不使用默认编码，要声明文件所使用的编码，文件的 第一行 要写成特殊的注释。语法如下所示： # -*- coding: encoding -*- 关于 第一行 规则的一种例外情况是，源码以 UNIX \"shebang\" 行开头。这种情况下，编码声明就要写在文件的第二行。例如： 1 2 #!/usr/bin/env python3 # -*- coding: cp1252 -*- 3. Python 的非正式介绍 3.1 数字 整数有 int 类型，有小数部分的有 float 类型。 除法运算 (/) 永远返回浮点数类型。 如果要得到一个整数结果（忽略小数部分）你可以使用 // 运算符。 如果要计算余数，可以使用 %。 在Python中，可以使用 ** 运算符来计算乘方。 Python 也内置对复数的支持，使用后缀 j 或者 J 就可以表示虚数部分。 在交互模式下，上一次打印出来的表达式被赋值给变量 _。 3.2 字符串 字符串有多种形式，可以使用单引号（'……'），双引号（\"……\"）都可以获得同样的结果。反斜杠 \\ 可以用来转义。 在交互式解释器中，输出字符串是在引号中的，特殊字符是前置了反斜杠的。函数 print() 会产生更方便阅读的输出，就是不使用引号，也不转义特殊字符。 如果你不希望前置了 \\ 的字符转义成特殊字符，可以使用原始字符串方式，在引号前添加 r 即可。 字符串字面值可以跨行连续输入。一种方式是用三重引号：\"\"\"...\"\"\" 或 '''...'''。字符串中的回车换行会自动包含到字符串中，如果不想包含，在行尾添加一个 \\ 即可。 字符串可以用 + 进行连接（粘到一起），也可以用 * 进行重复。相邻的两个或多个 字符串字面值（引号引起来的字符）将会自动连接到一起，只能对两个字面值这样操作，变量或表达式不行。 字符串是可以被 索引（下标访问）的，第一个字符索引是 0。单个字符并没有特殊的类型，只是一个长度为一的字符串。索引也可以用负数，这种会从右边开始数。注意 -0 和 0 是一样的，所以负数索引从 -1 开始。 使用过大的索引会产生一个错误，但是，切片中的越界索引会被自动处理。 Python 中的字符串不能被修改，它们是 immutable 的。因此，向字符串的某个索引位置赋值会产生一个错误。 内建函数 len() 返回一个字符串的长度。 3.3 列表 列表，可以通过方括号括起、逗号分隔的一组值得到。一个列表可以包含不同类型的元素，但通常使用时各个元素类型相同。 列表也支持索引和切片。所有的切片操作都返回一个新列表，这个新列表包含所需要的元素。 列表同样支持拼接操作 +。 列表是一个 mutable 类型，就是说，它自己的内容可以改变。 在列表结尾，通过 append() 方法 添加新元素。 内建函数 len() 返回一个列表的长度。 4. 其他流程控制工具 4.1 if 语句 >>> if x < 0: ... x = 0 ... print('Negative changed to zero') ... elif x == 0: ... print('Zero') ... elif x == 1: ... print('Single') ... else: ... print('More') 4.2 for 语句 >>> for w in words: ... print(w, len(w)) 如果在循环内需要修改序列中的值（比如重复某些选中的元素），推荐你先拷贝一份副本。对序列进行循环不代表制作了一个副本进行操作。 4.3 range() 函数 给定的终止数值并不在要生成的序列里； range(10) 会生成 10 个值，并且是以合法的索引生成一个长度为 10 的序列。 range 也可以以另一个数字开头，或者以指定的幅度增加（甚至是负数；有时这也被叫做 '步进'）。 range() 所返回的对象在许多方面表现得像一个列表，但实际上却并不是。此对象会在你迭代它时基于所希望的序列返回连续的项，但它没有真正生成列表，这样就能节省空间。 我们说这样的对象是可迭代的，也就是说，适合作为函数和结构体的参数，这些函数和结构体期望在迭代结束之前可以从中获取连续的元素。我们已经看到 for 语句就是这样一个迭代器。函数 list() 是另外一个；它从可迭代对象中创建列表。 >>> list(range(5)) [0, 1, 2, 3, 4] 4.4 break 和 continue 语句，以及循环中的 else 子句 循环语句可能带有一个 else 子句；它会在循环遍历完列表 (使用 for ) 或是在条件变为假 (使用 while ) 的时候被执行，但是不会在循环被 break 语句终止时被执行。 4.5 pass 语句 pass 语句什么也不做。 4.6 定义函数 >>> def fib(n): # write Fibonacci series up to n ... \"\"\"Print a Fibonacci series up to n.\"\"\" ... a, b = 0, 1 ... while a < n: ... print(a, end=' ') ... a, b = b, a+b ... print() ... 函数体的第一个语句可以（可选的）是字符串文字；这个字符串文字是函数的文档字符串或 docstring 。 4.7 函数定义的更多形式 4.7.1 参数默认值 默认值是在定义过程中在函数定义处计算的，所以 i = 5 def f(arg=i): print(arg) i = 6 f() 会打印 5。 重要警告： 默认值只会执行一次。这条规则在默认值为可变对象（列表、字典以及大多数类实例）时很重要。比如，下面的函数会存储在后续调用中传递给它的参数： def f(a, L=[]): L.append(a) return L print(f(1)) print(f(2)) print(f(3)) 这将打印出 [1] [1, 2] [1, 2, 3] 4.7.2 关键字参数 在函数调用中，关键字参数必须跟随在位置参数的后面。 传递的所有关键字参数必须与函数接受的其中一个参数匹配，它们的顺序并不重要。 不能对同一个参数多次赋值。 4.7.3 任意的参数列表 最不常用的选项是可以使用任意数量的参数调用函数。这些参数会被包含在一个元组里（参见 元组和序列 ）。在可变数量的参数之前，可能会出现零个或多个普通参数。 4.7.4 解包参数列表 使用 * 运算符编写函数调用以从列表或元组中解包参数。 >>> list(range(3, 6)) # normal call with separate arguments [3, 4, 5] >>> args = [3, 6] >>> list(range(*args)) # call with arguments unpacked from a list [3, 4, 5] 4.7.5 Lambda 表达式 Lambda 函数可以在需要函数对象的任何地方使用。它们在语法上限于单个表达式。 从语义上来说，它们只是正常函数定义的语法糖。与嵌套函数定义一样， lambda 函数可以引用包含范围的变量。 返回两个参数的和： lambda a, b: a+b 4.7.6 文档字符串 以下是有关文档字符串的内容和格式的一些约定。 第一行应该是对象目的的简要概述。这一行应以大写字母开头，以句点结尾。 如果文档字符串中有更多行，则第二行应为空白，从而在视觉上将摘要与其余描述分开。 Python 解析器不会从 Python 中删除多行字符串文字的缩进，因此处理文档的工具必须在需要时删除缩进。这是使用以下约定完成的。文档字符串第一行之后的第一个非空行确定整个文档字符串的缩进量。（我们不能使用第一行，因为它通常与字符串的开头引号相邻，因此它的缩进在字符串文字中不明显。）然后从字符串的所有行的开头剥离与该缩进 \"等效\" 的空格。缩进的行不应该出现，但是如果它们出现，则应该剥离它们的所有前导空格。应在扩展标签后测试空白的等效性（通常为 8 个空格）。 4.7.7 函数标注 函数标注是关于用户自定义函数中使用的类型的完全可选元数据信息。 函数标注以字典的形式存放在函数的 __annotations__ 属性中，并且不会影响函数的任何其他部分。 形参标注的定义方式是在形参名称后加上冒号，后面跟一个表达式，该表达式会被求值为标注的值。 返回值标注的定义方式是加上一个组合符号 ->，后面跟一个表达式，该标注位于形参列表和表示 def 语句结束的冒号之间。 >>> def f(ham: str, eggs: str = 'eggs') -> str: ... print(\"Annotations:\", f.__annotations__) ... print(\"Arguments:\", ham, eggs) ... return ham + ' and ' + eggs ... >>> f('spam') Annotations: {'ham': <class 'str'>, 'return': <class 'str'>, 'eggs': <class 'str'>} Arguments: spam eggs 'spam and eggs' 4.8 编码风格 使用 4 个空格缩进，不要使用制表符 换行，使一行不超过 79 个字符 使用空行分隔函数和类，以及函数内的较大的代码块 如果可能，把注释放到单独的一行 使用文档字符串 在运算符前后和逗号后使用空格，但不能直接在括号内使用： a = f(1, 2) + g(3, 4) 类和函数命名的一致性；规范是使用 CamelCase 命名类，lower_case_with_underscores 命名函数和方法。始终使用 self 作为第一个方法参数的名称 如果你的代码旨在用于国际环境，请不要使用花哨的编码 不要在标识符中使用非 ASCII 字符 5. 数据结构 5.1 列表的更多特性 list.append(x) 在列表的末尾添加一个元素。相当于 a[len(a):] = [x]。 list.extend(iterable) 使用可迭代对象中的所有元素来扩展列表。相当于 a[len(a):] = iterable 。 list.insert(i, x) 在给定的位置插入一个元素。第一个参数是要插入的元素的索引。 list.remove(x) 移除列表中第一个值为 x 的元素。如果没有这样的元素，则抛出 ValueError 异常。 list.pop([i]) 删除列表中给定位置的元素并返回它。如果没有给定位置， a.pop() 将会删除并返回列表中的最后一个元素。 list.clear() 删除列表中所有的元素。相当于 del a[:] 。 list.index(x[, start[, end]]) 返回列表中第一个值为 x 的元素的从 零 开始的索引。如果没有这样的元素将会抛出 ValueError 异常。 list.count(x) 返回元素 x 在列表中出现的次数。 list.sort(key=None, reverse=False) 对列表中的元素进行排序（参数可用于自定义排序）。 list.reverse() 反转列表中的元素。 list.copy() 返回列表的一个浅拷贝。相当于 a[:]。 像 insert ， remove 或者 sort 方法，只修改列表，没有打印出返回值——它们返回默认值 None 。 5.2 元组和序列 一个元组由几个被逗号隔开的值组成。输入时圆括号可有可无，不过经常会是必须的（如果这个元组是一个更大的表达式的一部分）。 元组是 immutable （不可变的），其序列通常包含不同种类的元素，并且通过解包（这一节下面会解释）或者 索引 来访问（如果是 namedtuples 的话甚至还可以通过属性访问）。 列表是 mutable （可变的），并且列表中的元素一般是同种类型的，并且通过 迭代 访问。 一个特殊的问题是构造包含 0 个或 1 个元素的元组：为了适应这种情况，语法有一些额外的改变。空元组可以直接被一对空圆括号创建，含有一个元素的元组可以通过在这个元素后添加一个逗号来构建（圆括号里只有一个值的话不够明确）。 5.3 集合 Python 也包含有 集合 类型。集合是由不重复元素组成的无序的集。它的基本用法包括成员检测和消除重复元素。集合对象也支持像 联合，交集，差集，对称差分等数学运算。 花括号或 set() 函数可以用来创建集合。注意：要创建一个空集合你只能用 set() 而不能用 {} ，因为后者是创建一个空字典。 5.4 字典 与以连续整数为索引的序列不同，字典是以 关键字 为索引的，关键字可以是任意不可变类型，通常是字符串或数字。如果一个元组只包含字符串、数字或元组，那么这个元组也可以用作关键字。但如果元组直接或间接地包含了可变对象，那么它就不能用作关键字。 一对花括号可以创建一个空字典： {} 。 dict() 构造函数可以直接从键值对序列里创建字典。 可以用 del 来删除一个键值对。 对一个字典执行 list(d) 将返回包含该字典中所有 键 的列表，按插入次序排列 (如需其他排序，则要使用 sorted(d) )。要检查字典中是否存在一个特定键，可使用 in 关键字。 5.5 循环的技巧 当在字典中循环时，用 items() 方法可将关键字和对应的值同时取出。 >>> knights = {'gallahad': 'the pure', 'robin': 'the brave'} >>> for k, v in knights.items(): ... print(k, v) ... gallahad the pure robin the brave 当在序列中循环时，用 enumerate() 函数可以将索引位置和其对应的值同时取出。 >>> for i, v in enumerate(['tic', 'tac', 'toe']): ... print(i, v) ... 0 tic 1 tac 2 toe 当同时在两个或更多序列中循环时，可以用 zip() 函数将其内元素一一匹配。 >>> questions = ['name', 'quest', 'favorite color'] >>> answers = ['lancelot', 'the holy grail', 'blue'] >>> for q, a in zip(questions, answers): ... print('What is your {0}? It is {1}.'.format(q, a)) ... What is your name? It is lancelot. What is your quest? It is the holy grail. What is your favorite color? It is blue. 当逆向循环一个序列时，先正向定位序列，然后调用 reversed() 函数。 >>> for i in reversed(range(1, 10, 2)): ... print(i) ... 9 7 5 3 1 如果要按某个指定顺序循环一个序列，可以用 sorted() 函数，它可以在不改动原序列的基础上返回一个新的排好序的序列。 有时可能会想在循环时修改列表内容，一般来说改为创建一个新列表是比较简单且安全的。 5.6 深入条件控制 比较操作符 in 和 not in 校验一个值是否在（或不在）一个序列里。操作符 is 和 is not 比较两个对象是不是同一个对象，这只跟像列表这样的可变对象有关。 比较操作可以传递。例如 a < b == c 会校验是否 a 小于 b 并且 b 等于 c。 比较操作可以通过布尔运算符 and 和 or 来组合，并且比较操作（或其他任何布尔运算）的结果都可以用 not 来取反。在它们之中， not 优先级最高， or 优先级最低。 布尔运算符 and 和 or 也被成为 短路 运算符：它们的参数从左至右解析，一旦可以确定结果解析就会停止。当作用于普通值而非布尔值时，短路操作符的返回值通常是最后一个变量。 6. 模块 模块是一个包含 Python 定义和语句的文件。文件名就是模块名后跟文件后缀 .py 。在一个模块内部，模块名（作为一个字符串）可以通过全局变量 __name__ 的值获得。 6.1 有关模块的更多信息 模块可以包含可执行的语句以及函数定义。这些语句用于初始化模块。它们仅在模块 第一次 在 import 语句中被导入时才执行。(当文件被当作脚本运行时，它们也会执行。) 出于效率的考虑，每个模块在每个解释器会话中只被导入一次。因此，如果你更改了你的模块，则必须重新启动解释器，或者，如果它只是一个要交互式地测试的模块，请使用 importlib.reload() ，例如： import importlib importlib . reload ( modulename ) 6.2 以脚本的方式执行模块 当你用下面方式运行一个 Python 模块： python fibo.py <arguments> 模块里的代码会被执行，就好像你导入了模块一样，但是 __name__ 被赋值为 \"__main__\" 。 这意味着通过在你的模块末尾添加这些代码： if __name__ == \"__main__\" : import sys fib ( int ( sys . argv [ 1 ])) 你既可以把这个文件当作脚本又可当作一个可调入的模块来使用。","tags":"教程","url":"https://xutree.github.io/pages/2018/10/05/py/"},{"title":"HTML 入门","text":"HTML ，即超文本标记语言（ H yper T ext M arkup L anguage）。与脚本或编程语言不同，标记语言使用标记（ tag ）来标识内容。 下面是一个 HTML tag 的例子： <p> 这是一个段落。</p> <p> 称为开始标签， </p> 称为结束标签。 1. 网页的结构 HTML：结构 CSS：样式 JavaScript：行为 PHP 或类似语言：后端 CMS：内容管理 2. 基本 HTML 文件结构 标签 解释 <html></html> HTML文件的所有内容都包含在其中 <head></head> HTML文件的头部包含有助于使页面工作的所有非可视元素 <body></body> 所有可视化元素都包含在body标签中 <title></title> 包含网页选项卡上现实的标题内容 <!DOCTYPE html> 声明为 HTML5 文档 <!DOCTYPE html> < html > < head > < meta charset = \"utf-8\" > < title > 第一个 HTML 例子 </ title > </ head > < body > Hello World! </ body > </ html > 3. <!DOCTYPE> 声明 <!DOCTYPE> 声明有助于浏览器中正确显示网页。网络上有很多不同的文件，如果能够正确声明 HTML 的版本，浏览器就能正确显示网页内容。 doctype 声明是不区分大小写的，以下方式均可： <!DOCTYPE html> <!DOCTYPE HTML> <!doctype html> <!Doctype Html> 4. 中文编码 目前在大部分浏览器中，直接\b输出中文会出现中文乱码的情况，这时候我们就需要在头部将字符声明为 <meta charset=\"utf-8\"> 。 5. 字体标签 标签 解释 <p></p> 段落标签（浏览器会在段落前后自动添加空行） <br /> 换行而不开启新段落（它没有结束标记） <b></b> 粗体 <big></big> 大号文本 <i></i> 斜体 <small></small> 小号文本 <strong></strong> 强调（一种phrase tag） <sub></sub> 下标 <sup></sup> 上标 <ins></ins> 插入线 <del></del> 删除线 6. 标题标签 <h1></h1> ， <h2></h2> ， <h3></h3> ， <h4></h4> ， <h5></h5> ， <h6></h6> 六种标题， <h1></h1> 字号最大。 7. 标签属性\b 属性提供有关元素或标记的附加信息，同时还可以修改它们。例如 <p align= \"center\" > This text is aligned to center </p> 会将段落居中显示（\b <p> 标签的align属性在HTML5中不再支持）。\b 双引号是最常用的，不过使用单引号也没有问题。属性的数值可以通过像素或百分比指定，如 <hr width=\"50px\" /> <hr width=\"50%\" /> 7.1 HTML 全局属性 加粗为 HTML5 新属性。 属性 描述 accesskey 设置访问元素的键盘快捷键 class 规定元素的类名（classname） contenteditable 规定是否可编辑元素的内容 contextmenu 指定一个元素的上下文菜单，当用户右击该元素，出现上下文菜单 data-* 用于存储页面的自定义数据 dir 设置元素中内容的文本方向 draggable 指定某个元素是否可以拖动 dropzone 指定是否将数据复制，移动，或链接，或删除 hidden hidden 属性规定对元素进行隐藏 id 规定元素的唯一 id lang 设置元素中内容的语言代码 spellcheck 检测元素是否拼写错误 style 规定元素的行内样式（inline style） tabindex 设置元素的 Tab 键控制次序 title 规定元素的额外信息（可在工具提示中显示） translate 指定是否一个元素的值在页面载入时是否需要翻译 7.2 HTML 标签 加粗为 HTML5 新标签。 标签 描述 abbr 定义缩写 acronym 定义只取首字母的缩写，不支持 HTML5 address 定义文档作者或拥有者的联系信息 applet HTML5 中不赞成使用，定义嵌入的 applet area 定义图像映射内部的区域 article 定义一个文章区域 aside 定义页面的侧边栏内容 audio 定义音频内容 b 定义文本粗体 base 定义页面中所有链接的默认地址或默认目标 basefont HTML5 不支持，不赞成使用，定义页面中文本的默认字体、颜色或尺寸 bdi 允许您设置一段文本，使其脱离其父元素的文本方向设置 bdo 定义文字方向 big 定义大号文本，HTML5 不支持 blockquote 定义长的引用 body 定义文档的主体 br 定义换行 button 定义一个点击按钮 canvas 定义图形，比如图表和其他图像,标签只是图形容器，您必须使用脚本来绘制图形 caption 定义表格标题 center HTML5 不支持，不赞成使用，定义居中文本 cite 定义引用(citation) code 定义计算机代码文本 col 定义表格中一个或多个列的属性值 colgroup 定义表格中供格式化的列组 command 定义命令按钮，比如单选按钮、复选框或按钮 datalist 定义选项列表，请与 input 元素配合使用该元素，来定义 input 可能的值 dd 定义定义列表中项目的描述 del 定义被删除文本 details 用于描述文档或文档某个部分的细节 dfn 定义定义项目 dialog 定义对话框，比如提示框 dir HTML5 不支持，不赞成使用，定义目录列表 div 定义文档中的节 dl 定义列表详情 dt 定义列表中的项目 em 定义强调文本 embed 定义嵌入的内容，比如插件 fieldset 定义围绕表单中元素的边框 figcaption 定义 figure 元素的标题 figure 规定独立的流内容（图像、图表、照片、代码等等） font HTML5 不支持，不赞成使用，定义文字的字体、尺寸和颜色 footer 定义 section 或 document 的页脚 form 定义了 HTML 文档的表单 frame 定义框架集的窗口或框架 frameset 定义框架集 h1-h6 定义 HTML 标题 head 定义关于文档的信息 header 定义了文档的头部区域 hr 定义水平线 html 定义 HTML 文档 i 定义斜体字 iframe 定义内联框架 img 定义图像 input 定义输入控件 ins 定义被插入文本 kbd 定义键盘文本 keygen 规定用于表单的密钥对生成器字段 label 定义 input 元素的标注 legend 定义 fieldset 元素的标题 li 定义列表的项目 link 定义文档与外部资源的关系 map 定义图像映射 mark 定义带有记号的文本，请在需要突出显示文本时使用 m 标签 menu 不赞成使用，定义菜单列表 meta 定义关于 HTML 文档的元信息 meter 定义度量衡，仅用于已知最大和最小值的度量 nav 定义导航链接的部分 noframes 定义针对不支持框架的用户的替代内容，HTML5 不支持 noscript 定义针对不支持客户端脚本的用户的替代内容 object 定义内嵌对象 ol 定义有序列表 optgroup 定义选择列表中相关选项的组合 option 定义选择列表中的选项 output 定义不同类型的输出，比如脚本的输出 p 定义段落 param 定义对象的参数 pre 定义预格式文本 progress 定义运行中的进度（进程） q 定义短的引用 rp rp 标签在 ruby 注释中使用，以定义不支持 ruby 元素的浏览器所显示的内容 rt rt 标签定义字符（中文注音或字符）的解释或发音 ruby ruby 标签定义 ruby 注释（中文注音或字符） s 不赞成使用，定义加删除线的文本 samp 定义计算机代码样本 script 定义客户端脚本 section section 标签定义文档中的节（section、区段），比如章节、页眉、页脚或文档中的其他部分 select 定义选择列表（下拉列表） small 定义小号文本 source source 标签为媒介元素（比如 video 和 audio）定义媒介资源 span 定义文档中的节 strike HTML5 不支持，不赞成使用定义加删除线文本 strong 定义强调文本 style 定义文档的样式信息 sub 定义下标文本 summary summary 标签包含 details 元素的标题，\"details\" 元素用于描述有关文档或文档片段的详细信息 sup 定义上标文本 table 定义表格 tbody 定义表格中的主体内容 td 定义表格中的单元 textarea 定义多行的文本输入控件 tfoot 定义表格中的表注内容（脚注） th 定义表格中的表头单元格 thead 定义表格中的表头内容 time 定义日期或时间，或者两者 title 定义文档的标题 tr 定义表格中的行 track track 标签为诸如 video 元素之类的媒介规定外部文本轨道 tt 定义打字机文本 u 不赞成使用定义下划线文本 ul 定义无序列表 var 定义文本的变量部分 video video 标签定义视频，比如电影片段或其他视频流 wbr 规定在文本中的何处适合添加换行符 8. 图像标签 <img src=\"\" height=\"\" width=\"\" border=\"\" alt=\"\"/> src：图像名称 height：图像高 width：图像宽 border：边界宽度 alt：如果无法显示图像，则alt属性指定以单词形式描述图像的替代文本 9. 链接标签 <a href=\"\" target=\"\"></a> href：目标网址 target：指定打开链接文档的位置，\b_blank值将在新窗口或新标签中打开链接 10. 列表标签 10.1 有序列表 <html> <head> <title> first page </title> </head> <body> <ol> <li> Red </li> <li> Blue </li> <li> Green </li> </ol> </body> </html> 10.2 无序列表 <html> <head> <title> first page </title> </head> <body> <ul> <li> Red </li> <li> Blue </li> <li> Green </li> </ul> </body> </html> 11. 表格标签 <table border= \"\" align= \"\" > <tr> <td bgcolor= \"red\" > Red </td> <td> Blue </td> <td> Green </td> </tr> <tr> <td> Yellow </td> <td colspan= \"2\" > Orange </td> </tr> </table> 12. 其他 标签 解释 <hr /> 水平线 <!--...--> 注释 13. HTML 元素类型\b 在 HTML 中，大多数元素被定义为块级或内联元素。| 块级元素从新行开始，如 <h1>, <form>, <li>, <ol>, <ul>, <p>, <pre>, <table>, <div> 等 内联元素通常显示没有换行符，如 <b>, <a>, <strong>, <img>, <input>, <em>, <span> 等 <div> 元素是一个块级元素，通常用作其他 HTML 元素的容器。与一些 CSS 样式一起使用时， <div> 元素可用于设置内容块的样式。 同样， <span> 元素是一个内联元素，通常用作\b某些文本的容器。与 CSS 一起使用时， <span> 元素可用于设置文本的部分样式。 其他元素可以用作块级元素或内联元素。 这包括以下这些： APPLET - 嵌入式 Java 小程序 IFRAME - 内联框架 INS - 插入文本 MAP - 图像映射 OBJECT - 嵌入对象 SCRIPT - HTML 文档中的脚本 你可以在块元素内插入内联元素。 例如，可以在 <div> 元素中包含多个 <span> 元素。反之不行。 14. 表单标签 HTML 表单用于从用户收集信息。使用 <form> 元素及其开始和结束标记定义表单，使用 action 属性指向将在用户提交表单后加载的网页： <body> <form action= \"\" method= \"\" > … </form> </body> method 属性指定在提交表单时使用的 HTTP 方法（GET 或 POST）： 使用 GET 时，表单数据将显示在页面地址中 如果表单正在更新数据，请使用 POST，或者包含敏感信息（密码）。POST 提供了更好的安全性，因为提交的数据在页面地址中不可见 要接受用户输入，需要相应的表单元素，例如文本字段。 <input> 元素有许多变体，具体取决于 type 属性。 它可以是文本，密码，广播，URL，提交等。 <form> <input type= \"text\" name= \"username\" /><br /> <input type= \"password\" name= \"password\" /> </form> 15. <frame> 标签 可以使用特殊帧文档将页面划分为帧。 <frame> 标签定义 <frameset> 中的一个特定窗口（框架）。 <frameset> 中的每个 <frame> 可以具有不同的属性，例如边框，滚动，调整大小的能力等。 <frameset> 元素指定框架集中的列数或行数，以及每个框架占空间像素的百分比或数量。 <frameset cols= \"25%,50%,25%\" > <frame src= \"a.htm\" /> <frame src= \"b.htm\" /> <frame src= \"c.htm\" /> <noframes> Frames not supported! </noframes> </frameset> 使用 <noresize> 属性指定用户无法调整 <frame> 元素的大小： <frame noresize=\"noresize\"> HTML5 中不支持 <frame> 标签。 16. 颜色 16.1 颜色值 HTML 颜色表示为十六进制值，0~\bF。零表示最低值，F表示最高值。 16.2 颜色模式 颜色以红色，绿色和蓝色光（RGB）的组合显示。 十六进制值使用＃标签符号，后跟六个十六进制字符。所有浏览器都支持 RGB 颜色值。","tags":"教程","url":"https://xutree.github.io/pages/2018/10/05/html-overview/"},{"title":"X3DOM 图像和视频纹理","text":"本章你将知道哪些图像类型和视频格式可以用作 X3DOM 的纹理，以及纹理的特性和限制。 你可以使用 PNG ， LPEG 或者 GIF 来编码你的静态纹理数据。 JPG 图像需要的内存少但是存在压缩损失而且没有 alpha 通道。 PNG 图像属于无损压缩并且有 alpha 通道， GIF 也是无损压缩并且有 alpha 通道。一般来讲：如果你不需要 alpha 通道并且图像中不包含硬边界(例如：文本)，使用 JPG ，否则使用 PNG 。你应该避免使用 GIF 。 1. 图像 利用 ImageTexture 节点把图像作为纹理： <x3d width= '500px' height= '400px' > <scene> <shape> <appearance> <ImageTexture url= \"myTexture.png\" ><ImageTexture/> </appearance> <box> </box> </shape> </scene> </x3d> 2. 视频 利用 MovieTexture 节点可以把视频作为纹理。但是目前还没有哪一种视频格式支持所有的用户。可以使用 X3DOM 格式 示例 来确定你的浏览器支持的格式。目前最好的解决方法是将你的视频编码成 MP4 和 OGV 格式并在 MovieTexture 节点中提供这两个选项： <x3d width= '500px' height= '400px' > <scene> <shape> <appearance> <MovieTexture url= '\"foo.mp4″,\"foo.ogv\"' ><MovieTexture/> </appearance> <box> </box> </shape> </scene> </x3d>","tags":"教程","url":"https://xutree.github.io/pages/2018/10/05/X3DOM图像和视频纹理/"},{"title":"Python 100 days","text":"整理自 Python-100-Days 1. 初识 Python 1.1 Python 简介 Python 的版本号分为三段，形如 A.B.C。其中 A 表示大版本号，一般当整体重写，或出现不向后兼容的改变时，增加 A；B 表示功能更新，出现新功能时增加 B；C 表示小的改动（如修复了某个 Bug），只要有修改就增加 C。 1.2 Python 的优缺点 Python 的优点很多，简单的可以总结为以下几点： 简单和明确，做一件事只有一种方法 学习曲线低，跟其他很多语言相比，Python 更容易上手 开放源代码，拥有强大的社区和生态圈 解释型语言 ，天生具有平台可移植性 支持两种主流的编程范式（面向对象编程和函数式编程）都提供了支持 可扩展性和可嵌入性，可以调用 C/C++ 代码，也可以在 C/C++ 中调用 Python 代码规范程度高，可读性强，适合有代码洁癖和强迫症的人群 Python 的缺点主要集中在以下几点： 执行效率稍低，因此计算密集型任务可以由 C/C++ 编写 代码无法加密，但是现在的公司很多都不是卖软件而是卖服务，这个问题会被淡化 在开发时可以选择的框架太多（如 Web 框架就有 100 多个），有选择的地方就有错误 2. 语言元素 2.1 变量和类型 整型 ：Python 中可以处理任意大小的整数，支持二进制（0b），八进制（0o），十进制和十六进制（0x）表示法 浮点型 字符串型 ：字符串是以单引号或双引号括起来的任意文本 布尔型 ：布尔值只有 True 、 False 两种值，注意大写 复数型 ：形如 3+5j，虚部用 j 表示 2.2 变量命名 硬性规则： 变量名由字母（广义的 Unicode 字符，不包括特殊字符）、数字和下划线构成，数字不能开头 大小写敏感 不要跟关键字（有特殊含义的单词，后面会讲到）和系统保留字（如函数、模块等的名字）冲突 PEP 8要求： 用小写字母拼写，多个单词用下划线连接 受保护的实例属性用单个下划线开头 私有的实例属性用两个下划线开头 2.3 类型转换 在对变量类型进行转换时可以使用 Python 的内置函数（准确的说下面列出的并不是真正意义上的函数，而是后面我们要讲到的创建对象的构造方法）。 int() ：将一个数值或字符串转换成整数，可以指定进制 float() ：将一个字符串转换成浮点数 str() ：将指定的对象转换成字符串形式，可以指定编码 chr() ：将整数转换成该编码对应的字符串（一个字符） ord() ：将字符串（一个字符）转换成对应的编码（整数） 2.4 运算符 Python 支持多种运算符，下表大致按照优先级从高到低的顺序列出了所有的运算符，我们会陆续使用到它们。 运算符 描述 [] [:] 下标，切片 ** 指数 ~ + - 按位取反, 正负号 * / % // 乘，除，模，整除 + - 加，减 >> << 右移，左移 & 按位与 &#94; | 按位异或，按位或 <= < > >= 小于等于，小于，大于，大于等于 == != 等于，不等于 is is not 身份运算符 in not in 成员运算符 not or and 逻辑运算符 = += -= *= /= %= //= **= &= |= &#94;= >>= <<= （复合）赋值运算符 2.5 程序结构 分支结构： if 、 elif 、 else 循环结构： for-in 、 while range(1, 100, 2) 可以产生一个 1 到 99 的奇数序列，其中的 2 是步长，即数值序列的增量。 不需要\b指明循环对象可以用下面的语句： for _ in range(nums): 3. 函数和模块的使用 3.1 定义函数 def funname(paralist): \"\"\" information about function \"\"\" ... return result Python 中可以在函数内部再定义函数 Python 查找一个变量时会按照\b\"局部作用域\"、\"嵌套作用域\"、\"全局作用域\"和\"内置作用域\"的顺序进行搜索 我们可以使用 global 关键字来指示函数中的变量来自于全局作用域 如果我们希望函数内部的函数能够修改嵌套作用域中的变量，可以使用 nonlocal 关键字来指示变量来自于嵌套作用域 如果我们希望将一个局部变量的生命周期延长，使其在函数调用结束后依然可以访问，这时候就需要使用 闭包 3.2 用模块管理函数 需要说明的是，如果我们导入的模块除了定义函数之外还中有可以执行代码，那么 Python 解释器在导入这个模块时就会执行这些代码，事实上我们可能并不希望如此，因此如果我们在模块中编写了执行代码，最好是将这些执行代码放入如下所示的条件中，这样的话除非直接运行该模块， if 条件下的这些代码是不会执行的，因为只有直接执行的模块的名字才是 __main__ 。 def main(): # Todo: Add your code here pass if __name__ == '__main__': main() 4. 字符串和常用数据结构 4.1 使用字符串 def main () : str1 = 'hello, world!' # 通过len函数计算字符串的长度 print ( len ( str1 )) # 13 # 获得字符串首字母大写的拷贝 print ( str1 . capitalize ()) # Hello , world ! # 获得字符串变大写后的拷贝 print ( str1 . upper ()) # HELLO , WORLD ! # 从字符串中查找子串所在位置 print ( str1 . find ( 'or' )) # 8 print ( str1 . find ( 'shit' )) # - 1 # 与find类似但找不到子串时会引发异常 # print ( str1 . index ( 'or' )) # print ( str1 . index ( 'shit' )) # 检查字符串是否以指定的字符串开头 print ( str1 . startswith ( 'He' )) # False print ( str1 . startswith ( 'hel' )) # True # 检查字符串是否以指定的字符串结尾 print ( str1 . endswith ( '!' )) # True # 将字符串以指定的宽度居中并在两侧填充指定的字符 print ( str1 . center ( 50 , '*' )) # 将字符串以指定的宽度靠右放置左侧填充指定的字符 print ( str1 . rjust ( 50 , ' ' )) str2 = 'abc123456' # 从字符串中取出指定位置的字符 ( 下标运算 ) print ( str2 [ 2 ]) # c # 字符串切片 ( 从指定的开始索引到指定的结束索引 ) print ( str2 [ 2 : 5 ]) # c12 print ( str2 [ 2 : ]) # c123456 print ( str2 [ 2 :: 2 ]) # c246 print ( str2 [ :: 2 ]) # ac246 print ( str2 [ ::- 1 ]) # 654321 cba print ( str2 [ - 3 :- 1 ]) # 45 # 检查字符串是否由数字构成 print ( str2 . isdigit ()) # False # 检查字符串是否以字母构成 print ( str2 . isalpha ()) # False # 检查字符串是否以数字和字母构成 print ( str2 . isalnum ()) # True str3 = ' jackfrued@126.com ' print ( str3 ) # 获得字符串修剪左右两侧空格的拷贝 print ( str3 . strip ()) if __ name__ == '__main__': main () 4.2 使用列表 def main(): list1 = [1, 3, 5, 7, 100] print(list1) list2 = ['hello'] * 5 print(list2) # 计算列表长度(元素个数) print(len(list1)) # 下标(索引)运算 print(list1[0]) print(list1[4]) # print(list1[5]) # IndexError: list index out of range print(list1[-1]) print(list1[-3]) list1[2] = 300 print(list1) # 添加元素 list1.append(200) list1.insert(1, 400) list1 += [1000, 2000] print(list1) print(len(list1)) # 删除元素 list1.remove(3) if 1234 in list1: list1.remove(1234) del list1[0] print(list1) # 清空列表元素 list1.clear() print(list1) if __name__ == '__main__': main() def main () : fruits = [ 'grape' , 'apple' , 'strawberry' , 'waxberry' ] fruits += [ 'pitaya' , 'pear' , 'mango' ] # 循环遍历列表元素 for fruit in fruits : print ( fruit . title (), end=' ' ) print () # 列表切片 fruits2 = fruits [ 1 : 4 ] print ( fruits2 ) # fruit3 = fruits # 没有复制列表只创建了新的引用 # 可以通过完整切片操作来复制列表 fruits3 = fruits [ : ] print ( fruits3 ) fruits4 = fruits [ - 3 :- 1 ] print ( fruits4 ) # 可以通过反向切片操作来获得倒转后的列表的拷贝 fruits5 = fruits [ ::- 1 ] print ( fruits5 ) if __ name__ == '__main__': main () def main(): list1 = ['orange', 'apple', 'zoo', 'internationalization', 'blueberry'] list2 = sorted(list1) # sorted函数返回列表排序后的拷贝不会修改传入的列表 # 函数的设计就应该像sorted函数一样尽可能不产生副作用 list3 = sorted(list1, reverse=True) # 通过key关键字参数指定根据字符串长度进行排序而不是默认的字母表顺序 list4 = sorted(list1, key=len) print(list1) print(list2) print(list3) print(list4) # 给列表对象发出排序消息直接在列表对象上进行排序 list1.sort(reverse=True) print(list1) if __name__ == '__main__': main() import sys def main (): f = [ x for x in range ( 1 , 10 )] print ( f ) f = [ x + y for x in 'ABCDE' for y in '1234567' ] print ( f ) # 用列表的生成表达式语法创建列表容器 # 用这种语法创建列表之后元素已经准备就绪所以需要耗费较多的内存空间 f = [ x ** 2 for x in range ( 1 , 1000 )] print ( sys . getsizeof ( f )) # 查看对象占用内存的字节数 print ( f ) # 请注意下面的代码创建的不是一个列表而是一个生成器对象 # 通过生成器可以获取到数据但它不占用额外的空间存储数据 # 每次需要数据的时候就通过内部的运算得到数据(需要花费额外的时间) f = ( x ** 2 for x in range ( 1 , 1000 )) print ( sys . getsizeof ( f )) # 相比生成式生成器不占用存储数据的空间 print ( f ) for val in f : print ( val ) if __name__ == '__main__' : main () 除了上面提到的生成器语法，Python 中还有另外一种定义生成器的方式，就是通过 yield 关键字将一个普通函数改造成生成器函数： def fib(n): a, b = 0, 1 for _ in range(n): a, b = b, a + b yield a def main(): for val in fib(20): print(val) if __name__ == '__main__': main() 4.3 使用元组 def main(): # 定义元组 t = ('骆昊', 38, True, '四川成都') print(t) # 获取元组中的元素 print(t[0]) print(t[3]) # 遍历元组中的值 for member in t: print(member) # 重新给元组赋值 # t[0] = '王大锤' # TypeError # 变量t重新引用了新的元组原来的元组将被垃圾回收 t = ('王大锤', 20, True, '云南昆明') print(t) # 将元组转换成列表 person = list(t) print(person) # 列表是可以修改它的元素的 person[0] = '李小龙' person[1] = 25 print(person) # 将列表转换成元组 fruits_list = ['apple', 'banana', 'orange'] fruits_tuple = tuple(fruits_list) print(fruits_tuple) if __name__ == '__main__': main() 这里有一个非常值得探讨的问题，我们已经有了列表这种数据结构，为什么还需要元组这样的类型呢？ 元组中的元素是无法修改的，事实上我们在项目中尤其是多线程环境（后面会讲到）中可能更喜欢使用的是那些不变对象（一方面因为对象状态不能修改，所以可以避免由此引起的不必要的程序错误，简单的说就是一个不变的对象要比可变的对象更加容易维护；另一方面因为没有任何一个线程能够修改不变对象的内部状态，一个不变对象自动就是线程安全的，这样就可以省掉处理同步化的开销。一个不变对象可以方便的被共享访问）。所以结论就是：如果不需要对元素进行添加、删除、修改的时候，可以考虑使用元组，当然如果一个方法要返回多个值，使用元组也是不错的选择 元组在创建时间和占用的空间上面都优于列表。我们可以使用 sys 模块的 getsizeof 函数来检查存储同样的元素的元组和列表各自占用了多少内存空间，这个很容易做到。我们也可以在 ipython 中使用魔法指令 %timeit 来分析创建同样内容的元组和列表所花费的时间 4.4 使用集合 def main(): set1 = {1, 2, 3, 3, 3, 2} print(set1) print('Length =', len(set1)) set2 = set(range(1, 10)) print(set2) set1.add(4) set1.add(5) set2.update([11, 12]) print(set1) print(set2) set2.discard(5) # remove的元素如果不存在会引发KeyError if 4 in set2: set2.remove(4) print(set2) # 遍历集合容器 for elem in set2: print(elem ** 2, end=' ') print() # 将元组转换成集合 set3 = set((1, 2, 3, 3, 2, 1)) print(set3.pop()) print(set3) # 集合的交集、并集、差集、对称差运算 print(set1 & set2) # print(set1.intersection(set2)) print(set1 | set2) # print(set1.union(set2)) print(set1 - set2) # print(set1.difference(set2)) print(set1 &#94; set2) # print(set1.symmetric_difference(set2)) # 判断子集和超集 print(set2 <= set1) # print(set2.issubset(set1)) print(set3 <= set1) # print(set3.issubset(set1)) print(set1 >= set2) # print(set1.issuperset(set2)) print(set1 >= set3) # print(set1.issuperset(set3)) if __name__ == '__main__': main() 4.5 使用字典 def main(): scores = {'骆昊': 95, '白元芳': 78, '狄仁杰': 82} # 通过键可以获取字典中对应的值 print(scores['骆昊']) print(scores['狄仁杰']) # 对字典进行遍历(遍历的其实是键再通过键取对应的值) for elem in scores: print('%s\\t--->\\t%d' % (elem, scores[elem])) # 更新字典中的元素 scores['白元芳'] = 65 scores['诸葛王朗'] = 71 scores.update(冷面=67, 方启鹤=85) print(scores) if '武则天' in scores: print(scores['武则天']) print(scores.get('武则天')) # get方法也是通过键获取对应的值但是可以设置默认值 print(scores.get('武则天', 60)) # 删除字典中的元素 print(scores.popitem()) print(scores.popitem()) print(scores.pop('骆昊', 100)) # 清空字典 scores.clear() print(scores) if __name__ == '__main__': main() 5. 可变对象（mutable）与不可变对象（immutable） 在 Python 中任何对象都有的三个通用属性：唯一标识、类型、值。 唯一标识 ：用于标识对象的在内存中唯一性，它在对象创建之后就不会再改变，函数 id() 可以查看对象的唯一标识 类型 ：决定了该对象支持哪些操作，不同类型的对象支持的操作就不一样，比如列表可以有 length 属性，而整数没有。同样地对象的类型一旦确定了就不会再变，函数 type() 可以返回对象的类型信息。 对象的 值 与唯一标识不一样，并不是所有的对象的值都是一成不变的，有些对象的值可以通过某些操作发生改变，值可以变化的对象称之为可变对象（mutable），值不能改变的对象称之为不可变对象（immutable） 5.1 不可变对象 对于不可变对象，值永远是刚开始创建时候的值，对该对象做的任何操作都会导致一个新的对象的创建。 >>> a = 1 >>> id(a) 32574568 >>> a += 1 >>> id(a) 32574544 整数 \"1\" 是一个不可变对象，最初赋值的时候，a 指向的是整数对象 1 ，但对变量 a 执行 += 操作后， a 指向另外一个整数对象 2 ，但对象 1 还是在那里没有发生任何变化，而变量 a 已经指向了一个新的对象 2，常见的不可变对象有： int 、 tuple 、 set 、 str 。 5.2 可变对象 可变对象的值可以通过某些操作动态的改变，比如列表对象，可以通过 append 方法不断地往列表中添加元素，该列表的值就在不断的处于变化中，一个可变对象赋值给两个变量时，他们共享同一个实例对象，指向相同的内存地址，对其中任何一个变量操作时，同时也会影响另外一个变量。 5.3 _add_ 和 _iadd_ 的区别 += 操作首先会尝试调用对象的 __iadd__ 方法，如果没有该方法，那么尝试调用 __add__ 方法，先来看看这两个方法有什么区别： _add_ 方法接收两个参数，返回它们的和，两个参数的值均不会改变 _iadd_ 方法同样接收两个参数，但它是属于 in-place 操作，就是说它会改变第一个参数的值，因为这需要对象是可变的，所以对于不可变对象没有 __iadd__ 方法 >>> l1 = range(3) >>> l2 = l1 >>> l2 = l2 + [3] >>> l1 [0, 1, 2] >>> l2 [0, 1, 2, 3] >>> l1 = range(3) >>> l2 = l1 >>> l2 += [3] >>> l1 [0, 1, 2, 3] >>> l2 [0, 1, 2, 3] 6. 面向对象编程基础 把一组数据结构和处理它们的方法组成 对象 （object），把相同行为的对象归纳为 类 （class），通过类的 封装 （encapsulation）隐藏内部细节，通过 继承 （inheritance）实现类的特化（specialization）和泛化（generalization），通过 多态 （polymorphism）实现基于对象类型的动态分派。 6.1 定义类 class Student ( object ) : # __init__是一个特殊方法用于在创建对象时进行初始化操作 # 通过这个方法我们可以为学生对象绑定 name和age两个属性 def __init__ ( self , name , age ) : self . name = name self . age = age def study ( self , course_name ) : print ( '%s正在学习%s.' % ( self . name , course_name )) # PEP 8 要求标识符的名字用全小写多个单词用下划线连接 # 但是很多程序员和公司更倾向于使用驼峰命名法 ( 驼峰标识 ) def watch_av ( self ) : if self . age < 18 : print ( '%s只能观看《熊出没》.' % self . name ) else : print ( '%s正在观看岛国爱情动作片.' % self . name ) 6.2 访问可见性问题 在 Python 中，属性和方法\b的访问权限只有两种，也就是 公开的 和 私有的 ，如果希望属性是私有的，在给属性命名时可以 用两个下划线作为开头 。 但是，Python 并没有从语法上严格保证私有属性或方法的私密性，它只是给私有的属性和方法换了一个名字来\"妨碍\"对它们的访问，事实上\b如果你知道更换名字的规则仍然可以访问到它们。新名字的格式为 \b_类名__函数名或变量名 。 在实际开发中，我们并不建议将属性设置为私有的，因为这会导致子类无法访问（后面会讲到）。所以大多数 Python 程序员会遵循一种命名惯例就是让 属性名以单下划线开头 来表示属性是受保护的，本类之外的代码在访问这样的属性时应该要保持慎重。这种做法并不是语法上的规则，单下划线开头的属性和方法外界仍然是可以访问的，所以更多的时候它是一种暗示或隐喻。 7. 面向对象进阶 7.1 @property装饰器 使用 @property 包装器来包装 getter 和 setter 方法，使得对属性的访问既安全又方便。 class Person ( object ) : def __init__ ( self , name , age ) : self . _name = name self . _age = age # 访问器 - getter方法 @property def name ( self ) : return self . _name # 访问器 - getter方法 @property def age ( self ) : return self . _age # 修改器 - setter方法 @age . setter # 用对应的 age 声明 def age ( self , age ) : self . _age = age def play ( self ) : if self . _age <= 16 : print ( '%s正在玩飞行棋.' % self . _name ) else : print ( '%s正在玩斗地主.' % self . _name ) def main () : person = Person ( '王大锤' , 12 ) person . play () person . age = 22 # 自动转换为 person . age ( 22 ) person . play () # person . name = '白元芳' # AttributeError : can 't set attribute if __name__ == ' __main__ ' : main () 7.2 __slots__ 魔法 Python 是一门动态语言。通常，动态语言允许我们在程序运行时给对象绑定新的属性或方法，当然也可以对已经绑定的属性和方法进行解绑定。但是如果我们需要限定自定义类型的对象只能绑定某些属性，可以通过在类中定义 __slots__ 变量来进行限定。需要注意的是 __slots__ 的限定只对当前类的对象生效，对子类并不起任何作用。 class Person ( object ) : # 限定 Person对象只能绑定_name , _age和_gender属性 __slots__ = ( '_name' , '_age' , '_gender' ) def __init__ ( self , name , age ) : self . _name = name self . _age = age @property def name ( self ) : return self . _name @property def age ( self ) : return self . _age @age . setter def age ( self , age ) : self . _age = age def play ( self ) : if self . _age <= 16 : print ( '%s正在玩飞行棋.' % self . _name ) else : print ( '%s正在玩斗地主.' % self . _name ) def main () : person = Person ( '王大锤' , 22 ) person . play () person . _gender = '男' # AttributeError : 'Person' object has no attribute '_is_gay' # person . _is_gay = True 7.3 静态方法和类方法 @staticmethod 在类中定义的方法都是对象方法，也就是说这些方法都是发送给对象的消息。实际上，我们写在类中的方法并不需要都是对象方法，例如我们定义一个\"三角形\"类，通过传入三条边长来构造三角形，并提供计算周长和面积的方法，但是传入的三条边长未必能构造出三角形对象，因此我们可以先写一个方法来验证三条边长是否可以构成三角形，这个方法很显然就不是对象方法，因为在调用这个方法时三角形对象尚未创建出来（因为都不知道三条边能不能构成三角形），所以这个方法是属于三角形类而并不属于三角形对象的。我们可以使用静态方法来解决这类问题，代码如下所示： from math import sqrt class Triangle ( object ): def __init__ ( self , a , b , c ): self . _a = a self . _b = b self . _c = c @staticmethod def is_valid ( a , b , c ): return a + b > c and b + c > a and a + c > b def perimeter ( self ): return self . _a + self . _b + self . _c def area ( self ): half = self . perimeter () / 2 return sqrt ( half * ( half - self . _a ) * ( half - self . _b ) * ( half - self . _c )) def main (): a , b , c = 3 , 4 , 5 # 静态方法和类方法都是通过给类发消息来调用的 if Triangle . is_valid ( a , b , c ): t = Triangle ( a , b , c ) print ( t . perimeter ()) # 也可以通过给类发消息来调用对象方法但是要传入接收消息的对象作为参数 # print(Triangle.perimeter(t)) print ( t . area ()) # print(Triangle.area(t)) else : print ( '无法构成三角形.' ) if __name__ == '__main__' : main () @classmethod 和静态方法比较类似，Python 还可以在类中定义类方法，类方法的第一个参数约定名为 cls ，它代表的是当前类相关的信息的对象（类本身也是一个对象，有的地方也称之为类的元数据对象），通过这个参数我们可以获取和类相关的信息并且可以创建出类的对象，代码如下所示： from time import time , localtime , sleep class Clock ( object ): \"\"\"数字时钟\"\"\" def __init__ ( self , hour = 0 , minute = 0 , second = 0 ): self . _hour = hour self . _minute = minute self . _second = second @classmethod def now ( cls ): ctime = localtime ( time ()) return cls ( ctime . tm_hour , ctime . tm_min , ctime . tm_sec ) def run ( self ): \"\"\"走字\"\"\" self . _second += 1 if self . _second == 60 : self . _second = 0 self . _minute += 1 if self . _minute == 60 : self . _minute = 0 self . _hour += 1 if self . _hour == 24 : self . _hour = 0 def show ( self ): \"\"\"显示时间\"\"\" return ' %02d : %02d : %02d ' % \\ ( self . _hour , self . _minute , self . _second ) def main (): # 通过类方法创建对象并获取系统时间 clock = Clock . now () while True : print ( clock . show ()) sleep ( 1 ) clock . run () if __name__ == '__main__' : main () 7.4 类之间的关系 简单的说，类和类之间的关系有三种： is-a 、 has-a 和 use-a 关系。 is-a 关系也叫继承或泛化，比如学生和人的关系、手机和电子产品的关系都属于继承关系 has-a 关系通常称之为关联，比如部门和员工的关系，汽车和引擎的关系都属于关联关系；关联关系如果是整体和部分的关联，那么我们称之为聚合关系；如果整体进一步负责了部分的生命周期（整体和部分是不可分割的，同时同在也同时消亡），那么这种就是最强的关联关系，我们称之为合成关系 use-a 关系通常称之为依赖，比如司机有一个驾驶的行为（方法），其中（的参数）使用到了汽车，那么司机和汽车的关系就是依赖关系 7.5 继承和多态 子类在继承了父类的方法后，可以对父类已有的方法给出新的实现版本，这个动作称之为方法重写（override）。通过方法重写我们可以让父类的同一个行为在子类中拥有不同的实现版本，当我们调用这个经过子类重写的方法时，不同的子类对象会表现出不同的行为，这个就是多态（poly-morphism）。 Python 从语法层面并没有像 Java 或 C# 那样提供对抽象类的支持，但是我们可以通过 abc 模块的 ABCMeta 元类和 abstractmethod 包装器来达到抽象类的效果，如果一个类中存在抽象方法那么这个类就不能够实例化（创建对象）。 from abc import ABCMeta , abstractmethod class Pet ( object , metaclass = ABCMeta ): \"\"\"宠物\"\"\" def __init__ ( self , nickname ): self . _nickname = nickname @abstractmethod def make_voice ( self ): \"\"\"发出声音\"\"\" pass","tags":"教程","url":"https://xutree.github.io/pages/2018/10/05/100/"},{"title":"X3DOM，HTML，CSS 和 JavaScript","text":"本节，你将学习关于 X3DOM, HTML 和 CSS的更多知识，以及怎么利用 HTML 和 CSS 技术构建出强大的 3D 应用。在本节最后，你讲学习怎么在你的应用中使用 JavaScript。我们将继续使用前一节的例子。拷贝 HelloX3DOM.html 文件并重命名为 HTMLEventsCSS.html。 1. X3DOM 和 CSS 我们首先来看下怎么通过 CSS 操控 X3DOM 元素。你可能已经注意到，在 HelloX3DOM.html 中，3D 内容位于一个被黑色边界包围的白色区域中。X3DOM 有一个单独的 css 文件，自从版本1.3以后，名字一直为 x3dom.css，在这个文件中可以找到关于 X3DOM 元素的所有 css 定义以及 debug 信息。假设你的页面使用灰色和橙色作为主要颜色。你可以通过许多方式改变 X3DOM 默认的 CSS 属性： 在 x3dom.css 后包含你自己的 CSS 文件(External Style Sheet) 在 x3dom.css 之后，利用 style 标签定制 css(Internal Style Sheet) 直接操纵相关元素的 style 属性(Inline Styles) 关于 CSS 有很多网上教程，例如 这里 。我们现在利用第二种方法改变 css，通常不推荐第三种方法。为了定制 x3d 代表的 X3DOM 边界，在你的 HTML 文件头部 x3dom.css 之后插入 style 标签： <html> <head> <title> My first X3DOM page </title> <script type= 'text/javascript' src= 'http://www.x3dom.org/download/x3dom.js' > </script> <link rel= 'stylesheet' type= 'text/css' href= 'http://www.x3dom.org/download/x3dom.css' ></link> <style> x3d { border:2px solid darkorange; } </style> </head> <body> <h1> Hello, X3DOM! </h1> <p> This is my first html page with some 3d objects. </p> <x3d width= '600px' height= '400px' > ... </x3d> </body> </html> 现在，X3DOM 的边界颜色已经改变了。假设你的网页已经有了橙色和灰色风格，使用 pattern.png 作为背景(背景图片在 这里 )。那么完整的 style sheet 如下所示： x3d { border : 2 px solid darkorange ; } body { font-size : 110 % ; font-family : verdana , sans-serif ; background-image : url ( 'pattern.png' ); margin : 3 em ; color : lightgray ; } h1 { color : darkorange ; } 现在你的网页看起来如下所示： 从图中可以看出，X3DOM 使用与网页相同的背景。这是一个很重要的行为：你的 X3DOM scene 是在 HTML 之上进行渲染的。让我们设置 x3d 元素为半透明背景： x3d { border : 2 px solid darkorange ; background : rgba ( 128 , 128 , 128 , 0.4 ); } 现在结果看起来如下所示： 2. X3DOM, HTML 事件和 JavaScript 使用 HTML 和 JavaScript，你可以使用大量有用的回调函数来操纵大多数 DOM 元素。X3DOM 为 node 提供了相似的函数。例如，当我们点击红色立方体的时候，可以弹出一个文本信息，在 shape 里插入一个 onclick 函数就可以实现这个功能： <shape onclick= \"alert('Hello, click!');\" > <appearance> <material diffuseColor= '1 0 0' ></material> </appearance> <box></box> </shape> 目前，你可以对 X3DOM 使用 onmousemove ， onmousedown ， onmouseup ， onmouseover 和 onmouseout 事件。你不仅可以在 shape 节点插入事件，也可以在组节点，例如 transform 插入事件。这样你就可以使用一个回调函数捕捉多个节点的事件。 你可以在每个 DOM 元素上使用 JavaScript，所以你可以随心所欲的操纵 node 。你已经知道怎么使用 onclick 事件，让我们尝试当点击时，改变立方体的颜色。如果你从没使用过 JavaScript，这个 网站 或许可以帮助你。 首先，给你想操纵的节点一个 id ： <shape onclick= \"alert('Hello, click!');\" > <appearance> <material id= \"color\" diffuseColor= '1 0 0' ></material> </appearance> <box></box> </shape> 然后，你就可以通过下面这个函数改变颜色： <script> function changeColor() { if(document.getElementById(\"color\").getAttribute('diffuseColor')==\"1 0 0\") document.getElementById(\"color\").setAttribute('diffuseColor', '0 0 1'); else document.getElementById(\"color\").setAttribute('diffuseColor', '1 0 0'); } </script> <shape onclick=\"changeColor();\"> 3. 下一步：自动创建 (X)HTML 如果你有大量的模型数据，你想把这些数据分配到不同的页面上。那么自动生成实际的页面而不是手动编写代码将更加有趣。你可以使用自动化工具，例如 XSLT，允许你直接将 X3DOM 文件转化为 XHTML 网页。 这里 是一个例子。","tags":"教程","url":"https://xutree.github.io/pages/2018/10/05/X3DOMHTMLCSS和JavaScript/"},{"title":"Hello，X3DOM！","text":"本教程将教会你怎么配置和运行你的第一个 X3DOM 应用。你只需要一个相容于 WebGL 的浏览器和一个文本编辑器。整个 X3DOM 应用是常规网页的一部分，并且编写方式也与HTML很相似，所以如果你的编辑器支持HTML或者XML的语法高亮那将更好，像 WebStorm 这种 Web 编程 IDE 也是可以的。如果你手头有一个网页浏览器和一个文本编辑器，并且你知道怎么在浏览器中打开网页(参考 这里 )，那么你可以开始你的第一个 X3DOM 应用了。 首先，创建一个新文件 HelloX3DOM.html 。然后将下面的内容复制粘贴进这个空文件： <html> <head> <title> My first X3DOM page </title> <script type= 'text/javascript' src= 'http://www.x3dom.org/download/x3dom.js' > </script> <link rel= 'stylesheet' type= 'text/css' href= 'http://www.x3dom.org/download/x3dom.css' ></link> </head> <body> <h1> Hello, X3DOM! </h1> <p> This is my first html page with some 3d objects. </p> </body> </html> 如果你在浏览器中打开这个文件，你会看到一个包含一个文本信息的常规HTML页面。你可能已经注意到，我们已经在我们的网页中添加了一些 X3DOM 元素，因为我们已经包含 X3DOM 作为一个 JaveScript 库，还包含了 X3DOM CSS 文件，用于规则的显示 X3DOM 元素。在上面的 HTML 代码中，我们通过 script 和 link 标签是用了 development 版本的 X3DOM。 让我们继续添加一些 3D 内容。首先，我们需要一个 x3d 元素，用来描述 X3DOM 内容在哪个 scene 显示。和 HTML 元素 p 、 div 类似， x3d 在 HTML 里定义了一个矩形范围。整个 X3DOM 的 3D 内容用 scene 描述，所以我们在 x3d 标签里添加一个 scene 标签。这种结构是来自于X3D标准。一个 scene 可以包含很多不同的 node ，例如， lights 、 groups 、 viewpoint 和 objects 。在第一个例子里，我们通过 shape 简单地定义一个3D物体。我们用 box 定义这个物体的几何形状。现在，你可以将下面的代码添加在你的 HTML 文件闭合 p 标签之后： <x3d width= '600px' height= '400px' > <scene> <shape> <box></box> </shape> </scene> </x3d> 如果你现在在浏览器中打开这个文件，会像下面这样： 由于 box 目前没有颜色，所以无法看到它，为了看到它我们需要声明 material ，X3DOM 基于 X3D 标准选择了一个白色的 material ，由于网页的背景也是白色的，所以我们看不到它。为了改变 material 的颜色，我们首先需要在 shape 中插入 appearance 。在 appearance 里面，我们就可以插入 material ，利用 material 的 diffuseColor 我们可以定义 material 的颜色，我们现在将它定义为 RGB 颜色的红色： <shape> <appearance> <material diffuseColor= '1 0 0' ></material> </appearance> <box></box> </shape> 现在，在你的浏览器中，网页将变成： 现在，你可以利用鼠标进行交互了。按住鼠标左键并移动鼠标，你可以旋转视角，按住鼠标右键并移动鼠标，你可以放大和缩小。 我们继续在这个 scene 中添加两个物体：一个蓝色的球体和一个绿色的圆锥。这和我们添加 box 类似，但是，在 sphere 和 cone 节点处，我们需要移动球和圆锥以避免他们相互重叠，因为所有的 3D 物体都默认不进行任何的坐标转换，也就是说它们会重叠在一起。像X3D和其他的图像相关标准(例如，OpenGL)一样，X3DOM 的坐标系统 Y 轴指向上，X 轴指向右，Z 轴指向外： 在添加绿色圆锥之前，我们将坐标往左移动3个单位；在添加蓝色球之前，我们将坐标往右移动3个单位。如下所示： <shape> <appearance> <material diffuseColor= '1 0 0' ></material> </appearance> <box></box> </shape> <transform translation= '-3 0 0' > <shape> <appearance> <material diffuseColor= '0 1 0' ></material> </appearance> <cone></cone> </shape> </transform> <transform translation= '3 0 0' > <shape> <appearance> <material diffuseColor= '0 0 1' ></material> </appearance> <sphere></sphere> </shape> </transform> 现在，在你的浏览器中，你将看到如下内容： 如果你在浏览器中看到了上图的结果，恭喜你！你刚刚使用了一系列的 X3D node 创建了你的第一个 X3DOM scene 。","tags":"教程","url":"https://xutree.github.io/pages/2018/10/04/X3DOM-hello/"},{"title":"X3DOM 第一课","text":"下面的指南可以作为 X3DOM 使用者和开发者的入门资料。本指南包括许多重要的内容，例如怎么配置你的环境去运行 X3DOM 的示例。如果你没有足够的时间阅读这篇入门文章，又或许你已经熟悉一点关于 X3D 的知识，你可以迅速的浏览下第3部分和第4部分的一些内容去设置你的环境，然后根据 tutorials 的指导去完成你的第一个 X3DOM 应用。 1. 背景：什么是X3DOM，它可以用来做什么？ 1.1 无需插件即可在浏览器中显示的3D场景 X3DOM（发音：\"X-Freedom\"）是一个开源的 JaveScript 框架，用于在网页中创建 declarative 3D 场景。由于它基于标准的浏览器技术，你的浏览器不需要其他任何插件就可以显示 X3DOM 场景。概括地说，declarative 3D 意味着你可以使用结构化的文本表示去创建和显示 3D 场景，而不需要去编写代码。在 X3DOM 中，这种文本表示是表示网页的 HTML 文件的一部分。也就是说，3D 内容成为了网页元素的一部分，就像网页中的文本、链接、图片和视频一样。 1.2 X3DOM = X3D + DOM X3DOM 这个名字是由两个缩写组合而成。第一个缩写是 X3D （\"Extensible 3D Graphics\"），指代一个 3D 图形的免版税 ISO 标准。第二个缩写是 DOM （\"Document Object Model\"），描述与HTML文档的内容相关联的交互概念和分层表示。X3DOM 使用 X3D 的一个专门的子集（所谓的 HTML Profile ）来作为网页内 3D 内容的描述语言。X3D（OM)元素可以通过 DOM 操作，就像其他的 HTML 元素一样。例如，你可以动态地改变一个 3D 物体的颜色通过 JavaScript 调用相应 DOM 元素的 setAttribute(...) 函数，这就像你可以动态改变一个普通网页里一个标签的内容一样。 1.3 使用 X3DOM 的原因 使用 X3DOM 而不是其他的基于浏览器的库或者 X3D 播放器是因为 X3DOM 具有以下几个优势： 显示 X3DOM 场景不需要额外插件，因为 X3DOM 是完全基于标准浏览器技术，例如 HTML5 和 WebGL 基于 ISO 标准 X3D 的一种新的 HTML 配置，X3DOM 绝大部分都是标准一致的。这大大方便了 X3DOM 的学习 从2009年至今，X3DOM 已经具有了很大的使用者和开发者群体 如果你知道怎么创建简单的网页，你就可以利用你现有的关于 HTML 和 DOM 的知识，而不需要学习新的 API 1.4 怎么做？ 如果你想开发你的第一个 X3DOM 应用，你只需要一个浏览器和一个文本编辑器。当然，你也可以选择功能更多的 HTML 和 JavaScript 开发环境，比如 WebStorm 。 2. 一些基本 X3D 概念：Nodes、Components 和 Profiles 2.1 X3D Nodes X3D 定义每一个 3D 场景都是由一组 node 组成。每一个 node 代表 3D 场景中一个确定的部分：光线、物体、物体表面的材质等等。场景里的所用 node 排列成树结构或者图结构，整体结构被叫做 scene-graph 。每一个 node 的行为，比如材质的颜色，可以通过node的 fields 设置。例如，一个用来设置某物体表面颜色为红色（RGB编码 1 0 0）的node的 XML 描述为： <Material diffuseColor= '1 0 0' ></Material> 你可能已经意识到，描述 X3D node 的 XML 很像常规的 HTML 代码，属性值 diffuseColor 的设置也像 HTML 属性的设置一样。事实上，如果你熟悉 HTML，那么就很容易理解 X3DOM 中的 node 了。你可以在 tutorials 中学习怎样使用 node。如果你想了解更多 X3D 中 node 的概念，可以参考 external X3D documentation resources 。 2.2 X3D Components 一组具有相同功能的 node 称为 components。例如定义光线的 node， PointLight 和 SpotLight ，在 Lighting component 里。关于 Components 的全部信息可以在 这里 找到。 2.3 X3D Profiles 和 X3DOM HTML Profile X3D 标准定义了大量的 node，一些特殊用途的 node 对大多说用户来说并不重要。因此，X3D 引入了 profile 的概念，把许多组 node 放在一起成为一个包，每一个包代表一类特殊的应用。例如， CAD 包， Immersive 包是用于交互环境的。profile 是在 component 之上的一个概念。 X3DOM 使用的 X3D component 经过十分仔细的选择，以提供一个最合适的 X3D 子集来满足现代 HTML 应用的需要。X3DOM 通过定义一个特殊的 profile，即 HTML profile，来解决这一问题。这个 HTML profile 也包括一些处于试验阶段的 X3D 没有的 node 和 filed，这些 node 和 filed 是专门为 X3DOM 设计的。具体来说，有些 X3D node 在 X3DOM 里没有，而有些 node X3DOM 里有但是 X3D 里没有。你可以在 这里 找到每个 node 的起源。如果你想学习更多关于 HTML profile 的知识以及它与现有的 X3D component、profile 的关系，可以查看 这里 。 最后，X3DOM 也提供一些不在原始HTML profile 中的 X3D node。这些 node 不在 X3DOM 的标准发行版本中，只在 X3DOM-Full 版本中。 3. 选择一个 X3DOM 版本 3.1 版本和 Components 有许多可供选择的 X3DOM 版本，你可能想知道对特殊的目的哪一个才是最好的。一般来讲，我们推荐最新的 release 版本。但是，如果你需要采用的新特性在 release 版中没有，那么 dev 版本可能更适合你。当你完成了网页应用的主要开发工作进而部署时，你可能需要用来开发的 X3DOM 的版本信息。你也可能，出于某种原因需要老版本的 X3DOM，比如你的网页应用包含了一些试验特性只在老版本出现，而在新版本中被移除了。 所有的 X3DOM release 版本，包括 dev 版本，都被打包好了，里面包括一个 JavaScript 文件（如 x3dom.js），一个 css文件（如 x3dom.css）和一个可选的 shockwave 文件（如 x3dom.swf，对于那些支持 flash 的版本），可在 这里 下载： 版本1.0到1.2的文件以 x3dom-v 标记，后面跟着版本号（如 http://x3dom.org/download/x3dom-v1.1.js ） 从版本1.3开始，x3dom.js, x3dom.css, x3dom.swf 和一个 .zip 存档文件b被放置在一个以版本号为名字的子文件夹里（如 http://x3dom.org/download/1.3/x3dom.js ） 从版本1.3开始，一些 HTML profile 之外的 component 出现了。这些 component 在文件 x3dom-full.js 中。如果你只需要使用其中一个 component，你也可以考虑仍使用 x3dom.js 然后包含所需的 component 的文件（如 http://x3dom.org/download/1.3/components/ ） 最新的稳定 release 版总是位于： http://x3dom.org/release/x3dom.js 目前的 development 版本总是位于 dec 子文件夹： http://x3dom.org/download/dev/x3dom.js 为使用最新版本 release X3DOM，你可以在你的HTML页面中包含下面的标签： <script src= \"http://www.x3dom.org/release/x3dom.js\" ></script> <link rel= \"stylesheet\" href= \"http://www.x3dom.org/release/x3dom.css\" > 为使用最新的 development 版本，使用下面的标签： <script src= \"http://www.x3dom.org/download/dev/x3dom.js\" ></script> <link rel= \"stylesheet\" href= \"http://www.x3dom.org/download/dev/x3dom.css\" > 为使用版本1.5的 X3DOM-Full 版本，使用下面的标签： <script src= \"http://www.x3dom.org/download/1.5/x3dom-full.js\" ></script> <link rel= \"stylesheet\" href= \"http://www.x3dom.org/download/1.5/x3dom.css\" > 最后，为使用1.3版本的 release X3DOM 和额外的 Geospatial component 和另外的 flash 支持，使用下面的标签： <script src= \"http://www.x3dom.org/download/1.3/x3dom.js\" ></script> <script src= \"http://www.x3dom.org/download/1.3/components/Geospatial.js\" ></script> <script src= \"http://www.x3dom.org/download/1.3/x3dom.swf\" ></script> <link rel= \"stylesheet\" href= \"http://www.x3dom.org/download/1.3/x3dom.css\" > 3.2 Debugging 如果在 debug 你的应用的时候你想看到 X3DOM 的源码，只需将 x3dom.js 替换成 x3dom.debug.js 或者将 x3dom-full.js 替换成 x3dom-full.debug.js。其注意，此特性只适用于版本1.4以后的 X3DOM。相比于常规版本，debug 版本包含缩进和注释，所以比较大。所以，当你最终发布你的 Web 应用时，请不要使用 debug 版本的 js。 4. 运行 X3DOM 应用 4.1 通过简单的 Python 服务器 一个简便的方法在服务器上来测试你的 Web 应用是使用 Python 的 HTTP 服务器模块。你只需要安装一个 Python 解释器。你可以在 这里 下载。你可以用 Python 做许多有趣的事情。首先，打开命令行窗口，定位到 X3DOM 文件夹。如果你的 Python 是2.X版本，你可以使用 SimpleHTTP 服务器模块如下所示： python -m SimpleHTTPServer 如果你的 Python 是3.x版本，如下所示： python3 -m http.server 默认情况下，服务器使用8000端口。如果你想改变端口，直接在命令后面加上端口号即可，例如： python -m SimpleHTTPServer 8023 然后，通过浏览器输入如下地址就可以到达你的服务器： http://localhost:8023 如果你在启动 Python 服务器的文件夹里放置了 index.html 文件，那么这个文件的内容就会显示在浏览器窗口里。否则，你会看到服务器所在文件夹内的文件列表。 4.2 在 Web 服务器上运行 X3DOM 通常，你会在Web服务器上运行你的 X3DOM 应用，本节针对一些普通的 Web 服务器，如 Apache 和 IIS，给出具体的方法。 Apache 是使用最多的 Web 服务器。它是开源的可以在 这里 下载。最新版本是2.4，但是版本2.2仍然被支持。 如果你的应用需要一整套 Web 服务器组件，我们推荐 XAMPP ，它包含 Apache、MySQL、PHP 和 Perl 的最新发行版。 互联网信息服务（IIS）被集成在微软的任何的最新版本的 Windows 当中。但是，对于非服务器操作系统，同时连接数会受到限制。","tags":"教程","url":"https://xutree.github.io/pages/2018/10/04/X3DOM第一课/"},{"title":"安装 Pelican","text":"1. 安装 Pelican Pelican 目前支持最好的是 Python 2.7 和 3.3+，早期版本的 Python 已经不支持了。有许多不同的方法可以安装 Pelican，最简单的方法是使用 pip，在终端输入： pip install pelican 上面是最简单的方法，官方更为推荐的方法是利用 virtualenv 为 Pelican 建立一个虚拟环境。假设你已经安装好了 virtualenv，下面打开终端，开始为 Pelican 新建一个虚拟环境： virtualenv ~/virtualenv/pelican cd ~/virtualenv/pelican source bin/activate 当虚拟环境被创建并激活以后，然后利用 pip install pelican 安装 Pelican。 当 Pelican 安装好以后，你可以在终端输入 pelican --help 查看使用选项。 2. 可选的 Packages\b 如果你计划用 Markdown 来书写你的网页的话，你需要安装 Markdown： pip install Markdown 通过设置 Pelican 的 pelicanconf.py 文件，你可以对生成的 HTML 文件启用增强语法。但是首先你需要安装 Typogrify ： pip install typorify 3. 更新 更新到最新的稳定版本，使用： pip install --upgrade pelican","tags":"教程","url":"https://xutree.github.io/pages/2018/10/04/在mac上安装Pelican/"}]}