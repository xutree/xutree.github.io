{"pages":[{"title":"Search · You Know Nothing\n","text":"\n\n\n\n\n\n\nSearch · You Know Nothing\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nYou Know Nothing\n\n\n主页\n分类\n标签\n归档\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPowered by Pelican. Theme: Elegant by Talha Mansoor\n\n\n\n\n\n\n    $(document).ready(function() {\n        $('#tipue_search_input').tipuesearch({\n            'mode': 'json',\n            'show': 10,\n            'newWindow': false,\n            'contentLocation': 'tipuesearch_content.json'\n        });\n    });\n\n\n","tags":"","url":"https://xutree.github.io/search.html"},{"title":"Page not found · You Know Nothing\n","text":"\n\n\n\n\n\n\nPage not found · You Know Nothing\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nYou Know Nothing\n\n\n主页\n分类\n标签\n归档\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n该页面不存在！\n\n\n\n\n抱歉，找不到您要查找的页面。 您尝试访问的页面似乎不存在，或者可能刚刚移动，或者它已不再存在。\n或许你想从主页重新开始。\n\n\n\n\n\n\n\n\n\n\nPowered by Pelican. Theme: Elegant by Talha Mansoor\n\n\n \n\n\n        function validateForm(query) {\n            return (query.length > 0);\n        }\n    \n\n","tags":"","url":"https://xutree.github.io/404.html"},{"title":"Atom 快捷键","text":"参考： https://www.jianshu.com/p/e33f864981bb 、 https://github.com/nwinkler/atom-keyboard-shortcuts 基本快捷键 快捷键 快捷键的功能 cmd-, 打开设置面板 shift-cmd-p 打开和关闭命令面板 ctrl-alt-cmd-l 重启 alt-cmd-i 打开开发者工具 文件切换 快捷键 快捷键的功能 cmd-shift-o 打开目录 ctrl-0 焦点移到目录树,注意这里是数字0，非常实用也可以用cmd+\\来变相达到效果 a, m, d, delete 目录树下，增加，修改，另存为和删除 cmd-t 或 cmd-p 查找文件（模糊查找） cmd-b 在打开的文件之间切换 cmd-shift-b 只搜索从上次 git commit 后修改或者新增的文件 alt-cmd-left 在打开的标签页往左切换 alt-cmd-right 在打开的标签页往右切换 导航 快捷键 快捷键的功能 ctrl-p 前一行 ctrl-n 后一行 ctrl-f 后一个字符 ctrl-b 前一个字符 alt-b, alt-left 移动到单词开始 alt-f, alt-right 移动到单词末尾 cmd-right, ctrl-e 移动到一行结束 cmd-left, ctrl-a 移动到一行开始 cmd-up 移动到文件开始 cmd-down 移动到文件结束 cmd-r 在方法之间跳转 窗口管理 快捷键 快捷键的功能 cmd-n 新建文件 shift-cmd-n 新建窗口 cmd-o 打开文件 cmd-shift-o 打开文件夹 cmd-s 保存 shift-cmd-s 另存为 alt-cmd-s 保存所有 cmd-w 关闭标签 shift-cmd-w 关闭窗口 cmd-k up/down/left/right 分隔窗口 cmd-k cmd-up/down/left/right 聚焦窗口 ctrl-cmd-f 全屏 目录树操作 快捷键 快捷键的功能 cmd-\\ 显示(隐藏)目录树 ctrl-0 焦点切换到目录树(再按一次或者 Esc 退出目录树) alt-right 和 alt-left 展开(隐藏)所有目录 ctrl-alt-] 和 ctrl-alt-[ 同上 ctrl-[ 和 ctrl-] 展开(隐藏)当前目录 ctrl-shift-c 复制当前文件绝对路径 cmd-k h 或 cmd-k left 在左半视图中打开文件 cmd-k j 或 cmd-k down 在下半视图中打开文件 cmd-k k 或 cmd-k up 在上半视图中打开文件 cmd-k l 或 cmd-k right 在右半视图中打开文件 cmd-k h 为先按下 cmd-k ，松开后按 h 。 书签 快捷键 快捷键的功能 cmd-F2 在本行增加书签 F2 跳到当前文件的下一条书签 shift-F2 跳到当前文件的上一条书签 选取 快捷键 快捷键的功能 ctrl-shift-p 选取至上一行 ctrl-shift-n 选取至下一行 ctrl-shift-b 选取至前一个字符 ctrl-shift-f 选取至后一个字符 alt-shift-b, alt-shift-left 选取至字符开始 alt-shift-f, alt-shift-right 选取至字符结束 ctrl-shift-e, cmd-shift-right 选取至本行结束 ctrl-shift-a, cmd-shift-left 选取至本行开始 cmd-shift-up 选取至文件开始 cmd-shift-down 选取至文件结尾 cmd-a 全选 cmd-l 选取一行，继续按会继续选取下一行 ctrl-shift-w 选取当前单词 编辑和删除文本 快捷键 快捷键的功能 ctrl-t 使光标前后字符交换 cmd-j 将下一行与当前行合并 ctrl-cmd-up, ctrl-cmd-down 使当前行向上或者向下移动 cmd-shift-d 复制当前行到下一行 cmd-/ 将选择的文件加入注释 Atom 大小写转换 快捷键 快捷键的功能 cmd-k, cmd-u 使当前字符大写 cmd-k, cmd-l 使当前字符小写 cmd-k, cmd-u 为先按 cmd-k 再按 cmd-u 。 删除和剪切 快捷键 快捷键的功能 ctrl-shift-k 删除当前行 ctrl-k 剪切到当前行结束 alt-h 或 alt-delete 删除到当前单词开始 alt-d 删除到当前单词结束 多光标和多处选取 快捷键 快捷键的功能 cmd-click 增加新光标 cmd-shift-l 将多行选取改为多行光标 ctrl-shift-up, ctrl-shift-down 增加上（下）一行光标 cmd-d 选取文档中和当前单词相同的下一处 cmd-u 取消选择 ctrl-cmd-g 选取文档中所有和当前光标单词相同的位置 跳转 快捷键 快捷键的功能 ctrl-m 相应括号之间，html tag之间等跳转 ctrl-g 移动到指定行 row:column 处 ctrl-cmd-m 括号(tag)之间文本选取 alt-cmd-.|关闭当前XML/HTML tag ctrl-shift-o 打开链接 编码方式，文件类型，Markdown 预览 快捷键 快捷键的功能 ctrl-shift-u 调出切换编码选项 ctrl-shift-l 选择文本类型 ctrl-shift-m Markdown 预览 查找和替换 快捷键 快捷键的功能 cmd-f 在buffer中查找 cmd-g 查找下一个 shift-cmd-g 查找上一个 cmd-shift-f 在整个工程中查找 折叠 快捷键 快捷键的功能 alt-cmd-[ 折叠 alt-cmd-] 展开 alt-cmd-shift-{ 折叠全部 alt-cmd-shift-} 展开全部 cmd-k cmd-n 指定折叠层级 N为层级数 git 操作 快捷键 快捷键的功能 cmd-alt-z checkout HEAD 版本 cmd-shift-b 弹出 untracked 和 modified 文件列表 alt-g down alt-g up 在修改处跳转 alt-g d 弹出diff列表 alt-g o 在 github 上打开文件 alt-g g 在 github 上打开项目地址 alt-g b 在 github 上打开文件 blame` alt-g h 在 github 上打开文件 history` alt-g i 在 github 上打开 issues` alt-g r 在 github 打开分支比较 alt-g c 拷贝当前文件在 gihub 上的网址","tags":"教程","url":"https://xutree.github.io/pages/2018/10/16/atom快捷键/"},{"title":"Perl 入门","text":"Perl 是 Practical Extraction and Report Language 的缩写，可翻译为 \"实用报表提取语言\"。 Perl 是高级、通用、直译式、动态的程序语言。 Perl 最初的设计者为拉里·沃尔（Larry Wall），于1987年12月18日发表。 Perl 借用了 C、sed、awk、shell 脚本以及很多其他编程语言的特性。 Perl 最重要的特性是 Perl 内部集成了正则表达式的功能，以及巨大的第三方代码库CPAN。 以下代码为使用 Perl 输出 \"Hello World！\"： 1 2 #!/usr/bin/perl print \"Hello, World!\\n\" ; Perl 语言的应用范围很广，除 CGI 以外，Perl 被用于图形编程、系统管理、网络编程、金融、生物以及其他领域。由于其灵活性，Perl 被称为脚本语言中的瑞士军刀。 Perl 与脚本语言一样，Perl 不需要编译器和链接器来运行代码，你要做的只是写出程序并告诉 Perl 来运行而已。这意味着 Perl 对于小的编程问题的快速解决方案和为大型事件创建原型来测试潜在的解决方案是十分理想的。 运行 Perl 交互式 $perl -e <perl code> # Unix/Linux C:>perl -e <perl code> # Windows/DOS 选项 描述 -d[:debugger] 在调试模式下运行程序 -Idirectory 指定 @INC/#include 目录 -T 允许污染检测 -t 允许污染警告 -U 允许不安全操作 -w 许很多有用的警告 -W 允许所有警告 -X 禁用使用警告 -e program 执行 perl 代码 file 执行 perl 脚本文件 脚本执行 $perl script.pl # Unix/Linux C:>perl script.pl # Windows/DOS Perl 基础语法 语句 Perl 程序有声明与语句组成，程序自上而下执行，包含了循环，条件控制，每个语句以分号 ( ; ) 结束。Perl 语言没有严格的格式规范，你可以根据自己喜欢的风格来缩进。 注释 perl 注释的方法为在语句的开头用字符 #。 perl 也支持多行注释，最常用的方法是使用 POD(Plain Old Documentations) 来进行多行注释。方法如下: 1 2 3 4 5 6 7 8 9 10 11 #!/usr/bin/perl # 这是一个单行注释 print \"Hello, world\\n\" ; =pod 注释 这是一个多行注释 这是一个多行注释 这是一个多行注释 这是一个多行注释 =cut =pod、 =cut只能在行首 以=开头，以=cut结尾 =后面要紧接一个字符，=cut后面可以不用 空白 Perl 解释器不会关心有多少个空白。但是如果空格和分行出现在字符串内，他会原样输出。 引号 Perl 双引号和单引号的区别: 双引号可以正常解析一些转义字符与变量，而单引号无法解析会原样输出。 Here 文档 必须后接分号，否则编译通不过 END 可以用任意其它字符代替，只需保证结束标识与开始标识一致 结束标识必须顶格独自占一行(即必须从行首开始，前后不能衔接任何空白和字符) 开始标识可以不带引号号或带单双引号，不带引号与带双引号效果一致，解释内嵌的变量和转义符号，带单引号则不解释内嵌的变量和转义符号 当内容需要内嵌引号（单引号或双引号）时，不需要加转义符，本身对单双引号转义 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #!/usr/bin/perl $a = 10 ; $var = <<\" EOF \"; 这是一个 Here 文档实例，使用双引号。 可以在这输如字符串和变量。 例如：a = $a EOF print \"$var\\n\" ; $var = <<' EOF '; 这是一个 Here 文档实例，使用单引号。 例如：a = $a EOF print \"$var\\n\" ; 执行以上程序输出结果为： 这是一个 Here 文档实例，使用双引号。 可以在这输如字符串和变量。 例如：a = 10 这是一个 Here 文档实例，使用单引号。 例如：a = $a Perl 数据类型 Perl 是一种弱类型语言，所以变量不需要指定类型，Perl 解释器会根据上下文自动选择匹配类型。 Perl 有三个基本的数据类型：标量、数组、哈希。 标量 标量是 Perl 语言中最简单的一种数据类型。这种数据类型的变量可以是数字，字符串，浮点数，不作严格的区分。在使用时在变量的名字前面加上一个\"$\",表示是标量。 数组 数组变量以字符\"@\"开头，索引从0开始。 哈希 哈希是一个无序的 key/value 对集合。可以使用键作为下标获取值。哈希变量以字符\"%\"开头。 数字字面量 整型 Perl 实际上把整数存在你的计算机中的浮点寄存器中，所以实际上被当作浮点数看待。 在多数计算机中，浮点寄存器可以存贮约16位数字，长于此的被丢弃。整数实为浮点数的特例。 8进制和16进制数：8进制以0开始，16进制以0x开始。 浮点数 浮点数数据如：11.4 、 -0.3 、.3 、 3. 、 54.1e+02 、 5.41e03 浮点寄存器通常不能精确地存贮浮点数，从而产生误差，在运算和比较中要特别注意。指数的范围通常为-309到+308。 字符串 Perl 中的字符串使用一个标量来表示，定义方式和 c 很像，但是在 Perl 里面字符串不是用0来表示结束的。 Perl 双引号和单引号的区别: 双引号可以正常解析一些转义字符与变量，而单引号无法解析会原样输出。但是用单引号定义可以使用多行文本。 转义字符 转义字符 含义 \\\\ 反斜线 \\' 单引号 \\\" 双引号 \\a 系统响铃 \\b 退格 \\f 换页符 \\n 换行 \\r 回车 \\t 水平制表符 \\v 垂直制表符 \\0nn 创建八进制格式的数字 \\xnn 创建十六进制格式的数字 \\cx 控制字符，x可以是任何字符 \\u 强制下一个字符为大写 \\l 强制下一个字符为小写 \\U 强制将所有字符转换为大写 \\L 强制将所有的字符转换为小写 \\Q 将到\\E为止的非单词（non-word）字符加上反斜线 \\E 结束\\L、\\U、\\Q Perl 变量 标量 $ 开始， 如$a $b 是两个标量。 数组 @ 开始 ， 如 \\@a \\@b 是两个数组。 哈希 % 开始 ， %a %b 是两个哈希。 Perl 为每个变量类型设置了独立的命令空间，所以不同类型的变量可以使用相同的名称，你不用担心会发生冲突。例如 $foo 和 \\@foo 是两个不同的变量。 变量不需要显式声明类型，在变量赋值后，解释器会自动分配匹配的类型空间。 Perl 标量 标量是一个简单的数据单元。 标量可以是一个整数，浮点数，字符，字符串，段落或者一个完整的网页。 特殊字符 以下我们将演示 Perl 中特殊字符的应用，如 __FILE__, __LINE__, 和 __PACKAGE__ 分别表示当前执行脚本的文件名，行号，包名。 注意： 是两条下划线，__FILE 前后各两条下划线。 这些特殊字符是单独的标记，不能写在字符串中，例如： 1 2 3 4 5 6 7 8 #!/usr/bin/perl print \"文件名 \" . __FILE__ . \"\\n\" ; print \"行号 \" . __LINE__ . \"\\n\" ; print \"包名 \" . __PACKAGE__ . \"\\n\" ; # 无法解析 print \"__FILE__ __LINE__ __PACKAGE__\\n\" ; 文件名 test.pl 行号 4 包名 main __FILE__ __LINE__ __PACKAGE__ v 字符串 用于十六进制： 1 2 3 4 5 6 7 8 9 #!/usr/bin/perl $smile = v9786 ; $foo = v102 .111.111 ; $martin = v77 .97.114.116.105.110 ; print \"smile = $smile\\n\" ; print \"foo = $foo\\n\" ; print \"martin = $martin\\n\" ; Wide character in print at test.pl line 7. smile = &#x263a; foo = foo martin = Martin 数组 Perl 数组一个是存储标量值的列表变量，变量可以是不同类型。 数组变量以 \\@ 开头。访问数组元素使用 $ + 变量名称 + [索引值] 格式来读取。","tags":"教程","url":"https://xutree.github.io/pages/2018/10/15/perl入门/"},{"title":"数据结构——向量","text":"数据结构大致可分为：线性结构、半线性结构和非线性结构。线性结构中最基本的称为序列（sequence），根据其中数据项的逻辑次序与其物理存储地址的对应关系不同，又可分为向量（vector）和列表（list）。 从数组到向量 数组：集合 S 由 n 个元素组成，且各元素之间具有一个线性次序，则可以将它们存放于起始地址 A，物理位置连续的一段存储空间。记为： A[0,n) = { A[0], A[1], ..., A[n-1] } 将它们存放于起始地址 A，若每个元素占用 s 个单位的空间，则元素 A[i] 的物理地址为： A + i * s ，所以被称作线性数组。 向量： V[0,n) = { v[0], v[1], ..., v[n-1] } 是线性数组的一种抽象和泛化，由具有线性次序的一组元素构成的集合，其中的元素由秩区分。各元素秩互异，且均为 [0, n) 内的整数。采用\"寻秩访问\"。经过抽象，不限定同一向量中元素都属于同一数据类型，故而不保证它们之间可以相互比较大小。 接口 作为一种抽象数据类型，向量对象应支持如下操作接口： 操作接口 功能 适用对象 size() 元素总数 向量 get(r) 获取秩为 r 的元素 向量 put(r, e) 用 e 代替秩为 r 的元素 向量 insert(r, e) e 作为秩为 r 的元素插入，原后继元素依次后移 向量 remove(r) 删除秩为 r 的元素，返回该元素中原存放的对象 向量 disordered() 判断所有元素是否已按非降序排列 向量 sort() 非降序排序 向量 find(e) 查找等于 e 且秩最大的元素 向量 search(e) 查找目标元素 e，返回不大于 e 且秩最大的元素 有序向量 deduplicate() 剔除重复元素 向量 uniquify() 剔除重复元素 有序向量 traverse() 遍历向量并统一处理所有元素，处理方法由函数对象指定 向量 Vector 模板类 typedef int Rank; //秩 #define DEFAULT_CAPACITY 3 //默认的初始容量（实际应用中可设置为更大） template <typename T> class Vector { //向量模板类 protected: Rank _size; int _capacity; T* _elem; //规模、容量、数据区 void copyFrom(T const* A, Rank lo, Rank hi); //复制数组区间A[lo,hi) void expand(); //空间不足时扩容 void shrink(); //装填因子过小时压缩 bool bubble(Rank lo, Rank hi); //扫描交换 void bubbleSort()Rank lo, Rank hi); //气泡排序算法 Rank max(Rank lo, Rank hi); //选取最大元素 void selectionSort(Rank lo, Rank hi); //选择排序算法 void merge(Rank lo, Rank mi, Rank hi); //归并算法 void mergeSort(Rank lo, Rank hi); //归并排序算法 Rank partition(Rank lo, Rank hi); //轴点构造算法 void quickSort(Rank lo, Rank hi); //快速排序算法 void heapSort(Rank lo, Rank hi); //堆排序 public: //构造函数 //容量为 c，规模为 s，所有元素初始化为 v，s<=c Vector(int c = DEFAULT_CAPACITY, int s = 0, T v = 0) { _elem = new T[_capacity = c]; for(_size = 0; _size < s; _elem[_size++] = v); } Vector(T const* A, Rank n) { copyFrom(A, 0, n); } //数组整体复制 Vector(T const* A, Rank lo, Rank hi) { copyFrom(A, lo, hi); } //区间 Vector(Vector<T> const& V) { copyFrom(V._elem, 0, V._size); } //向量整体复制 Vector(Vector<T> const& V, Rank lo, Rank hi) { copyFrom(V._elem, lo, hi); } //区间 //析构函数 ~Vector() { delete [] _elem; } //释放内部空间 //只读访问接口 Rank size() const { return _size; } //规模 bool empty() const { return !_size; } //判空 int disordered() const; //判断向量是否已排序 Rank find(T const& e) const { return find(e, 0, _size); } //无序向量整体查找 Rank find(T const& e, Rank lo, Rank hi) const; //无序向量区间查找 Rank search(T const& e) const //有序向量整体查找 { return (0 >= _size) ? -1 : search(e, 0, _size); } Rank search(T const& e, Rank lo, Rank hi) const //有序向量区间查找 //可写访问接口 T& operator[](Rank r) const; //重载下标运算符，可以类似于数组形式引用各元素 Vector<T> & operator=(Vector<T> const&); //重载赋值运算符，以便直接克隆向量 T remove(Rank r); //删除秩为 r 的元素 int remove(Rank lo, Rank hi); //删除秩在区间 [lo,hi) 之内的元素 Rank insert(Rank r, T const& e); //插入元素 Rank insert(T const& e) { return insert(_size, e); } //默认作为尾元素插入 void sort(Rank lo, Rank hi); //对 [lo,hi) 排序 void sort() { sort(0, _size); } //整体排序 void unsort(Rank lo, Rank hi); //对 [lo,hi) 置乱 void unsort() { unsort(0, _size); } //整体置乱 int deduplicate(); //无序去重 int uniquify(); //有序去重 //遍历 void traverse(void (*)(T&)); //遍历（使用函数指针，只读或局部性修改） template <typename VST> void traverse(VST&); //遍历（使用函数对象，可全局性修改） };//Vector 构造与析构 约定：向量中秩为 r 的元素，对应于内部数组中的 _elem[r]，其物理地址为：_elem + r 默认构造函数 整个默认构造过程顺序进行，没有任何迭代，故忽略用于分配数组空间的时间，需要常数时间。 基于复制的构造函数 在模板的实现中，我们将基于数组或者向量的复制操作（局部或整体的）都转交给如下的 copyFrom 函数处理： template <typename T> void Vector<T>::copyFrom(T const* A, Rank lo, Rank hi) { _elem = new T[_capacity = 2 * (hi -lo) ]; _size = 0; //分配空间，规模清零 while( lo <hi) //A[lo,hi) 元素逐一复制 _elem[_size++] = A[lo++]; // } 需要 O (_size) 时间。 需要强调的是，由于向量内部含有动态分配的空间，默认的\"=\"运算符不足以支持向量之间的直接赋值。故要重建\"=\"： template <typename T> Vector<T>& Vector<T>::operator=(Vector<T> const& V) { if( _elem ) delet [] _elem; copyFrom(V._elem, 0, V.size()); return *this; } 析构 若不计系统用于空间回收的时间，整个析构过程只需常数时间。 动态空间管理 扩容 template <typename T> void Vector<T>::expand() { if(_size < _capacity) return; //尚未满员，不必扩容 if(_capacity < DEFAULT_CAPACITY) _capacity = DEFAULT_CAPACITY; //不低于最小容量 T *oldElem = _elem; _elem = new T[_capacity << 1]; //容量加倍 for( int i = 0; i < _size; i++) _elem[i] = oldElem[i]; //复制原向量内容（T为基本类型，或以重载赋值运算符 delete [] oldElem; //释放原空间 } 分摊运行时间为 O (1) 缩容 template <typename T> void Vector<T>::shrink() { if(_capacity < DEFAULT_CAPACITY << 1) return; //不至收缩到DEFAULT_CAPACITY if(_size << 2 > _capacity) return; //以25%为界 T *oldElem = _elem; _elem = new T[_capacity >> 1]; //容量减半 for( int i = 0; i < _size; i++) _elem[i] = oldElem[i]; //复制原向量内容（T为基本类型，或以重载赋值运算符 delete [] oldElem; //释放原空间 } 就单次扩容或缩容操作而言，所需时间的确会高达 O (n)，因此在对单次操作的执行速度及其敏感的应用场合以上策略并不适用，其中缩容操作甚至可以完全不予考虑。 常规向量 直接引用元素 与数组直接通过下标访问元素的形式相比，向量 ADT（abstract data type）所设置的 get() 和 put() 接口都显得不甚自然。 template <typename T> T& Vector<T>::operator[](Rank r) const { return _elem[r]; } //assert: 0 <= r < _size 置乱器 重载后 [] 返回的是对数组元素的引用，这就意味着它既可以取代 get() 操作（通常作为赋值表达式的右值），也可以取代 set() 操作（通常作为左值）。采用这种形式，可以很清晰地实现如下的向量置乱器： template <typename T> void permute(Vector<T>& V) { for(int i = V.size(); i > 0; i--) swap(V[i-1], V[rand() % i]); //V[i-1] 与 V[0,i) 中某一随机元素交换 } 从理论上讲，上述算法可以枚举出同一向量所有可能的排列，而且能够保证生成各种排列的概率均等。 为便于对各种向量算法的测试与比较，不妨将上述算法封装到向量 ADT 中，并对外提供向量的置乱接口操作： template <typename T> void Vector<T>::unsort(Rank lo, Rank hi) { T* V = _elem + lo; for(Rank i =hi -lo; i > 0; i--) swap(V[i-1], V[rand() % i]); } 上述两段代码的细微差异：上面的代码通过重载\"[]\"，利用秩间接访问 向量 元素，下面的代码通过下标直接访问内部 数组 的元素。 判等器和比较器 template <typename T> static bool lt(T* a, T* b) { return lt(*a, *b); } //less than template <typename T> static bool lt(T& a, T& b) { return a < b; } //less than template <typename T> static bool eq(T* a, T* b) { return eq(*a, *b); } //equal template <typename T> static bool eq(T& a, T& b) { return a == b; } //equal 在一些复杂的数据结构中，内部元素本身的类型可能就是指向其他对象的指针，从而外部更多关注的，往往是其所指向对象的大小如直接比较指针，则结果毫无意义，故上面的代码分别出了了指针和引用的情况。 无序查找 判等器 Vector 模板中的 find 接口的语义为\"查找与数据对象 e 相等的元素\"。这暗示向量元素可以通过相互\"比对\"判断是否相等。这类仅支持比对，但未必支持比较的向量，称为无序向量（unsorted vector）。 顺序查找 由于 find 函数查找相等的最大秩元素，故从后往前比对： template <typename T> Rank Vector<T>::find(T const& e, Rank lo, Rank hi) const { while( (lo < hi--) && (e != _elem[hi]) ); //assert: 0 <= lo < hi <= _size return hi; } 最坏情况： O (n)；最好情况： O (1)。为输入敏感（input sensitive）算法。 插入 //assert: 0 <= r <= size template <typename T> Rank Vector<T>::insert(Rank r, T const& e) { expan(); //如有必要，扩容 for(int i = _size; i > r; i--) _elem[i] = _elem[i-1]; _elem[r] = e; _size++; //插入并更新容量 return r; } 注意从后往前搬移数据，以防覆盖。复杂度：若插入位置等概论分布，则平均运行时间为 O (_size)= O (n)。 删除 应将单元素删除视为区间删除的特例，并基于后者来实现前者。 区间删除 //删除区间[lo, hi) template <typename T> int Vector<T>::remove(Rank lo, Rank hi) { if(lo === hi) return 0; while(hi < _size) _elem[lo++] = _elem[hi++]; _size = lo; shrink(); return hi - lo; //返回被删除元素个数 } 单元素删除 template <typename T> T Vector<T>::remove(Rank r) { T e = _elem[r]; remove(r, r + 1); return e; } 被删除元素在向量中的位置越靠后（前）所需时间越短（长），最好为 O (1)，最坏为 O (n)。 唯一化 template <typename T> int Vector<T>::deduplicate() { int oldSize = _size; Rank i = 1; while(i < _size) (find(_elem[i], 0, i) < 0) ? i++ : remove(i); return oldSize - _size; }","tags":"读书笔记","url":"https://xutree.github.io/pages/2018/10/10/数据结构向量/"},{"title":"C++ Primer 第八章 IO 库","text":"IO 类 iostream 头文件： istream , wistream , ostream , wostream , iostream , wiostream 类型。 fstream 头文件： ifstream , wifstream , ofstream , wofstream , fstream , wfstream 类型。 sstream 头文件： istringstream , wistringstream , ostringstream , wostringstream , stringstream , wstringstream 类型。 宽字符版本的类型和函数的名字以一个\"w\"开始。 IO 对象无拷贝和赋值。进行 IO 操作的函数通常以引用方式传递和返回值。读写一个 IO 对象会改变其状态，因此传递和返回的引用不能是 const 的。 条件状态 下表中 strm 是一种 IO 类型： 状态 含义 strm ::iostate iostate 是一种机器相关的类型，提供了表达条件状态的完整功能 strm ::badbit 流已崩溃 strm ::failbit IO 操作失败了 strm ::eofbit 流到达了文件结束 strm ::goodbit 流未处于错误状态，此值保证为0 s.eof() 若流 s 的 eofbit 置位，返回 true s.fail() 若流 s 的 failbit 或 badbit 置位，返回 true s.bad() 若流 s 的 badbit 置位，返回 true s.good() 若流 s 处于有效状态，返回 true s.clear() 将流 s 所以状态位复位，将流的状态设为有效，返回 void s.clear(flags) 根据 flags 复位，flags 类型为 strm ::iostate，返回 void s.setstate(flags) 根据 flags 置位，flags 类型为 strm ::iostate，返回 void s.rdstate() 返回流 s 的当前条件状态，返回值类型为 strm ::iostate badbit 表示系统级错误，如不可恢复的读写错误，一旦被置位，流就无法再使用了。 failbit 表示可恢复的错误，例如期望读取数值却读到一个字符等错误。这种问题通常是可以修正的，流还可以继续使用。 如果到达文件结尾， eofbit 和 failbit 都会被置位。 goodbit 值为0，表示流未发生错误。 如果 badbit 、 failbit 和 eofbit 任一个被置位，则检测流状态的条件会失败。 good() 函数在所有错误位均未置位的情况下返回 true 。 我们将流当做条件使用的代码等价于 !fail() 。 管理条件状态 // 记住 cin 的当前状态 auto old_state = cin.rdstate(); // 记住 cin 的当前状态 cin.clean(); // 使 cin 有效 process_input(cin); // 使用 cin cin.setstate(old_state); // 将 cin 置为原有状态 // 复位 failbit 和 badbit，保持其他标志位布标 cin.clear(cin.rdstate() & ~cin.failbit & ~cin.badbit); 管理输出缓冲 每个输出流都管理一个缓冲区，用来保存程序读写的数据。 导致缓冲刷新（即，数据真正写到输出设备或文件）的原因有很多： 程序正常结束，作为 main 函数的 return 操作的一部分，缓冲刷新被执行 缓冲区满 使用操纵符 endl （插入换行）、 ends （插入空字符）、 flush （什么都不插入）显式刷新 在每个输出操作之后，可以用操纵符 unitbuf 设置流的内部状态，来情况缓冲区。默认情况下，对 cerr 是设置 unitbuf 的，因此 cerr 的内容都是立即刷新的 一个输出流可以关联到另一个流。当读写被关联的流时，关联到的流的缓冲区会被刷新。默认情况下， cin 和 cerr 都关联到 cout 。因此读 cin 或者写 cerr 都会导致 cout 的缓冲区被刷新 unitbuf 操纵符 如果想在每次输出操作后都刷新缓冲区，可以使用 unitbuf 操纵符。它告诉流在接下来的每次写操作之后都执行一次 flush 刷新。 nounitbuf 操纵符则重置流，使其恢复使用正常的系统管理的缓冲区刷新机制： cout << unitbuf; // 所有输出操作后都会立即刷新缓冲区 // 任何输出都会立即刷新，无缓冲 cout << nounitbuf; // 回到正常的缓冲方式 关联输入和输出流 tie() 有两个重载的版本： 不带参数的版本返回指向输出流的指针。如果本对象当前关联到一个输出流，则返回的就是指向这个流的指针，如果对象未关联到流，则返回空指针 第二个版本接受一个指向 ostream 的指针，将自己关联到此 ostream 每个流同时最多关联到一个流，但多个流可以同时关联到同一个 ostream 文件输入输出 fstream 特有的操作 下表中的 fstream 是头文件 fstream 中定义的一个类型： 操作 含义 fstream fstrm; 创建一个未绑定的文件流 fstream fstrm(s); 创建一个 fstream ，并打开名为 s 的文件。s 可以是 string 类型或者指向 C 风格字符串的指针。这些构造函数都是 explicit 的。默认的文件模式 mode 依赖于 fstream 的类型 fstream fstrm(s, mode); 按 mode 打开文件 fstrm.open(s) 打开名为 s 的文件并与 fstrm 绑定。s 可以是 string 类型或者指向 C 风格字符串的指针。默认的文件模式 mode 依赖于 fstream 的类型。返回 void fstrm.close() 关闭与 fstrm 绑定的文件。返回 void fstrm.is_open() 返回一个布尔值，指出与 fstrm 关联的文件是否打开成功且尚未关闭 如果调用 open() 失败， failbit 会被置位，条件会为假： if(open(file)) 可用于判定。 对一个已经打开的文件流调用 open() 会失败，并且 failbit 会被置位。为了将文件流关联到另一个文件，必须先关闭已经关联的文件。 当一个 fstream 对象被销毁时， close 会自动被调用。 文件模式 文件模式 意义 in 只读 out 只写（会清空已有数据） app 每次写操作前均定位到文件末尾 ate 打开文件后立即定位到文件末尾 trunc 截断文件 binary 以二进制方式进行 IO ifstream 默认 in 模式； ofstream 默认 out 模式； fstream 默认 in 和 out 模式打开。 string 流 fstream 特有的操作 下表中的 sstream 是头文件 sstream 中定义的一个类型： 操作 含义 sstream strm; 创建一个未绑定的 stringstream 对象 sstream strm(s); strm 是一个 sstream 对象，保存 string s 的一个拷贝。此构造函数时 explicit 的 strm.str() 返回 strm 所保存的 string 的拷贝 strm.str(s) 将 string s 拷贝到 strm 中，返回 void","tags":"读书笔记","url":"https://xutree.github.io/pages/2018/10/09/C++_Primer_Chapter_8/"},{"title":"C++ Primer 第七章 类","text":"类的基本思想是数据抽象和封装。 数据抽象是一种依赖于接口和实现分离的编程（以及设计）技术。类的接口包括用户可以执行的操作，类的实现包括类的数据成员，负责接口实现的函数体以及定义类所需的各种私有函数。 封装实现了类的接口和实现的分离。封装后的类隐藏了它的实现细节，类的用户只能使用接口而无法访问实现部分。 类的定义 定义在类内部的函数时隐式 inline 的。 this 是一个常量指针。 const 成员函数 通过在紧随参数列表之后添加 const ，可以定义 const 成员函数。 const 的作用是修改隐式 this 指针的类型。 默认情况下， this 指针的类型是指向类类型非常量版本的常量指针（顶层常量）。这意味着我们不能把 this 绑定到一个常量对象上。 常量对象，以及常量对象的引用或者指针都只能调用常量成员函数。 类作用域和成员函数 编译器分两步处理类：首先编译成员的声明，然后才轮到成员函数体（如果有的话）。因此，成员函数体可以随意使用类中的其他成员而无须在意这些成员出现的顺序。 编译器处理完类中的全部声明后才会处理成员函数的定义。 这种两阶段的处理方式只适用于成员函数中使用的名字。声明中使用的名字，包括返回类型或者参数列表中使用的名字，都必须在使用前确保可见。如果某个成员的声明使用了类中尚未出现的名字，则编译器将会在定义该类的作用域中继续查找。 typedef double Money ; string bal ; class Account { public : Money balance() { return bal ; } private : Money bal ; // ... }; 当编译器看到 balance 函数的声明语句时，它将在 Account 类的范围内寻找对 Money 的声明。编译器只考虑 Account 中在使用 Money 前出现的声明，因为没找到匹配的成员，所以编译器会接着到 Account 的外层作用域中查找。在上面的例子中，编译器会找到 Money 的 typedef 语句，该类型被用作 balance 函数的返回类型及数据成员 bal 的类型。另一方面，balance 函数体在整个类可见后才被处理。因此，该函数的 return 语句返回名为 bal 的成员，而非外层作用域的 string 对象。 构造函数 构造函数不能被声明成 const 的。 当我们创建类的一个 const 对象时，直到构造函数完成初始化过程，对象才能真正取得其\"常量\"属性。因此，构造函数在 const 对象的构造过程中可以向其写值。 如果我们的类没有显式定义构造函数，编译器会生成合成的默认构造函数。对于大多数类来说，合成的默认构造函数按照如下规则初始化类的数据成员： 如果存在类内的初始值，用它来初始化成员 否则，执行默认初始化 在 C++ 11中，如果我们需要默认的行为，那么可以通过在参数列表后面写上 = default 来要求编译器生成构造函数。如果 = default 出现在类的内部，则默认构造函数是内联的；如果它出现在外部，则该成员默认情况下不是内联的。 构造函数初始值列表 构造函数初始值列表： Sales_data(const std::string &s) : bookNo(s) { } 如果成员是 const 或者引用的话，必须将其初始化。类似的，当成员属于某种类类型且该类类型没有定义默认构造函数时，也必须将这个成员初始化。 随着构造函数体一开始执行，初始化就完成了。我们初始化 const 或者引用类型的唯一机会就是通过构造函数初始化。 构造函数初始值列表只说明用于初始化成员的值。成员的初始化顺序与它们在类定义中出现顺序一致。 委托构造函数 一个委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程，或者说它把它自己的一些（或者全部）职责委托给了其他构造函数。 class Sales_data { public : // 非委托构造函数 Sales_data ( std :: string s , unsigned cnt , double price ) : bookNo ( s ), units_sold ( cnt ), revenue ( cnt * price ) { } // 其余构造函数都委托给另外一个构造函数 Sales_data () : Sales_data ( \"\" , 0 , 0 ) { } Sales_data ( std :: string s ) : Sales_data ( s , 0 , 0 ) { } Sales_data ( std :: istream & is ) : Sales_data() { read ( is , * this ); } //其他成员 } 受委托的构造函数先执行。 访问控制与封装 定义在 public 说明符之后的成员在整个程序内可被访问， public 成员定义类的接口。 定义在 private 说明符之后的成员可以被类的成员函数访问，但是不能被使用该类的代码访问。 class 和 struct 定义类唯一的区别就是默认的访问权限。 友元 通过友元，类可以允许其他类或者函数访问它的 非公有成员 。 如果类想把一个函数作为它的友元，只需要增加一条以 friend 关键字开始的函数声明即可。友元声明只能出现在类定义的内部，但是在类内出现的具体位置不限。友元不是类的成员也不受它所在区域访问控制级别的约束。 友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明。如果我们希望类的用户能够调用某个友元函数，那么我们必须在友元声明之外再专门对函数进行一次声明。 友元关系不存在传递性。 如果一个类指定了友元类，则友元类的成员函数可以访问此类 包括非公有成员在内的所有成员 。 类的其他特性 定义类型成员 类可以自定义某种类型在类中的别名。要注意，用来定义类型的成员必须先定义后使用。 可变数据成员 有时我们希望能够修改类的某个数据成员，即使是在一个 const 成员函数内。通过关键字 mutable 可以达到这种效果。一个可变数据成员永远不会是 const ，即使它是 const 对象的成员。 返回 *this 的成员函数 一个 const 成员函数如果以引用的方式返回*this，那么它的返回类型将是常量引用。 基于 const 的重载： class Screen { public : // 根据对象是否是 const 重载 display 函数 Screen & display ( std :: ostream & os ) { do_display ( os ); return * this ; } const Screen & display ( std :: ostream & os ) const { do_display ( os ); return * this ; } private : // 该函数负责显示 Screen 的内容 void do_display ( std :: ostream & os ) const { os << contents ; } }; 类类型 声明方法： Sales_data item1; 或 class Sales_data item1; 后一种从 C 语言继承而来。 类的声明：前向声明，在类声明之后定义之前，类是一个不完全类型。 不完全类型只能在非常有限的情景下使用：定义指向这种类型的引用或指针，也可以声明（但是不能定义）以不完全类型作为参数或者返回类型的函数。 直到类被定义之后数据成员才可以被声明成这种类类型。然而，当一个类的名字出现后，它被认为是声明过了（但尚未定义），因此允许包含指向它自身类型的引用或者指针（有没有想到链表结构）。 隐式的类类型转换 如果构造函数只接受一个实参，则它实际上定义了转换为此类类型的隐式转换机制，有时我们把这种构造函数称为转换构造函数。 只允许一步类类型转换。类类型转换不是总有效。 抑制构造函数定义的隐式转换 可以通过将构造函数声明为 explicit 加以阻止。 关键字 explicit 只对一个实参的构造函数有效。需要多个实参的构造函数不能用于执行隐式转换，所以无须将这些构造函数指定为 explicit 。 只能在类内声明构造函数时使用 explicit 关键字，在类外部定义时不应重复。 explicit 构造函数只能用于直接初始化。 尽管编译器不会将 explicit 的构造函数用于隐式转换过程，但是我们可以使用这样的构造函数显式地强制类型转换： item.combine(static_cast<Sales_data>(cin)); 聚合类 当一个类满足如下条件时，我们说它是聚合的： 所有成员都是 public 的 没有定义任何构造函数 没有类内初始值 没有基类，也没有虚函数 例子： struct Data { int ival; string s; } 可以使用初始化列表初始化，初始值的顺序必须与声明的顺序一致。如果初始值列表中的元素个数少于类的成员数量，则靠后的成员被值初始化。 字面值常量类 字面值类型的类可能含有 constexpr 函数成员，它们是隐式 const 成员函数。 数据成员都是字面值类型的聚合类是字面值常量类。 如果一个类不是聚合类，符合以下要求也是一个字面值常量类： 数据成员都必须是字面值类型 类必须至少有一个 constexpr 构造函数 如果一个数据成员含有类内初始值，则内置类型成员的初始值必须是一条常量表达式；如果成员属于某种类类型，则初始值必须使用成员自己的 constexpr 构造函数 类必须使用析构函数的默认定义，该成员负责销毁类的定义 尽管构造函数不能是 const 的，但是字面值常量类的构造函数可以使 constexpr 函数。事实上，一个字面值常量类都必须至少提供一个 constexpr 构造函数。通过前置关键字 constexpr 就可以声明一个 constexpr 构造函数。 constexpr 构造函数可以声明成 =default 或者删除函数的形式，否则， constexpr 构造函数就必须既符合构造函数的要求（意味着不能包含返回语句），又符合 constexpr 函数的要求（意味着它唯一可执行语句就是返回语句），综合这两点， constexpr 构造函数体一般来说应该是空的。 constexpr 构造函数必须初始化所有数据成员，初始值或者使用 constexpr 构造函数，或者是一条常量表达式。 类的静态成员 类的静态成员存在于任何对象之外，对象中不包含任何与静态数据成员有关的数据。类似的，静态成员函数也不与任何对象绑定在一起，它们不包含 this 指针。作为结果，静态成员函数不能声明成 const 的，而且我们也不能在静态函数体内使用 this 指针。 成员函数不用通过作用域运算符就能直接使用静态成员。 当在类的外部定义静态成员时，不能重复 static 关键字，该关键字只出现在类内部的声明语句。 必须在类的外部定义和初始化每个静态成员（一个例外，如果静态成员是字面值类型的 constexpr 可以在类内给它提供一个整数类型的常量表达式初始值），一个静态成员只能被初始化一次。 类似于全局变量，静态数据成员定义在任何函数之外，一直存在于程序的整个生命周期中。 静态数据成员可以是不完全类型，非静态数据成员只能声明成它所属类的指针或引用。 静态数据成员可以作为默认实参，非静态数据成员不行，因为它的值本身属于对象的一部分，这么做的结果是无法真正提供一个对象以便从中获得成员的值（类似于循环定义），将引发错误。","tags":"读书笔记","url":"https://xutree.github.io/pages/2018/10/09/C++_Primer_Chapter_7/"},{"title":"C++ Primer 第六章 函数","text":"函数是一个命名了的代码块。 函数基础 为了与 C 语言兼容，可以使用关键字 void 表示函数没有形参。 函数的返回值不能是数组或者函数类型，但可以返回指向数组和函数的指针。 自动对象：只存在于块执行期间的对象。当块的执行结束后，块中创建的自动对象的值就变成未定义的了。 局部静态对象：在程序执行路径第一次经过对象定义语句时初始化，并且直到程序终止才销毁。如果没有显示初始化，则执行值初始化，内置类型的局部静态变量初始化为0。 参数传递 值传递和引用传递。 当某种类型不支持拷贝操作时，函数只能通过引用形参访问该类型的对象。如 IO 类型。 const 形参和实参 如果函数无须改变引用形参的值，最好将其声明为常量引用。 此外，使用引用而非常量引用也会极大地限制函数所能接受的实参类型。例如，我们不能把 const 对象、字面值或者需要类型转换的对象传递给普通的引用形参，这种绝不像看起来那么简单，它可能造成出人意料的后果。考虑如下函数： string :: size_type find_char ( string & s , char c , string :: size_type & occurs ); 则只能将 find_char 函数用于 string 对象。类似下面的调用将在编译时发生错误： find_char(\"Hello World\", 'o', ctr); 还有一个更难察觉的问题。假如其它函数（正确的）将它们的形参定义成常量引用，那么上述的 find_char 函数无法在此类函数中正常使用。例如 bool is_sentence ( const string & s ) { string : : size_type ctr = 0 ; return find_char(s, '.', ctr) == s.size() - 1 && ctr == 1 ; } 正确的修改思路是改正 find_char 函数的形参。如果实在不能修改 find_char，就在 is_sentence 内部定义一个 string 类型的变量，令其为 s 的副本，然后把这个对象传递给 find_char。 用实参初始化形参时，会忽略顶层 const 。也就是说，当形参是顶层 const 时，传给它常量对象或者非常量对象都是可以的。 可以使用一个非常量初始化一个底层 const 对象，但反过来不行。 数组形参 数组的两个性质：不允许拷贝数组；使用数组时会将其转换成指针。 当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针。 尽管不能以值传递的方式传递数组，但是我们可以把形参写成类似数组的形式： void print(const int*); void print(const int[]); void print(const int[10]); 尽管表现形式不同，但是上面的三个函数是等价的：每个函数的唯一形参都是 const int* 类型的。如果我们传给 print 函数的是一个数组，则实参自动的转换成指向数组首元素的指针，数组的大小对函数的调用没有影响。 因为数组是以指针的形式传递给函数的，所以一开始函数并不知道数组的确切尺寸，调用者应该为此提供一些额外的信息： 使用标记指定数组长度：让数组本身包含一个结束标记，例如 C 风格字符串 使用标准库规范， begin() 和 end() 函数 显示传递一个表示数组大小的形参 当函数不需要对数组元素执行写操作的时候，数组形参应该是指向 const 的指针，注意下面的函数只能作用于大小为10的数组 void print(int (&arr)[10]) { for (auto elem : arr) cout << elem << endl; } main：处理命令行选项 int main(int argc, char *argv[]) { ... } 第二个形参 argv 是一个数组，它的元素是指向 C 风格字符串的指针；第一个形参 argc 表示数组中字符串的数量。因为第二个形参是数组，所以 main 函数也可以定义成： int main(int argc, char **argv) { ... } 当实参传给 main 函数之后，argv 的第一个元素指向程序的名字或者一个空字符串，接下来的元素依次传递命令行提供的实参，最后一个指针之后的元素值保证为0。 含有可变形参的函数 为了编写能够处理不同数量实参的函数，C++11 新标准提供了两种主要的方法： 如果所有实参类型相同，可以传递一个名为 initializer_list 的标准库类型 如果实参的类型不同，可以编写可变参数模板 C++ 还有一种特殊的形参类型（即省略号），可以用它传递可变数量的实参，不过需要注意的是，这种功能一般只用于与 C 函数交互的接口程序 initializer_list 形参 initializer_list 类型定义在同名的头文件中。 initializer_list 是一种类型模板，提供的操作如下： initializer_list <T> lst; 默认初始化；T 类型元素的空列表。 initializer_list <T> lst{a,b,c...}; lst 的元素数量和初始值一样多；lst 的元素是对应初始值的副本；列表中的元素是 const。 lst2(lst); 拷贝或赋值一个 initializer_list 对象不会拷贝列表中的元素；拷贝后，原始列表和副本共享元素。 lst2 = lst; 等价于 lst2(lst) 。 lst.size(); 列表中的元素数量。 lst.begin(); 返回指向 lst 中首元素的指针。 lst.end(); 返回指向 lst 中尾元素下一位置的指针。 initializer_list 和 vector 一样，也是类型模板，定义 initializer_list 对象时，必须说明列表中所含对象的类型。和 vector 不一样的是， initializer_list 对象中的元素永远是常量值。 如果想向 initializer_list 形参中传递一个值的序列，则必须把序列放在一对花括号内： //expected和actual是string对象 if (expected != actual) error_msg({\"functionX\", expected, actual}); else error_msg({\"functionX\", \"okay\"}); 省略符形参 省略符形参是为了便于 C++ 程序访问某些特殊的 C 代码而设置的，这些代码使用了名为 varargs 的 C 标准库功能。通常，省略符形参不应用于其他目的。你的 C 编译器文档会描述如何使用 varargs。 省略符形参只能出现在形参列表的最后一个位置，无外乎两种形式，在第一种形式中，形参声明后面的逗号是可选的： void foo(parm_list,...); void foo(...); 返回类型和 return 语句 返回 void 的函数不要求非得有 return 语句，以为这类函数的最后一句会隐式的执行 return 。 返回的值用于初始化调用点的一个临时量，该临时量就是函数调用的结果。 不要返回局部对象的引用或指针。 调用一个返回引用的函数得到左值，其他返回类型得到右值。 C++ 11新标准规定，函数可以返回花括号包围的值的列表，类似于其他返回结果，此处的列表也用来对表示函数返回的临时量进行初始化。如果列表为空，临时量执行值初始化。如果函数返回的是内置类型，则花括号包围的列表最多包含一个值，且该值所占空间不应该大于目标类型的空间。如果返回的是类类型，由类本身定义初始值如何使用。 如果控制语句到达了 main 函数的结尾处而且没有 return 语句，编译器会隐式的插入一条返回0的 return 语句。 cstdlib 头文件定义了两个预处理变量表示成功与失败： EXIT_SUCCESS ， EXIT_FAILURE 。 int (*func(int i))[10]; func 是一个函数指针，指向：接受一个 int 参数，返回值是包含10个 int 数组的地址的函数。也可以利用尾置返回类型（C++ 11）写为： auto func(int i) -> int(*)[10]; 还有一种情况，如果我们知道函数返回的指针将指向哪个数组，就可以使用 decltype 关键字声明返回类型。例如，下面的函数返回一个指针，该指针根据参数i的不同指向两个已知数组中的某一个： int odd[] = {1, 3, 5, 7, 9}; int even[] = {0, 2, 4, 6, 8}; //返回一个指针，该指针指向含有5个整数的数组 decltype(odd) *arrPtr(int i) { return (i % 2) ? &odd : &even; } arrPtr 使用关键字 decltype 表示它的返回类型是个指针，并且该指针所指的对象与 odd 的类型一致。因为 odd 是数组，所以 arrPtr 返回一个指向含有5个整数的数组的指针。有一个地方需要注意， decltype 并不负责把数组类型转换成对应的指针，所以 decltype 的结果是个数组，要想表示 arrPtr 返回指针还必须在函数声明时加一个 * 符号。 函数重载 顶层 const 顶层 const 不影响传入函数的对象。一个用于顶层 const 的形参无法和一个没有顶层 const 的形参区分开，无法重载： Record lookup(Phone); Record lookup(const Phone); // Record lookup(Phone*); Record lookup(Phone* const); 底层 const 底层 const 可以实现重载。当我们传递一个非常量对象或者指向非常量对象的指针时，编译器会优先选用非常量的版本： Record lookup(Account&); Record lookup(const Account&); // Record lookup(Account*); Record lookup(const Account*); const_cast和重载 //函数1 const string &shorterString(const string &s1, const strinf &s2) { return s1.size() <= s2.size() ? s1 : s2; } //函数2 string &shorterString(string &s1, string &s2) { auto &r = shorterString(const_cast<const string &>(s1), const_cast<const string&>(s2)); return const_cast<string&>(r); } 函数1的参数和返回类型都是 const string 的引用。我们当然可以对两个非常量的 string 实参调用这个函数，但返回的结果仍然是 const string 的引用。 作用域与重载 编译器首先在当前作用域寻找函数，一旦找到，就会忽略掉外层作用域中的同名实体，剩下的工作就是检查函数调用是否有效了。 在C++语言中，名字查找发生在类型检查之前。 特殊用于语言特性 默认实参 一旦一个形参被赋予了默认值，它后面的所有形参都必须有默认值。 在给定的作用域中，一个形参只能被赋予一次默认实参。 局部变量不能作为默认实参。 用作函数实参的名字在函数声明所在的作用域内解析，而这些名字的求值过程发生在函数调用时： sz wd = 80; char def = ''; sz ht(); string screen(sz = ht(), sz = wd, char = def); void f() { def = '*'; //改变默认实参的值 sz wd = 100; //隐藏了外层定义的wd，但是没有改变默认值 window = screen(); //调用 screen(ht(), 80, '*') } 内联函数 以空间换时间。在函数返回类型前面加上关键字 inline 。内联说明只是向编译器发出一个请求，编译器可以选择忽略这个请求。 constexpr 函数 能用于常量表达式的函数。函数的返回类型及所有的形参类型都得是字面值类型。函数体中必须有且只有一条 return 语句。 constexpr int new_sz() { return 42; } constexpr int foo = new_sz(); 编译器在程序编译时验证 new_sz 函数的返回类型。执行初始化任务时，编译器把对 constexpr 函数的调用替换成其结果值。为了能在编译过程中随时展开， constexpr 函数被隐式指定为内联函数。 constexpr 函数体内也可以包含其他语句，只要这些语句在运行时不执行任何操作就行，例如，空语句、类型别名及 using 声明。 constexpr 函数不一定返回常量表达式，当把这类函数用在需要常量表达式的上下文中时，会出错。 把内联函数和 constexpr 函数放在头文件内。 和其它函数不一样，内联函数和 constexpr 函数可以在程序中多次定义，但是多个定义必须完全一致。 调试帮助 assert 预处理宏 所谓预处理宏其实是一个预处理变量，它的行为有点类似于内联函数。 assert 宏使用一个表达式作为它的条件： assert(expr); 首先对 expr 求值，如果表达式为假， assert 输出信息并终止程序的执行。如果表达式为真， assert 什么也不做。 assert 定义在cassert头文件中， assert 宏常用于检查\"不能发生\"的条件。 NDEBUG 预处理变量 assert 的行为依赖于 NDEBUG 预处理变量的状态。如果定义了 NDEBUG ， assert 什么都不做，默认情况下没有定义 NDEBUG ， assert 将执行运行时检查。我们可以使用一个 #define 语句定义 NDEBUG ，从而关闭调试状态。同时，很多编译器都提供了一个命令行选项使我们可以定义预处理变量： $ CC -D NDEBUG main.C #use /D with the Mocrosoft compiler. 除了使用 assert 外，也可以使用 NDEBUG 编写自己的条件调试代码。如果 NDEBUG 未定义，将执行 #ifndef 和 #endif 之间的代码；如果定义了 NDEBUG ，这些代码将被忽略掉。 编译器为每个函数都定义了 __func__ ，它是一个 const char 局部静态数组，用于存放函数的名字，除了 C++ 编译器定义的 __func__ 之外，预处理器还定义了另外4个对于程序调试很有用的名字： __FILE__ 存放文件名的字符串字面值 __LINE__ 存放当前行号的整型字面值 __TIME__ 存放文件编译时间的字符串字面值 __DATE__ 存放文件编译日期的字符串字面值 函数匹配 候选函数：函数匹配的第一步是选定本次调用对应的重载函数集。 可行函数：形参数量与本次提供的实参数量相等（默认形参可以少于）；每个实参的类型与对应的形参相同，或者可以转换成形参的类型。 寻找最佳匹配（如果有的话）：该函数每个实参的匹配都不劣于其他可行函数需要的匹配；至少有一个实参的匹配优于其他可行函数提供的匹配。 如果没找到可行函数：编译器报告无匹配函数的错误；如果最佳匹配不唯一，编译器报告二义性错误。 函数指针 要声明一个函数指针，只需要用指针替换函数名： bool (*pf)(const string &, const string &); //未初始化，pf 两端括号必不可少 当把函数名作为一个值使用时，该函数自动转换为指针，也就是说取地址符是可选的。同样，我们可以直接用函数指针调用函数，解引用符也是可选的。 不同类型的函数指针之前不存在转换规则。 函数指针没有指向任何一个函数：将函数指针赋为0或者 nullptr 。 和数组类似，虽然不能定义函数类型的形参，但是可以定义指向函数的指针。此时，形参看起来是函数，实际上被当成指针使用： //形参是函数类型，会自动转化为指向函数的指针 void test(bool pf(const string &, const string &)); //等价的定义 void test(bool (*pf)(const string &, const string &)); 如果函数返回指向函数的指针，那么必须显示的将返回类型指定为指针。","tags":"读书笔记","url":"https://xutree.github.io/pages/2018/10/09/C++_Primer_Chapter_6/"},{"title":"回车与换行的区别","text":"转载自： 这里 关于换行和回车其实平时我们不太在意，所以关于两者的区别也不太清楚，在平时开发时可能会遇到一些文件处理的问题，放到不同的操作系统上出现各种坑。那么回车和换行到底有哪些区别呢？今天咱们就来总结一下。 由来 在计算机还没有出现之前，有一种叫做电传打字机（Teletype Model 33）的机械打字机，每秒钟可以打10个字符。但是它有一个问题，就是打完一行换行的时候，要用去0.2秒，正好可以打两个字符。要是在这0.2秒里面，又有新的字符传过来，那么这个字符将丢失。 于是，研制人员想了个办法解决这个问题，就是在每行后面加两个表示结束的字符。一个叫做\"回车\"，告诉打字机把打印头定位在左边界，不卷动滚筒；另一个叫做\"换行\"，告诉打字机把滚筒卷一格，不改变水平位置。 这就是\"换行\"和\"回车\"的由来。 使用 后来，计算机发明了，这两个概念也就被般到了计算机上。那时，存储器很贵，一些科学家认为在每行结尾加两个字符太浪费了，加一个就可以。于是，就出现了分歧。 回车 \\r 本义是光标重新回到本行开头，r 的英文 return，控制字符可以写成 CR ，即 Carriage Return。 换行 \\n 本义是光标往下一行（不一定到下一行行首），n 的英文 newline，控制字符可以写成 LF ，即 Line Feed。 符号 ASCII 码 意义 \\n 10 换行 LF \\r 13 回车 CR 在不同的操作系统这几个字符表现不同，比如在 WIN 系统下，这两个字符就是表现的本义，在 UNIX 类系统，换行 \\n 就表现为光标下一行并回到行首，在 MAC 上， \\r 就表现为回到本行开头并往下一行，至于 ENTER 键的定义是与操作系统有关的。通常用的 Enter 是两个加起来。 不同操作系统下的含义： \\n ：UNIX 系统行末结束符 \\n\\r ：window 系统行末结束符 \\r ：MAC OS 系统行末结束符 我们经常遇到的一个问题就是，Unix/Mac 系统下的文件在 Windows 里打开的话，所有文字会变成一行；而 Windows 里的文件在 Unix/Mac 下打开的话，在每行的结尾可能会多出一个 &#94;M 符号。 软回车和硬回车 硬回车就是普通我们按回车产生的，它在换行的同时也起着段落分隔的作用。 软回车是用 Shift + Enter 产生的，它换行，但是并不换段，即前后两段文字在 Word 中属于同一\"段\"。在应用格式时你会体会到这一点。 软回车能使前后两行的行间距大幅度缩小，因为它不是段落标记，要和法定的段落标记——硬回车区别出来。硬回车的 html 代码是 <p>..</p> ，段落的内容就夹在里面，而软回车的代码很精悍： <br> 。网页的文字如果复制到 word 中，则硬回车变为弯曲的箭头，软回车变为向下的箭头。","tags":"趣闻","url":"https://xutree.github.io/pages/2018/10/09/回车与换行的区别/"},{"title":"C++ Primer 第五章 语句","text":"空语句 使用空语句时应该加上注释，从而令读这段代码的知道该语句是有意省略的。 悬垂 else C++ 规定 else 与离它最近的尚未匹配的 if 匹配。 switch 语句 switch 语句中的 case 标签必须是 整型常量表达式 或者 可以转换成整型常量表达式的类型 。 如果某个 case 标签匹配成功，将从该标签处开始往后顺序执行所有 case 分支，除非程序显示的中断了这一过程，否则直到 switch 结尾处才停下来。在大多说情况下，在下一个 case 标签之前应该有一条 break 语句用于中断。 标签不应该孤零零的出现，它后面必须跟上一条语句或者另一个 case 标签。如果 switch 结构以一个空的 default 标签作为结束，则该 default 标签后面必须跟上一条空语句或一个空块。 不允许跨过变量的初始化语句直接跳转到该变量作用域内的另一个位置。 范围 for 在范围 for 语句中，预存了 end() 的值，一旦程序中添加（删除）元素， end 函数的值就可能变得无效，所以不能通过范围 for 语句增加或删除容器的元素。 do while 语句 应该在括号包围起来的条件后面用一个分号表示语句结束。 跳转语句 break 语句 break 语句负责终止离它最近的 while 、 do while 、 for 或 switch 语句，并从这些语句之后的第一条语句开始继续执行。 break 语句只能出现在迭代语句或者 switch 语句内部（包括嵌套在此类循环里的语句或块的内部）。 break 语句的作用范围仅限于最近的循环或者 switch 。 continue 语句 continu e语句终止最近的循环中的当前迭代并立即开始下一次迭代。 continue 语句只能出现在 for 、 while 和 do while 的循环的内部，或者嵌套在此类循环里的语句或块的内部。 和 break 语句类似的是，出现在嵌套循环中的 continue 语句也仅作用于离它最近的循环。 和 break 语句不同的是，只有当 switch 语句嵌套在迭代语句内部时，才能在 switch 里使用 continue 。 goto 语句 goto 语句的作用是从 goto 语句无条件跳转到同一函数内的另一条语句。 goto 语句和控制权转向的那条带标签的语句必须位于同一函数之内。 异常处理 throw 表达式 异常检测部分使用 throw 表达式来表示它遇到了无法处理的问题。我们说 throw 引发了异常，例如： throw runtime_error(\"Data must refer to same ISBN\"); try 语句块 异常处理部分使用 try 语句处理异常。 try 语句块以关键字 try 开始，并以一个或多个 catch 字句结束。 try 语句块中代码抛出的异常通常会被某个catch字句处理，这些字句称为异常处理代码。 try{ program-statements } catch (exception-declaration) { handler-statements } catch (exception-declaration) { handler-statements } 跟在 try 块之后的是一个或多个 catch 子句。 catch 子句包括三个部分： 关键字 catch 括号内一个（可能未命名的）对象的声明（称作异常声明） 一个块 try 语句块中 program-statements 组成程序的正常逻辑，像其他任何块一样，可以有包含声明在内的任意 C++ 语句。 try 语句块内声明的变量在块外部无法访问，特别是在 catch子 句内也无法访问。 函数在寻找代码处理的过程中退出，如果最终没能找到任何匹配的 catch 子句，程序转到名为 terminate 的标准库函数。该函数的行为与系统有关，一般情况下，执行该函数将导致程序非正常退出。 标准异常 C++ 标准库定义了一组类，用于报告标准库函数遇到的问题，这些异常类也可以在用户别写的程序中使用，它们分别定义在4个头文件中： exception 头文件 定义了最通用的异常类 exception 。它只报告异常的发生，不提供任何异常信息 stdexcept 头文件定义了几种常见的异常类 异常类 解释 exception 最常见的问题 runtime_error 只有在运行时才能检测出的问题 range_error 运行时错误：生成的结果超出了有意义的值域范围 overflow_error 运行时错误：计算上溢 underflow_error 运行时错误：计算下溢 logic_error 程序逻辑错误 domain_error 逻辑错误：参数对应的结果值不存在 invalid_argument 逻辑错误：无效参数 length_error 逻辑错误：试图创建一个超出该类型最大长度的对象 out_of_range 逻辑错误：使用一个超出有效范围的值 new 头文件 定义了 bad_alloc 异常类型 type_info 头文件 定义了 bad_cast 异常类型 标准异常库只定义了几种运算，包括创建和拷贝异常类型的对象，以及为异常类型的对象赋值。我们只能以默认初始化的方式初始化 exception 、 bad_alloc 和 bad_cas t对象，不允许为这些对象提供初始值。 其他异常类型的行为则刚好相反。应该使用 string 对象或者 C 风格字符串初始化这些类型的对象，但是不允许使用默认初始化的方式。当创建此类对象时，必须提供初始值，该初始值含有错误相关的信息。 异常类型只定义了一个名为 what 的成员函数，该函数没有任何参数，返回值是一个指向 C 风格字符串的 const char * 。该字符串的目的是提供关于异常的一些文本信息。 what 函数返回的 C 风格字符串的内容与异常对象的类型有关。如果异常类型只有一个字符串初始值，则 what 返回该字符串。对于其他无初始值的异常类型来说， what 返回的内容由编译器决定。","tags":"读书笔记","url":"https://xutree.github.io/pages/2018/10/09/C++_Primer_Chapter_5/"},{"title":"几个奇葩的 Linux 命令","text":"Linux 中有一些很奇葩的命令，可能你的发行版默认没有安装，你可以自己安装： [me@linuxbox ~]$ apt-get install 命令 (Debian) [me@linuxbox ~]$ yum install 命令 (Red Hat） [me@linuxbox ~]$ brew install 命令 （Mac） rev rev 命令反转输入的内容（来自文件或者标准输入或者管道）： [me@linuxbox ~]$ echo Hello, World! | rev !dlroW ,olleH tac cat 命令的反写，执行效果也和 cat 相反，即，将文件列表中的每一个文件输出到标准输出，行号大的优先。 sl 你可能知道命令 ls ,并经常使用它来查看文件夹的内容。但是由于错误输入有时会导致 sl ，如何在终端获得一点乐趣而不是\"command not found\"？ sl 命令！ 当你把 ls 错误打成 sl 时，一辆蒸汽机车（ s team l ocomotive）会在屏幕上驶过... yes yes命令将进入一个循环，一遍又一遍地重复相同的字符串。默认重复\"y\"，你可以指定其他字符串。 [me@linuxbox ~]$ yes \"这是一个测试\" 这是一个测试 这是一个测试 这是一个测试 这是一个测试 这是一个测试 这是一个测试 这是一个测试 利用 Ctrl C 终止。 cowsay 屏幕上会出现一只 ASCII 码拼成的奶牛。。。你可以指定奶牛要说的话。这个命令还有其他版本，如 xcowsay ， cowthink 。 figlet 这个算不上奇葩，他它利用 ASCII 码拼成你输出\b字符串的横幅，而且有许多参数可以定制。还有个 toilet 命令和 figlet 很类似。比如， figlet good ： fortune 会显示你的未来（ 😆 )。可以试试： [me@linuxbox ~]$ fortune | cowsay cmatrix 会像《黑客帝国》里那样显示\b。 Fork 炸弹 [me@linuxbox ~]$ :(){ :|:& }: 不要尝试不要尝试不要尝试... asciiquarium 水族馆 lolcat lolcat 可以在终端产生彩虹。 lolcat 是一个 RubyGem 因此它必须有你的系统上安装了 Ruby 的最新版本。利用文章开头部分的方法安装好 lolcat 后，在终端执行 gem install lolcat 安装。 [me@linuxbox ~]$ git log -1 | cowsay -f dragon-and-cow | lolcat lolcat 接受管道输入，所以你可以试试： [me@linuxbox ~]$ sl | lolcat","tags":"趣闻","url":"https://xutree.github.io/pages/2018/10/08/几个奇葩的Linux命令/"},{"title":"Linux 中的扩展和引用","text":"扩展 当我们每次在命令行按下 Enter 键时，bash 会在执行命令之前对文本进行多重处理。产生这个结果的处理过程称为扩展（expansion）。 一个 🌰 : echo * 会将当前目录下所有的非隐藏文件名打印出来。 单词分隔 单词分隔会先查找是否存在空格、制表符以及换行，然后把它们作为单词的界定符（delimiter）。所以下面的命令后面跟着4个不同的参数： [me@linuxbox ~]$ echo this is a test this is a test 路径名扩展 通过使用通配符来实现扩展的\b机制称为路径名扩展（pathname expansion）。 波浪线扩展（~） 如果把它用在一个单词的开头，那么它将被扩展为指定用户的主目录名；如果没有指定用户名，则扩展为当前用户的主目录： [me@linuxbox ~]$ ech ~ /home/me [me@linuxbox ~]$ ech ~foo /home/foo 算术扩展 shell 支持通过扩展来运行算术表达式。这允许我们把 shell 提示符当做计算器来使用： [me@linuxbox ~]$ echo $((2+2)) 4 算术扩展使用形式： $((expression)) ，其中 expression 是包含数\b值和算术操作符的算术表达式。算术扩展 只支持整数 。 运算符 运算符 描述 + 加 - 减 * 乘 / 除（结果为整数） % 取余 ** 取幂 空格在算术表达式中无意义，表达式可以嵌套： [me@linuxbox ~]$ echo $(($((5**2)) * 3)) 75 还可以使用\b一对括号来组合多个子表达式： [me@linuxbox ~]$ echo $(((5**2) * 3)) 75 数字进制 符号 描述 number 默认情况下，number 没有任何符号，将作为十进制数字 0number 在数字表达式中，以0开始的数字被视为八进制数字 0xnumber 十六进制数 base#number base 进制的 number 🌰 ： [me@linuxbox ~]$ echo $((0xff)) 255 [me@linuxbox ~]$ echo $((3#11)) 4 花括号扩展 花括号扩展可以用于创建多种文本字符串，例如 [me@linuxbox ~]$ echo Front-{A,B,C}-Back Front-A-Back Front-B-Back Front-C-Back 用于花括号扩展的模式信息可以包含一个称为 前导字符 的开头部分和一个称为 附言 的结尾部分。花括号表达式本身可以包含一些列逗号分隔的字符串，也可以包含一系列整数或者单个字符。 模式信息不能包含内嵌的\b空白。 花括号扩展最普遍的应用是创建一系列的文件或者目录： [me@linuxbox ~]$ mkdir {2009..2011}-0{1..9} {2009..2010}-{10..12} 参数扩展 shell 提供了多种参数扩展的形式。 基本参数 参数扩展的最简单形式体现在平时对变量的使用中。举例来说， $a 扩展后成为变量 a 所包含的内容，无论 a 包含什么。 简单参数可以被括号包围，如 ${a} ，当变量相邻与其他文本时，必须使用括号，否则可能让 shell 混淆。 [me@linuxbox ~]$ a=\"foo\" [me@linuxbox ~]$ echo \" $a_file \" [me@linuxbox ~]$ echo \" ${ a } _file\" foo_file 因为不存在 a_file 变量，所以 shell 输出空。 同样，对于大于9的位置参数可以通过给相应数字加上括号来访问，例如访问第11个位置参数： ${11} 空变量扩展的管理 有的参数扩展用于处理不存在的变量和空变量。这些参数扩展在处理缺失的位置参数和给参数赋默认值时很有用。 ${parameter:-word} ：如果 parameter 未被设定或者是空参数，则其扩展为 word 的值。如果\b parameter 非空，则扩展为 parameter 的值。 [ me@linuxbox ~ ] $ foo = [ me@linuxbox ~ ] $ echo $ { foo : - \"substitute value if unset\" } substitute value if unset [ me@linuxbox ~ ] $ echo $ foo [ me@linuxbox ~ ] $ foo = bar [ me@linuxbox ~ ] $ echo $ { foo : - \"substitute value if unset\" } bar [ me@linuxbox ~ ] $ echo $ foo bar ${parameter:=word} ：如果 parameter 未被设定或者是空参数，则其扩展为 word 的值；此外，word 的值也将赋给 parameter。如果\b parameter 非空，则扩展为 parameter 的值。注意：位置参数和其他特殊参数不能以这种方式赋值。 [ me@linuxbox ~ ] $ foo = [ me@linuxbox ~ ] $ echo $ { foo : = \"deafult value if unset\" } deafult value if unset [ me@linuxbox ~ ] $ echo $ foo deafult value if unset [ me@linuxbox ~ ] $ foo = bar [ me@linuxbox ~ ] $ echo $ { foo : - \"deafult value if unset\" } bar [ me@linuxbox ~ ] $ echo $ foo bar ${parameter:？word} ：如果 parameter 未被设定或者是空参数，这样扩展会致使脚本\b出错而退出，并且 word 的内容输出到标准错误。如果 parameter 非空，则扩展为 parameter 的值。 [me@linuxbox ~]$ foo= [me@linuxbox ~]$ echo ${ foo : ? \"parameter is empty\" } bash: foo: parameter is empty [me@linuxbox ~]$ echo $? 1 [me@linuxbox ~]$ foo=bar [me@linuxbox ~]$ echo ${ foo : ? \"parameter is empty\" } bar [me@linuxbox ~]$ echo $? 0 ${parameter:+word} ：如果 parameter 未被设定或者是空参数，则不产生任何扩展。若 parameter 非空，word 的值将取代 parameter 的值产生扩展；然而，parameter 的值并不发生变化。 [me@linuxbox ~]$ foo= [me@linuxbox ~]$ echo ${ foo : + \"substitute value if unset\" } [me@linuxbox ~]$ foo=bar [me@linuxbox ~]$ echo ${ foo : + \"substitute value if unset\" } substitute value if unset [me@linuxbox ~]$ echo $foo bar 返回变量名的扩展 shell 具有返回变量名的扩展。这种功能在相当特殊的情况下才会使用。 ${ ! prefix * } ${ ! prefix @ } 该扩展返回当前以 prefix 开通的变量名。根据 bash 文档，这两种形式的扩展形式执行的效果一模一样。 字符串操作 ${#parameter} ：扩展为 parameter 内包含的字符串的长度。如果 parameter 是 \"@\" 或 \"*\"，那么扩展的结果就是位置参数的个数。 [me@linuxbox ~]$ foo=\"This string is long.\" [me@linuxbox ~]$ echo \"' $foo ' is ${ #foo } characters long.\" 'This string is long.' is 20 characters long. {parameter:offset} 和 {parameter:offset:length} ：这个扩展提取一部分字符串。扩展以 offset 字符开始，直到字符串末尾，除非 length 特别指定它。 [me@linuxbox ~]$ foo=\"This string is long.\" [me@linuxbox ~]$ echo ${ foo : 5 } string is long. [me@linuxbox ~]$ echo ${ foo : 5 : 6 } string 如果 offset 为负，默认表示从字符串末尾开始。 注意，负值前必须有一个空格 ，以防和 ${parameter:-word} 扩展混淆。length 不能小于0。 [me@linuxbox ~]$ foo=\"This string is long.\" [me@linuxbox ~]$ echo ${ foo : - 5 } long. [me@linuxbox ~]$ echo ${ foo : - 5 : 2 } lo 如果参数是 \"@\"，扩展的结果则是从 offset 开始，length 为位置参数。 ${parameter#pattern} 和 ${parameter##pattern} ：pattern 是一个通配符模式，\"#\" 去除最短匹配，\"##\" 去除最长匹配。 [me@linuxbox ~]$ foo=file.txt.zip [me@linuxbox ~]$ echo ${ foo #*. } txt.zip [me@linuxbox ~]$ echo ${ foo ##*. } zip ${parameter%pattern} 和 ${parameter%%pattern} ：从尾部去除。pattern 是一个通配符模式，\"%\" 去除最短匹配，\"%%\" 去除最长匹配。 [me@linuxbox ~]$ foo=file.txt.zip [me@linuxbox ~]$ echo ${ foo %*. } file.txt [me@linuxbox ~]$ echo ${ foo %%*. } file ${parameter/pattern/string} ：查找替换，只替换第一个出现的 ${parameter//pattern/string} ：替换所有的 ${parameter/#pattern/string} ：要求匹配出现在字符串开头 ${parameter/%pattern/string} ：要求匹配出现在字符串末尾 /string 可以省略，此时匹配到的字符被删除 [me@linuxbox ~]$ foo=JPG.JPG [me@linuxbox ~]$ echo ${ foo / JPG / jpg } jpg.JPG [me@linuxbox ~]$ echo ${ foo // JPG / jpg } jpg.jpg [me@linuxbox ~]$ echo ${ foo / #JPG/jpg } jpg.JPG [me@linuxbox ~]$ echo ${ foo /% JPG / jpg } JPG.jpg 命令替换 命令替换可以把一个命令的输出作为一个扩展模式使用： [me@linuxbox ~]$ ls -l $(which cp) -rwxr-xr-x 1 root wheel 29008 10 26 2017 /bin/cp 在早期的 shell 程序中，存在命令替换的另一种语法，bash 也支持这种格式。它用反引号代替美元符号和括号： [me@linuxbox ~]$ ls -l `which cp` -rwxr-xr-x 1 root wheel 29008 10 26 2017 /bin/cp 引用 引用主要用于控制扩展。 双引号 如果把文本放在双引号中，那么 shell 使用的所有特殊字符都被看成普通字符，除了 \"$（美元符号）\"，\"\\（反斜杠）\"，\"`（反引号）\" 除外。 单词分隔、路径名扩展、波浪线扩展、花括号扩展都失效。 参数扩展、算术扩展、命令替换仍然有效。 使用双引号可以阻止单词分隔，这可以用来处理包含空白的文件名。 单引号 抑制所有扩展。 转义字符 转义字符通常用在双引号中用来有选择性的阻止扩展。 关于反斜杠转义字符（backslash escape sequence） 反斜杠除了作为转义字符外，也是一种表示法的一部分。ASCII 码表的前32个字符用来向电传打字类设备传送命令。 转义字符 含义 \\a 响铃（警告声——计算机发出哔哔声） \\b 退格 \\n 新的一行（在类 UNIX 系统中，产生的是换行效果 \\r 回车 \\t 制表 在 echo 命令中带上 -e 选项，就能够解释转义字符序列，也可以将其放在 \"$''\"中。下面的例子，实现一个简单的倒计时计时器： [me@linuxbox ~]$ sleep 10; echo -e \"Time's up\\a\" 也可以这样做： [me@linuxbox ~]$ sleep 10; echo -e \"Time's up\" $'\\a'","tags":"教程","url":"https://xutree.github.io/pages/2018/10/08/linux中的扩展和引用/"},{"title":"CSS 入门","text":"什么是 CSS CSS（ C ascading S tyle S heets），即层叠样式表。 层叠是指 CSS 将一种样式应用于另一种样式的方式。样式表控制 Web 文档的外观。 为什么使用 CSS CSS 允许你将特定样式应用于特定 HTML 元素 CSS 的主要好处是它允许您将样式与内容分开 仅使用 HTML，所有样式和格式都在同一个地方，随着页面的增长，这变得相当难以维护 CSS 三种形式 内联 CSS：inline CSS 使用内联样式是插入样式表的方法之一。 使用内联样式，将独特的样式应用于单个元素。 要使用内联样式，请将style属性添加到相关标记。 <p style= \"color:white; background-color:gray;\" > This is an example of inline styling. </p> 嵌入式/内部 CSS：Embedded/Internal CSS 内部样式在 HTML 页面的 head 部分内的 <style> 元素中定义。 <html> <head> <style> p { color:white; background-color:gray; } </style> </head> <body> <p> This is my first paragraph. </p> <p> This is my second paragraph. </p> </body> </html> 外部 CSS：External CSS 使用此方法，所有样式规则都包含在单个文本文件中，该文件以 .css 扩展名保存。 然后使用 <link> 标记在 HTML 中引用此 CSS 文件。 <link> 元素位于 head 部分内部。 <head> <link rel= \"stylesheet\" href= \"example.css\" > </head> <body> <p> This is my first paragraph. </p> <p> This is my second paragraph. </p> <p> This is my third paragraph. </p> </body> CSS 语法 CSS 由浏览器解释的样式规则组成，然后应用于文档中的相应元素。样式规则有三个部分： selector ， property 和 value 。 例如，标题颜色可以定义为： h1 { color: orange; } 选择器指向要设置样式的HTML元素。声明块包含一个或多个声明，以分号分隔。每个声明都包含一个属性名称和一个以冒号分隔的值。CSS 声明始终以分号结尾，声明组由大括号括起。 类型选择器 最常见且易于理解的选择器是类型选择器。 此选择器针对页面上的元素类型。 例如，要定位页面上的所有段落： p { color : red ; font-size : 130 % ; } id 和 clss 选择器 id 选择器允许您设置具有 id 属性的 HTML 元素的样式，而不管它们在文档树中的位置如何。 以下是 id 选择器的示例： HTML 文件： <div id= \"intro\" > <p> This paragraph is in the intro section. </p> </div> <p> This paragraph is not in the intro section. </p> CSS 文件: # intro { color : white ; background-color : gray ; } 要选择具有特定 id 的元素，请使用井号 # 字符，然后使用元素的 id 跟随它。 类选择器以类似的方式工作。 主要区别在于 id 每页只能应用一次，而类可以根据需要在页面上多次使用。 在下面的示例中，具有\"first\"类的两个段落都将受到 CSS 的影响： HTML 文件： <div> <p class= \"first\" > This is a paragraph </p> <p> This is the second paragraph. </p> </div> <p class= \"first\" > This is not in the intro section </p> <p> The second paragraph is not in the intro section. </p> CSS 文件： .first { font-size : 200 % ;} 要选择具有特定类的元素，请使用句点 . 字符，后跟类的名称。不要用数字开始一个类或 id 名称。 后代选择器 这些选择器用于选择作为另一个元素的后代的元素。 选择级别时，您可以根据需要选择多个级别。 例如，要仅定位\"intro\"部分第一段中的 <em> 元素： HTML 文件： <div id= \"intro\" > <p class= \"first\" > This is a <em> paragraph. </em></p> <p> This is the second paragraph. </p> </div> <p class= \"first\" > This is not in the intro section. </p> <p> The second paragraph is not in the intro section. </p> CSS 文件： # intro . first em { color : pink ; background-color : gray ; } 后代选择器匹配作为指定元素后代的所有元素。 注释 注释用于解释你的代码，浏览器会忽略。 /* Comment goes here */ 层叠 网页的最终外观是不同样式规则的结果。形成层叠的三种主要风格来源是： 页面作者创建的样式表 浏览器的默认样式 用户指定的样式 继承是指属性在页面中流动的方式。 除非另有定义，否则子元素通常会采用父元素的特征。","tags":"教程","url":"https://xutree.github.io/pages/2018/10/07/css_overview/"},{"title":"C++ Primer 第四章 表达式","text":"重载运算符时，其包括运算对象的类型和返回值的类型，都是由该运算符定义的；但是运算对象的个数、运算符的优先级和结合律都是无法改变的。 左值和右值 当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。 一个重要的原则：在需要右值的地方可以用左值来代替，但是不能把右值当成左值（也就是位置）使用。当一个左值被当成右值使用时，实际使用的是它的内容（值）。 要用到左值的运算符： 赋值运算符需要一个左值作为其左侧运算对象，得到的结果也仍然是一个左值 取地址符作用于一个左值运算对象，返回一个指向该运算对象的指针，这个指针是一个右值 内置解引用运算符、下标运算符、迭代器解引用运算符、 string 和 vector 的下标运算符的求值结果都是左值 内置类型和迭代器的递增递减运算符作用于左值运算对象 求值顺序 优先级规定了运算对象的组合方式，但是没有说明运算对象按照什么顺序求值。对于那些没有指定执行顺序的运算符来说，如果表达式指向并修改了同一个对象，将会引发错误并产生未定义的行为。 例如，下面的输出表达式是未定义的，我们无法推测编译器是先求 ++i 还是先输出： int i = 0; cout << i << \" \" << ++i << endl; //未定义的 有4种运算符明确规定了运算对象的求值顺序。&&、||、?:、和逗号（，）运算符。 对于f()+g()*h()+j()的表达式： 优先级规定，g() 的返回值和 h() 的返回值相乘 结合律规定，f() 的返回值先与 g() 和 h() 的乘积相加，所得结果再与 j() 的返回值相加 对于这些函数的调用顺序没有明确规定 如果 f、g、h 和 j 是无关函数，它们既不会改变同一对象的状态也不执行 IO 任务，那么函数的调用顺序不受限制。反之，如果其中某几个函数影响同一对象，则它是一条错误的表达式，将产生未定义的行为 算术运算符 +(正号)、-(负号)、*(乘)、/(除),%(求余)，+(加)、-(减) 算术运算符的运算对象和求值结果都是右值。 一元正号负号运算符对运算对象作用后，返回一个（提升后的）副本： int i = 1024; int k = -i; bool b = true; bool b2 = -b; //b2 是 true 对大多数运算符来说，布尔类型的运算对象将被提升为 int 类型。如上，b 参与运算时被提升成整数值1，对它求负-1，转换为布尔值将其作为 b2 的初始值。 在除法运算中，如果两个运算对象的符号相同则商为正，否则商为负。C++ 语言的早期版本允许结果为负值的商向上或向下取整，C++11 新标准则规定商一律向0取整（即直接切除小数部分）。 逻辑和关系运算符 运算对象和求值结果都是右值；短路求值；进行比较运算符时，除非比较的对象是布尔类型，否则不要使用布尔字面值 true 和 false 作为运算对象 赋值运算符 赋值运算符的左侧运算对象必须是一个可修改的左值 赋值运算的结果是它的左侧运算对象，并且是一个左值，结果的类型就是左侧运算对象的类型 如果赋值运算符的左右两个运算对象类型不同，则右侧运算对象将转换成左侧运算对象的类型 赋值运算满足右结合律：ival = jval = 0； ++ 和 -- 运算符 前置版本将对象本身作为左值返回，后置版本则将对象原始值的副本作为右值返回 建议：除非必须，否则不用递增递减算符的后置版本 后置递增运算符的优先级高于解引用运算符，因此 *pbeg++ 等价于 *(pbeg++)，pbeg++ 把 pbeg 的值加1，然后返回 pbeg 的初始值的副本作为其求值结果 成员访问运算符 由于解引用运算符的优先级低于逗号运算符，因此要对解引用运算符加括号 箭头运算符作用于一个指针类型的运算对象，结果是一个左值 点运算符分成两种情况：如果成员所属的对象是左值，那么结果就是左值；反之，如果成员所属的对象是右值，那么结果是右值 条件运算符 当条件运算符的两个表达式都是左值或者能转换成同一种左值类型时，运算的结果是左值；否则运算的结果是右值 条件运算符满足右结合律 位运算符 位运算符作用于整数类型的运算对象 关于符号位如何处理没有明确的规定，所以强烈建议仅将位运算符作用于处理无符号类型 移位运算符 首先令左侧运算对象的内容按照右侧运算对象的要求移动指定位数，然后将经过移动的（可能还进行了提升）左侧运算对象的拷贝作为求值结果。其中，右侧的运算对象一定不能为负，而且值必须严格小于结果的位数，否则就会产生未定义的行为。移出边界之外的位就被舍弃掉了 移位运算符满足左结合律 移位运算符的优先级比算术运算符低，比关系运算符、赋值运算符和条件运算符高 sizeof运算符 sizeof 运算符返回一条表达式或一个类型名字所占的字节数。 sizeof 运算符满足右结合律，其所得的值是一个 size_t 类型的常量表达式 两种形式 sizeof (type) sizeof expr sizeof 并不直接计算其运算对象的值。 对于 sizeof *p ： 因为 sizeof 满足右结合律并且与 * 的运算符的优先级一样，所以表达式按照从右到左的顺序结合，等价于： sizeof (*p) 其次，因为 sizeof 不实际求运算对象的值，所以即使 p 是一个无效（即未初始化）的指针也不会有什么影响 在 sizeof 的运算对象中解引用一个无效的指针仍然是一种安全的行为，因为指针实际上并没有被真正使用 sizeof 运算符的结果部分地依赖于其作用的类型： 对 char 或者类型为 char 的表达式执行 sizeof 运算，结果得1 对引用类型执行 sizeof 运算得到被引用对象所占空间的大小 对指针执行 sizeof 运算得到指针本身所占空间的大小 对解引用指针执行 sizeof 运算得到指针指向的对象所占空间的大小，指针不需有效 对数值执行 sizeof 运算符得到整个数组所占空间的大小。 sizeof 运算不会把数组转换成指针来处理 对 string 对象或者 vector 对象执行 sizeof 运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。即只取决于里面存放的数据类型，与元素的个数无关，是个编译器相关的值 逗号运算符 首先对左侧的表达式求值，然后将求值结果丢弃掉。逗号表达式真正的结果是右侧表达式的值。如果右侧运算对象是左值，那么最终的求值结果也是左值。 类型转换 何时发生隐式类型转换 在大多数表达式中，比 int 类型小的整数值首先提升为较大的整数类型 在条件中，非布尔值转换成布尔类型 初始化过程中，初始值转换成变量的类型；在赋值语句中，右侧运算对象装换成左侧运算对象的类型 如果算术运算或关系运算的运算对象有多种类型，需要转换成同一种类型 函数调用时也会发生类型转换 数组转换成指针（当数组被用作 decltype 关键字的参数，或者作为取地址符、 sizeof 即 typeid 等运算符的运算对象时，上述转换不会发生，如果用一个引用来初始化数组，上述转换也不会发生） 指针的转换 常量整数值0或者字面值 nullptr 能转换成任意指针类型 指向任意非常量的指针能转换成 void * 指向任意对象的指针能转换成 const void * 转换成常量：允许将指向非常量类型的指针转换成指向相应的常量类型的指针，对于引用也是这样。相反的转换并不存在，因为它试图删掉底层 const 类类型定义的转换 类类型能定义由编译器自动执行的转换，不过编译器每次只能执行一种类类型的转换，如果同时提出多个转换请求，这些请求将被拒绝 之前遇到过的类类型转换 string s, t = \"a value\"; //字符串字面值转换成 string 类型 wile( cin >> s) //while 的条件部分把 cin 转换成布尔值 显示转换 虽然有时不得不使用强制类型转换，但这种方法本质上是非常危险的。 命名的强制类型转换 一个命名的强制类型转换具有如下格式： cast-name<type>(expression); type 是转换的目标类型。如果 type 是引用类型，则结果是左值；expression 是要转换的值；cast-name 是 static_cast 、 dynamic_cast 、 const_cast 和 reinterpret_cast 中的一种。 dynamic_cast 支持运行时类型识别。 static_cast 任何具有明确定义的类型转换，只要不包含底层 const ，都可以使用 static_cast 。当需要把一个较大的算术类型赋给较小的类型时， static_cast 非常有用。此时，强制类型转换告诉程序的读者和编译器：我们知道并且不在乎潜在的精度损失。 static_cast 对于编译器无法自动执行的类型转换也非常有用。例如，我们可以使用它找回 void * 指针中的值: void *p = &d; double *dp = static_cast<double *>(p); const_cast const_cast 只能改变运算对象的底层 const : const char *pc; char *p = const_cast<char*>(pc);//正确，但通过p写值是未定义的行为 只有 const_cast 能改变表达式的常量属性。 reinterpret_cast einterpret_cast 通常为运算对象的位模式提供较低层次上的重新解释。 假如有以下转换： int *ip; char *pc = reinterpret_cast<char*>(ip); 我们必须牢记 pc 所指的真实对象是一个 int 而非字符，如果把 pc 当成普通的字符指针使用就可能在运行时发生错误。 string str(pc); //可能导致异常的运行时行为 reinterpret_cast 本质上依赖于机器。要想安全地使用 reinterpret_cast 必须对涉及的类型和编译器实现转换的过程都非常了解。 强制类型转换干扰了正常的类型检查，因此强烈建议避免使用强制类型转换。 旧式的强制类型转换 在早期版本的 C++ 语言中，显示地进行强制类型转换包含两种形式： type (expr); //函数形式的强制类型转换 (type) expr; //C 语言风格的强制类型转换 根据所设计的类型不同，旧式的强制类型转换分别具有与 const_cast ， static_cast 或 reinterpret_cast 相似的行为。当我们在某处执行旧式的强制类型转换时，如果换成 const_cast 和 static_cast 也合法，则其行为与相应的命名转换一致。如果替换后不合法，则旧式强制类型转换执行与 reinterpret_cast 类似的功能。 char *pc = (char*) ip; //ip是指向整数的指针 上述代码的效果与 reinterpret_cast 一样。","tags":"读书笔记","url":"https://xutree.github.io/pages/2018/10/07/C++_Primer_Chapter_4/"},{"title":"C++ Primer 第三章 字符串、向量和数组","text":"string 表示可变长的字符数组。 vector 存放的是某种给定类型对象的可变长序列。 数组和其他内置类型一样，实现与硬件密切相关，在灵活性上稍显不足。 命名空间 using 声明： using namespace::name; 例如： using std::cin; 。 头文件不应包含 using 声明，防止名字冲突。 标准库类型 string 头文件和声明 #include <string> using std :: string ; 定义和初始化 string s1; //默认初始化，空字符串 string s2 = s1; //s2是s1的副本，等价于 s2(s1) string s3 = \"hiya\"; //s3是字符串字面值的副本，等价于s3(\"hiya\") string s4(10, 'c'); //s4的内容是cccccccccc string 对象上的操作 操作 意义 os << s 将 s 写到输出流 os 中，返回 os is >> s 从 is 中读取字符串赋给 s，字符串以空白分隔，返回 is getline(is, s) 从 is 中读取一行赋给 s，返回 is s.empty() s 为空返回 true，否则返回 false s.size() 返回 s 中字符的个数 s[n] 返回 s 中第 n 个字符的引用，位置 n 从0记起 s1 + s2 返回连接后的结果 s1 = s2 用 s2 的副本代替 s1 s1 == s2 如果 s1 和 s2 中所含的字符完全一样，则他们相等 s1 != s2 string 对象的相等性判断对大小写敏感 <, <=, >, >= 利用字符在字典里的顺序进行比较，大小写敏感 读取未知数量的 string 对象 int main() { string word; while (cin >> word) cout << word << endl; return 0; } 直到遇到结束标记或者非法输入才会停止 使用 getline 读取一整行 int main() { string line; while (getline(cin,line)) cout << line << endl; return 0; } getline 函数的参数是一个输入流和一个 string 对象， getline 从给定的输入流中读入内容，直到遇到换行符为止（注意换行符也被读进来了），然后把所读的内容存入 string 对象中（注意不存换行符）。如果输入一开始就是换行符，那么所得的结果是个空 string 。 string::size_type 类型 是一个无符号类型的值。如果一个表达式中已经有 size 函数就不要再使用 int 了，这样可以避免混用 int 和 unsigned 可能带来的问题。 string 对象可以和字符字符串字面值相加，只要保证 + 号两侧的运算对象至少有一个 string 对象即可。 由于某些历史原因，也为了和 C 兼容，所以 C++ 中的字符串字面值并不是标准库 string 类型。 处理 string 对象里的字符 包含在 cctype 头文件中： 函数 意义 isalunm(c) 当 c 是字母或数字时为真 isalpha(c) 当 c 是字母时为真 iscntrl(c) 当 c 是控制字符时为真 isdigit(c) 当 c 是数字时为真 isgraph(c) 当 c 不是空格但可打印时为真 islower(c) 当 c 是小写字母时为真 isprint(c) 当 c 是可打印字符时为真（即 c 是空格或 c 具有可视形式） ispunct(c) 当 c 是标点符号时为真（即 c 不是控制字符、数字、字母、可打印空白中的一种） isspace(c) 当 c 是空白时为真（即 c 是空格、横向制表符、纵向制表符、回车符、换行符、进纸符中的一种） isupper(c) 当 c 是大写字母时为真 isxdigit(c) 当 c 是十六进制数字时为真 tolower(c) 输出 c 的小写 toupper(c) 输出 c 的大写 C++ 标准库除了定义 C++ 语言特有的功能外，也兼容了 C 语言的标准库。C 语言的头文件形如 name.h，C++ 则将这些文件命名为 cname。因此 cctype 头文件和 ctype.h 头文件的内容是一样的，只不过从命名规范上来讲更符合 C++ 语言的要求。特别地，在名为 cname 的头文件中定义的名字从属于命名空间 std 。 范围 for for (declaration: expression) statement expression 是一个对象，用于表示一个序列；declaration 负责定义一个变量，该变量将被用于访问序列中的基础元素，每次迭代，declaration 部分的变量会被初始化为 expression 部分的下一个元素值。 使用范围for输出 string str(\"some string\"); for (auto c : str) cout << c << endl; 使用范围for修改 string s(\"Hello World!\"); for (auto &c : s) c = toupper(c); cout << s << endl; 下标运算符 [ ] [ ]接收的输入参数是 string:size_type 类型的值，这个参数表示要访问的字符的位置，返回值是该位置上字符的引用。 string 对象的下标必须大于等于0而小于 s.size() 。 标准库类型 vector vector 表示对象的集合，其中所有对象的类型都相同，也常被称作容器，是一种类模板 #include <vector> using std :: vector ; 编译器根据模板创建类或函数的过程称为实例化，对于类模板，我们通过提供一些额外信息来指定模板到底实例化成什么样的类：在模板名字后面跟一对尖括号，在括号内放上信息 vector<int> ivec; vector<Sales_item> Sales_vec; vector<vector<string>> file; 在早期版本的 C++ 标准中如果 vector 的元素还是 vector （或者其他模板类型），则其定义的形式与现在的 C++11 新标准略有不同。过去，必须在外层 vector 对象的右尖括号和其元素类型之间添加一个空格，如应写成 vector<vector<int> > 初始化 默认初始化。 列表初始化。 值初始化：通常情况下，可以只提供vector对象容纳的元素数量而略去初始值。此时库会创建一个值初始化的元素初值，并把它赋给容器中的所有元素。这个初值由vector对象中元素的类型决定。内置类型：0；类类型：由类默认初始化。 添加元素 push_back ：负责把一个值当成 vector 对象的尾元素压到 vector 对象的尾端 vector<int> v2; for (int i = 0; i != 100; ++i) v2.push_back(i); 如果循环内部包含有向 vector 对象添加元素的语句，则不能使用范围 for 循环。 其他vector操作 函数 含义 v.empty() 如果 v 不含有任何元素，返回真；否则返回假 v.size() 返回 v 中元素的个数 v.push_back(t) 向 v 的尾端添加一个值为 t 的元素 v[n] 返回 v 中第 n 个位置上元素的引用 v1 = v2 用 v2 中的元素拷贝替换 v1 中的元素 v1 = 用列表中元素的拷贝替换 v1 中的元素 v1 == v2 v1 和 v2 相等当且仅当它们的元素数量相同且对应位置的元素值都相同 v1 != v2 <,<=,>,>= 以字典顺序进行比较 vector 的 size_type vector<int>::size_type //正确 vector::size_type //错误 和 string 一样， vector 对象的下标也是从0开始计算， vector 对象（以及 string 对象）的下标运算符可用于访问已存在的元素，而不能用于添加元素。 迭代器 所有标准库容器都可以使用迭代器，但只有少数的几种才同时支持下标运算符。 严格来讲， string 不属于容器类型，但是 string 支持很多与容器类型相似的操作。 vector 支持下标运算符，这点和 string 一样。 和指针不一样，获取迭代器不是使用取地址符，有迭代器的类型同时拥有返回迭代器的成员。 begin 和 end ： auto b = v.begin(), e = v.end(); 。 end 成员负责返回指向容器\"尾元素的下一位置\"的迭代器。常被称作尾后迭代器或尾迭代器。 如果容器为空，则 begin 和 end 返回的是同一个迭代器，都是尾后迭代器。 标准容器迭代器的运算符 符号 含义 *iter 返回迭代器 iter 所指元素的引用 iter->mem 解引用 iter 并获取该元素的名为 mem 的成员，等价于(*iter).mem ++iter 令 iter 指向容器中的下一个元素 --iter 令 iter 指向容器中的上一个元素 iter1 == iter2 判断两个迭代器是否相等 iter1 != iter2 如果指向同一元素或者他们是同一容器的尾后迭代器 因为 end 返回的迭代器并不实际指向某个元素，所以不能对其进行递增或解引用操作。C++ 程序员习惯性地使用 != ，其原因和他们更愿意使用迭代器而非下标的原因一样：这种编程风格在标准库提供的所有容器上都有效，因为所有标准库容器都定义了 == 和 != 。 迭代器类型 拥有迭代器的标准库类型使用 iterator 和 const_iterator 来表示迭代器的类型 vector < int > :: iterator it ; // it 能读写 vector < int > 的元素 string :: iterator it2 ; // it2 能读写 string 对象中的元素 vector < int > const_iterator it3 ; // it3 只能读元素 ， 不能写元素 string :: const_iterator it4 ; // it4 只能读字符 ， 不能写字符 begin 和 end 返回的具体类型由对象是否是常量决定，如果对象是常量， begin 和 end 返回 const_iterator ；如果对象不是常量，返回 iterator 。如果对象只需读操作而无需写操作的话最好使用常量类型迭代器。为了专门得到 const_iterator ，C++11 标准引入两个新函数： cbegin 和 cend 。任何一种可能改变容器容量的操作，都会是迭代器失效。 迭代器运算 string 和 vector 的迭代器提供了更多额外的运算符： iter + n ：迭代器加上一个整数值仍得到一个迭代器，迭代器指示的新位置与原来相比向前移动了若干个元素。结果迭代器或者指示容器内的一个元素，或者指示容器尾元素的下一位置。 iter - n ：迭代器减去一个整数值仍得一个迭代器，迭代器指示的新位置与原来相比向后移动了若干位置。结果迭代器或者指示容器内的一个元素，或者指示容器尾元素的下一位置。 iter1 - iter2 ：两个迭代器相减的结果是它们之间的距离，也就是说，将运算符右侧的迭代器向前移动差值个元素后将得到左侧的迭代器。参与运算的两个迭代器必须指向的是同一容器中的元素或者尾元素的下一位置。 >, >=, <, <= ：迭代器的关系运算符，如果迭代器指向的容器位置在另一个迭代器所指位置之前，则说前者小于后者。 数组 因为数组的大小固定，因此在对某些特殊的应用来说程序的运行时性能较好，但是相应的也损失了一些灵活性。 数组的维度必须是一个常量表达式。 默认情况下数组的元素被默认初始化。 和内置类型的变量一样，如果在函数内部定义了某种内置类型的数组，那么默认初始化会令数组含有未定义的值。 定义数组的时候必须指定数组的类型，不允许用auto关键字由初始值的列表推断类型。 字符数组可以利用字符串字面值初始化，此时注意字符串字面值末尾的空字符，也会被拷贝到字符数组中。 不允许拷贝和赋值。一些编译器支持数组的赋值，这就是所谓的编译器扩展，但一般来说，最好避免使用非标准特性，因为可能在其他编译器上无法正常工作。 理解复杂的数组声明：由内向外阅读 int *ptrs[10]; //ptrs 是含有10个整型指针的数组 int (*Parray)[10] = &arr; //Parray 是指针，指向一个含有10个整数的数组 int (&arrRef)[10] = arr; //arrRef 是引用，引用一个含有10个整数的数组 int *(&arry)[10] = ptrs; //arry 是引用，引用一个含有10个整型指针的数组 访问数组元素 数组的索引从0开始。 在使用数组下标的时候，通常将其定义为 size_t 类型。 size_t 是一种机器相关的无符号类型，它被设计的足够大以便能表示内存中任意对象的大小。 在 cstddef 头文件中定义了 size_t 类型，这个文件是 C 标准库 stddef.h 头文件的 C++ 版本。 使用数组的时候编译器一般会把它转换成指针。 通常情况下，使用取地址符来获取指向某个对象的指针，取地址符可以用于任何对象。数组的元素也是对象，对数组使用下标运算符得到该数组指定位置的元素，对数组元素应用取地址符就能得到指向该元素的指针。 数组还有一个特性：在很多时候用到数组名字的地方，编译器都会自动地将其替换为一个指向数组首元素的指针 string *p2 = nums; //等价于 p2 = &nums[0] 所以如果使用数组作为一个auto变量的初始值时，推断的类型是指针而非数组 int ia[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9,}; auto ia2(ia); // ia2 是一个整型指针，指向 ia 的第一个元素 ia2 = 42; //错误，ia2 是一个指针，不能用 int 赋值 当使用 decltype 关键字时上述转换不会发生， decltype(ia) 返回的类型是由10个整数构成的数组 decltype(ia) ia3 = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; ia3 = p; //错误，不能用整型指针给数组赋值 ia3[4] = i; //正确：把 i 的值赋给 ia3 的一个元素 为了让指针的使用更简单、更安全，C++11 新标准引入两个名为 begin 和 end 的函数，不过数组毕竟不是类类型，因此这两个函数不是成员函数。正确的使用形式是将数组作为它们的参数 int ia[] = {1, 2, 3, 4, 5, 6, 7, 8, 9}; int *beg = begin(ia); int *last = end(ia); begin 函数返回指向 ia 首元素的指针， end 函数返回指向 ia 尾元素下一位置的指针，这两个函数定义在 iterator 头文件中 两个指针相减结果的类型是一种名为 ptrdiff_t 的类型，和 size_t 一样，它也是定义在 cstddef 头文件中的机器相关的类型。因为差值可能是负值，所以它是一种带符号类型。 内置的下标运算符所用的索引值不是无符号类型，这一点和 vector 和 string 不一样 int *p = &ia[2]; int k = p[-2]; //k 是 ia[0] 那个元素 C 风格字符串 按此习惯书写的字符串存放在字符数组中并以空字符结束。 C 语言标准库提供了一组函数用于操作 C 风格字符串，它们定义在 cstring 头文件中，cstring 是 C 语言头文件 string.h 的 C++ 版本。 与旧代码的接口 任何出现字符串字面值的地方都可以用空字符结尾的字符数组来代替。不能用string对象直接初始化指向字符的指针，为了完成该功能，string专门提供了一个名为c_str的成员函数 char *str = s; //错误，不能用 string 对象初始化 char* const char *str = s.c_str(); //正确 我们无法保证 c_str 函数返回的数组一直有效，事实上，如果后续的操作改变了 s 的值就可能让之前返回的数组失去效用 使用数组初始化 vector 对象 int int_arr[] = {0, 1, 2, 3, 4, 5}; vector<int> ivec(begin(int_arr),end(int_arr)); 现代的 C++ 程序员应当尽量使用 vector 和迭代器，避免使用内置的数组和指针，应该尽量使用 string ，避免使用 C 风格的基于数组的字符串。 多维数组：要使用范围 for 语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型。 缓冲区溢出：主要原因是试图通过一个越界的索引访问容器内容。 difference_type ：由 string 和 vector 定义的一种带符号整数类型，表示两个迭代器之间的距离。","tags":"读书笔记","url":"https://xutree.github.io/pages/2018/10/06/C++_Primer_Chapter_3/"},{"title":"C++ Primer 第二章 变量和基本类型","text":"类型 下表列出了 C++ 标准规定的数据类型尺寸的最小值，同时允许编译器赋予这些类型更大的尺寸 类型 含义 最小尺寸 bool 布尔类型 未定义 char 字符 8位 wchar_t 宽字符 16位 char16_t Unicode 字符 16位 char32_t Unicode 字符 32位 short 短整型 16位 int 整型 16位 long 长整型 32位 long long 长整型 64位 float 单精度浮点数 6位有效数字 double 双精度浮点数 10位有效数字 long double 扩展精度浮点数 10位有效数字 一个 char 的空间应确保可以存放机器基本字符集中任意字符对应的数字值。也就是说，一个 char 的大小和一个机器字节一样。 wchar_t 类型用于确保可以存放机器最大扩展字符集中的任意一个字符。 C++ 语言规定，一个 int 至少和一个 short 一样大，一个 long 至少和一个 int 一样大，一个 long long 至少和一个 long 一样大。 可寻址的最小内存块成称为\"字节（byte）\"，存储的基本单元称为\"字（word）\"，它通常有几个字节组成。 在 C++ 语言中，一个字节至少能容纳机器基本字符串中的字符。大多数机器的字节由8比特构成，字则由32或64比特构成，也就是4字节或8字节。 C++ 标准指定了一个浮点数有效位数的最小值，然而大多数编译器都实现了更高的精度。通常， float 以1个字（32比特）来表示， double 以2个字（64位）来表示， long double 以3或4个字（96或128比特）来表示。一般来说， float 和 double 分别有7和16个有效位；类型 long double 则常常被用于有特殊浮点要求的硬件，它的具体实现不同，精度也各不相同。 类型 int 、 short 、 long 和 long long 都是带符号的，通过在这些类型名前添加 unsigned 就可以得到无符号类型。 char 、 signed char 和 unsigned char ， char 是否等于 signed char 由编译器决定。 C++ 标准并没有规定带符号类型应如何表示，但是约定了在表示范围内正值和负值的量应该平衡。因此，8比特的 signed char 理论上可以表示-127至127区间内的值，大多数现代计算机将实际的表示范围定为-128至127。 如何选择类型 明知数值不可能为负数，选用无符号类型。 如果数值超过了 int 的表示范围，选用 long long ，因为 long 一般和 int 有一样的尺寸。 算术表达式中不要使用 bool 或 char 。 执行浮点数运算选用 double 。因为 float 通常精度不够而且计算代价相差无几。 long double 提供的精度一般情况下是没有必要的而且计算代价大。 类型转换 非布尔 -> 布尔：0 -> false ，其他 -> ture 。 布尔 -> 非布尔： false -> 0， ture -> 1。 浮点 -> 整型：仅保留小数点前。 整型 -> 浮点：小数部分记为0，如果该整数所占的空间超过浮点类型的容量，精度可能损失。 当我们赋给无符号类型一个超过它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。 当我们赋给带符号类型一个超出它表示范围的值时，结果是未定义的。此时，程序可能继续工作、可能崩溃，也可能生成垃圾数据。 当一个算术表达式中既有无符号数又有 int 值时，那个 int 会转换成无符号数。把 int 转换成无符号数的过程和把 int 赋值给无符号变量一样。 当从一个无符号数中减去一个值时，我们必须确保结果不是负值，否则实际结果会是取模后的值。 字面值常量 整型和浮点型字面值。 字符和字符串字面值： ‘a' 和\"a\"，字符串字面值最后补'\\0' 如果两个字符串字面值位置紧邻且仅由空格、缩进和换行分隔，则它们是一个整体 布尔字面值： true 、 false 。 指针字面值： nullptr 。 指定字面值的类型 字符和字符串字面值 前缀 类型 u char16_t U char32_t L wchar_t u8 char 整型字面值 后缀 最小匹配类型 u 或 U unsigned l 或 L long ll 或 LL long long 浮点型字面值 后缀 类型 f 或 F float l 或 L long double 列表初始化 int units_sold{0} 列表初始化的重要特点：如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将报错。 默认初始化 内置类型变量 定义于任何函数之外，初始化为0 定义于函数体内的局部静态变量，初始化为0 定义于函数体内的非局部静态变量，不被初始化，试图拷贝或以其他方式访问此类值将引发错误 每个类各自决定其初始化对象的方式。 分离式编译 将程序分割为若干个文件，每个文件可被独立编译 声明 extern int i; extern 语句如果包含初始值就不再是声明，而变成定义了： extern int i = 0; 在函数体内部，试图初始化一个由 extern 关键字标记的变量将引发错误。 静态类型语言：在编译阶段执行类型检查 C++ 标识符 字母、数字、下划线，必须以字母或下划线开头，长度无限制，大小写敏感。 C++ 为标准库保留了一些名字 自定义标识符中不能连续出现两个下划线 不能以下划线紧接大写字母开头 定义在函数体外的函数不能以下划线开头 作用域操作符 :: 若左侧为空，则指代全局作用域 复合类型 引用 int &b = a; b指向a。 引用必须初始化。 引用本身不是一个对象，不能定义引用的引用。 引用必须绑定到对象上，不能绑定到字面值或者某个表达式的计算结果上。 除了两种例外，所有引用的类型都要和它所绑定的对象严格匹配： 初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可 允许将基类的引用绑定到派生类上 指针 int *b = &a; 。 指针是一个对象。 在块作用域内定义的指针如果未初始化，将拥有一个不确定的值。 除了两种例外，所有指针的类型都要和它所指向的对象严格匹配： 允许一个指向常量的指针指向一个非常量对象 允许将基类的指针绑定到派生类上 试图拷贝或以其他方式访问无效指针的值将引起错误，编译器不负责检查此类错误。 任何非零的指针对应的条件值都是true。 合法指针可以比较大小：== 或 !=。 void * 是一个特殊的指针类型，可用于存放任意对象的地址，只支持有限的操作： 拿它和别的指针比较 作为函数的输入或输出 赋给另外一个 void * 指针 理解复合类型的声明 变量的定义包括一个基本数据类型和一组声明符。 一条定义语句可能定义出不同类型的变量： int i = 1024, *p = &i, &r =i; 。 面对一条比较复杂的指针或者引用的声明语句时，从右往左阅读有助于弄清楚它的真实含义，例如： int \\*&r; 首先 r 是一个引用，其次 r 是一个指针的引用，再次 r 是一个指向整型指针的引用。 const 限定符 因为 const 对象一旦创建就无法改变其值，所以必须初始化。 当用一个对象去初始化另外一个对象，它们是不是 const 都无关紧要，常量的特性仅仅在执行改变其值的操作时才会发挥作用。 默认情况下， const 对象仅在文件内有效。 如果想在多个文件之间共享 const 对象，必须在变量的定义之前添加 extern 关键字。 const 的引用，常量引用的初始化：初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。尤其，允许为一个常量引用绑定非常量的对象、字面值甚至是一个表达式。实际上是通过绑定到一个临时量对象上实现的。 对 const 的引用可能引用一个并非 const 的对象，常量引用仅对引用可参与的操作做了限制，对于引用的对象本身是不是常量未做限制。 指针和 const 指向常量的指针 允许一个指向常量的指针指向一个非常量对象。 仅对指向常量的指针可参与的操作做了限制，对于指向的对象本身是不是常量未做限制。 const 指针 指针是对象，可以把指针本身定为常量。 常量指针必须初始化，一经初始化就不能再改变。 把*放在 const 关键字之前说明指针是一个常量。 顶层和底层 const 顶层 const ：指针本身是个常量。 底层 const ：指针所值的对象是一个常量。 更一般的，顶层 const 可以表示任意的对象是常量，这一点对任意数据类型都适用。底层 const 则与指针和引用等复合类型的基本类型部分有关。 执行对象的拷贝操作时，顶层 const 不受影响；拷入和拷出的对象必须具有相同的底层 const 资格，或者两个对象的数据类型必须能够转换。一般来说，非常量可以转换成常量，反之不行。 constexpr 和常量表达式 常量表达式：值不会改变并且在编译过程就能得到计算结果的表达式。 constexpr 变量：由编译器来验证变量的值是否是一个常量表达式，声明为 constexpr 的变量一定是一个常量，并且必须用常量表达式初始化。 字面值类型：算术类型、引用、指针、字面值常量类、枚举。 声明 constexpr 用到的类型为字面值类型。 一个 constexpr 指针的初始值必须是 nullptr 或者0，或者是存储于某个固定地址中的对象： 函数体内定义的变量一般并非存放在固定地址中， constexpr 指针不能指向这样的变量（局部静态对象除外） 定义于所有函数体之外的对象地址固定不变，能用来初始化 constexpr 指针 在 constexpr 声明中如果定义了一个指针，限定符 constexpr 仅对指针有效，与指针所指的对象无关。 constexpr 把它所定义的对象置为顶层 const 。 处理类型 类型别名 typedef double wages; using SI = Sales_item; auto 类型说明符 让编译器自己去分析表达式所属的类型。 auto 也能在一条语句中声明多个变量。因为一条声明语句只能有一个基本数据类型，所以该语句中所有变量的基本数据类型都必须一样。 当引用被用作初始化 auto 变量时，编译器以引用所引用对象的类型作为 auto 的类型。 auto 一般会忽略顶层 const ，同时底层 const 会保留下来。 如果希望推断出的 auto 类型是一个顶层 const ，需要明确指出。 auto 引用 auto &b = a; 初始值 a 的顶层 const 会保留。 decltype 类型指示符 选择并返回操作数的数据类型，编译器分析表达式得到它的类型，却不实际计算表达式的值，编译器并不实际调用f。 如果 decltype 使用的表达式是一个变量，则 decltype 返回该变量的类型（包括顶层 const 和引用在内），需要指出的是，引用从来都作为其所指对象的同义词出现，只有在 decltype 处是一个例外。 如果 decltype 使用的表达式不是一个变量，则 decltype 返回该表达式的结果对应的类型： 因为 r 是一个引用， decltype(r) 的结果是引用类型，如果想让结果类型是 r 所指的类型，可以把 r 作为表达式的一部分，显然这个表达式的结果是一个具体的值而非一个引用 如果表达式的内容是解引用操作，则 decltype 将得到引用类型 如果 decltype 使用的表达式是一个变量： 不加括号，得到该变量的类型 加括号，得到引用类型 自定义数据结构：结构体和类 记得定义末尾的分号。可以类内初始化。 头文件保护符 头文件保护符依赖于预处理变量。 预处理变量由两个状态：已定义和未定义。 #define 指令把一个名字设定为预处理变量。 #ifdef 当且仅当变量已定义时为真。 #ifndef 当且仅当变量未定义时为真。 一旦检查结果为真，则执行后续操作直到遇到 #endif 指令为止","tags":"读书笔记","url":"https://xutree.github.io/pages/2018/10/06/C++_Primer_Chapter_2/"},{"title":"利用 Mac stat 添加文件创建时间、最后修改时间","text":"Pelican 根据 .md 文件生成网页的时候需要 metadata，所以写个命令行自动添加文件创建时间、最后修改时间，这样写博客的时候只需要把 title、category 和 tags 标签填上就行了，其中用了 stat 命令。 自动添加文件创建时间、最后修改时间 stat 命令的 a, m, c, B 参数分别代表上次访问或修改时间文件，上次更改 inode 的时间或 inode 的生成时间（ UNIX 时间戳），所以我们可以通过提取这些信息实现想要的功能。唯一需要注意的是，结果是UNIX时间戳，我们需要将其转换为普通时间。 UNIX 时间，或称 POSIX 时间是 UNIX 或类 UNIX 系统使用的时间表示方式：从协调世界时1970年1月1日0时0分0秒起至现在的总秒数，不考虑闰秒。在多数 UNIX 系统上 UNIX 时间可以通过 date +%s 指令来检查。 在 Mac 系统是由 UNIX 时间戳转化为普通时间的指令为： 所以我们\b先根据 stat 获得文件的创建时间： 然后转化为普通时间： \b以下为脚本： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #! /bin/bash # 输入：需要修改的文件 filename = $1 # 提取创建时间 create_time = $( date -r $( stat -f \"%B\" $filename ) \"+%Y-%m-%d %H:%M:%S\" ) # 提取修改时间 modify_time = $( date -r $( stat -f \"%m\" $filename ) \"+%Y-%m-%d %H:%M:%S\" ) # 查找Date标签的行号 num1 = $( head -5 $filename | grep -n 'Date' | cut -d \":\" -f 1 ) # 查找Modified标签的行号 num2 = $( head -5 $filename | grep -n 'Modified' | cut -d \":\" -f 1 ) # 如果Date标签行号为空，说明不存在Date标签，则插入Date if [ -z \" $num1 \" ] ; then sed -i '' -e \"2s/&#94;//p; 2s/&#94;.*/Date: $create_time /\" $filename fi # 如果Modified标签行号为空，插入Modified if [ -z \" $num2 \" ] ; then sed -i '' -e \"3s/&#94;//p; 3s/&#94;.*/Modified: $modify_time /\" $filename else # 否则，替换Modified标签到最新时间 sed -i '' ${ num2 } d $filename sed -i '' -e \"3s/&#94;//p; 3s/&#94;.*/Modified: $modify_time /\" $filename fi 附：stat 命令详情 stat 显示有关文件的信息。 不需要读取，写入或执行指定文件的权限，但必须可搜索通向该文件的路径名中列出的所有目录。 如果没有给出参数， stat 将显示有关标准输入的文件描述符（stdin）的信息。 当作为 readlink 调用时，仅打印符号链接的目标。 如果给定的参数不是符号链接，则 readlink 将不打印任何内容并退出并显示错误。 显示的信息是通过使用给定参数调用 lstat 系统调用并解释返回的结构来获得的。 参数 -F 与 ls 命令\b的 -F 参数一样，在作为目录的每个路径名之后显示斜杠（'/'），在每个可执行的路径名后面显示星号（'*'），在每个符号链接后显示at符号（'@'）， 在每个without文件后面显示百分号（'％'），每个套接字后显示等号（'='），以及在每个FIFO文件后面显示一个垂直条（'|'）。 -F 的使用意味着 -l -f format 使用指定的格式显示信息 -L 使用 stat 而不是 lstat 。 如果文件是符号链接，则stat给出的信息是链接文件目标文件的信息，而不是链接\b文件本身 -l 将输出以 ls -lT 格式显示，即显示文件的完整时间信息，包括月，日，小时，分钟，秒和年 -n 输出不强制换行 -q 如果对 stat 或 lstat 的调用失败，则不\b显示失败消息。以 readlink 方式运行时，会自动禁止错误消息 -r 显示原始信息。即，对于stat结构（UNIX/Linux系统中定义的结构体）中的所有字段，显示原始数值（例如，自纪元以来的秒数等） -s 在\"shell输出\"中显示信息，适用于初始化变量 -t timefmt 使用指定的格式显示时间戳。 此格式直接传递给 strftime 命令 -x 从某些Linux发行版中以更详细的方式显示信息 格式 格式字符串类似于 printf 格式，因为它们以 ％ 开头，然后是一系列格式化字符，最后是一个字符，用于选择要格式化的 struct stat 字段。 如果 ％ 后面紧跟 n，t，％ 或 @ 之一，则会打印换行符，制表符，百分号或当前文件号，否则将检查字符串是否包含以下内容： 以下是任何可选标志： # 为八进制和十六进制输出选择备用输出形式。 非零八进制输出将具有前导零，并且非零十六进制输出将具有前缀\"0x\" + 断言应始终打印指示数字是正数还是负数的符号。 非负数通常不打印带符号 - 将字符串输出对齐到字段的左侧，而不是右侧 0 将左边距的填充字\b符设置为\"0\"字符，而不是空格 space 在非负有符号输出字段的前面保留一个空格。 如果同时使用 ‘+' ，则 ‘+' 将覆盖空格 以下是任何可选字段： size 可选的十进制数字字符串，指定最小字段宽度 prec 由小数点'.'和十进制数字字符串组成的可选精度，指示最大字符串长度，浮点输出中小数点后出现的位数，或数字输出中显示的最小位数 fmt 可选的输出格式说明符，它是D，O，U，X，F 或 S 之一。它们分别表示带符号的十进制输出，八进制输出，无符号十进制输出，十六进制输出，浮点输出和字符串输出。 某些输出格式不适用于所有字段。 浮点输出仅适用于 timespec 字段（a，m 和 c 字段）。 特殊输出说明符S可用于指示输出（如果适用）应为字符串格式。 可与以下标志结合使用： amc 以 strftime 格式显示日期 dr 显示实际设备名称 gu 显示组或用户名 p 以 ls -lTd 显示文件模式 N 显示文件名 T 显示文件类型 Y 在输出中插入\" -> \"。 请注意， Y 的默认输出格式是字符串，但如果明确指定，则会预先添加这四个字符 sub 可选的子字段说明符（高，中，低）。仅适用于 p，d，r 和 T 输出格式。 它可以是以下之一： H \"高\"，指定来自 r 或 d 的设备的主要编号，来自 p 的字符串形式的权限的\"用户\"位，来自 p 的数字形式的文件\"type\"位，以及 T 的长输出形式 L \"低\"，指定来自 r 或 d 的设备的次要编号，来自 p 的字符串形式的权限的\"其他\"位，来自 p 的数字形式的\"用户\"，\"组\"和\"其他\"位， 当与 T 一起使用时，文件类型的 ls -F 样式输出字符（对此使用 L 是可选的） M \"中\"，指定 p 的字符串输出形式的权限的\"组\"位，或 p 的数字形式的 \"suid\"，\"sgid\" 和 \"sticky\" 位 datum 必填字段说明符，是以下之一： d 文件所在的设备 i 文件的inode编号 p 文件类型和权限 l 文件的硬链接数 u, g 文件所有者的用户ID和组ID r 字符和块设备专用文件的设备编号 a, m, c, B 上次访问或修改时间文件，上次更改 inode 的时间或 inode 的生成时间（UNIX时间戳） z 文件大小（以字节为单位） b 分配给文件的块数 k 最佳文件系统I / O操作块大小 f 用户定义的文件标志 v Inode 生成号 以下四个字段说明符不是直接从struct stat中的数据中提取的，而是： N 文件的名称 T 文件类型，类似 ls -F ，如果给出子字段说明符H，则采用更具描述性的形式。 Y 符号链接的目标 Z 从字符或块特殊设备的rdev字段扩展为\"major，minor\"，并为所有其他设备提供大小输出 只有 ％ 和字段说明符是必需的。大多数字段说明符默认为 U 作为输出形式；p 默认输出形式是 O；a、m、c 默认输出形式是 D，Y、T、N 默认输出形式是 S。","tags":"教程","url":"https://xutree.github.io/pages/2018/10/06/mac-stat/"},{"title":"C++ Primer 第一章 开始","text":"g++ -std=c++14 -Wall -o test test.cpp iostream cin cout cerr clog << 运算符返回其左侧的运算对象 写入 endl 的效果是结束当前行，并将与设备关联的缓冲区中的内容刷到设备中。缓冲刷新操作可以保证到目前为止程序所产生的所有输出都真正写入到输出流中，而不是仅停留在内存中等待写入流 小心程序崩溃，输出可能还留在缓冲区的情况，利用 endl 标准库定义的所有名字都在命名空间 std 中 当我们使用一个 istream 对象作为条件时，其效果是检测流的状态。流有效，即流未遇到错误，那么检测成功。当遇到文件结束符（end of file），或遇到一个无效输入时， istream 对象的状态会变为无效。无效的 istream 对象会使条件为假 文件结束符：Windows 先Ctrl + Z，后Enter 或 Return；UNIX：Ctrl +D 标准库文件通常不带后缀。编译器一般不关心头文件名的形式，但有的IDE对此有特定要求 头文件包含：标准库头文件 <> 非标准库头文件 \"\" 文件重定向：从文件读入\\<infile，输出到文件>outfile cerr (无缓冲标准错误) 没有缓冲，发送给它的内容立即被输出 clog (缓冲标准错误) 有缓冲，缓冲区满时输出 cout 标准输出 cout 是在终端显示器输出， cout 流在内存中对应开辟了一个缓冲区，用来存放流中的数据，当向 cout 流插入一个 endl ，不论缓冲区是否满了，都立即输出流中所有数据，然后插入一个换行符 cerr 流对象是标准错误流，指定为和显示器关联，和 cout 作用差不多，有点不同就是 cout 通常是传到显示器输出，但可以被重定向输出到文件，而 cerr 流中的信息只能在显示器输出 clog 流也是标准错误流，作用和 cerr 一样，区别在于 cerr 不经过缓冲区，直接向显示器输出信息，而 clog 中的信息存放在缓冲区，缓冲区满或者遇到 endl 时才输出 对于为什么有 cerr 和 clog ？比如，你的程序遇到调用栈用完了的威胁（无限，没有出口的递归。你说，你到什么地方借内存，存放你的错误信息？所以有了 cerr 。其目的，就是在你最需要它的紧急情况下，还能得到输出功能的支持 缓冲区的目的，就是减少刷屏的次数——比如，你的程序输出圣经中的一篇文章。不带缓冲的话，就会每写一个字母，就输出一个字母，然后刷屏。有了缓冲，你将看到若干句子\"同时\"就出现在了屏幕上（由内存翻新到显存，然后刷新屏幕）","tags":"读书笔记","url":"https://xutree.github.io/pages/2018/10/05/C++_Primer_Chapter_1/"},{"title":"HTML 入门","text":"HTML ，即超文本标记语言（ H yper T ext M arkup L anguage）。与脚本或编程语言不同，标记语言使用标记（ tag ）来标识内容。 下面是一个 HTML tag 的例子： <p> 这是一个段落。</p> <p> 称为开始标签， </p> 称为结束标签。 网页的结构 HTML：结构 CSS：样式 JavaScript：行为 PHP 或类似语言：后端 CMS：内容管理 基本 HTML 文件结构 标签 解释 <html></html> HTML文件的所有内容都包含在其中 <head></head> HTML文件的头部包含有助于使页面工作的所有非可视元素 <body></body> 所有可视化元素都包含在body标签中 <title></title> 包含网页选项卡上现实的标题内容 <!DOCTYPE html> 声明为 HTML5 文档 <!DOCTYPE html> < html > < head > < meta charset = \"utf-8\" > < title > 第一个 HTML 例子 </ title > </ head > < body > Hello World! </ body > </ html > <!DOCTYPE> 声明 <!DOCTYPE> 声明有助于浏览器中正确显示网页。网络上有很多不同的文件，如果能够正确声明 HTML 的版本，浏览器就能正确显示网页内容。 doctype 声明是不区分大小写的，以下方式均可： <!DOCTYPE html> <!DOCTYPE HTML> <!doctype html> <!Doctype Html> 中文编码 目前在大部分浏览器中，直接\b输出中文会出现中文乱码的情况，这时候我们就需要在头部将字符声明为 <meta charset=\"utf-8\"> 。 字体标签 标签 解释 <p></p> 段落标签（浏览器会在段落前后自动添加空行） <br /> 换行而不开启新段落（它没有结束标记） <b></b> 粗体 <big></big> 大号文本 <i></i> 斜体 <small></small> 小号文本 <strong></strong> 强调（一种phrase tag） <sub></sub> 下标 <sup></sup> 上标 <ins></ins> 插入线 <del></del> 删除线 标题标签 <h1></h1> ， <h2></h2> ， <h3></h3> ， <h4></h4> ， <h5></h5> ， <h6></h6> 六种标题， <h1></h1> 字号最大。 标签属性\b 属性提供有关元素或标记的附加信息，同时还可以修改它们。例如 <p align= \"center\" > This text is aligned to center </p> 会将段落居中显示（\b <p> 标签的align属性在HTML5中不再支持）。\b 双引号是最常用的，不过使用单引号也没有问题。属性的数值可以通过像素或百分比指定，如 <hr width=\"50px\" /> <hr width=\"50%\" /> HTML 全局属性 加粗为 HTML5 新属性。 属性 描述 accesskey 设置访问元素的键盘快捷键 class 规定元素的类名（classname） contenteditable 规定是否可编辑元素的内容 contextmenu 指定一个元素的上下文菜单，当用户右击该元素，出现上下文菜单 data-* 用于存储页面的自定义数据 dir 设置元素中内容的文本方向 draggable 指定某个元素是否可以拖动 dropzone 指定是否将数据复制，移动，或链接，或删除 hidden hidden 属性规定对元素进行隐藏 id 规定元素的唯一 id lang 设置元素中内容的语言代码 spellcheck 检测元素是否拼写错误 style 规定元素的行内样式（inline style） tabindex 设置元素的 Tab 键控制次序 title 规定元素的额外信息（可在工具提示中显示） translate 指定是否一个元素的值在页面载入时是否需要翻译 HTML 标签 加粗为 HTML5 新标签。 标签 描述 abbr 定义缩写 acronym 定义只取首字母的缩写，不支持 HTML5 address 定义文档作者或拥有者的联系信息 applet HTML5 中不赞成使用，定义嵌入的 applet area 定义图像映射内部的区域 article 定义一个文章区域 aside 定义页面的侧边栏内容 audio 定义音频内容 b 定义文本粗体 base 定义页面中所有链接的默认地址或默认目标 basefont HTML5 不支持，不赞成使用，定义页面中文本的默认字体、颜色或尺寸 bdi 允许您设置一段文本，使其脱离其父元素的文本方向设置 bdo 定义文字方向 big 定义大号文本，HTML5 不支持 blockquote 定义长的引用 body 定义文档的主体 br 定义换行 button 定义一个点击按钮 canvas 定义图形，比如图表和其他图像,标签只是图形容器，您必须使用脚本来绘制图形 caption 定义表格标题 center HTML5 不支持，不赞成使用，定义居中文本 cite 定义引用(citation) code 定义计算机代码文本 col 定义表格中一个或多个列的属性值 colgroup 定义表格中供格式化的列组 command 定义命令按钮，比如单选按钮、复选框或按钮 datalist 定义选项列表，请与 input 元素配合使用该元素，来定义 input 可能的值 dd 定义定义列表中项目的描述 del 定义被删除文本 details 用于描述文档或文档某个部分的细节 dfn 定义定义项目 dialog 定义对话框，比如提示框 dir HTML5 不支持，不赞成使用，定义目录列表 div 定义文档中的节 dl 定义列表详情 dt 定义列表中的项目 em 定义强调文本 embed 定义嵌入的内容，比如插件 fieldset 定义围绕表单中元素的边框 figcaption 定义 figure 元素的标题 figure 规定独立的流内容（图像、图表、照片、代码等等） font HTML5 不支持，不赞成使用，定义文字的字体、尺寸和颜色 footer 定义 section 或 document 的页脚 form 定义了 HTML 文档的表单 frame 定义框架集的窗口或框架 frameset 定义框架集 h1-h6 定义 HTML 标题 head 定义关于文档的信息 header 定义了文档的头部区域 hr 定义水平线 html 定义 HTML 文档 i 定义斜体字 iframe 定义内联框架 img 定义图像 input 定义输入控件 ins 定义被插入文本 kbd 定义键盘文本 keygen 规定用于表单的密钥对生成器字段 label 定义 input 元素的标注 legend 定义 fieldset 元素的标题 li 定义列表的项目 link 定义文档与外部资源的关系 map 定义图像映射 mark 定义带有记号的文本，请在需要突出显示文本时使用 m 标签 menu 不赞成使用，定义菜单列表 meta 定义关于 HTML 文档的元信息 meter 定义度量衡，仅用于已知最大和最小值的度量 nav 定义导航链接的部分 noframes 定义针对不支持框架的用户的替代内容，HTML5 不支持 noscript 定义针对不支持客户端脚本的用户的替代内容 object 定义内嵌对象 ol 定义有序列表 optgroup 定义选择列表中相关选项的组合 option 定义选择列表中的选项 output 定义不同类型的输出，比如脚本的输出 p 定义段落 param 定义对象的参数 pre 定义预格式文本 progress 定义运行中的进度（进程） q 定义短的引用 rp rp 标签在 ruby 注释中使用，以定义不支持 ruby 元素的浏览器所显示的内容 rt rt 标签定义字符（中文注音或字符）的解释或发音 ruby ruby 标签定义 ruby 注释（中文注音或字符） s 不赞成使用，定义加删除线的文本 samp 定义计算机代码样本 script 定义客户端脚本 section section 标签定义文档中的节（section、区段），比如章节、页眉、页脚或文档中的其他部分 select 定义选择列表（下拉列表） small 定义小号文本 source source 标签为媒介元素（比如 video 和 audio）定义媒介资源 span 定义文档中的节 strike HTML5 不支持，不赞成使用定义加删除线文本 strong 定义强调文本 style 定义文档的样式信息 sub 定义下标文本 summary summary 标签包含 details 元素的标题，\"details\" 元素用于描述有关文档或文档片段的详细信息 sup 定义上标文本 table 定义表格 tbody 定义表格中的主体内容 td 定义表格中的单元 textarea 定义多行的文本输入控件 tfoot 定义表格中的表注内容（脚注） th 定义表格中的表头单元格 thead 定义表格中的表头内容 time 定义日期或时间，或者两者 title 定义文档的标题 tr 定义表格中的行 track track 标签为诸如 video 元素之类的媒介规定外部文本轨道 tt 定义打字机文本 u 不赞成使用定义下划线文本 ul 定义无序列表 var 定义文本的变量部分 video video 标签定义视频，比如电影片段或其他视频流 wbr 规定在文本中的何处适合添加换行符 图像标签 <img src=\"\" height=\"\" width=\"\" border=\"\" alt=\"\"/> src：图像名称 height：图像高 width：图像宽 border：边界宽度 alt：如果无法显示图像，则alt属性指定以单词形式描述图像的替代文本 链接标签 <a href=\"\" target=\"\"></a> href：目标网址 target：指定打开链接文档的位置，\b_blank值将在新窗口或新标签中打开链接 列表标签 有序列表 <html> <head> <title> first page </title> </head> <body> <ol> <li> Red </li> <li> Blue </li> <li> Green </li> </ol> </body> </html> 无序列表 <html> <head> <title> first page </title> </head> <body> <ul> <li> Red </li> <li> Blue </li> <li> Green </li> </ul> </body> </html> 表格标签 <table border= \"\" align= \"\" > <tr> <td bgcolor= \"red\" > Red </td> <td> Blue </td> <td> Green </td> </tr> <tr> <td> Yellow </td> <td colspan= \"2\" > Orange </td> </tr> </table> 其他 标签 解释 <hr /> 水平线 <!--...--> 注释 HTML 元素类型\b 在 HTML 中，大多数元素被定义为块级或内联元素。| 块级元素从新行开始，如 <h1>, <form>, <li>, <ol>, <ul>, <p>, <pre>, <table>, <div> 等 内联元素通常显示没有换行符，如 <b>, <a>, <strong>, <img>, <input>, <em>, <span> 等 <div> 元素是一个块级元素，通常用作其他 HTML 元素的容器。与一些 CSS 样式一起使用时， <div> 元素可用于设置内容块的样式。 同样， <span> 元素是一个内联元素，通常用作\b某些文本的容器。与 CSS 一起使用时， <span> 元素可用于设置文本的部分样式。 其他元素可以用作块级元素或内联元素。 这包括以下这些： APPLET - 嵌入式 Java 小程序 IFRAME - 内联框架 INS - 插入文本 MAP - 图像映射 OBJECT - 嵌入对象 SCRIPT - HTML 文档中的脚本 你可以在块元素内插入内联元素。 例如，可以在 <div> 元素中包含多个 <span> 元素。反之不行。 表单标签 HTML 表单用于从用户收集信息。使用 <form> 元素及其开始和结束标记定义表单，使用 action 属性指向将在用户提交表单后加载的网页： <body> <form action= \"\" method= \"\" > … </form> </body> method 属性指定在提交表单时使用的 HTTP 方法（GET 或 POST）： 使用 GET 时，表单数据将显示在页面地址中 如果表单正在更新数据，请使用 POST，或者包含敏感信息（密码）。POST 提供了更好的安全性，因为提交的数据在页面地址中不可见 要接受用户输入，需要相应的表单元素，例如文本字段。 <input> 元素有许多变体，具体取决于 type 属性。 它可以是文本，密码，广播，URL，提交等。 <form> <input type= \"text\" name= \"username\" /><br /> <input type= \"password\" name= \"password\" /> </form> <frame> 标签 可以使用特殊帧文档将页面划分为帧。 <frame> 标签定义 <frameset> 中的一个特定窗口（框架）。 <frameset> 中的每个 <frame> 可以具有不同的属性，例如边框，滚动，调整大小的能力等。 <frameset> 元素指定框架集中的列数或行数，以及每个框架占空间像素的百分比或数量。 <frameset cols= \"25%,50%,25%\" > <frame src= \"a.htm\" /> <frame src= \"b.htm\" /> <frame src= \"c.htm\" /> <noframes> Frames not supported! </noframes> </frameset> 使用 <noresize> 属性指定用户无法调整 <frame> 元素的大小： <frame noresize=\"noresize\"> HTML5 中不支持 <frame> 标签。 颜色 颜色值 HTML 颜色表示为十六进制值，0~\bF。零表示最低值，F表示最高值。 颜色模式 颜色以红色，绿色和蓝色光（RGB）的组合显示。 十六进制值使用＃标签符号，后跟六个十六进制字符。所有浏览器都支持 RGB 颜色值。","tags":"教程","url":"https://xutree.github.io/pages/2018/10/05/html-overview/"},{"title":"X3DOM 图像和视频纹理","text":"本章你将知道哪些图像类型和视频格式可以用作 X3DOM 的纹理，以及纹理的特性和限制。 你可以使用 PNG ， LPEG 或者 GIF 来编码你的静态纹理数据。 JPG 图像需要的内存少但是存在压缩损失而且没有 alpha 通道。 PNG 图像属于无损压缩并且有 alpha 通道， GIF 也是无损压缩并且有 alpha 通道。一般来讲：如果你不需要 alpha 通道并且图像中不包含硬边界(例如：文本)，使用 JPG ，否则使用 PNG 。你应该避免使用 GIF 。 图像 利用 ImageTexture 节点把图像作为纹理： <x3d width= '500px' height= '400px' > <scene> <shape> <appearance> <ImageTexture url= \"myTexture.png\" ><ImageTexture/> </appearance> <box> </box> </shape> </scene> </x3d> 视频 利用 MovieTexture 节点可以把视频作为纹理。但是目前还没有哪一种视频格式支持所有的用户。可以使用 X3DOM 格式 示例 来确定你的浏览器支持的格式。目前最好的解决方法是将你的视频编码成 MP4 和 OGV 格式并在 MovieTexture 节点中提供这两个选项： <x3d width= '500px' height= '400px' > <scene> <shape> <appearance> <MovieTexture url= '\"foo.mp4″,\"foo.ogv\"' ><MovieTexture/> </appearance> <box> </box> </shape> </scene> </x3d>","tags":"教程","url":"https://xutree.github.io/pages/2018/10/05/X3DOM图像和视频纹理/"},{"title":"X3DOM，HTML，CSS 和 JavaScript","text":"本节，你将学习关于 X3DOM, HTML 和 CSS的更多知识，以及怎么利用 HTML 和 CSS 技术构建出强大的 3D 应用。在本节最后，你讲学习怎么在你的应用中使用 JavaScript。我们将继续使用前一节的例子。拷贝 HelloX3DOM.html 文件并重命名为 HTMLEventsCSS.html。 X3DOM 和 CSS 我们首先来看下怎么通过 CSS 操控 X3DOM 元素。你可能已经注意到，在 HelloX3DOM.html 中，3D 内容位于一个被黑色边界包围的白色区域中。X3DOM 有一个单独的 css 文件，自从版本1.3以后，名字一直为 x3dom.css，在这个文件中可以找到关于 X3DOM 元素的所有 css 定义以及 debug 信息。假设你的页面使用灰色和橙色作为主要颜色。你可以通过许多方式改变 X3DOM 默认的 CSS 属性： 在 x3dom.css 后包含你自己的 CSS 文件(External Style Sheet) 在 x3dom.css 之后，利用 style 标签定制 css(Internal Style Sheet) 直接操纵相关元素的 style 属性(Inline Styles) 关于 CSS 有很多网上教程，例如 这里 。我们现在利用第二种方法改变 css，通常不推荐第三种方法。为了定制 x3d 代表的 X3DOM 边界，在你的 HTML 文件头部 x3dom.css 之后插入 style 标签： <html> <head> <title> My first X3DOM page </title> <script type= 'text/javascript' src= 'http://www.x3dom.org/download/x3dom.js' > </script> <link rel= 'stylesheet' type= 'text/css' href= 'http://www.x3dom.org/download/x3dom.css' ></link> <style> x3d { border:2px solid darkorange; } </style> </head> <body> <h1> Hello, X3DOM! </h1> <p> This is my first html page with some 3d objects. </p> <x3d width= '600px' height= '400px' > ... </x3d> </body> </html> 现在，X3DOM 的边界颜色已经改变了。假设你的网页已经有了橙色和灰色风格，使用 pattern.png 作为背景(背景图片在 这里 )。那么完整的 style sheet 如下所示： x3d { border : 2 px solid darkorange ; } body { font-size : 110 % ; font-family : verdana , sans-serif ; background-image : url ( 'pattern.png' ); margin : 3 em ; color : lightgray ; } h1 { color : darkorange ; } 现在你的网页看起来如下所示： 从图中可以看出，X3DOM 使用与网页相同的背景。这是一个很重要的行为：你的 X3DOM scene 是在 HTML 之上进行渲染的。让我们设置 x3d 元素为半透明背景： x3d { border : 2 px solid darkorange ; background : rgba ( 128 , 128 , 128 , 0.4 ); } 现在结果看起来如下所示： X3DOM, HTML 事件和 JavaScript 使用 HTML 和 JavaScript，你可以使用大量有用的回调函数来操纵大多数 DOM 元素。X3DOM 为 node 提供了相似的函数。例如，当我们点击红色立方体的时候，可以弹出一个文本信息，在 shape 里插入一个 onclick 函数就可以实现这个功能： <shape onclick= \"alert('Hello, click!');\" > <appearance> <material diffuseColor= '1 0 0' ></material> </appearance> <box></box> </shape> 目前，你可以对 X3DOM 使用 onmousemove ， onmousedown ， onmouseup ， onmouseover 和 onmouseout 事件。你不仅可以在 shape 节点插入事件，也可以在组节点，例如 transform 插入事件。这样你就可以使用一个回调函数捕捉多个节点的事件。 你可以在每个 DOM 元素上使用 JavaScript，所以你可以随心所欲的操纵 node 。你已经知道怎么使用 onclick 事件，让我们尝试当点击时，改变立方体的颜色。如果你从没使用过 JavaScript，这个 网站 或许可以帮助你。 首先，给你想操纵的节点一个 id ： <shape onclick= \"alert('Hello, click!');\" > <appearance> <material id= \"color\" diffuseColor= '1 0 0' ></material> </appearance> <box></box> </shape> 然后，你就可以通过下面这个函数改变颜色： <script> function changeColor() { if(document.getElementById(\"color\").getAttribute('diffuseColor')==\"1 0 0\") document.getElementById(\"color\").setAttribute('diffuseColor', '0 0 1'); else document.getElementById(\"color\").setAttribute('diffuseColor', '1 0 0'); } </script> <shape onclick=\"changeColor();\"> 下一步：自动创建 (X)HTML 如果你有大量的模型数据，你想把这些数据分配到不同的页面上。那么自动生成实际的页面而不是手动编写代码将更加有趣。你可以使用自动化工具，例如 XSLT，允许你直接将 X3DOM 文件转化为 XHTML 网页。 这里 是一个例子。","tags":"教程","url":"https://xutree.github.io/pages/2018/10/05/X3DOMHTMLCSS和JavaScript/"},{"title":"Hello，X3DOM！","text":"本教程将教会你怎么配置和运行你的第一个 X3DOM 应用。你只需要一个相容于 WebGL 的浏览器和一个文本编辑器。整个 X3DOM 应用是常规网页的一部分，并且编写方式也与HTML很相似，所以如果你的编辑器支持HTML或者XML的语法高亮那将更好，像 WebStorm 这种 Web 编程 IDE 也是可以的。如果你手头有一个网页浏览器和一个文本编辑器，并且你知道怎么在浏览器中打开网页(参考 这里 )，那么你可以开始你的第一个 X3DOM 应用了。 首先，创建一个新文件 HelloX3DOM.html 。然后将下面的内容复制粘贴进这个空文件： <html> <head> <title> My first X3DOM page </title> <script type= 'text/javascript' src= 'http://www.x3dom.org/download/x3dom.js' > </script> <link rel= 'stylesheet' type= 'text/css' href= 'http://www.x3dom.org/download/x3dom.css' ></link> </head> <body> <h1> Hello, X3DOM! </h1> <p> This is my first html page with some 3d objects. </p> </body> </html> 如果你在浏览器中打开这个文件，你会看到一个包含一个文本信息的常规HTML页面。你可能已经注意到，我们已经在我们的网页中添加了一些 X3DOM 元素，因为我们已经包含 X3DOM 作为一个 JaveScript 库，还包含了 X3DOM CSS 文件，用于规则的显示 X3DOM 元素。在上面的 HTML 代码中，我们通过 script 和 link 标签是用了 development 版本的 X3DOM。 让我们继续添加一些 3D 内容。首先，我们需要一个 x3d 元素，用来描述 X3DOM 内容在哪个 scene 显示。和 HTML 元素 p 、 div 类似， x3d 在 HTML 里定义了一个矩形范围。整个 X3DOM 的 3D 内容用 scene 描述，所以我们在 x3d 标签里添加一个 scene 标签。这种结构是来自于X3D标准。一个 scene 可以包含很多不同的 node ，例如， lights 、 groups 、 viewpoint 和 objects 。在第一个例子里，我们通过 shape 简单地定义一个3D物体。我们用 box 定义这个物体的几何形状。现在，你可以将下面的代码添加在你的 HTML 文件闭合 p 标签之后： <x3d width= '600px' height= '400px' > <scene> <shape> <box></box> </shape> </scene> </x3d> 如果你现在在浏览器中打开这个文件，会像下面这样： 由于 box 目前没有颜色，所以无法看到它，为了看到它我们需要声明 material ，X3DOM 基于 X3D 标准选择了一个白色的 material ，由于网页的背景也是白色的，所以我们看不到它。为了改变 material 的颜色，我们首先需要在 shape 中插入 appearance 。在 appearance 里面，我们就可以插入 material ，利用 material 的 diffuseColor 我们可以定义 material 的颜色，我们现在将它定义为 RGB 颜色的红色： <shape> <appearance> <material diffuseColor= '1 0 0' ></material> </appearance> <box></box> </shape> 现在，在你的浏览器中，网页将变成： 现在，你可以利用鼠标进行交互了。按住鼠标左键并移动鼠标，你可以旋转视角，按住鼠标右键并移动鼠标，你可以放大和缩小。 我们继续在这个 scene 中添加两个物体：一个蓝色的球体和一个绿色的圆锥。这和我们添加 box 类似，但是，在 sphere 和 cone 节点处，我们需要移动球和圆锥以避免他们相互重叠，因为所有的 3D 物体都默认不进行任何的坐标转换，也就是说它们会重叠在一起。像X3D和其他的图像相关标准(例如，OpenGL)一样，X3DOM 的坐标系统 Y 轴指向上，X 轴指向右，Z 轴指向外： 在添加绿色圆锥之前，我们将坐标往左移动3个单位；在添加蓝色球之前，我们将坐标往右移动3个单位。如下所示： <shape> <appearance> <material diffuseColor= '1 0 0' ></material> </appearance> <box></box> </shape> <transform translation= '-3 0 0' > <shape> <appearance> <material diffuseColor= '0 1 0' ></material> </appearance> <cone></cone> </shape> </transform> <transform translation= '3 0 0' > <shape> <appearance> <material diffuseColor= '0 0 1' ></material> </appearance> <sphere></sphere> </shape> </transform> 现在，在你的浏览器中，你将看到如下内容： 如果你在浏览器中看到了上图的结果，恭喜你！你刚刚使用了一系列的 X3D node 创建了你的第一个 X3DOM scene 。","tags":"教程","url":"https://xutree.github.io/pages/2018/10/04/X3DOM-hello/"},{"title":"X3DOM 第一课","text":"下面的指南可以作为 X3DOM 使用者和开发者的入门资料。本指南包括许多重要的内容，例如怎么配置你的环境去运行 X3DOM 的示例。如果你没有足够的时间阅读这篇入门文章，又或许你已经熟悉一点关于 X3D 的知识，你可以迅速的浏览下第3部分和第4部分的一些内容去设置你的环境，然后根据 tutorials 的指导去完成你的第一个 X3DOM 应用。 背景：什么是X3DOM，它可以用来做什么？ 无需插件即可在浏览器中显示的3D场景 X3DOM（发音：\"X-Freedom\"）是一个开源的 JaveScript 框架，用于在网页中创建 declarative 3D 场景。由于它基于标准的浏览器技术，你的浏览器不需要其他任何插件就可以显示 X3DOM 场景。概括地说，declarative 3D 意味着你可以使用结构化的文本表示去创建和显示 3D 场景，而不需要去编写代码。在 X3DOM 中，这种文本表示是表示网页的 HTML 文件的一部分。也就是说，3D 内容成为了网页元素的一部分，就像网页中的文本、链接、图片和视频一样。 X3DOM = X3D + DOM X3DOM 这个名字是由两个缩写组合而成。第一个缩写是 X3D （\"Extensible 3D Graphics\"），指代一个 3D 图形的免版税 ISO 标准。第二个缩写是 DOM （\"Document Object Model\"），描述与HTML文档的内容相关联的交互概念和分层表示。X3DOM 使用 X3D 的一个专门的子集（所谓的 HTML Profile ）来作为网页内 3D 内容的描述语言。X3D（OM)元素可以通过 DOM 操作，就像其他的 HTML 元素一样。例如，你可以动态地改变一个 3D 物体的颜色通过 JavaScript 调用相应 DOM 元素的 setAttribute(...) 函数，这就像你可以动态改变一个普通网页里一个标签的内容一样。 使用 X3DOM 的原因 使用 X3DOM 而不是其他的基于浏览器的库或者 X3D 播放器是因为 X3DOM 具有以下几个优势： 显示 X3DOM 场景不需要额外插件，因为 X3DOM 是完全基于标准浏览器技术，例如 HTML5 和 WebGL 基于 ISO 标准 X3D 的一种新的 HTML 配置，X3DOM 绝大部分都是标准一致的。这大大方便了 X3DOM 的学习 从2009年至今，X3DOM 已经具有了很大的使用者和开发者群体 如果你知道怎么创建简单的网页，你就可以利用你现有的关于 HTML 和 DOM 的知识，而不需要学习新的 API 怎么做？ 如果你想开发你的第一个 X3DOM 应用，你只需要一个浏览器和一个文本编辑器。当然，你也可以选择功能更多的 HTML 和 JavaScript 开发环境，比如 WebStorm 。 一些基本 X3D 概念：Nodes、Components 和 Profiles X3D Nodes X3D 定义每一个 3D 场景都是由一组 node 组成。每一个 node 代表 3D 场景中一个确定的部分：光线、物体、物体表面的材质等等。场景里的所用 node 排列成树结构或者图结构，整体结构被叫做 scene-graph 。每一个 node 的行为，比如材质的颜色，可以通过node的 fields 设置。例如，一个用来设置某物体表面颜色为红色（RGB编码 1 0 0）的node的 XML 描述为： <Material diffuseColor= '1 0 0' ></Material> 你可能已经意识到，描述 X3D node 的 XML 很像常规的 HTML 代码，属性值 diffuseColor 的设置也像 HTML 属性的设置一样。事实上，如果你熟悉 HTML，那么就很容易理解 X3DOM 中的 node 了。你可以在 tutorials 中学习怎样使用 node。如果你想了解更多 X3D 中 node 的概念，可以参考 external X3D documentation resources 。 X3D Components 一组具有相同功能的 node 称为 components。例如定义光线的 node， PointLight 和 SpotLight ，在 Lighting component 里。关于 Components 的全部信息可以在 这里 找到。 X3D Profiles 和 X3DOM HTML Profile X3D 标准定义了大量的 node，一些特殊用途的 node 对大多说用户来说并不重要。因此，X3D 引入了 profile 的概念，把许多组 node 放在一起成为一个包，每一个包代表一类特殊的应用。例如， CAD 包， Immersive 包是用于交互环境的。profile 是在 component 之上的一个概念。 X3DOM 使用的 X3D component 经过十分仔细的选择，以提供一个最合适的 X3D 子集来满足现代 HTML 应用的需要。X3DOM 通过定义一个特殊的 profile，即 HTML profile，来解决这一问题。这个 HTML profile 也包括一些处于试验阶段的 X3D 没有的 node 和 filed，这些 node 和 filed 是专门为 X3DOM 设计的。具体来说，有些 X3D node 在 X3DOM 里没有，而有些 node X3DOM 里有但是 X3D 里没有。你可以在 这里 找到每个 node 的起源。如果你想学习更多关于 HTML profile 的知识以及它与现有的 X3D component、profile 的关系，可以查看 这里 。 最后，X3DOM 也提供一些不在原始HTML profile 中的 X3D node。这些 node 不在 X3DOM 的标准发行版本中，只在 X3DOM-Full 版本中。 选择一个 X3DOM 版本 版本和 Components 有许多可供选择的 X3DOM 版本，你可能想知道对特殊的目的哪一个才是最好的。一般来讲，我们推荐最新的 release 版本。但是，如果你需要采用的新特性在 release 版中没有，那么 dev 版本可能更适合你。当你完成了网页应用的主要开发工作进而部署时，你可能需要用来开发的 X3DOM 的版本信息。你也可能，出于某种原因需要老版本的 X3DOM，比如你的网页应用包含了一些试验特性只在老版本出现，而在新版本中被移除了。 所有的 X3DOM release 版本，包括 dev 版本，都被打包好了，里面包括一个 JavaScript 文件（如 x3dom.js），一个 css文件（如 x3dom.css）和一个可选的 shockwave 文件（如 x3dom.swf，对于那些支持 flash 的版本），可在 这里 下载： 版本1.0到1.2的文件以 x3dom-v 标记，后面跟着版本号（如 http://x3dom.org/download/x3dom-v1.1.js ） 从版本1.3开始，x3dom.js, x3dom.css, x3dom.swf 和一个 .zip 存档文件b被放置在一个以版本号为名字的子文件夹里（如 http://x3dom.org/download/1.3/x3dom.js ） 从版本1.3开始，一些 HTML profile 之外的 component 出现了。这些 component 在文件 x3dom-full.js 中。如果你只需要使用其中一个 component，你也可以考虑仍使用 x3dom.js 然后包含所需的 component 的文件（如 http://x3dom.org/download/1.3/components/ ） 最新的稳定 release 版总是位于： http://x3dom.org/release/x3dom.js 目前的 development 版本总是位于 dec 子文件夹： http://x3dom.org/download/dev/x3dom.js 为使用最新版本 release X3DOM，你可以在你的HTML页面中包含下面的标签： <script src= \"http://www.x3dom.org/release/x3dom.js\" ></script> <link rel= \"stylesheet\" href= \"http://www.x3dom.org/release/x3dom.css\" > 为使用最新的 development 版本，使用下面的标签： <script src= \"http://www.x3dom.org/download/dev/x3dom.js\" ></script> <link rel= \"stylesheet\" href= \"http://www.x3dom.org/download/dev/x3dom.css\" > 为使用版本1.5的 X3DOM-Full 版本，使用下面的标签： <script src= \"http://www.x3dom.org/download/1.5/x3dom-full.js\" ></script> <link rel= \"stylesheet\" href= \"http://www.x3dom.org/download/1.5/x3dom.css\" > 最后，为使用1.3版本的 release X3DOM 和额外的 Geospatial component 和另外的 flash 支持，使用下面的标签： <script src= \"http://www.x3dom.org/download/1.3/x3dom.js\" ></script> <script src= \"http://www.x3dom.org/download/1.3/components/Geospatial.js\" ></script> <script src= \"http://www.x3dom.org/download/1.3/x3dom.swf\" ></script> <link rel= \"stylesheet\" href= \"http://www.x3dom.org/download/1.3/x3dom.css\" > Debugging 如果在 debug 你的应用的时候你想看到 X3DOM 的源码，只需将 x3dom.js 替换成 x3dom.debug.js 或者将 x3dom-full.js 替换成 x3dom-full.debug.js。其注意，此特性只适用于版本1.4以后的 X3DOM。相比于常规版本，debug 版本包含缩进和注释，所以比较大。所以，当你最终发布你的 Web 应用时，请不要使用 debug 版本的 js。 运行 X3DOM 应用 通过简单的 Python 服务器 一个简便的方法在服务器上来测试你的 Web 应用是使用 Python 的 HTTP 服务器模块。你只需要安装一个 Python 解释器。你可以在 这里 下载。你可以用 Python 做许多有趣的事情。首先，打开命令行窗口，定位到 X3DOM 文件夹。如果你的 Python 是2.X版本，你可以使用 SimpleHTTP 服务器模块如下所示： python -m SimpleHTTPServer 如果你的 Python 是3.x版本，如下所示： python3 -m http.server 默认情况下，服务器使用8000端口。如果你想改变端口，直接在命令后面加上端口号即可，例如： python -m SimpleHTTPServer 8023 然后，通过浏览器输入如下地址就可以到达你的服务器： http://localhost:8023 如果你在启动 Python 服务器的文件夹里放置了 index.html 文件，那么这个文件的内容就会显示在浏览器窗口里。否则，你会看到服务器所在文件夹内的文件列表。 在 Web 服务器上运行 X3DOM 通常，你会在Web服务器上运行你的 X3DOM 应用，本节针对一些普通的 Web 服务器，如 Apache 和 IIS，给出具体的方法。 Apache 是使用最多的 Web 服务器。它是开源的可以在 这里 下载。最新版本是2.4，但是版本2.2仍然被支持。 如果你的应用需要一整套 Web 服务器组件，我们推荐 XAMPP ，它包含 Apache、MySQL、PHP 和 Perl 的最新发行版。 互联网信息服务（IIS）被集成在微软的任何的最新版本的 Windows 当中。但是，对于非服务器操作系统，同时连接数会受到限制。","tags":"教程","url":"https://xutree.github.io/pages/2018/10/04/X3DOM第一课/"},{"title":"安装 Pelican","text":"安装 Pelican Pelican 目前支持最好的是 Python 2.7 和 3.3+，早期版本的 Python 已经不支持了。有许多不同的方法可以安装 Pelican，最简单的方法是使用 pip，在终端输入： pip install pelican 上面是最简单的方法，官方更为推荐的方法是利用 virtualenv 为 Pelican 建立一个虚拟环境。假设你已经安装好了 virtualenv，下面打开终端，开始为 Pelican 新建一个虚拟环境： virtualenv ~/virtualenv/pelican cd ~/virtualenv/pelican source bin/activate 当虚拟环境被创建并激活以后，然后利用 pip install pelican 安装 Pelican。 当 Pelican 安装好以后，你可以在终端输入 pelican --help 查看使用选项。 可选的 Packages\b 如果你计划用 Markdown 来书写你的网页的话，你需要安装 Markdown： pip install Markdown 通过设置 Pelican 的 pelicanconf.py 文件，你可以对生成的 HTML 文件启用增强语法。但是首先你需要安装 Typogrify ： pip install typorify 更新 更新到最新的稳定版本，使用： pip install --upgrade pelican","tags":"教程","url":"https://xutree.github.io/pages/2018/10/04/在mac上安装Pelican/"}]}